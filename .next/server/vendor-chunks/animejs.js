"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/animejs";
exports.ids = ["vendor-chunks/animejs"];
exports.modules = {

/***/ "(ssr)/./node_modules/animejs/lib/anime.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/animejs/lib/anime.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animatable: () => (/* binding */ Animatable),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   JSAnimation: () => (/* binding */ JSAnimation),\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   ScrollObserver: () => (/* binding */ ScrollObserver),\n/* harmony export */   Spring: () => (/* binding */ Spring),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   Timer: () => (/* binding */ Timer),\n/* harmony export */   WAAPIAnimation: () => (/* binding */ WAAPIAnimation),\n/* harmony export */   animate: () => (/* binding */ animate),\n/* harmony export */   createAnimatable: () => (/* binding */ createAnimatable),\n/* harmony export */   createDraggable: () => (/* binding */ createDraggable),\n/* harmony export */   createScope: () => (/* binding */ createScope),\n/* harmony export */   createSpring: () => (/* binding */ createSpring),\n/* harmony export */   createTimeline: () => (/* binding */ createTimeline),\n/* harmony export */   createTimer: () => (/* binding */ createTimer),\n/* harmony export */   eases: () => (/* binding */ eases),\n/* harmony export */   engine: () => (/* binding */ engine),\n/* harmony export */   onScroll: () => (/* binding */ onScroll),\n/* harmony export */   scrollContainers: () => (/* binding */ scrollContainers),\n/* harmony export */   stagger: () => (/* binding */ stagger),\n/* harmony export */   svg: () => (/* binding */ svg),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   waapi: () => (/* binding */ waapi)\n/* harmony export */ });\n/**\n * anime.js - ESM\n * @version v4.0.2\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */ /**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */ /** @typedef {JSAnimation|Timeline} Renderable */ /** @typedef {Timer|Renderable} Tickable */ /** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */ /** @typedef {Animatable|Tickable|Draggable|ScrollObserver|Scope} Revertible */ /**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */ /**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */ /**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */ /**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */ /**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */ /**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */ // A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */ /** @typedef {HTMLElement|SVGElement} DOMTarget */ /** @typedef {Record<String, any>} JSTarget */ /** @typedef {DOMTarget|JSTarget} Target */ /** @typedef {Target|NodeList|String} TargetSelector */ /** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */ /** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */ /** @typedef {Array.<DOMTarget>} DOMTargetsArray */ /** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */ /** @typedef {Array.<JSTarget>} JSTargetsArray */ /** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */ /** @typedef {Array.<Target>} TargetsArray */ /**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */ /**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */ /** @typedef {[Number, Number, Number, Number]} ColorArray */ /**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */ /**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */ /**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */ /**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */ /**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */ /** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */ /** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */ /** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */ /** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */ /**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */ /**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */ /**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */ /**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */ /**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */ /**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */ /**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */ /**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */ /**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */ /**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */ /**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */ /**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */ /**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */ /**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */ /**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */ /**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */ // TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */ /**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */ /**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */ /**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */ /**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */ /**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */ /**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */ /**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */ /**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */ // Environments\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = \"undefined\" !== \"undefined\";\n/** @type {Object|Null} */ const win = isBrowser ? window : null;\n/** @type {Document} */ const doc = isBrowser ? document : null;\n// Enums\n/** @enum {Number} */ const tweenTypes = {\n    OBJECT: 0,\n    ATTRIBUTE: 1,\n    CSS: 2,\n    TRANSFORM: 3,\n    CSS_VAR: 4\n};\n/** @enum {Number} */ const valueTypes = {\n    NUMBER: 0,\n    UNIT: 1,\n    COLOR: 2,\n    COMPLEX: 3\n};\n/** @enum {Number} */ const tickModes = {\n    NONE: 0,\n    AUTO: 1,\n    FORCE: 2\n};\n/** @enum {Number} */ const compositionTypes = {\n    replace: 0,\n    none: 1,\n    blend: 2\n};\n// Cache symbols\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n// Numbers\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n// Strings\nconst emptyString = \"\";\nconst shortTransforms = new Map();\nshortTransforms.set(\"x\", \"translateX\");\nshortTransforms.set(\"y\", \"translateY\");\nshortTransforms.set(\"z\", \"translateZ\");\nconst validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\nconst transformsFragmentStrings = validTransforms.reduce((a, v)=>({\n        ...a,\n        [v]: v + \"(\"\n    }), {});\n// Functions\n/** @return {void} */ const noop = ()=>{};\n// Regex\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n/** @type {DefaultsParams} */ const defaults = {\n    id: null,\n    keyframes: null,\n    playbackEase: null,\n    playbackRate: 1,\n    frameRate: maxFps,\n    loop: 0,\n    reversed: false,\n    alternate: false,\n    autoplay: true,\n    duration: K,\n    delay: 0,\n    loopDelay: 0,\n    ease: \"out(2)\",\n    composition: compositionTypes.replace,\n    modifier: (v)=>v,\n    onBegin: noop,\n    onBeforeUpdate: noop,\n    onUpdate: noop,\n    onLoop: noop,\n    onPause: noop,\n    onComplete: noop,\n    onRender: noop\n};\nconst globals = {\n    /** @type {DefaultsParams} */ defaults,\n    /** @type {Document|DOMTarget} */ root: doc,\n    /** @type {Scope} */ scope: null,\n    /** @type {Number} */ precision: 4,\n    /** @type {Number} */ timeScale: 1,\n    /** @type {Number} */ tickThreshold: 200\n};\nconst globalVersions = {\n    version: \"4.0.2\",\n    engine: null\n};\nif (isBrowser) {\n    if (!win.AnimeJS) win.AnimeJS = [];\n    win.AnimeJS.push(globalVersions);\n}\n// Strings\n/**\n * @param  {String} str\n * @return {String}\n */ const toLowerCase = (str)=>str.replace(lowerCaseRgx, \"$1-$2\").toLowerCase();\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */ const stringStartsWith = (str, sub)=>str.indexOf(sub) === 0;\n// Time\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n// Types checkers\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */ const isObj = (a)=>a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */ const isNum = (a)=>typeof a === \"number\" && !isNaN(a);\n/**@param {any} a @return {a is String} */ const isStr = (a)=>typeof a === \"string\";\n/**@param {any} a @return {a is Function} */ const isFnc = (a)=>typeof a === \"function\";\n/**@param {any} a @return {a is undefined} */ const isUnd = (a)=>typeof a === \"undefined\";\n/**@param {any} a @return {a is null | undefined} */ const isNil = (a)=>isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */ const isSvg = (a)=>isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */ const isHex = (a)=>hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */ const isRgb = (a)=>stringStartsWith(a, \"rgb\");\n/**@param {any} a @return {Boolean} */ const isHsl = (a)=>stringStartsWith(a, \"hsl\");\n/**@param {any} a @return {Boolean} */ const isCol = (a)=>isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */ const isKey = (a)=>!globals.defaults.hasOwnProperty(a);\n// Number\n/**\n * @param  {Number|String} str\n * @return {Number}\n */ const parseNumber = (str)=>isStr(str) ? parseFloat(/** @type {String} */ str) : /** @type {Number} */ str;\n// Math\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */ const clamp = (v, min, max)=>v < min ? min : v > max ? max : v;\nconst powCache = {};\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */ const round = (v, decimalLength)=>{\n    if (decimalLength < 0) return v;\n    if (!decimalLength) return _round(v);\n    let p = powCache[decimalLength];\n    if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n    return _round(v * p) / p;\n};\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */ const snap = (v, increment)=>isArr(increment) ? increment.reduce((closest, cv)=>abs(cv - v) < abs(closest - v) ? cv : closest) : increment ? _round(v / increment) * increment : v;\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */ const interpolate = (start, end, progress)=>start + (end - start) * progress;\n/**\n * @param  {Number} v\n * @return {Number}\n */ const clampInfinity = (v)=>v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;\n/**\n * @param  {Number} v\n * @return {Number}\n */ const normalizeTime = (v)=>v <= minValue ? minValue : clampInfinity(round(v, 11));\n// Arrays\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */ const cloneArray = (a)=>isArr(a) ? [\n        ...a\n    ] : a;\n// Objects\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */ const mergeObjects = (o1, o2)=>{\n    const merged = /** @type {T & U} */ {\n        ...o1\n    };\n    for(let p in o2){\n        const o1p = /** @type {T & U} */ o1[p];\n        merged[p] = isUnd(o1p) ? /** @type {T & U} */ o2[p] : o1p;\n    }\n    return merged;\n};\n// Linked lists\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */ const forEachChildren = (parent, callback, reverse, prevProp = \"_prev\", nextProp = \"_next\")=>{\n    let next = parent._head;\n    let adjustedNextProp = nextProp;\n    if (reverse) {\n        next = parent._tail;\n        adjustedNextProp = prevProp;\n    }\n    while(next){\n        const currentNext = next[adjustedNextProp];\n        callback(next);\n        next = currentNext;\n    }\n};\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */ const removeChild = (parent, child, prevProp = \"_prev\", nextProp = \"_next\")=>{\n    const prev = child[prevProp];\n    const next = child[nextProp];\n    prev ? prev[nextProp] = next : parent._head = next;\n    next ? next[prevProp] = prev : parent._tail = prev;\n    child[prevProp] = null;\n    child[nextProp] = null;\n};\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */ const addChild = (parent, child, sortMethod, prevProp = \"_prev\", nextProp = \"_next\")=>{\n    let prev = parent._tail;\n    while(prev && sortMethod && sortMethod(prev, child))prev = prev[prevProp];\n    const next = prev ? prev[nextProp] : parent._head;\n    prev ? prev[nextProp] = child : parent._head = child;\n    next ? next[prevProp] = child : parent._tail = child;\n    child[prevProp] = prev;\n    child[nextProp] = next;\n};\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */ class Clock {\n    /** @param {Number} [initTime] */ constructor(initTime = 0){\n        /** @type {Number} */ this.deltaTime = 0;\n        /** @type {Number} */ this._currentTime = initTime;\n        /** @type {Number} */ this._elapsedTime = initTime;\n        /** @type {Number} */ this._startTime = initTime;\n        /** @type {Number} */ this._lastTime = initTime;\n        /** @type {Number} */ this._scheduledTime = 0;\n        /** @type {Number} */ this._frameDuration = round(K / maxFps, 0);\n        /** @type {Number} */ this._fps = maxFps;\n        /** @type {Number} */ this._speed = 1;\n        /** @type {Boolean} */ this._hasChildren = false;\n        /** @type {Tickable|Tween} */ this._head = null;\n        /** @type {Tickable|Tween} */ this._tail = null;\n    }\n    get fps() {\n        return this._fps;\n    }\n    set fps(frameRate) {\n        const previousFrameDuration = this._frameDuration;\n        const fr = +frameRate;\n        const fps = fr < minValue ? minValue : fr;\n        const frameDuration = round(K / fps, 0);\n        this._fps = fps;\n        this._frameDuration = frameDuration;\n        this._scheduledTime += frameDuration - previousFrameDuration;\n    }\n    get speed() {\n        return this._speed;\n    }\n    set speed(playbackRate) {\n        const pbr = +playbackRate;\n        this._speed = pbr < minValue ? minValue : pbr;\n    }\n    /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */ requestTick(time) {\n        const scheduledTime = this._scheduledTime;\n        const elapsedTime = this._elapsedTime;\n        this._elapsedTime += time - elapsedTime;\n        // If the elapsed time is lower than the scheduled time\n        // this means not enough time has passed to hit one frameDuration\n        // so skip that frame\n        if (elapsedTime < scheduledTime) return tickModes.NONE;\n        const frameDuration = this._frameDuration;\n        const frameDelta = elapsedTime - scheduledTime;\n        // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n        // Skips ahead if the actual elapsed time is higher.\n        this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n        return tickModes.AUTO;\n    }\n    /**\n   * @param  {Number} time\n   * @return {Number}\n   */ computeDeltaTime(time) {\n        const delta = time - this._lastTime;\n        this.deltaTime = delta;\n        this._lastTime = time;\n        return delta;\n    }\n}\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */ const render = (tickable, time, muteCallbacks, internalRender, tickMode)=>{\n    const parent = tickable.parent;\n    const duration = tickable.duration;\n    const completed = tickable.completed;\n    const iterationDuration = tickable.iterationDuration;\n    const iterationCount = tickable.iterationCount;\n    const _currentIteration = tickable._currentIteration;\n    const _loopDelay = tickable._loopDelay;\n    const _reversed = tickable._reversed;\n    const _alternate = tickable._alternate;\n    const _hasChildren = tickable._hasChildren;\n    const tickableDelay = tickable._delay;\n    const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n    const tickableEndTime = tickableDelay + iterationDuration;\n    const tickableAbsoluteTime = time - tickableDelay;\n    const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n    const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n    const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n    const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n    const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n    const isSetter = duration <= minValue;\n    const forcedTick = tickMode === tickModes.FORCE;\n    let isOdd = 0;\n    let iterationElapsedTime = tickableAbsoluteTime;\n    // Render checks\n    // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n    let hasRendered = 0;\n    // Execute the \"expensive\" iterations calculations only when necessary\n    if (iterationCount > 1) {\n        // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n        const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n        tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n        // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n        if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n        isOdd = tickable._currentIteration % 2;\n        iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n    }\n    // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n    const isReversed = _reversed ^ (_alternate && isOdd);\n    const _ease = /** @type {Renderable} */ tickable._ease;\n    let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n    if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n    const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n    tickable._currentTime = tickableAbsoluteTime;\n    tickable._iterationTime = iterationTime;\n    tickable.backwards = isRunningBackwards;\n    if (isCurrentTimeAboveZero && !tickable.began) {\n        tickable.began = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n            tickable.onBegin(/** @type {CallbackArgument} */ tickable);\n        }\n    } else if (tickableAbsoluteTime <= 0) {\n        tickable.began = false;\n    }\n    // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n    // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n    if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n        tickable.onLoop(/** @type {CallbackArgument} */ tickable);\n    }\n    if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime || // Normal render\n    time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n    time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n    ) {\n        if (isCurrentTimeAboveZero) {\n            // Trigger onUpdate callback before rendering\n            tickable.computeDeltaTime(tickablePrevTime);\n            if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */ tickable);\n        }\n        // Start tweens rendering\n        if (!_hasChildren) {\n            // Time has jumped more than globals.tickThreshold so consider this tick manual\n            const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n            const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n            // Only Animation can have tweens, Timer returns undefined\n            let tween = /** @type {Tween} */ /** @type {JSAnimation} */ tickable._head;\n            let tweenTarget;\n            let tweenStyle;\n            let tweenTargetTransforms;\n            let tweenTargetTransformsProperties;\n            let tweenTransformsNeedUpdate = 0;\n            while(tween){\n                const tweenComposition = tween._composition;\n                const tweenCurrentTime = tween._currentTime;\n                const tweenChangeDuration = tween._changeDuration;\n                const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n                const tweenNextRep = tween._nextRep;\n                const tweenPrevRep = tween._prevRep;\n                const tweenHasComposition = tweenComposition !== compositionTypes.none;\n                if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime) && (!tweenPrevRep || tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay))) {\n                    const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n                    const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n                    const tweenModifier = tween._modifier;\n                    const tweenValueType = tween._valueType;\n                    const tweenType = tween._tweenType;\n                    const tweenIsObject = tweenType === tweenTypes.OBJECT;\n                    const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n                    // Only round the in-between frames values if the final value is a string\n                    const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n                    // Recompose tween value\n                    /** @type {String|Number} */ let value;\n                    /** @type {Number} */ let number;\n                    if (tweenIsNumber) {\n                        value = number = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n                    } else if (tweenValueType === valueTypes.UNIT) {\n                        // Rounding the values speed up string composition\n                        number = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n                        value = `${number}${tween._unit}`;\n                    } else if (tweenValueType === valueTypes.COLOR) {\n                        const fn = tween._fromNumbers;\n                        const tn = tween._toNumbers;\n                        const r = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[0], tn[0], tweenProgress)), 0, 255), 0);\n                        const g = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[1], tn[1], tweenProgress)), 0, 255), 0);\n                        const b = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[2], tn[2], tweenProgress)), 0, 255), 0);\n                        const a = clamp(/** @type {Number} */ tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision)), 0, 1);\n                        value = `rgba(${r},${g},${b},${a})`;\n                        if (tweenHasComposition) {\n                            const ns = tween._numbers;\n                            ns[0] = r;\n                            ns[1] = g;\n                            ns[2] = b;\n                            ns[3] = a;\n                        }\n                    } else if (tweenValueType === valueTypes.COMPLEX) {\n                        value = tween._strings[0];\n                        for(let j = 0, l = tween._toNumbers.length; j < l; j++){\n                            const n = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision));\n                            const s = tween._strings[j + 1];\n                            value += `${s ? n + s : n}`;\n                            if (tweenHasComposition) {\n                                tween._numbers[j] = n;\n                            }\n                        }\n                    }\n                    // For additive tweens and Animatables\n                    if (tweenHasComposition) {\n                        tween._number = number;\n                    }\n                    if (!internalRender && tweenComposition !== compositionTypes.blend) {\n                        const tweenProperty = tween.property;\n                        tweenTarget = tween.target;\n                        if (tweenIsObject) {\n                            tweenTarget[tweenProperty] = value;\n                        } else if (tweenType === tweenTypes.ATTRIBUTE) {\n                            /** @type {DOMTarget} */ tweenTarget.setAttribute(tweenProperty, /** @type {String} */ value);\n                        } else {\n                            tweenStyle = /** @type {DOMTarget} */ tweenTarget.style;\n                            if (tweenType === tweenTypes.TRANSFORM) {\n                                if (tweenTarget !== tweenTargetTransforms) {\n                                    tweenTargetTransforms = tweenTarget;\n                                    // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                                    tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                                }\n                                tweenTargetTransformsProperties[tweenProperty] = value;\n                                tweenTransformsNeedUpdate = 1;\n                            } else if (tweenType === tweenTypes.CSS) {\n                                tweenStyle[tweenProperty] = value;\n                            } else if (tweenType === tweenTypes.CSS_VAR) {\n                                tweenStyle.setProperty(tweenProperty, /** @type {String} */ value);\n                            }\n                        }\n                        if (isCurrentTimeAboveZero) hasRendered = 1;\n                    } else {\n                        // Used for composing timeline tweens without having to do a real render\n                        tween._value = value;\n                    }\n                }\n                // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n                // to reduce memory usage on string composition\n                if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n                    let str = emptyString;\n                    for(let key in tweenTargetTransformsProperties){\n                        str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;\n                    }\n                    tweenStyle.transform = str;\n                    tweenTransformsNeedUpdate = 0;\n                }\n                tween = tween._next;\n            }\n            if (!muteCallbacks && hasRendered) {\n                /** @type {JSAnimation} */ tickable.onRender(/** @type {JSAnimation} */ tickable);\n            }\n        }\n        if (!muteCallbacks && isCurrentTimeAboveZero) {\n            tickable.onUpdate(/** @type {CallbackArgument} */ tickable);\n        }\n    }\n    // End tweens rendering\n    // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n    if (parent && isSetter) {\n        if (!muteCallbacks && (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {\n            tickable.onComplete(/** @type {CallbackArgument} */ tickable);\n            tickable.completed = !isRunningBackwards;\n        }\n    // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n    } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n        if (iterationCount === Infinity) {\n            // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n            tickable._startTime += tickable.duration;\n        } else if (tickable._currentIteration >= iterationCount - 1) {\n            // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n            tickable.paused = true;\n            if (!completed && !_hasChildren) {\n                // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n                tickable.completed = true;\n                if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n                    tickable.onComplete(/** @type {CallbackArgument} */ tickable);\n                    tickable._resolve(/** @type {CallbackArgument} */ tickable);\n                }\n            }\n        }\n    // Otherwise set the completed flag to false\n    } else {\n        tickable.completed = false;\n    }\n    // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n    return hasRendered;\n};\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */ const tick = (tickable, time, muteCallbacks, internalRender, tickMode)=>{\n    const _currentIteration = tickable._currentIteration;\n    render(tickable, time, muteCallbacks, internalRender, tickMode);\n    if (tickable._hasChildren) {\n        const tl = /** @type {Timeline} */ tickable;\n        const tlIsRunningBackwards = tl.backwards;\n        const tlChildrenTime = internalRender ? time : tl._iterationTime;\n        const tlCildrenTickTime = now();\n        let tlChildrenHasRendered = 0;\n        let tlChildrenHaveCompleted = true;\n        // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n        if (!internalRender && tl._currentIteration !== _currentIteration) {\n            const tlIterationDuration = tl.iterationDuration;\n            forEachChildren(tl, (/** @type {JSAnimation} */ child)=>{\n                if (!tlIsRunningBackwards) {\n                    // Force an internal render to trigger the callbacks if the child has not completed on loop\n                    if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n                        render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n                    }\n                    // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n                    child.began = false;\n                    child.completed = false;\n                } else {\n                    const childDuration = child.duration;\n                    const childStartTime = child._offset + child._delay;\n                    const childEndTime = childStartTime + childDuration;\n                    // Triggers the onComplete callback on reverse for children on the edges of the timeline\n                    if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n                        child.onComplete(child);\n                    }\n                }\n            });\n            if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */ tl);\n        }\n        forEachChildren(tl, (/** @type {JSAnimation} */ child)=>{\n            const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n            const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n            tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n            if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n        }, tlIsRunningBackwards);\n        // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n        if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */ tl);\n        // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n        if (tlChildrenHaveCompleted && tl._currentTime >= tl.duration) {\n            // Make sure the paused flag is false in case it has been skipped in the render function\n            tl.paused = true;\n            if (!tl.completed) {\n                tl.completed = true;\n                if (!muteCallbacks) {\n                    tl.onComplete(/** @type {CallbackArgument} */ tl);\n                    tl._resolve(/** @type {CallbackArgument} */ tl);\n                }\n            }\n        }\n    }\n};\nconst additive = {\n    animation: null,\n    update: noop\n};\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */ /**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */ const addAdditiveAnimation = (lookups)=>{\n    let animation = additive.animation;\n    if (!animation) {\n        animation = {\n            duration: minValue,\n            computeDeltaTime: noop,\n            _offset: 0,\n            _delay: 0,\n            _head: null,\n            _tail: null\n        };\n        additive.animation = animation;\n        additive.update = ()=>{\n            lookups.forEach((propertyAnimation)=>{\n                for(let propertyName in propertyAnimation){\n                    const tweens = propertyAnimation[propertyName];\n                    const lookupTween = tweens._head;\n                    if (lookupTween) {\n                        const valueType = lookupTween._valueType;\n                        const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n                        let additiveValue = lookupTween._fromNumber;\n                        let tween = tweens._tail;\n                        while(tween && tween !== lookupTween){\n                            if (additiveValues) {\n                                for(let i = 0, l = tween._numbers.length; i < l; i++)additiveValues[i] += tween._numbers[i];\n                            } else {\n                                additiveValue += tween._number;\n                            }\n                            tween = tween._prevAdd;\n                        }\n                        lookupTween._toNumber = additiveValue;\n                        lookupTween._toNumbers = additiveValues;\n                    }\n                }\n            });\n            // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n            render(animation, 1, 1, 0, tickModes.FORCE);\n        };\n    }\n    return animation;\n};\nconst engineTickMethod = isBrowser ? requestAnimationFrame : setImmediate;\nconst engineCancelMethod = isBrowser ? cancelAnimationFrame : clearImmediate;\nclass Engine extends Clock {\n    /** @param {Number} [initTime] */ constructor(initTime){\n        super(initTime);\n        this.useDefaultMainLoop = true;\n        this.pauseOnDocumentHidden = true;\n        /** @type {DefaultsParams} */ this.defaults = defaults;\n        this.paused = isBrowser && doc.hidden ? true : false;\n        /** @type {Number|NodeJS.Immediate} */ this.reqId = null;\n    }\n    update() {\n        const time = this._currentTime = now();\n        if (this.requestTick(time)) {\n            this.computeDeltaTime(time);\n            const engineSpeed = this._speed;\n            const engineFps = this._fps;\n            let activeTickable = /** @type {Tickable} */ this._head;\n            while(activeTickable){\n                const nextTickable = activeTickable._next;\n                if (!activeTickable.paused) {\n                    tick(activeTickable, (time - activeTickable._startTime) * activeTickable._speed * engineSpeed, 0, 0, activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO);\n                } else {\n                    removeChild(this, activeTickable);\n                    this._hasChildren = !!this._tail;\n                    activeTickable._running = false;\n                    if (activeTickable.completed && !activeTickable._cancelled) {\n                        activeTickable.cancel();\n                    }\n                }\n                activeTickable = nextTickable;\n            }\n            additive.update();\n        }\n    }\n    wake() {\n        if (this.useDefaultMainLoop && !this.reqId && !this.paused) {\n            this.reqId = engineTickMethod(tickEngine);\n        }\n        return this;\n    }\n    pause() {\n        this.paused = true;\n        return killEngine();\n    }\n    resume() {\n        if (!this.paused) return;\n        this.paused = false;\n        forEachChildren(this, (/** @type {Tickable} */ child)=>child.resetTime());\n        return this.wake();\n    }\n    // Getter and setter for speed\n    get speed() {\n        return this._speed * (globals.timeScale === 1 ? 1 : K);\n    }\n    set speed(playbackRate) {\n        this._speed = playbackRate * globals.timeScale;\n        forEachChildren(this, (/** @type {Tickable} */ child)=>child.speed = child._speed);\n    }\n    // Getter and setter for timeUnit\n    get timeUnit() {\n        return globals.timeScale === 1 ? \"ms\" : \"s\";\n    }\n    set timeUnit(unit) {\n        const secondsScale = 0.001;\n        const isSecond = unit === \"s\";\n        const newScale = isSecond ? secondsScale : 1;\n        if (globals.timeScale !== newScale) {\n            globals.timeScale = newScale;\n            globals.tickThreshold = 200 * newScale;\n            const scaleFactor = isSecond ? secondsScale : K;\n            /** @type {Number} */ this.defaults.duration *= scaleFactor;\n            this._speed *= scaleFactor;\n        }\n    }\n    // Getter and setter for precision\n    get precision() {\n        return globals.precision;\n    }\n    set precision(precision) {\n        globals.precision = precision;\n    }\n}\nconst engine = /*#__PURE__*/ (()=>{\n    const engine = new Engine(now());\n    if (isBrowser) {\n        globalVersions.engine = engine;\n        doc.addEventListener(\"visibilitychange\", ()=>{\n            if (!engine.pauseOnDocumentHidden) return;\n            doc.hidden ? engine.pause() : engine.resume();\n        });\n    }\n    return engine;\n})();\nconst tickEngine = ()=>{\n    if (engine._head) {\n        engine.reqId = engineTickMethod(tickEngine);\n        engine.update();\n    } else {\n        engine.reqId = 0;\n    }\n};\nconst killEngine = ()=>{\n    engineCancelMethod(/** @type {NodeJS.Immediate & Number} */ engine.reqId);\n    engine.reqId = 0;\n    return engine;\n};\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */ const parseInlineTransforms = (target, propName, animationInlineStyles)=>{\n    const inlineTransforms = target.style.transform;\n    let inlinedStylesPropertyValue;\n    if (inlineTransforms) {\n        const cachedTransforms = target[transformsSymbol];\n        let t;\n        while(t = transformsExecRgx.exec(inlineTransforms)){\n            const inlinePropertyName = t[1];\n            // const inlinePropertyValue = t[2];\n            const inlinePropertyValue = t[2].slice(1, -1);\n            cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n            if (inlinePropertyName === propName) {\n                inlinedStylesPropertyValue = inlinePropertyValue;\n                // Store the new parsed inline styles if animationInlineStyles is provided\n                if (animationInlineStyles) {\n                    animationInlineStyles[propName] = inlinePropertyValue;\n                }\n            }\n        }\n    }\n    return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, \"scale\") ? \"1\" : stringStartsWith(propName, \"rotate\") || stringStartsWith(propName, \"skew\") ? \"0deg\" : \"0px\";\n};\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */ function getNodeList(v) {\n    const n = isStr(v) ? globals.root.querySelectorAll(v) : v;\n    if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */ function parseTargets(targets) {\n    if (isNil(targets)) return /** @type {TargetsArray} */ [];\n    if (isArr(targets)) {\n        const flattened = targets.flat(Infinity);\n        /** @type {TargetsArray} */ const parsed = [];\n        for(let i = 0, l = flattened.length; i < l; i++){\n            const item = flattened[i];\n            if (!isNil(item)) {\n                const nodeList = getNodeList(item);\n                if (nodeList) {\n                    for(let j = 0, jl = nodeList.length; j < jl; j++){\n                        const subItem = nodeList[j];\n                        if (!isNil(subItem)) {\n                            let isDuplicate = false;\n                            for(let k = 0, kl = parsed.length; k < kl; k++){\n                                if (parsed[k] === subItem) {\n                                    isDuplicate = true;\n                                    break;\n                                }\n                            }\n                            if (!isDuplicate) {\n                                parsed.push(subItem);\n                            }\n                        }\n                    }\n                } else {\n                    let isDuplicate = false;\n                    for(let j = 0, jl = parsed.length; j < jl; j++){\n                        if (parsed[j] === item) {\n                            isDuplicate = true;\n                            break;\n                        }\n                    }\n                    if (!isDuplicate) {\n                        parsed.push(item);\n                    }\n                }\n            }\n        }\n        return parsed;\n    }\n    if (!isBrowser) return /** @type {JSTargetsArray} */ [\n        targets\n    ];\n    const nodeList = getNodeList(targets);\n    if (nodeList) return /** @type {DOMTargetsArray} */ Array.from(nodeList);\n    return /** @type {TargetsArray} */ [\n        targets\n    ];\n}\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */ function registerTargets(targets) {\n    const parsedTargetsArray = parseTargets(targets);\n    const parsedTargetsLength = parsedTargetsArray.length;\n    if (parsedTargetsLength) {\n        for(let i = 0; i < parsedTargetsLength; i++){\n            const target = parsedTargetsArray[i];\n            if (!target[isRegisteredTargetSymbol]) {\n                target[isRegisteredTargetSymbol] = true;\n                const isSvgType = isSvg(target);\n                const isDom = /** @type {DOMTarget} */ target.nodeType || isSvgType;\n                if (isDom) {\n                    target[isDomSymbol] = true;\n                    target[isSvgSymbol] = isSvgType;\n                    target[transformsSymbol] = {};\n                }\n            }\n        }\n    }\n    return parsedTargetsArray;\n}\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */ const getPath = (path)=>{\n    const parsedTargets = parseTargets(path);\n    const $parsedSvg = /** @type {SVGGeometryElement} */ parsedTargets[0];\n    if (!$parsedSvg || !isSvg($parsedSvg)) return;\n    return $parsedSvg;\n};\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */ const morphTo = (path2, precision = .33)=>($path1)=>{\n        const $path2 = /** @type {SVGGeometryElement} */ getPath(path2);\n        if (!$path2) return;\n        const isPath = $path1.tagName === \"path\";\n        const separator = isPath ? \" \" : \",\";\n        const previousPoints = $path1[morphPointsSymbol];\n        if (previousPoints) $path1.setAttribute(isPath ? \"d\" : \"points\", previousPoints);\n        let v1 = \"\", v2 = \"\";\n        if (!precision) {\n            v1 = $path1.getAttribute(isPath ? \"d\" : \"points\");\n            v2 = $path2.getAttribute(isPath ? \"d\" : \"points\");\n        } else {\n            const length1 = /** @type {SVGGeometryElement} */ $path1.getTotalLength();\n            const length2 = $path2.getTotalLength();\n            const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n            for(let i = 0; i < maxPoints; i++){\n                const t = i / (maxPoints - 1);\n                const pointOnPath1 = /** @type {SVGGeometryElement} */ $path1.getPointAtLength(length1 * t);\n                const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n                const prefix = isPath ? i === 0 ? \"M\" : \"L\" : \"\";\n                v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + \" \";\n                v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + \" \";\n            }\n        }\n        $path1[morphPointsSymbol] = v2;\n        return [\n            v1,\n            v2\n        ];\n    };\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */ const getScaleFactor = ($el)=>{\n    let scaleFactor = 1;\n    if ($el && $el.getCTM) {\n        const ctm = $el.getCTM();\n        if (ctm) {\n            const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n            const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n            scaleFactor = (scaleX + scaleY) / 2;\n        }\n    }\n    return scaleFactor;\n};\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */ const createDrawableProxy = ($el, start, end)=>{\n    const pathLength = K;\n    const computedStyles = getComputedStyle($el);\n    const strokeLineCap = computedStyles.strokeLinecap;\n    // @ts-ignore\n    const $scalled = computedStyles.vectorEffect === \"non-scaling-stroke\" ? $el : null;\n    let currentCap = strokeLineCap;\n    const proxy = new Proxy($el, {\n        get (target, property) {\n            const value = target[property];\n            if (property === proxyTargetSymbol) return target;\n            if (property === \"setAttribute\") {\n                return (...args)=>{\n                    if (args[0] === \"draw\") {\n                        const value = args[1];\n                        const values = value.split(\" \");\n                        const v1 = +values[0];\n                        const v2 = +values[1];\n                        // TOTO: Benchmark if performing two slices is more performant than one split\n                        // const spaceIndex = value.indexOf(' ');\n                        // const v1 = round(+value.slice(0, spaceIndex), precision);\n                        // const v2 = round(+value.slice(spaceIndex + 1), precision);\n                        const scaleFactor = getScaleFactor($scalled);\n                        const os = v1 * -1e3 * scaleFactor;\n                        const d1 = v2 * pathLength * scaleFactor + os;\n                        const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;\n                        if (strokeLineCap !== \"butt\") {\n                            const newCap = v1 === v2 ? \"butt\" : strokeLineCap;\n                            if (currentCap !== newCap) {\n                                target.style.strokeLinecap = `${newCap}`;\n                                currentCap = newCap;\n                            }\n                        }\n                        target.setAttribute(\"stroke-dashoffset\", `${os}`);\n                        target.setAttribute(\"stroke-dasharray\", `${d1} ${d2}`);\n                    }\n                    return Reflect.apply(value, target, args);\n                };\n            }\n            if (isFnc(value)) {\n                return (...args)=>Reflect.apply(value, target, args);\n            } else {\n                return value;\n            }\n        }\n    });\n    if ($el.getAttribute(\"pathLength\") !== `${pathLength}`) {\n        $el.setAttribute(\"pathLength\", `${pathLength}`);\n        proxy.setAttribute(\"draw\", `${start} ${end}`);\n    }\n    return /** @type {DrawableSVGGeometry} */ proxy;\n};\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */ const createDrawable = (selector, start = 0, end = 0)=>{\n    const els = parseTargets(selector);\n    return els.map(($el)=>createDrawableProxy(/** @type {SVGGeometryElement} */ $el, start, end));\n};\n// Motion path animation\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */ const getPathPoint = ($path, progress, lookup = 0)=>{\n    return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */ const getPathProgess = ($path, pathProperty)=>{\n    return ($el)=>{\n        const totalLength = +$path.getTotalLength();\n        const inSvg = $el[isSvgSymbol];\n        const ctm = $path.getCTM();\n        /** @type {TweenObjectValue} */ return {\n            from: 0,\n            to: totalLength,\n            /** @type {TweenModifier} */ modifier: (progress)=>{\n                if (pathProperty === \"a\") {\n                    const p0 = getPathPoint($path, progress, -1);\n                    const p1 = getPathPoint($path, progress, 1);\n                    return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n                } else {\n                    const p = getPathPoint($path, progress, 0);\n                    return pathProperty === \"x\" ? inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e : inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;\n                }\n            }\n        };\n    };\n};\n/**\n * @param {TargetsParam} path\n */ const createMotionPath = (path)=>{\n    const $path = getPath(path);\n    if (!$path) return;\n    return {\n        translateX: getPathProgess($path, \"x\"),\n        translateY: getPathProgess($path, \"y\"),\n        rotate: getPathProgess($path, \"a\")\n    };\n};\n// Check for valid SVG attribute\nconst cssReservedProperties = [\n    \"opacity\",\n    \"rotate\",\n    \"overflow\",\n    \"color\"\n];\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */ const isValidSVGAttribute = (el, propertyName)=>{\n    // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n    if (cssReservedProperties.includes(propertyName)) return false;\n    if (el.getAttribute(propertyName) || propertyName in el) {\n        if (propertyName === \"scale\") {\n            const elParentNode = /** @type {SVGGeometryElement} */ /** @type {DOMTarget} */ el.parentNode;\n            // Only consider scale as a valid SVG attribute on filter element\n            return elParentNode && elParentNode.tagName === \"filter\";\n        }\n        return true;\n    }\n};\nconst svg = {\n    morphTo,\n    createMotionPath,\n    createDrawable\n};\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */ const rgbToRgba = (rgbValue)=>{\n    const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n    const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n    return [\n        +rgba[1],\n        +rgba[2],\n        +rgba[3],\n        a\n    ];\n};\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */ const hexToRgba = (hexValue)=>{\n    const hexLength = hexValue.length;\n    const isShort = hexLength === 4 || hexLength === 5;\n    return [\n        +(\"0x\" + hexValue[1] + hexValue[isShort ? 1 : 2]),\n        +(\"0x\" + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n        +(\"0x\" + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n        hexLength === 5 || hexLength === 9 ? +(+(\"0x\" + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1\n    ];\n};\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */ const hue2rgb = (p, q, t)=>{\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    return t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;\n};\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */ const hslToRgba = (hslValue)=>{\n    const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n    const h = +hsla[1] / 360;\n    const s = +hsla[2] / 100;\n    const l = +hsla[3] / 100;\n    const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const q = l < .5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n        g = round(hue2rgb(p, q, h) * 255, 0);\n        b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n    }\n    return [\n        r,\n        g,\n        b,\n        a\n    ];\n};\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */ const convertColorStringValuesToRgbaArray = (colorString)=>{\n    return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [\n        0,\n        0,\n        0,\n        1\n    ];\n};\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */ const setValue = (targetValue, defaultValue)=>{\n    return isUnd(targetValue) ? defaultValue : targetValue;\n};\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */ const getFunctionValue = (value, target, index, total, store)=>{\n    if (isFnc(value)) {\n        const func = ()=>{\n            const computed = /** @type {Function} */ value(target, index, total);\n            // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n            return !isNaN(+computed) ? +computed : computed || 0;\n        };\n        if (store) {\n            store.func = func;\n        }\n        return func();\n    } else {\n        return value;\n    }\n};\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */ const getTweenType = (target, prop)=>{\n    return !target[isDomSymbol] ? tweenTypes.OBJECT : // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE : // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM : // CSS variables\n    stringStartsWith(prop, \"--\") ? tweenTypes.CSS_VAR : // All other CSS properties\n    prop in /** @type {DOMTarget} */ target.style ? tweenTypes.CSS : // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE;\n};\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */ const getCSSValue = (target, propName, animationInlineStyles)=>{\n    const inlineStyles = target.style[propName];\n    if (inlineStyles && animationInlineStyles) {\n        animationInlineStyles[propName] = inlineStyles;\n    }\n    const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n    return value === \"auto\" ? \"0\" : value;\n};\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */ const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles)=>{\n    const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n    return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */ target.getAttribute(propName) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */ target, propName, animationInlineStyles) : type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */ target, propName, animationInlineStyles).trimStart() : getCSSValue(/** @type {DOMTarget} */ target, propName, animationInlineStyles);\n};\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */ const getRelativeValue = (x, y, operator)=>{\n    return operator === \"-\" ? x - y : operator === \"+\" ? x + y : x * y;\n};\n/** @return {TweenDecomposedValue} */ const createDecomposedValueTargetObject = ()=>{\n    return {\n        /** @type {valueTypes} */ t: valueTypes.NUMBER,\n        n: 0,\n        u: null,\n        o: null,\n        d: null,\n        s: null\n    };\n};\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */ const decomposeRawValue = (rawValue, targetObject)=>{\n    /** @type {valueTypes} */ targetObject.t = valueTypes.NUMBER;\n    targetObject.n = 0;\n    targetObject.u = null;\n    targetObject.o = null;\n    targetObject.d = null;\n    targetObject.s = null;\n    if (!rawValue) return targetObject;\n    const num = +rawValue;\n    if (!isNaN(num)) {\n        // It's a number\n        targetObject.n = num;\n        return targetObject;\n    } else {\n        // let str = /** @type {String} */(rawValue).trim();\n        let str = /** @type {String} */ rawValue;\n        // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n        if (str[1] === \"=\") {\n            targetObject.o = str[0];\n            str = str.slice(2);\n        }\n        // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n        const unitMatch = str.includes(\" \") ? false : unitsExecRgx.exec(str);\n        if (unitMatch) {\n            // Has a number and a unit\n            targetObject.t = valueTypes.UNIT;\n            targetObject.n = +unitMatch[1];\n            targetObject.u = unitMatch[2];\n            return targetObject;\n        } else if (targetObject.o) {\n            // Has an operator (+=, -=, *=)\n            targetObject.n = +str;\n            return targetObject;\n        } else if (isCol(str)) {\n            // Is a color\n            targetObject.t = valueTypes.COLOR;\n            targetObject.d = convertColorStringValuesToRgbaArray(str);\n            return targetObject;\n        } else {\n            // Is a more complex string (generally svg coords, calc() or filters CSS values)\n            const matchedNumbers = str.match(digitWithExponentRgx);\n            targetObject.t = valueTypes.COMPLEX;\n            targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n            targetObject.s = str.split(digitWithExponentRgx) || [];\n            return targetObject;\n        }\n    }\n};\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */ const decomposeTweenValue = (tween, targetObject)=>{\n    targetObject.t = tween._valueType;\n    targetObject.n = tween._toNumber;\n    targetObject.u = tween._unit;\n    targetObject.o = null;\n    targetObject.d = cloneArray(tween._toNumbers);\n    targetObject.s = cloneArray(tween._strings);\n    return targetObject;\n};\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\nconst lookups = {\n    /** @type {TweenReplaceLookups} */ _rep: new WeakMap(),\n    /** @type {TweenAdditiveLookups} */ _add: new Map()\n};\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */ const getTweenSiblings = (target, property, lookup = \"_rep\")=>{\n    const lookupMap = lookups[lookup];\n    let targetLookup = lookupMap.get(target);\n    if (!targetLookup) {\n        targetLookup = {};\n        lookupMap.set(target, targetLookup);\n    }\n    return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n        _head: null,\n        _tail: null\n    };\n};\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */ const addTweenSortMethod = (p, c)=>{\n    return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n/**\n * @param {Tween} tween\n */ const overrideTween = (tween)=>{\n    tween._isOverlapped = 1;\n    tween._isOverridden = 1;\n    tween._changeDuration = minValue;\n    tween._currentTime = minValue;\n};\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */ const composeTween = (tween, siblings)=>{\n    const tweenCompositionType = tween._composition;\n    // Handle replaced tweens\n    if (tweenCompositionType === compositionTypes.replace) {\n        const tweenAbsStartTime = tween._absoluteStartTime;\n        addChild(siblings, tween, addTweenSortMethod, \"_prevRep\", \"_nextRep\");\n        const prevSibling = tween._prevRep;\n        // Update the previous siblings for composition replace tweens\n        if (prevSibling) {\n            const prevParent = prevSibling.parent;\n            const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n            // Handle looped animations tween\n            if (// Check if the previous tween is from a different animation\n            tween.parent.id !== prevParent.id && // Check if the animation has loops\n            prevParent.iterationCount > 1 && // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n            prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {\n                // TODO: Find a way to only override the iterations overlapping with the tween\n                overrideTween(prevSibling);\n                let prevPrevSibling = prevSibling._prevRep;\n                // If the tween was part of a set of keyframes, override its siblings\n                while(prevPrevSibling && prevPrevSibling.parent.id === prevParent.id){\n                    overrideTween(prevPrevSibling);\n                    prevPrevSibling = prevPrevSibling._prevRep;\n                }\n            }\n            const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n            if (prevAbsEndTime > absoluteUpdateStartTime) {\n                const prevChangeStartTime = prevSibling._startTime;\n                const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n                prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;\n                prevSibling._currentTime = prevSibling._changeDuration;\n                prevSibling._isOverlapped = 1;\n                if (prevSibling._changeDuration < minValue) {\n                    overrideTween(prevSibling);\n                }\n            }\n            // Pause (and cancel) the parent if it only contains overlapped tweens\n            let pausePrevParentAnimation = true;\n            forEachChildren(prevParent, (/** @type Tween */ t)=>{\n                if (!t._isOverlapped) pausePrevParentAnimation = false;\n            });\n            if (pausePrevParentAnimation) {\n                const prevParentTL = prevParent.parent;\n                if (prevParentTL) {\n                    let pausePrevParentTL = true;\n                    forEachChildren(prevParentTL, (/** @type JSAnimation */ a)=>{\n                        if (a !== prevParent) {\n                            forEachChildren(a, (/** @type Tween */ t)=>{\n                                if (!t._isOverlapped) pausePrevParentTL = false;\n                            });\n                        }\n                    });\n                    if (pausePrevParentTL) {\n                        prevParentTL.cancel();\n                    }\n                } else {\n                    prevParent.cancel();\n                // Previously, calling .cancel() on a timeline child would affect the render order of other children\n                // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n                // This is no longer needed since timeline tween composition is now handled separatly\n                // Keeping this here for reference\n                // prevParent.completed = true;\n                // prevParent.pause();\n                }\n            }\n        }\n    // let nextSibling = tween._nextRep;\n    // // All the next siblings are automatically overridden\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n    // Handle additive tweens composition\n    } else if (tweenCompositionType === compositionTypes.blend) {\n        const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, \"_add\");\n        const additiveAnimation = addAdditiveAnimation(lookups._add);\n        let lookupTween = additiveTweenSiblings._head;\n        if (!lookupTween) {\n            lookupTween = {\n                ...tween\n            };\n            lookupTween._composition = compositionTypes.replace;\n            lookupTween._updateDuration = minValue;\n            lookupTween._startTime = 0;\n            lookupTween._numbers = cloneArray(tween._fromNumbers);\n            lookupTween._number = 0;\n            lookupTween._next = null;\n            lookupTween._prev = null;\n            addChild(additiveTweenSiblings, lookupTween);\n            addChild(additiveAnimation, lookupTween);\n        }\n        // Convert the values of TO to FROM and set TO to 0\n        const toNumber = tween._toNumber;\n        tween._fromNumber = lookupTween._fromNumber - toNumber;\n        tween._toNumber = 0;\n        tween._numbers = cloneArray(tween._fromNumbers);\n        tween._number = 0;\n        lookupTween._fromNumber = toNumber;\n        if (tween._toNumbers) {\n            const toNumbers = cloneArray(tween._toNumbers);\n            if (toNumbers) {\n                toNumbers.forEach((value, i)=>{\n                    tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n                    tween._toNumbers[i] = 0;\n                });\n            }\n            lookupTween._fromNumbers = toNumbers;\n        }\n        addChild(additiveTweenSiblings, tween, null, \"_prevAdd\", \"_nextAdd\");\n    }\n    return tween;\n};\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */ const removeTweenSliblings = (tween)=>{\n    const tweenComposition = tween._composition;\n    if (tweenComposition !== compositionTypes.none) {\n        const tweenTarget = tween.target;\n        const tweenProperty = tween.property;\n        const replaceTweensLookup = lookups._rep;\n        const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n        const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n        removeChild(tweenReplaceSiblings, tween, \"_prevRep\", \"_nextRep\");\n        if (tweenComposition === compositionTypes.blend) {\n            const addTweensLookup = lookups._add;\n            const addTargetProps = addTweensLookup.get(tweenTarget);\n            if (!addTargetProps) return;\n            const additiveTweenSiblings = addTargetProps[tweenProperty];\n            const additiveAnimation = additive.animation;\n            removeChild(additiveTweenSiblings, tween, \"_prevAdd\", \"_nextAdd\");\n            // If only one tween is left in the additive lookup, it's the tween lookup\n            const lookupTween = additiveTweenSiblings._head;\n            if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n                removeChild(additiveTweenSiblings, lookupTween, \"_prevAdd\", \"_nextAdd\");\n                removeChild(additiveAnimation, lookupTween);\n                let shouldClean = true;\n                for(let prop in addTargetProps){\n                    if (addTargetProps[prop]._head) {\n                        shouldClean = false;\n                        break;\n                    }\n                }\n                if (shouldClean) {\n                    addTweensLookup.delete(tweenTarget);\n                }\n            }\n        }\n    }\n    return tween;\n};\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */ const resetTimerProperties = (timer)=>{\n    timer.paused = true;\n    timer.began = false;\n    timer.completed = false;\n    return timer;\n};\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */ const reviveTimer = (timer)=>{\n    if (!timer._cancelled) return timer;\n    if (timer._hasChildren) {\n        forEachChildren(timer, reviveTimer);\n    } else {\n        forEachChildren(timer, (/** @type {Tween} tween*/ tween)=>{\n            if (tween._composition !== compositionTypes.none) {\n                composeTween(tween, getTweenSiblings(tween.target, tween.property));\n            }\n        });\n    }\n    timer._cancelled = 0;\n    return timer;\n};\nlet timerId = 0;\n/**\n * Base class used to create Timers, Animations and Timelines\n */ class Timer extends Clock {\n    /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */ constructor(parameters = {}, parent = null, parentPosition = 0){\n        super(0);\n        const { id, delay, duration, reversed, alternate, loop, loopDelay, autoplay, frameRate, playbackRate, onComplete, onLoop, onPause, onBegin, onBeforeUpdate, onUpdate } = parameters;\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const timerInitTime = parent ? 0 : engine._elapsedTime;\n        const timerDefaults = parent ? parent.defaults : globals.defaults;\n        const timerDelay = /** @type {Number} */ isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay;\n        const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n        const timerLoop = setValue(loop, timerDefaults.loop);\n        const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n        const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */ timerLoop < 0 ? Infinity : /** @type {Number} */ timerLoop + 1;\n        let offsetPosition = 0;\n        if (parent) {\n            offsetPosition = parentPosition;\n        } else {\n            let startTime = now();\n            // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation\n            if (engine.paused) {\n                engine.requestTick(startTime);\n                startTime = engine._elapsedTime;\n            }\n            offsetPosition = startTime - engine._startTime;\n        }\n        // Timer's parameters\n        this.id = !isUnd(id) ? id : ++timerId;\n        /** @type {Timeline} */ this.parent = parent;\n        // Total duration of the timer\n        this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;\n        /** @type {Boolean} */ this.backwards = false;\n        /** @type {Boolean} */ this.paused = true;\n        /** @type {Boolean} */ this.began = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Callback<this>} */ this.onBegin = onBegin || timerDefaults.onBegin;\n        /** @type {Callback<this>} */ this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n        /** @type {Callback<this>} */ this.onUpdate = onUpdate || timerDefaults.onUpdate;\n        /** @type {Callback<this>} */ this.onLoop = onLoop || timerDefaults.onLoop;\n        /** @type {Callback<this>} */ this.onPause = onPause || timerDefaults.onPause;\n        /** @type {Callback<this>} */ this.onComplete = onComplete || timerDefaults.onComplete;\n        /** @type {Number} */ this.iterationDuration = timerDuration; // Duration of one loop\n        /** @type {Number} */ this.iterationCount = timerIterationCount; // Number of loops\n        /** @type {Boolean|ScrollObserver} */ this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n        /** @type {Number} */ this._offset = offsetPosition;\n        /** @type {Number} */ this._delay = timerDelay;\n        /** @type {Number} */ this._loopDelay = timerLoopDelay;\n        /** @type {Number} */ this._iterationTime = 0;\n        /** @type {Number} */ this._currentIteration = 0; // Current loop index\n        /** @type {Function} */ this._resolve = noop; // Used by .then()\n        /** @type {Boolean} */ this._running = false;\n        /** @type {Number} */ this._reversed = +setValue(reversed, timerDefaults.reversed);\n        /** @type {Number} */ this._reverse = this._reversed;\n        /** @type {Number} */ this._cancelled = 0;\n        /** @type {Boolean} */ this._alternate = setValue(alternate, timerDefaults.alternate);\n        /** @type {Renderable} */ this._prev = null;\n        /** @type {Renderable} */ this._next = null;\n        // Clock's parameters\n        /** @type {Number} */ this._elapsedTime = timerInitTime;\n        /** @type {Number} */ this._startTime = timerInitTime;\n        /** @type {Number} */ this._lastTime = timerInitTime;\n        /** @type {Number} */ this._fps = setValue(frameRate, timerDefaults.frameRate);\n        /** @type {Number} */ this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n    }\n    get cancelled() {\n        return !!this._cancelled;\n    }\n    /** @param {Boolean} cancelled  */ set cancelled(cancelled) {\n        cancelled ? this.cancel() : this.reset(1).play();\n    }\n    get currentTime() {\n        return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n    }\n    /** @param {Number} time  */ set currentTime(time) {\n        const paused = this.paused;\n        // Pausing the timer is necessary to avoid time jumps on a running instance\n        this.pause().seek(+time);\n        if (!paused) this.resume();\n    }\n    get iterationCurrentTime() {\n        return round(this._iterationTime, globals.precision);\n    }\n    /** @param {Number} time  */ set iterationCurrentTime(time) {\n        this.currentTime = this.iterationDuration * this._currentIteration + time;\n    }\n    get progress() {\n        return clamp(round(this._currentTime / this.duration, 5), 0, 1);\n    }\n    /** @param {Number} progress  */ set progress(progress) {\n        this.currentTime = this.duration * progress;\n    }\n    get iterationProgress() {\n        return clamp(round(this._iterationTime / this.iterationDuration, 5), 0, 1);\n    }\n    /** @param {Number} progress  */ set iterationProgress(progress) {\n        const iterationDuration = this.iterationDuration;\n        this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;\n    }\n    get currentIteration() {\n        return this._currentIteration;\n    }\n    /** @param {Number} iterationCount  */ set currentIteration(iterationCount) {\n        this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);\n    }\n    get reversed() {\n        return !!this._reversed;\n    }\n    /** @param {Boolean} reverse  */ set reversed(reverse) {\n        reverse ? this.reverse() : this.play();\n    }\n    get speed() {\n        return super.speed;\n    }\n    /** @param {Number} playbackRate  */ set speed(playbackRate) {\n        super.speed = playbackRate;\n        this.resetTime();\n    }\n    /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */ reset(internalRender = 0) {\n        // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n        reviveTimer(this);\n        if (this._reversed && !this._reverse) this.reversed = false;\n        // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n        // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n        // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n        this._iterationTime = this.iterationDuration;\n        // Set tickMode to tickModes.FORCE to force rendering\n        tick(this, 0, 1, internalRender, tickModes.FORCE);\n        // Reset timer properties after revive / render to make sure the props are not updated again\n        resetTimerProperties(this);\n        // Also reset children properties\n        if (this._hasChildren) {\n            forEachChildren(this, resetTimerProperties);\n        }\n        return this;\n    }\n    /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */ init(internalRender = 0) {\n        this.fps = this._fps;\n        this.speed = this._speed;\n        // Manually calling .init() on timelines should render all children intial state\n        // Forces all children to render once then render to 0 when reseted\n        if (!internalRender && this._hasChildren) {\n            tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n        }\n        this.reset(internalRender);\n        // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n        const autoplay = this._autoplay;\n        if (autoplay === true) {\n            this.resume();\n        } else if (autoplay && !isUnd(/** @type {ScrollObserver} */ autoplay.linked)) {\n            /** @type {ScrollObserver} */ autoplay.link(this);\n        }\n        return this;\n    }\n    /** @return {this} */ resetTime() {\n        const timeScale = 1 / (this._speed * engine._speed);\n        this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n        return this;\n    }\n    /** @return {this} */ pause() {\n        if (this.paused) return this;\n        this.paused = true;\n        this.onPause(this);\n        return this;\n    }\n    /** @return {this} */ resume() {\n        if (!this.paused) return this;\n        this.paused = false;\n        // We can safely imediatly render a timer that has no duration and no children\n        if (this.duration <= minValue && !this._hasChildren) {\n            tick(this, minValue, 0, 0, tickModes.FORCE);\n        } else {\n            if (!this._running) {\n                addChild(engine, this);\n                engine._hasChildren = true;\n                this._running = true;\n            }\n            this.resetTime();\n            // Forces the timer to advance by at least one frame when the next tick occurs\n            this._startTime -= 12;\n            engine.wake();\n        }\n        return this;\n    }\n    /** @return {this} */ restart() {\n        return this.reset(0).resume();\n    }\n    /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */ seek(time, muteCallbacks = 0, internalRender = 0) {\n        // Recompose the tween siblings in case the timer has been cancelled\n        reviveTimer(this);\n        // If you seek a completed animation, otherwise the next play will starts at 0\n        this.completed = false;\n        const isPaused = this.paused;\n        this.paused = true;\n        // timer, time, muteCallbacks, internalRender, tickMode\n        tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n        return isPaused ? this : this.resume();\n    }\n    /** @return {this} */ alternate() {\n        const reversed = this._reversed;\n        const count = this.iterationCount;\n        const duration = this.iterationDuration;\n        // Calculate the maximum iterations possible given the iteration duration\n        const iterations = count === Infinity ? floor(maxValue / duration) : count;\n        this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n        if (count === Infinity) {\n            // Handle infinite loops to loop on themself\n            this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n        } else {\n            this.seek(duration * iterations - this._currentTime);\n        }\n        this.resetTime();\n        return this;\n    }\n    /** @return {this} */ play() {\n        if (this._reversed) this.alternate();\n        return this.resume();\n    }\n    /** @return {this} */ reverse() {\n        if (!this._reversed) this.alternate();\n        return this.resume();\n    }\n    // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n    /** @return {this} */ cancel() {\n        if (this._hasChildren) {\n            forEachChildren(this, (/** @type {Renderable} */ child)=>child.cancel(), true);\n        } else {\n            forEachChildren(this, removeTweenSliblings);\n        }\n        this._cancelled = 1;\n        // Pausing the timer removes it from the engine\n        return this.pause();\n    }\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        const normlizedDuration = normalizeTime(newDuration);\n        if (currentDuration === normlizedDuration) return this;\n        const timeScale = newDuration / currentDuration;\n        const isSetter = newDuration <= minValue;\n        this.duration = isSetter ? minValue : normlizedDuration;\n        this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n        this._offset *= timeScale;\n        this._delay *= timeScale;\n        this._loopDelay *= timeScale;\n        return this;\n    }\n    /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */ revert() {\n        tick(this, 0, 1, 0, tickModes.AUTO);\n        const ap = /** @type {ScrollObserver} */ this._autoplay;\n        if (ap && ap.linked && ap.linked === this) ap.revert();\n        return this.cancel();\n    }\n    /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */ complete() {\n        return this.seek(this.duration).cancel();\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then(callback = noop) {\n        const then = this.then;\n        const onResolve = ()=>{\n            // this.then = null prevents infinite recursion if returned by an async function\n            // https://github.com/juliangarnierorg/anime-beta/issues/26\n            this.then = null;\n            callback(this);\n            this.then = then;\n            this._resolve = noop;\n        };\n        return new Promise((r)=>{\n            this._resolve = ()=>r(onResolve());\n            // Make sure to resolve imediatly if the timer has already completed\n            if (this.completed) this._resolve();\n            return this;\n        });\n    }\n}\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */ const createTimer = (parameters)=>new Timer(parameters, null, 0).init();\n/** @type {EasingFunction} */ const none = (t)=>t;\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease  Gatan Renaudeau\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */ const calcBezier = (aT, aA1, aA2)=>(((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */ const binarySubdivide = (aX, mX1, mX2)=>{\n    let aA = 0, aB = 1, currentX, currentT, i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (abs(currentX) > .0000001 && ++i < 100);\n    return currentT;\n};\n/**\n * @param  {Number} [mX1]\n * @param  {Number} [mY1]\n * @param  {Number} [mX2]\n * @param  {Number} [mY2]\n * @return {EasingFunction}\n */ const cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0)=>mX1 === mY1 && mX2 === mY2 ? none : (t)=>t === 0 || t === 1 ? t : calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */ const steps = (steps = 10, fromStart)=>{\n    const roundMethod = fromStart ? ceil : floor;\n    return (t)=>roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...String|Number} [args] - Points\n * @return {EasingFunction}\n */ const linear = (...args)=>{\n    const argsLength = args.length;\n    if (!argsLength) return none;\n    const totalPoints = argsLength - 1;\n    const firstArg = args[0];\n    const lastArg = args[totalPoints];\n    const xPoints = [\n        0\n    ];\n    const yPoints = [\n        parseNumber(firstArg)\n    ];\n    for(let i = 1; i < totalPoints; i++){\n        const arg = args[i];\n        const splitValue = isStr(arg) ? /** @type {String} */ arg.trim().split(\" \") : [\n            arg\n        ];\n        const value = splitValue[0];\n        const percent = splitValue[1];\n        xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n        yPoints.push(parseNumber(value));\n    }\n    yPoints.push(parseNumber(lastArg));\n    xPoints.push(1);\n    return function easeLinear(t) {\n        for(let i = 1, l = xPoints.length; i < l; i++){\n            const currentX = xPoints[i];\n            if (t <= currentX) {\n                const prevX = xPoints[i - 1];\n                const prevY = yPoints[i - 1];\n                return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n            }\n        }\n        return yPoints[yPoints.length - 1];\n    };\n};\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */ const irregular = (length = 10, randomness = 1)=>{\n    const values = [\n        0\n    ];\n    const total = length - 1;\n    for(let i = 1; i < total; i++){\n        const previousValue = values[i - 1];\n        const spacing = i / total;\n        const segmentEnd = (i + 1) / total;\n        const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n        // Mix the even spacing and random variation based on the randomness parameter\n        const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n        values.push(clamp(randomValue, previousValue, 1));\n    }\n    values.push(1);\n    return linear(...values);\n};\n// Easing functions adapted from http://www.robertpenner.com/ease  Robert Penner\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */ /**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */ /**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */ /**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */ /** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */ const halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */ const easeInPower = (p = 1.68)=>(t)=>pow(t, +p);\n/** @type {Record<String, EasesFactory|EasingFunction>} */ const easeInFunctions = {\n    [emptyString]: easeInPower,\n    Quad: easeInPower(2),\n    Cubic: easeInPower(3),\n    Quart: easeInPower(4),\n    Quint: easeInPower(5),\n    /** @type {EasingFunction} */ Sine: (t)=>1 - cos(t * halfPI),\n    /** @type {EasingFunction} */ Circ: (t)=>1 - sqrt(1 - t * t),\n    /** @type {EasingFunction} */ Expo: (t)=>t ? pow(2, 10 * t - 10) : 0,\n    /** @type {EasingFunction} */ Bounce: (t)=>{\n        let pow2, b = 4;\n        while(t < ((pow2 = pow(2, --b)) - 1) / 11);\n        return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n    },\n    /** @type {BackEasing} */ Back: (overshoot = 1.70158)=>(t)=>(+overshoot + 1) * t * t * t - +overshoot * t * t,\n    /** @type {ElasticEasing} */ Elastic: (amplitude = 1, period = .3)=>{\n        const a = clamp(+amplitude, 1, 10);\n        const p = clamp(+period, minValue, 2);\n        const s = p / doublePI * asin(1 / a);\n        const e = doublePI / p;\n        return (t)=>t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin((1 - t - s) * e);\n    }\n};\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */ /** @type {Record<String, EaseType>} */ const easeTypes = {\n    in: (easeIn)=>(t)=>easeIn(t),\n    out: (easeIn)=>(t)=>1 - easeIn(1 - t),\n    inOut: (easeIn)=>(t)=>t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n    outIn: (easeIn)=>(t)=>t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2\n};\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */ const parseEaseString = (string, easesFunctions, easesLookups)=>{\n    if (easesLookups[string]) return easesLookups[string];\n    if (string.indexOf(\"(\") <= -1) {\n        const hasParams = easeTypes[string] || string.includes(\"Back\") || string.includes(\"Elastic\");\n        const parsedFn = /** @type {EasingFunction} */ hasParams ? /** @type {EasesFactory} */ easesFunctions[string]() : easesFunctions[string];\n        return parsedFn ? easesLookups[string] = parsedFn : none;\n    } else {\n        const split = string.slice(0, -1).split(\"(\");\n        const parsedFn = /** @type {EasesFactory} */ easesFunctions[split[0]];\n        return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(\",\")) : none;\n    }\n};\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */ const eases = /*#__PURE__*/ (()=>{\n    const list = {\n        linear,\n        irregular,\n        steps,\n        cubicBezier\n    };\n    for(let type in easeTypes){\n        for(let name in easeInFunctions){\n            const easeIn = easeInFunctions[name];\n            const easeType = easeTypes[type];\n            list[type + name] = /** @type {EasesFactory|EasingFunction} */ name === emptyString || name === \"Back\" || name === \"Elastic\" ? (a, b)=>easeType(/** @type {EasesFactory} */ easeIn(a, b)) : easeType(/** @type {EasingFunction} */ easeIn);\n        }\n    }\n    return /** @type {EasesFunctions} */ list;\n})();\n/** @type {Record<String, EasingFunction>} */ const JSEasesLookups = {\n    linear: none\n};\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */ const parseEasings = (ease)=>isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */ ease, eases, JSEasesLookups) : none;\nconst propertyNamesCache = {};\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */ const sanitizePropertyName = (propertyName, target, tweenType)=>{\n    if (tweenType === tweenTypes.TRANSFORM) {\n        const t = shortTransforms.get(propertyName);\n        return t ? t : propertyName;\n    } else if (tweenType === tweenTypes.CSS || // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    tweenType === tweenTypes.ATTRIBUTE && isSvg(target) && propertyName in /** @type {DOMTarget} */ target.style) {\n        const cachedPropertyName = propertyNamesCache[propertyName];\n        if (cachedPropertyName) {\n            return cachedPropertyName;\n        } else {\n            const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n            propertyNamesCache[propertyName] = lowerCaseName;\n            return lowerCaseName;\n        }\n    } else {\n        return propertyName;\n    }\n};\nconst angleUnitsMap = {\n    \"deg\": 1,\n    \"rad\": 180 / PI,\n    \"turn\": 360\n};\nconst convertedValuesCache = {};\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */ const convertValueUnit = (el, decomposedValue, unit, force = false)=>{\n    const currentUnit = decomposedValue.u;\n    const currentNumber = decomposedValue.n;\n    if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) {\n        return decomposedValue;\n    }\n    const cachedKey = currentNumber + currentUnit + unit;\n    const cached = convertedValuesCache[cachedKey];\n    if (!isUnd(cached) && !force) {\n        decomposedValue.n = cached;\n    } else {\n        let convertedValue;\n        if (currentUnit in angleUnitsMap) {\n            convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n        } else {\n            const baseline = 100;\n            const tempEl = /** @type {DOMTarget} */ el.cloneNode();\n            const parentNode = el.parentNode;\n            const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;\n            parentEl.appendChild(tempEl);\n            const elStyle = tempEl.style;\n            elStyle.width = baseline + currentUnit;\n            const currentUnitWidth = /** @type {HTMLElement} */ tempEl.offsetWidth || baseline;\n            elStyle.width = baseline + unit;\n            const newUnitWidth = /** @type {HTMLElement} */ tempEl.offsetWidth || baseline;\n            const factor = currentUnitWidth / newUnitWidth;\n            parentEl.removeChild(tempEl);\n            convertedValue = factor * currentNumber;\n        }\n        decomposedValue.n = convertedValue;\n        convertedValuesCache[cachedKey] = convertedValue;\n    }\n    decomposedValue.t === valueTypes.UNIT;\n    decomposedValue.u = unit;\n    return decomposedValue;\n};\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */ const cleanInlineStyles = (renderable)=>{\n    // Allow cleanInlineStyles() to be called on timelines\n    if (renderable._hasChildren) {\n        forEachChildren(renderable, cleanInlineStyles, true);\n    } else {\n        const animation = /** @type {JSAnimation} */ renderable;\n        animation.pause();\n        forEachChildren(animation, (/** @type {Tween} */ tween)=>{\n            const tweenProperty = tween.property;\n            const tweenTarget = tween.target;\n            if (tweenTarget[isDomSymbol]) {\n                const targetStyle = /** @type {DOMTarget} */ tweenTarget.style;\n                const originalInlinedValue = animation._inlineStyles[tweenProperty];\n                if (tween._tweenType === tweenTypes.TRANSFORM) {\n                    const cachedTransforms = tweenTarget[transformsSymbol];\n                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n                        delete cachedTransforms[tweenProperty];\n                    } else {\n                        cachedTransforms[tweenProperty] = originalInlinedValue;\n                    }\n                    if (tween._renderTransforms) {\n                        if (!Object.keys(cachedTransforms).length) {\n                            targetStyle.removeProperty(\"transform\");\n                        } else {\n                            let str = emptyString;\n                            for(let key in cachedTransforms){\n                                str += transformsFragmentStrings[key] + cachedTransforms[key] + \") \";\n                            }\n                            targetStyle.transform = str;\n                        }\n                    }\n                } else {\n                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n                        targetStyle.removeProperty(tweenProperty);\n                    } else {\n                        targetStyle[tweenProperty] = originalInlinedValue;\n                    }\n                }\n                if (animation._tail === tween) {\n                    animation.targets.forEach((t)=>{\n                        if (t.getAttribute && t.getAttribute(\"style\") === emptyString) {\n                            t.removeAttribute(\"style\");\n                        }\n                    });\n                }\n            }\n        });\n    }\n    return renderable;\n};\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = {\n    func: null\n};\nconst keyframesTargetArray = [\n    null\n];\nconst fastSetValuesArray = [\n    null,\n    null\n];\n/** @type {TweenKeyValue} */ const keyObjectTarget = {\n    to: null\n};\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */ let key;\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */ const generateKeyframes = (keyframes, parameters)=>{\n    /** @type {AnimationParams} */ const properties = {};\n    if (isArr(keyframes)) {\n        const propertyNames = [].concat(.../** @type {DurationKeyframes} */ keyframes.map((key)=>Object.keys(key))).filter(isKey);\n        for(let i = 0, l = propertyNames.length; i < l; i++){\n            const propName = propertyNames[i];\n            const propArray = /** @type {DurationKeyframes} */ keyframes.map((key)=>{\n                /** @type {TweenKeyValue} */ const newKey = {};\n                for(let p in key){\n                    const keyValue = /** @type {TweenPropValue} */ key[p];\n                    if (isKey(p)) {\n                        if (p === propName) {\n                            newKey.to = keyValue;\n                        }\n                    } else {\n                        newKey[p] = keyValue;\n                    }\n                }\n                return newKey;\n            });\n            properties[propName] = /** @type {ArraySyntaxValue} */ propArray;\n        }\n    } else {\n        const totalDuration = /** @type {Number} */ setValue(parameters.duration, globals.defaults.duration);\n        const keys = Object.keys(keyframes).map((key)=>{\n            return {\n                o: parseFloat(key) / 100,\n                p: keyframes[key]\n            };\n        }).sort((a, b)=>a.o - b.o);\n        keys.forEach((key)=>{\n            const offset = key.o;\n            const prop = key.p;\n            for(let name in prop){\n                if (isKey(name)) {\n                    let propArray = /** @type {Array} */ properties[name];\n                    if (!propArray) propArray = properties[name] = [];\n                    const duration = offset * totalDuration;\n                    let length = propArray.length;\n                    let prevKey = propArray[length - 1];\n                    const keyObj = {\n                        to: prop[name]\n                    };\n                    let durProgress = 0;\n                    for(let i = 0; i < length; i++){\n                        durProgress += propArray[i].duration;\n                    }\n                    if (length === 1) {\n                        keyObj.from = prevKey.to;\n                    }\n                    if (prop.ease) {\n                        keyObj.ease = prop.ease;\n                    }\n                    keyObj.duration = duration - (length ? durProgress : 0);\n                    propArray.push(keyObj);\n                }\n            }\n            return key;\n        });\n        for(let name in properties){\n            const propArray = /** @type {Array} */ properties[name];\n            let prevEase;\n            // let durProgress = 0\n            for(let i = 0, l = propArray.length; i < l; i++){\n                const prop = propArray[i];\n                // Emulate WAPPI easing parameter position\n                const currentEase = prop.ease;\n                prop.ease = prevEase ? prevEase : undefined;\n                prevEase = currentEase;\n            // durProgress += prop.duration;\n            // if (i === l - 1 && durProgress !== totalDuration) {\n            //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n            // }\n            }\n            if (!propArray[0].duration) {\n                propArray.shift();\n            }\n        }\n    }\n    return properties;\n};\nclass JSAnimation extends Timer {\n    /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */ constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0){\n        super(/** @type {TimerParams&AnimationParams} */ parameters, parent, parentPosition);\n        const parsedTargets = registerTargets(targets);\n        const targetsLength = parsedTargets.length;\n        // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n        const kfParams = /** @type {AnimationParams} */ parameters.keyframes;\n        const params = /** @type {AnimationParams} */ kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */ kfParams, parameters), parameters) : parameters;\n        const { delay, duration, ease, playbackEase, modifier, composition, onRender } = params;\n        const animDefaults = parent ? parent.defaults : globals.defaults;\n        const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n        const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ ease.ease);\n        const tEasing = hasSpring ? /** @type {Spring} */ ease.ease : setValue(ease, animEase ? \"linear\" : animDefaults.ease);\n        const tDuration = hasSpring ? /** @type {Spring} */ ease.duration : setValue(duration, animDefaults.duration);\n        const tDelay = setValue(delay, animDefaults.delay);\n        const tModifier = modifier || animDefaults.modifier;\n        // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n        const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n        // TODO: Do not create an empty object until we know the animation will generate inline styles\n        const animInlineStyles = {};\n        // const absoluteOffsetTime = this._offset;\n        const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n        let iterationDuration = NaN;\n        let iterationDelay = NaN;\n        let animationAnimationLength = 0;\n        let shouldTriggerRender = 0;\n        for(let targetIndex = 0; targetIndex < targetsLength; targetIndex++){\n            const target = parsedTargets[targetIndex];\n            const ti = index || targetIndex;\n            const tl = length || targetsLength;\n            let lastTransformGroupIndex = NaN;\n            let lastTransformGroupLength = NaN;\n            for(let p in params){\n                if (isKey(p)) {\n                    const tweenType = getTweenType(target, p);\n                    const propName = sanitizePropertyName(p, target, tweenType);\n                    let propValue = params[p];\n                    const isPropValueArray = isArr(propValue);\n                    if (fastSet && !isPropValueArray) {\n                        fastSetValuesArray[0] = propValue;\n                        fastSetValuesArray[1] = propValue;\n                        propValue = fastSetValuesArray;\n                    }\n                    // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n                    // Normalize property values to valid keyframe syntax:\n                    // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n                    // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n                    if (isPropValueArray) {\n                        const arrayLength = /** @type {Array} */ propValue.length;\n                        const isNotObjectValue = !isObj(propValue[0]);\n                        // Convert [x, y] to [{to: [x, y]}]\n                        if (arrayLength === 2 && isNotObjectValue) {\n                            keyObjectTarget.to = /** @type {unknown} */ propValue;\n                            keyframesTargetArray[0] = keyObjectTarget;\n                            keyframes = keyframesTargetArray;\n                        // Convert [x, y, z] to [[x, y], z]\n                        } else if (arrayLength > 2 && isNotObjectValue) {\n                            keyframes = [];\n                            /** @type {Array.<Number>} */ propValue.forEach((v, i)=>{\n                                if (!i) {\n                                    fastSetValuesArray[0] = v;\n                                } else if (i === 1) {\n                                    fastSetValuesArray[1] = v;\n                                    keyframes.push(fastSetValuesArray);\n                                } else {\n                                    keyframes.push(v);\n                                }\n                            });\n                        } else {\n                            keyframes = /** @type {Array.<TweenKeyValue>} */ propValue;\n                        }\n                    } else {\n                        keyframesTargetArray[0] = propValue;\n                        keyframes = keyframesTargetArray;\n                    }\n                    let siblings = null;\n                    let prevTween = null;\n                    let firstTweenChangeStartTime = NaN;\n                    let lastTweenChangeEndTime = 0;\n                    let tweenIndex = 0;\n                    for(let l = keyframes.length; tweenIndex < l; tweenIndex++){\n                        const keyframe = keyframes[tweenIndex];\n                        if (isObj(keyframe)) {\n                            key = keyframe;\n                        } else {\n                            keyObjectTarget.to = /** @type {TweenParamValue} */ keyframe;\n                            key = keyObjectTarget;\n                        }\n                        toFunctionStore.func = null;\n                        const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n                        let tweenToValue;\n                        // Allows function based values to return an object syntax value ({to: v})\n                        if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n                            key = computedToValue;\n                            tweenToValue = computedToValue.to;\n                        } else {\n                            tweenToValue = computedToValue;\n                        }\n                        const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n                        const keyEasing = key.ease;\n                        const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */ keyEasing.ease);\n                        // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n                        const tweenEasing = hasSpring ? /** @type {Spring} */ keyEasing.ease : keyEasing || tEasing;\n                        // Calculate default individual keyframe duration by dividing the tl of keyframes\n                        const tweenDuration = hasSpring ? /** @type {Spring} */ keyEasing.duration : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);\n                        // Default delay value should only be applied to the first tween\n                        const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);\n                        const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n                        const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n                        // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n                        const tweenModifier = key.modifier || tModifier;\n                        const hasFromvalue = !isUnd(tweenFromValue);\n                        const hasToValue = !isUnd(tweenToValue);\n                        const isFromToArray = isArr(tweenToValue);\n                        const isFromToValue = isFromToArray || hasFromvalue && hasToValue;\n                        const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n                        const absoluteStartTime = absoluteOffsetTime + tweenStartTime;\n                        // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n                        if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n                        let prevSibling = prevTween;\n                        if (tweenComposition !== compositionTypes.none) {\n                            if (!siblings) siblings = getTweenSiblings(target, propName);\n                            let nextSibling = siblings._head;\n                            // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n                            while(nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime){\n                                prevSibling = nextSibling;\n                                nextSibling = nextSibling._nextRep;\n                                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                                    while(nextSibling){\n                                        overrideTween(nextSibling);\n                                        // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                                        nextSibling = nextSibling._nextRep;\n                                    }\n                                }\n                            }\n                        }\n                        // Decompose values\n                        if (isFromToValue) {\n                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n                            if (fromTargetObject.t === valueTypes.NUMBER) {\n                                if (prevSibling) {\n                                    if (prevSibling._valueType === valueTypes.UNIT) {\n                                        fromTargetObject.t = valueTypes.UNIT;\n                                        fromTargetObject.u = prevSibling._unit;\n                                    }\n                                } else {\n                                    decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue);\n                                    if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                                        fromTargetObject.t = valueTypes.UNIT;\n                                        fromTargetObject.u = decomposedOriginalValue.u;\n                                    }\n                                }\n                            }\n                        } else {\n                            if (hasToValue) {\n                                decomposeRawValue(tweenToValue, toTargetObject);\n                            } else {\n                                if (prevTween) {\n                                    decomposeTweenValue(prevTween, toTargetObject);\n                                } else {\n                                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                                }\n                            }\n                            if (hasFromvalue) {\n                                decomposeRawValue(tweenFromValue, fromTargetObject);\n                            } else {\n                                if (prevTween) {\n                                    decomposeTweenValue(prevTween, fromTargetObject);\n                                } else {\n                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                                }\n                            }\n                        }\n                        // Apply operators\n                        if (fromTargetObject.o) {\n                            fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);\n                        }\n                        if (toTargetObject.o) {\n                            toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n                        }\n                        // Values omogenisation in cases of type difference between \"from\" and \"to\"\n                        if (fromTargetObject.t !== toTargetObject.t) {\n                            if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                                notComplexValue.t = valueTypes.COMPLEX;\n                                notComplexValue.s = cloneArray(complexValue.s);\n                                notComplexValue.d = complexValue.d.map(()=>notComplexValue.n);\n                            } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                                notUnitValue.t = valueTypes.UNIT;\n                                notUnitValue.u = unitValue.u;\n                            } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                                notColorValue.t = valueTypes.COLOR;\n                                notColorValue.s = colorValue.s;\n                                notColorValue.d = [\n                                    0,\n                                    0,\n                                    0,\n                                    1\n                                ];\n                            }\n                        }\n                        // Unit conversion\n                        if (fromTargetObject.u !== toTargetObject.u) {\n                            let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n                            valueToConvert = convertValueUnit(/** @type {DOMTarget} */ target, valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n                        // TODO:\n                        // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n                        }\n                        // Fill in non existing complex values\n                        if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {\n                            const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n                            const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n                            // TODO: Check if n should be used instead of 0 for default complex values\n                            shortestValue.d = longestValue.d.map((_, i)=>isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n                            shortestValue.s = cloneArray(longestValue.s);\n                        }\n                        // Tween factory\n                        // Rounding is necessary here to minimize floating point errors\n                        const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n                        /** @type {Tween} */ const tween = {\n                            parent: this,\n                            id: tweenId++,\n                            property: propName,\n                            target: target,\n                            _value: null,\n                            _func: toFunctionStore.func,\n                            _ease: parseEasings(tweenEasing),\n                            _fromNumbers: cloneArray(fromTargetObject.d),\n                            _toNumbers: cloneArray(toTargetObject.d),\n                            _strings: cloneArray(toTargetObject.s),\n                            _fromNumber: fromTargetObject.n,\n                            _toNumber: toTargetObject.n,\n                            _numbers: cloneArray(fromTargetObject.d),\n                            _number: fromTargetObject.n,\n                            _unit: toTargetObject.u,\n                            _modifier: tweenModifier,\n                            _currentTime: 0,\n                            _startTime: tweenStartTime,\n                            _delay: +tweenDelay,\n                            _updateDuration: tweenUpdateDuration,\n                            _changeDuration: tweenUpdateDuration,\n                            _absoluteStartTime: absoluteStartTime,\n                            // NOTE: Investigate bit packing to stores ENUM / BOOL\n                            _tweenType: tweenType,\n                            _valueType: toTargetObject.t,\n                            _composition: tweenComposition,\n                            _isOverlapped: 0,\n                            _isOverridden: 0,\n                            _renderTransforms: 0,\n                            _prevRep: null,\n                            _nextRep: null,\n                            _prevAdd: null,\n                            _nextAdd: null,\n                            _prev: null,\n                            _next: null\n                        };\n                        if (tweenComposition !== compositionTypes.none) {\n                            composeTween(tween, siblings);\n                        }\n                        if (isNaN(firstTweenChangeStartTime)) {\n                            firstTweenChangeStartTime = tween._startTime;\n                        }\n                        // Rounding is necessary here to minimize floating point errors\n                        lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n                        prevTween = tween;\n                        animationAnimationLength++;\n                        addChild(this, tween);\n                    }\n                    // Update animation timings with the added tweens properties\n                    if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n                        iterationDelay = firstTweenChangeStartTime;\n                    }\n                    if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n                        iterationDuration = lastTweenChangeEndTime;\n                    }\n                    // TODO: Find a way to inline tween._renderTransforms = 1 here\n                    if (tweenType === tweenTypes.TRANSFORM) {\n                        lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n                        lastTransformGroupLength = animationAnimationLength;\n                    }\n                }\n            }\n            // Set _renderTransforms to last transform property to correctly render the transforms list\n            if (!isNaN(lastTransformGroupIndex)) {\n                let i = 0;\n                forEachChildren(this, (/** @type {Tween} */ tween)=>{\n                    if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n                        tween._renderTransforms = 1;\n                        if (tween._composition === compositionTypes.blend) {\n                            forEachChildren(additive.animation, (/** @type {Tween} */ additiveTween)=>{\n                                if (additiveTween.id === tween.id) {\n                                    additiveTween._renderTransforms = 1;\n                                }\n                            });\n                        }\n                    }\n                    i++;\n                });\n            }\n        }\n        if (!targetsLength) {\n            console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n        }\n        if (iterationDelay) {\n            forEachChildren(this, (/** @type {Tween} */ tween)=>{\n                // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n                if (!(tween._startTime - tween._delay)) {\n                    tween._delay -= iterationDelay;\n                }\n                tween._startTime -= iterationDelay;\n            });\n            iterationDuration -= iterationDelay;\n        } else {\n            iterationDelay = 0;\n        }\n        // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n        // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n        if (!iterationDuration) {\n            iterationDuration = minValue;\n            this.iterationCount = 0;\n        }\n        /** @type {TargetsArray} */ this.targets = parsedTargets;\n        /** @type {Number} */ this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;\n        /** @type {Callback<this>} */ this.onRender = onRender || animDefaults.onRender;\n        /** @type {EasingFunction} */ this._ease = animEase;\n        /** @type {Number} */ this._delay = iterationDelay;\n        // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n        // this._delay = parent ? 0 : iterationDelay;\n        // this._offset += parent ? iterationDelay : 0;\n        /** @type {Number} */ this.iterationDuration = iterationDuration;\n        /** @type {{}} */ this._inlineStyles = animInlineStyles;\n        if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n    }\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        if (currentDuration === normalizeTime(newDuration)) return this;\n        const timeScale = newDuration / currentDuration;\n        // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n        forEachChildren(this, (/** @type {Tween} */ tween)=>{\n            // Rounding is necessary here to minimize floating point errors\n            tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n            tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n            tween._currentTime *= timeScale;\n            tween._startTime *= timeScale;\n            tween._absoluteStartTime *= timeScale;\n        });\n        return super.stretch(newDuration);\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        forEachChildren(this, (/** @type {Tween} */ tween)=>{\n            const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n            decomposeRawValue(ogValue, decomposedOriginalValue);\n            tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n            tween._fromNumber = decomposedOriginalValue.n;\n            if (tween._func) {\n                decomposeRawValue(tween._func(), toTargetObject);\n                tween._toNumbers = cloneArray(toTargetObject.d);\n                tween._strings = cloneArray(toTargetObject.s);\n                tween._toNumber = toTargetObject.n;\n            }\n        });\n        return this;\n    }\n    /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */ revert() {\n        super.revert();\n        return cleanInlineStyles(this);\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then(callback) {\n        return super.then(callback);\n    }\n}\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */ const animate = (targets, parameters)=>new JSAnimation(targets, parameters, null, 0, false).init();\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */ const easingToLinear = (fn, samples = 100)=>{\n    const points = [];\n    for(let i = 0; i <= samples; i++)points.push(fn(i / samples));\n    return `linear(${points.join(\", \")})`;\n};\nconst WAAPIEasesLookups = {\n    in: \"ease-in\",\n    out: \"ease-out\",\n    inOut: \"ease-in-out\"\n};\nconst WAAPIeases = /*#__PURE__*/ (()=>{\n    const list = {};\n    for(let type in easeTypes)list[type] = (a)=>easeTypes[type](easeInPower(a));\n    return /** @type {Record<String, EasingFunction>} */ list;\n})();\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */ const parseWAAPIEasing = (ease)=>{\n    let parsedEase = WAAPIEasesLookups[ease];\n    if (parsedEase) return parsedEase;\n    parsedEase = \"linear\";\n    if (isStr(ease)) {\n        if (stringStartsWith(ease, \"linear\") || stringStartsWith(ease, \"cubic-\") || stringStartsWith(ease, \"steps\") || stringStartsWith(ease, \"ease\")) {\n            parsedEase = ease;\n        } else if (stringStartsWith(ease, \"cubicB\")) {\n            parsedEase = toLowerCase(ease);\n        } else {\n            const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n            if (isFnc(parsed)) parsedEase = parsed === none ? \"linear\" : easingToLinear(parsed);\n        }\n        WAAPIEasesLookups[ease] = parsedEase;\n    } else if (isFnc(ease)) {\n        const easing = easingToLinear(ease);\n        if (easing) parsedEase = easing;\n    } else if (/** @type {Spring} */ ease.ease) {\n        parsedEase = easingToLinear(/** @type {Spring} */ ease.ease);\n    }\n    return parsedEase;\n};\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */ /**\n * @callback WAAPIFunctionvalue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */ /**\n * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue\n */ /**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */ /**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */ /**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */ /**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */ const transformsShorthands = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nconst commonDefaultPXProperties = [\n    \"perspective\",\n    \"width\",\n    \"height\",\n    \"margin\",\n    \"padding\",\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\",\n    \"borderWidth\",\n    \"fontSize\",\n    \"borderRadius\",\n    ...transformsShorthands\n];\nconst validIndividualTransforms = [\n    ...transformsShorthands,\n    ...validTransforms.filter((t)=>[\n            \"X\",\n            \"Y\",\n            \"Z\"\n        ].some((axis)=>t.endsWith(axis)))\n];\n// Setting it to true in case CSS.registerProperty is not supported will automatically skip the registration and fallback to no animation\nlet transformsPropertiesRegistered = isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, \"registerProperty\"));\nconst registerTransformsProperties = ()=>{\n    if (transformsPropertiesRegistered) return;\n    validTransforms.forEach((t)=>{\n        const isSkew = stringStartsWith(t, \"skew\");\n        const isScale = stringStartsWith(t, \"scale\");\n        const isRotate = stringStartsWith(t, \"rotate\");\n        const isTranslate = stringStartsWith(t, \"translate\");\n        const isAngle = isRotate || isSkew;\n        const syntax = isAngle ? \"<angle>\" : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n        try {\n            CSS.registerProperty({\n                name: \"--\" + t,\n                syntax,\n                inherits: false,\n                initialValue: isTranslate ? \"0px\" : isAngle ? \"0deg\" : isScale ? \"1\" : \"0\"\n            });\n        } catch  {}\n    });\n    transformsPropertiesRegistered = true;\n};\nconst WAAPIAnimationsLookups = {\n    _head: null,\n    _tail: null\n};\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */ const removeWAAPIAnimation = ($el, property, parent)=>{\n    let nextLookup = WAAPIAnimationsLookups._head;\n    while(nextLookup){\n        const next = nextLookup._next;\n        const matchTarget = nextLookup.$el === $el;\n        const matchProperty = !property || nextLookup.property === property;\n        const matchParent = !parent || nextLookup.parent === parent;\n        if (matchTarget && matchProperty && matchParent) {\n            const anim = nextLookup.animation;\n            try {\n                anim.commitStyles();\n            } catch  {}\n            anim.cancel();\n            removeChild(WAAPIAnimationsLookups, nextLookup);\n            const lookupParent = nextLookup.parent;\n            if (lookupParent) {\n                lookupParent._completed++;\n                if (lookupParent.animations.length === lookupParent._completed) {\n                    lookupParent.completed = true;\n                    if (!lookupParent.muteCallbacks) {\n                        lookupParent.paused = true;\n                        lookupParent.onComplete(lookupParent);\n                        lookupParent._resolve(lookupParent);\n                    }\n                }\n            }\n        }\n        nextLookup = next;\n    }\n};\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */ const addWAAPIAnimation = (parent, $el, property, keyframes, params)=>{\n    const animation = $el.animate(keyframes, params);\n    const animTotalDuration = params.delay + +params.duration * params.iterations;\n    animation.playbackRate = parent._speed;\n    if (parent.paused) animation.pause();\n    if (parent.duration < animTotalDuration) {\n        parent.duration = animTotalDuration;\n        parent.controlAnimation = animation;\n    }\n    parent.animations.push(animation);\n    removeWAAPIAnimation($el, property);\n    addChild(WAAPIAnimationsLookups, {\n        parent,\n        animation,\n        $el,\n        property,\n        _next: null,\n        _prev: null\n    });\n    const handleRemove = ()=>{\n        removeWAAPIAnimation($el, property, parent);\n    };\n    animation.onremove = handleRemove;\n    animation.onfinish = handleRemove;\n    return animation;\n};\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */ const normalizeTweenValue = (propName, value, $el, i, targetsLength)=>{\n    let v = getFunctionValue(/** @type {any} */ value, $el, i, targetsLength);\n    if (!isNum(v)) return v;\n    if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, \"translate\")) return `${v}px`;\n    if (stringStartsWith(propName, \"rotate\") || stringStartsWith(propName, \"skew\")) return `${v}deg`;\n    return `${v}`;\n};\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */ const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength)=>{\n    /** @type {WAAPITweenValue} */ let tweenValue = \"0\";\n    const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n    if (!isUnd(from)) {\n        const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n        tweenValue = [\n            computedFrom,\n            computedTo\n        ];\n    } else {\n        tweenValue = isArr(to) ? to.map((/** @type {any} */ v)=>normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n    }\n    return tweenValue;\n};\nclass WAAPIAnimation {\n    /**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */ constructor(targets, params){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        registerTransformsProperties();\n        const parsedTargets = registerTargets(targets);\n        const targetsLength = parsedTargets.length;\n        if (!targetsLength) {\n            console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);\n        }\n        const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n        const spring = /** @type {Spring} */ ease.ease && ease;\n        const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n        const scroll = autoplay && /** @type {ScrollObserver} */ autoplay.link ? autoplay : false;\n        const alternate = params.alternate && /** @type {Boolean} */ params.alternate === true;\n        const reversed = params.reversed && /** @type {Boolean} */ params.reversed === true;\n        const loop = setValue(params.loop, globals.defaults.loop);\n        const iterations = /** @type {Number} */ loop === true || loop === Infinity ? Infinity : isNum(loop) ? loop + 1 : 1;\n        /** @type {PlaybackDirection} */ const direction = alternate ? reversed ? \"alternate-reverse\" : \"alternate\" : reversed ? \"reverse\" : \"normal\";\n        /** @type {FillMode} */ const fill = \"forwards\";\n        /** @type {String} */ const easing = parseWAAPIEasing(ease);\n        const timeScale = globals.timeScale === 1 ? 1 : K;\n        /** @type {DOMTargetsArray}] */ this.targets = parsedTargets;\n        /** @type {Array<globalThis.Animation>}] */ this.animations = [];\n        /** @type {globalThis.Animation}] */ this.controlAnimation = null;\n        /** @type {Callback<this>} */ this.onComplete = params.onComplete || noop;\n        /** @type {Number} */ this.duration = 0;\n        /** @type {Boolean} */ this.muteCallbacks = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Boolean} */ this.paused = !autoplay || scroll !== false;\n        /** @type {Boolean} */ this.reversed = reversed;\n        /** @type {Boolean|ScrollObserver} */ this.autoplay = autoplay;\n        /** @type {Number} */ this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n        /** @type {Function} */ this._resolve = noop; // Used by .then()\n        /** @type {Number} */ this._completed = 0;\n        /** @type {Array<Object>}] */ this._inlineStyles = parsedTargets.map(($el)=>$el.getAttribute(\"style\"));\n        parsedTargets.forEach(($el, i)=>{\n            const cachedTransforms = $el[transformsSymbol];\n            const hasIndividualTransforms = validIndividualTransforms.some((t)=>params.hasOwnProperty(t));\n            /** @type {Number} */ const duration = (spring ? /** @type {Spring} */ spring.duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n            /** @type {Number} */ const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n            /** @type {CompositeOperation} */ const composite = /** @type {CompositeOperation} */ setValue(params.composition, \"replace\");\n            for(let name in params){\n                if (!isKey(name)) continue;\n                /** @type {PropertyIndexedKeyframes} */ const keyframes = {};\n                /** @type {KeyframeAnimationOptions} */ const tweenParams = {\n                    iterations,\n                    direction,\n                    fill,\n                    easing,\n                    duration,\n                    delay,\n                    composite\n                };\n                const propertyValue = params[name];\n                const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n                let parsedPropertyValue;\n                if (isObj(propertyValue)) {\n                    const tweenOptions = /** @type {WAAPITweenOptions} */ propertyValue;\n                    const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n                    const tweenOptionsSpring = /** @type {Spring} */ tweenOptionsEase.ease && tweenOptionsEase;\n                    const to = /** @type {WAAPITweenOptions} */ tweenOptions.to;\n                    const from = /** @type {WAAPITweenOptions} */ tweenOptions.from;\n                    /** @type {Number} */ tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */ tweenOptionsSpring.duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n                    /** @type {Number} */ tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n                    /** @type {CompositeOperation} */ tweenParams.composite = /** @type {CompositeOperation} */ setValue(tweenOptions.composition, composite);\n                    /** @type {String} */ tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n                    parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n                    if (individualTransformProperty) {\n                        keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n                    } else {\n                        keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n                    }\n                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n                    if (!isUnd(from)) {\n                        if (!individualTransformProperty) {\n                            $el.style[name] = keyframes[name][0];\n                        } else {\n                            const key = `--${individualTransformProperty}`;\n                            $el.style.setProperty(key, keyframes[key][0]);\n                        }\n                    }\n                } else {\n                    parsedPropertyValue = isArr(propertyValue) ? propertyValue.map((/** @type {any} */ v)=>normalizeTweenValue(name, v, $el, i, targetsLength)) : normalizeTweenValue(name, /** @type {any} */ propertyValue, $el, i, targetsLength);\n                    if (individualTransformProperty) {\n                        keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;\n                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n                    } else {\n                        keyframes[name] = parsedPropertyValue;\n                    }\n                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n                }\n            }\n            if (hasIndividualTransforms) {\n                let transforms = emptyString;\n                for(let t in cachedTransforms){\n                    transforms += `${transformsFragmentStrings[t]}var(--${t})) `;\n                }\n                $el.style.transform = transforms;\n            }\n        });\n        if (scroll) {\n            /** @type {ScrollObserver} */ this.autoplay.link(this);\n        }\n    }\n    /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */ /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */ forEach(callback) {\n        const cb = isStr(callback) ? (a)=>a[callback]() : callback;\n        this.animations.forEach(cb);\n        return this;\n    }\n    get speed() {\n        return this._speed;\n    }\n    /** @param {Number} speed */ set speed(speed) {\n        this._speed = +speed;\n        this.forEach((anim)=>anim.playbackRate = speed);\n    }\n    get currentTime() {\n        const controlAnimation = this.controlAnimation;\n        const timeScale = globals.timeScale;\n        return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n    }\n    /** @param {Number} time */ set currentTime(time) {\n        const t = time * (globals.timeScale === 1 ? 1 : K);\n        this.forEach((anim)=>{\n            // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n            // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n            if (t >= this.duration) anim.play();\n            anim.currentTime = t;\n        });\n    }\n    get progress() {\n        return this.currentTime / this.duration;\n    }\n    /** @param {Number} progress */ set progress(progress) {\n        this.forEach((anim)=>anim.currentTime = progress * this.duration || 0);\n    }\n    resume() {\n        if (!this.paused) return this;\n        this.paused = false;\n        // TODO: Store the current time, and seek back to the last position\n        return this.forEach(\"play\");\n    }\n    pause() {\n        if (this.paused) return this;\n        this.paused = true;\n        return this.forEach(\"pause\");\n    }\n    alternate() {\n        this.reversed = !this.reversed;\n        this.forEach(\"reverse\");\n        if (this.paused) this.forEach(\"pause\");\n        return this;\n    }\n    play() {\n        if (this.reversed) this.alternate();\n        return this.resume();\n    }\n    reverse() {\n        if (!this.reversed) this.alternate();\n        return this.resume();\n    }\n    /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */ seek(time, muteCallbacks = false) {\n        if (muteCallbacks) this.muteCallbacks = true;\n        if (time < this.duration) this.completed = false;\n        this.currentTime = time;\n        this.muteCallbacks = false;\n        if (this.paused) this.pause();\n        return this;\n    }\n    restart() {\n        this.completed = false;\n        return this.seek(0, true).resume();\n    }\n    commitStyles() {\n        return this.forEach(\"commitStyles\");\n    }\n    complete() {\n        return this.seek(this.duration);\n    }\n    cancel() {\n        this.forEach(\"cancel\");\n        return this.pause();\n    }\n    revert() {\n        this.cancel();\n        this.targets.forEach(($el, i)=>$el.setAttribute(\"style\", this._inlineStyles[i]));\n        return this;\n    }\n    /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */ then(callback = noop) {\n        const then = this.then;\n        const onResolve = ()=>{\n            this.then = null;\n            callback(this);\n            this.then = then;\n            this._resolve = noop;\n        };\n        return new Promise((r)=>{\n            this._resolve = ()=>r(onResolve());\n            if (this.completed) this._resolve();\n            return this;\n        });\n    }\n}\nconst waapi = {\n    /**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */ animate: (targets, params)=>new WAAPIAnimation(targets, params),\n    convertEase: easingToLinear\n};\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */ const sync = (callback = noop)=>{\n    return new Timer({\n        duration: 1 * globals.timeScale,\n        onComplete: callback\n    }, null, 0).resume();\n};\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */ function getTargetValue(targetSelector, propName, unit) {\n    const targets = registerTargets(targetSelector);\n    if (!targets.length) return;\n    const [target] = targets;\n    const tweenType = getTweenType(target, propName);\n    const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n    let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n    if (isUnd(unit)) {\n        return originalValue;\n    } else {\n        decomposeRawValue(originalValue, decomposedOriginalValue);\n        if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n            if (unit === false) {\n                return decomposedOriginalValue.n;\n            } else {\n                const convertedValue = convertValueUnit(/** @type {DOMTarget} */ target, decomposedOriginalValue, /** @type {String} */ unit, false);\n                return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;\n            }\n        }\n    }\n}\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */ const setTargetValues = (targets, parameters)=>{\n    if (isUnd(parameters)) return;\n    parameters.duration = minValue;\n    // Do not overrides currently active tweens by default\n    parameters.composition = setValue(parameters.composition, compositionTypes.none);\n    // Skip init() and force rendering by playing the animation\n    return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */ const removeTargetsFromAnimation = (targetsArray, animation, propertyName)=>{\n    let tweensMatchesTargets = false;\n    forEachChildren(animation, (/**@type {Tween} */ tween)=>{\n        const tweenTarget = tween.target;\n        if (targetsArray.includes(tweenTarget)) {\n            const tweenName = tween.property;\n            const tweenType = tween._tweenType;\n            const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n            if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n                // Make sure to flag the previous CSS transform tween to renderTransform\n                if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) {\n                    tween._prev._renderTransforms = 1;\n                }\n                // Removes the tween from the selected animation\n                removeChild(animation, tween);\n                // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n                removeTweenSliblings(tween);\n                tweensMatchesTargets = true;\n            }\n        }\n    }, true);\n    return tweensMatchesTargets;\n};\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */ const remove = (targets, renderable, propertyName)=>{\n    const targetsArray = parseTargets(targets);\n    const parent = /** @type {Renderable|typeof engine} **/ renderable ? renderable : engine;\n    const waapiAnimation = renderable && /** @type {WAAPIAnimation} */ renderable.controlAnimation && /** @type {WAAPIAnimation} */ renderable;\n    for(let i = 0, l = targetsArray.length; i < l; i++){\n        const $el = /** @type {DOMTarget}  */ targetsArray[i];\n        removeWAAPIAnimation($el, propertyName, waapiAnimation);\n    }\n    let removeMatches;\n    if (parent._hasChildren) {\n        let iterationDuration = 0;\n        forEachChildren(parent, (/** @type {Renderable} */ child)=>{\n            if (!child._hasChildren) {\n                removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */ child, propertyName);\n                // Remove the child from its parent if no tweens and no children left after the removal\n                if (removeMatches && !child._head) {\n                    child.cancel();\n                    removeChild(parent, child);\n                } else {\n                    // Calculate the new iterationDuration value to handle onComplete with last child in render()\n                    const childTLOffset = child._offset + child._delay;\n                    const childDur = childTLOffset + child.duration;\n                    if (childDur > iterationDuration) {\n                        iterationDuration = childDur;\n                    }\n                }\n            }\n            // Make sure to also remove engine's children targets\n            // NOTE: Avoid recursion?\n            if (child._head) {\n                remove(targets, child, propertyName);\n            } else {\n                child._hasChildren = false;\n            }\n        }, true);\n        // Update iterationDuration value to handle onComplete with last child in render()\n        if (!isUnd(/** @type {Renderable} */ parent.iterationDuration)) {\n            /** @type {Renderable} */ parent.iterationDuration = iterationDuration;\n        }\n    } else {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */ parent, propertyName);\n    }\n    if (removeMatches && !parent._head) {\n        parent._hasChildren = false;\n        // Cancel the parent if there are no tweens and no children left after the removal\n        // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n        if (/** @type {Renderable} */ parent.cancel) /** @type {Renderable} */ parent.cancel();\n    }\n    return targetsArray;\n};\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */ const random = (min, max, decimalLength)=>{\n    const m = 10 ** (decimalLength || 0);\n    return floor((Math.random() * (max - min + 1 / m) + min) * m) / m;\n};\n/**\n * @param  {String|Array} items\n * @return {any}\n */ const randomPick = (items)=>items[random(0, items.length - 1)];\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */ const shuffle = (items)=>{\n    let m = items.length, t, i;\n    while(m){\n        i = random(0, --m);\n        t = items[m];\n        items[m] = items[i];\n        items[i] = t;\n    }\n    return items;\n};\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */ const roundPad = (v, decimalLength)=>(+v).toFixed(decimalLength);\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */ const padStart = (v, totalLength, padString)=>`${v}`.padStart(totalLength, padString);\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */ const padEnd = (v, totalLength, padString)=>`${v}`.padEnd(totalLength, padString);\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */ const wrap = (v, min, max)=>((v - min) % (max - min) + (max - min)) % (max - min) + min;\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */ const mapRange = (value, inLow, inHigh, outLow, outHigh)=>outLow + (value - inLow) / (inHigh - inLow) * (outHigh - outLow);\n/**\n * @param  {Number} degrees\n * @return {Number}\n */ const degToRad = (degrees)=>degrees * PI / 180;\n/**\n * @param  {Number} radians\n * @return {Number}\n */ const radToDeg = (radians)=>radians * 180 / PI;\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */ const lerp = (start, end, amount, renderable)=>{\n    let dt = K / globals.defaults.frameRate;\n    if (renderable !== false) {\n        const ticker = /** @type Renderable */ renderable || engine._hasChildren && engine;\n        if (ticker && ticker.deltaTime) {\n            dt = ticker.deltaTime;\n        }\n    }\n    const t = 1 - Math.exp(-amount * dt * .1);\n    return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n// Chain-able utilities\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */ const curry = (fn, last = 0)=>(...args)=>last ? (v)=>fn(...args, v) : (v)=>fn(v, ...args);\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */ const chain = (fn)=>{\n    return (...args)=>{\n        const result = fn(...args);\n        return new Proxy(noop, {\n            apply: (_, __, [v])=>result(v),\n            get: (_, prop)=>chain(/**@param {...Number|String} nextArgs */ (...nextArgs)=>{\n                    const nextResult = utils[prop](...nextArgs);\n                    return (/**@type {Number|String} */ v)=>nextResult(result(v));\n                })\n        });\n    };\n};\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */ const makeChainable = (fn, right = 0)=>(...args)=>(args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */ const utils = {\n    $: registerTargets,\n    get: getTargetValue,\n    set: setTargetValues,\n    remove,\n    cleanInlineStyles,\n    random,\n    randomPick,\n    shuffle,\n    lerp,\n    sync,\n    clamp: /** @type {typeof clamp & ChainedClamp} */ makeChainable(clamp),\n    round: /** @type {typeof round & ChainedRound} */ makeChainable(round),\n    snap: /** @type {typeof snap & ChainedSnap} */ makeChainable(snap),\n    wrap: /** @type {typeof wrap & ChainedWrap} */ makeChainable(wrap),\n    interpolate: /** @type {typeof interpolate & ChainedInterpolate} */ makeChainable(interpolate, 1),\n    mapRange: /** @type {typeof mapRange & ChainedMapRange} */ makeChainable(mapRange),\n    roundPad: /** @type {typeof roundPad & ChainedRoundPad} */ makeChainable(roundPad),\n    padStart: /** @type {typeof padStart & ChainedPadStart} */ makeChainable(padStart),\n    padEnd: /** @type {typeof padEnd & ChainedPadEnd} */ makeChainable(padEnd),\n    degToRad: /** @type {typeof degToRad & ChainedDegToRad} */ makeChainable(degToRad),\n    radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */ makeChainable(radToDeg)\n};\n/**\n * @typedef {Number|String|Function} TimePosition\n */ /**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */ const getPrevChildOffset = (timeline, timePosition)=>{\n    if (stringStartsWith(timePosition, \"<\")) {\n        const goToPrevAnimationOffset = timePosition[1] === \"<\";\n        const prevAnimation = /** @type {Tickable} */ timeline._tail;\n        const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n        return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n    }\n};\n/**\n * @param  {Timeline} timeline\n * @param  {TimePosition} [timePosition]\n * @return {Number}\n */ const parseTimelinePosition = (timeline, timePosition)=>{\n    let tlDuration = timeline.iterationDuration;\n    if (tlDuration === minValue) tlDuration = 0;\n    if (isUnd(timePosition)) return tlDuration;\n    if (isNum(+timePosition)) return +timePosition;\n    const timePosStr = /** @type {String} */ timePosition;\n    const tlLabels = timeline ? timeline.labels : null;\n    const hasLabels = !isNil(tlLabels);\n    const prevOffset = getPrevChildOffset(timeline, timePosStr);\n    const hasSibling = !isUnd(prevOffset);\n    const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n    if (matchedRelativeOperator) {\n        const fullOperator = matchedRelativeOperator[0];\n        const split = timePosStr.split(fullOperator);\n        const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n        const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n        const parsedNumericalOffset = +split[1];\n        return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n    } else {\n        return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;\n    }\n};\n/**\n * @param {Timeline} tl\n * @return {Number}\n */ function getTimelineTotalDuration(tl) {\n    return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;\n}\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */ function addTlChild(childParams, tl, timePosition, targets, index, length) {\n    const isSetter = isNum(childParams.duration) && /** @type {Number} */ childParams.duration <= minValue;\n    // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n    const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n    tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n    const tlChild = targets ? new JSAnimation(targets, /** @type {AnimationParams} */ childParams, tl, adjustedPosition, false, index, length) : new Timer(/** @type {TimerParams} */ childParams, tl, adjustedPosition);\n    tlChild.init(1);\n    // TODO: Might be better to insert at a position relative to startTime?\n    addChild(tl, tlChild);\n    forEachChildren(tl, (/** @type {Renderable} */ child)=>{\n        const childTLOffset = child._offset + child._delay;\n        const childDur = childTLOffset + child.duration;\n        if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n    });\n    tl.duration = getTimelineTotalDuration(tl);\n    return tl;\n}\nclass Timeline extends Timer {\n    /**\n   * @param {TimelineParams} [parameters]\n   */ constructor(parameters = {}){\n        super(/** @type {TimerParams&TimelineParams} */ parameters, null, 0);\n        /** @type {Number} */ this.duration = 0; // TL duration starts at 0 and grows when adding children\n        /** @type {Record<String, Number>} */ this.labels = {};\n        const defaultsParams = parameters.defaults;\n        const globalDefaults = globals.defaults;\n        /** @type {DefaultsParams} */ this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n        /** @type {Callback<this>} */ this.onRender = parameters.onRender || globalDefaults.onRender;\n        const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n        this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n        /** @type {Number} */ this.iterationDuration = 0;\n    }\n    /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimePosition} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {AnimationParams|TimePosition} a2\n   * @param {TimePosition} [a3]\n   */ add(a1, a2, a3) {\n        const isAnim = isObj(a2);\n        const isTimer = isObj(a1);\n        if (isAnim || isTimer) {\n            this._hasChildren = true;\n            if (isAnim) {\n                const childParams = /** @type {AnimationParams} */ a2;\n                // Check for function for children stagger positions\n                if (isFnc(a3)) {\n                    const staggeredPosition = /** @type {Function} */ a3;\n                    const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */ a1);\n                    // Store initial duration before adding new children that will change the duration\n                    const tlDuration = this.duration;\n                    // Store initial _iterationDuration before adding new children that will change the duration\n                    const tlIterationDuration = this.iterationDuration;\n                    // Store the original id in order to add specific indexes to the new animations ids\n                    const id = childParams.id;\n                    let i = 0;\n                    const parsedLength = parsedTargetsArray.length;\n                    parsedTargetsArray.forEach((/** @type {Target} */ target)=>{\n                        // Create a new parameter object for each staggered children\n                        const staggeredChildParams = {\n                            ...childParams\n                        };\n                        // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n                        this.duration = tlDuration;\n                        this.iterationDuration = tlIterationDuration;\n                        if (!isUnd(id)) staggeredChildParams.id = id + \"-\" + i;\n                        addTlChild(staggeredChildParams, this, staggeredPosition(target, i, parsedLength, this), target, i, parsedLength);\n                        i++;\n                    });\n                } else {\n                    addTlChild(childParams, this, parseTimelinePosition(this, a3), /** @type {TargetsParam} */ a1);\n                }\n            } else {\n                // It's a Timer\n                addTlChild(/** @type TimerParams */ a1, this, parseTimelinePosition(this, /** @type TimePosition */ a2));\n            }\n            return this.init(1); // 1 = internalRender\n        }\n    }\n    /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   */ sync(synced, position) {\n        if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n        synced.pause();\n        const duration = +(/** @type {globalThis.Animation} */ synced.effect ? /** @type {globalThis.Animation} */ synced.effect.getTiming().duration : /** @type {Tickable} */ synced.duration);\n        return this.add(synced, {\n            currentTime: [\n                0,\n                duration\n            ],\n            duration,\n            ease: \"linear\"\n        }, position);\n    }\n    /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimePosition} [position]\n   * @return {this}\n   */ set(targets, parameters, position) {\n        if (isUnd(parameters)) return this;\n        parameters.duration = minValue;\n        parameters.composition = compositionTypes.replace;\n        return this.add(targets, parameters, position);\n    }\n    /**\n   * @param {Callback<Timer>} callback\n   * @param {TimePosition} [position]\n   * @return {this}\n   */ call(callback, position) {\n        if (isUnd(callback) || callback && !isFnc(callback)) return this;\n        return this.add({\n            duration: 0,\n            onComplete: ()=>callback(this)\n        }, position);\n    }\n    /**\n   * @param {String} labelName\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   */ label(labelName, position) {\n        if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n        this.labels[labelName] = parseTimelinePosition(this, /** @type TimePosition */ position);\n        return this;\n    }\n    /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */ remove(targets, propertyName) {\n        remove(targets, this, propertyName);\n        return this;\n    }\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        if (currentDuration === normalizeTime(newDuration)) return this;\n        const timeScale = newDuration / currentDuration;\n        const labels = this.labels;\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>child.stretch(child.duration * timeScale));\n        for(let labelName in labels)labels[labelName] *= timeScale;\n        return super.stretch(newDuration);\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>{\n            if (child.refresh) child.refresh();\n        });\n        return this;\n    }\n    /**\n   * @return {this}\n   */ revert() {\n        super.revert();\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>child.revert, true);\n        return cleanInlineStyles(this);\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then(callback) {\n        return super.then(callback);\n    }\n}\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */ const createTimeline = (parameters)=>new Timeline(parameters).init();\nclass Animatable {\n    /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */ constructor(targets, parameters){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        /** @type {AnimationParams} */ const globalParams = {};\n        const properties = {};\n        this.targets = [];\n        this.animations = {};\n        if (isUnd(targets) || isUnd(parameters)) return;\n        for(let propName in parameters){\n            const paramValue = parameters[propName];\n            if (isKey(propName)) {\n                properties[propName] = paramValue;\n            } else {\n                globalParams[propName] = paramValue;\n            }\n        }\n        for(let propName in properties){\n            const propValue = properties[propName];\n            const isObjValue = isObj(propValue);\n            /** @type {TweenParamsOptions} */ let propParams = {};\n            let to = \"+=0\";\n            if (isObjValue) {\n                const unit = propValue.unit;\n                if (isStr(unit)) to += unit;\n            } else {\n                propParams.duration = propValue;\n            }\n            propParams[propName] = isObjValue ? mergeObjects({\n                to\n            }, propValue) : to;\n            const animParams = mergeObjects(globalParams, propParams);\n            animParams.composition = compositionTypes.replace;\n            animParams.autoplay = false;\n            const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n            if (!this.targets.length) this.targets.push(...animation.targets);\n            /** @type {AnimatableProperty} */ this[propName] = (to, duration, ease)=>{\n                const tween = /** @type {Tween} */ animation._head;\n                if (isUnd(to) && tween) {\n                    const numbers = tween._numbers;\n                    if (numbers && numbers.length) {\n                        return numbers;\n                    } else {\n                        return tween._modifier(tween._number);\n                    }\n                } else {\n                    forEachChildren(animation, (/** @type {Tween} */ tween)=>{\n                        if (isArr(to)) {\n                            for(let i = 0, l = /** @type {Array} */ to.length; i < l; i++){\n                                if (!isUnd(tween._numbers[i])) {\n                                    tween._fromNumbers[i] = /** @type {Number} */ tween._modifier(tween._numbers[i]);\n                                    tween._toNumbers[i] = to[i];\n                                }\n                            }\n                        } else {\n                            tween._fromNumber = /** @type {Number} */ tween._modifier(tween._number);\n                            tween._toNumber = /** @type {Number} */ to;\n                        }\n                        if (!isUnd(ease)) tween._ease = parseEasings(ease);\n                        tween._currentTime = 0;\n                    });\n                    if (!isUnd(duration)) animation.stretch(duration);\n                    animation.reset(1).resume();\n                    return this;\n                }\n            };\n        }\n    }\n    revert() {\n        for(let propName in this.animations){\n            this[propName] = noop;\n            this.animations[propName].revert();\n        }\n        this.animations = {};\n        this.targets.length = 0;\n        return this;\n    }\n}\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */ const createAnimatable = (targets, parameters)=>/** @type {AnimatableObject} */ new Animatable(targets, parameters);\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright  2016 Apple Inc\n */ /**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */ class Spring {\n    /**\n   * @param {SpringParams} [parameters]\n   */ constructor(parameters = {}){\n        this.timeStep = .02; // Interval fed to the solver to calculate duration\n        this.restThreshold = .0005; // Values below this threshold are considered resting position\n        this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n        this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n        this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n        this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n        this.m = clamp(setValue(parameters.mass, 1), 0, K);\n        this.s = clamp(setValue(parameters.stiffness, 100), 1, K);\n        this.d = clamp(setValue(parameters.damping, 10), .1, K);\n        this.v = clamp(setValue(parameters.velocity, 0), -1e3, K);\n        this.w0 = 0;\n        this.zeta = 0;\n        this.wd = 0;\n        this.b = 0;\n        this.solverDuration = 0;\n        this.duration = 0;\n        this.compute();\n        /** @type {EasingFunction} */ this.ease = (t)=>t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n    }\n    /** @type {EasingFunction} */ solve(time) {\n        const { zeta, w0, wd, b } = this;\n        let t = time;\n        if (zeta < 1) {\n            t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n        } else {\n            t = (1 + b * t) * exp(-t * w0);\n        }\n        return 1 - t;\n    }\n    compute() {\n        const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n        const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n        const zeta = this.zeta = d / (2 * sqrt(s * m));\n        const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n        this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n        let solverTime = 0;\n        let restSteps = 0;\n        let iterations = 0;\n        while(restSteps < maxRestSteps && iterations < maxIterations){\n            if (abs(1 - this.solve(solverTime)) < restThreshold) {\n                restSteps++;\n            } else {\n                restSteps = 0;\n            }\n            this.solverDuration = solverTime;\n            solverTime += timeStep;\n            iterations++;\n        }\n        this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n    }\n    get mass() {\n        return this.m;\n    }\n    set mass(v) {\n        this.m = clamp(setValue(v, 1), 0, K);\n        this.compute();\n    }\n    get stiffness() {\n        return this.s;\n    }\n    set stiffness(v) {\n        this.s = clamp(setValue(v, 100), 1, K);\n        this.compute();\n    }\n    get damping() {\n        return this.d;\n    }\n    set damping(v) {\n        this.d = clamp(setValue(v, 10), .1, K);\n        this.compute();\n    }\n    get velocity() {\n        return this.v;\n    }\n    set velocity(v) {\n        this.v = clamp(setValue(v, 0), -1e3, K);\n        this.compute();\n    }\n}\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */ const createSpring = (parameters)=>new Spring(parameters);\n/**\n * @param {Event} e\n */ const preventDefault = (e)=>{\n    if (e.cancelable) e.preventDefault();\n};\nclass DOMProxy {\n    /** @param {Object} el */ constructor(el){\n        this.el = el;\n        this.zIndex = 0;\n        this.parentElement = null;\n        this.classList = {\n            add: noop,\n            remove: noop\n        };\n    }\n    get x() {\n        return this.el.x || 0;\n    }\n    set x(v) {\n        this.el.x = v;\n    }\n    get y() {\n        return this.el.y || 0;\n    }\n    set y(v) {\n        this.el.y = v;\n    }\n    get width() {\n        return this.el.width || 0;\n    }\n    set width(v) {\n        this.el.width = v;\n    }\n    get height() {\n        return this.el.height || 0;\n    }\n    set height(v) {\n        this.el.height = v;\n    }\n    getBoundingClientRect() {\n        return {\n            top: this.y,\n            right: this.x,\n            bottom: this.y + this.height,\n            left: this.x + this.width\n        };\n    }\n}\nclass Transforms {\n    /**\n   * @param {DOMTarget|DOMProxy} $el\n   */ constructor($el){\n        this.$el = $el;\n        this.inlineTransforms = [];\n        this.point = new DOMPoint();\n        this.inversedMatrix = this.getMatrix().inverse();\n    }\n    /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */ normalizePoint(x, y) {\n        this.point.x = x;\n        this.point.y = y;\n        return this.point.matrixTransform(this.inversedMatrix);\n    }\n    /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */ /**\n   * @param {TraverseParentsCallback} cb\n   */ traverseUp(cb) {\n        let $el = /** @type {DOMTarget|Document} */ this.$el.parentElement, i = 0;\n        while($el && $el !== doc){\n            cb(/** @type {DOMTarget} */ $el, i);\n            $el = /** @type {DOMTarget} */ $el.parentElement;\n            i++;\n        }\n    }\n    getMatrix() {\n        const matrix = new DOMMatrix();\n        this.traverseUp(($el)=>{\n            const transformValue = getComputedStyle($el).transform;\n            if (transformValue) {\n                const elMatrix = new DOMMatrix(transformValue);\n                matrix.preMultiplySelf(elMatrix);\n            }\n        });\n        return matrix;\n    }\n    remove() {\n        this.traverseUp(($el, i)=>{\n            this.inlineTransforms[i] = $el.style.transform;\n            $el.style.transform = \"none\";\n        });\n    }\n    revert() {\n        this.traverseUp(($el, i)=>{\n            const ct = this.inlineTransforms[i];\n            if (ct === \"\") {\n                $el.style.removeProperty(\"transform\");\n            } else {\n                $el.style.transform = ct;\n            }\n        });\n    }\n}\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */ const parseDraggableFunctionParameter = (value, draggable)=>value && isFnc(value) ? /** @type {Function} */ value(draggable) : value;\nlet zIndex = 0;\nclass Draggable {\n    /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */ constructor(target, parameters = {}){\n        if (!target) return;\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const paramX = parameters.x;\n        const paramY = parameters.y;\n        const trigger = parameters.trigger;\n        const modifier = parameters.modifier;\n        const ease = parameters.releaseEase;\n        const customEase = ease && parseEasings(ease);\n        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ ease.ease);\n        const xProp = /** @type {String} */ isObj(paramX) && !isUnd(/** @type {Object} */ paramX.mapTo) ? /** @type {Object} */ paramX.mapTo : \"translateX\";\n        const yProp = /** @type {String} */ isObj(paramY) && !isUnd(/** @type {Object} */ paramY.mapTo) ? /** @type {Object} */ paramY.mapTo : \"translateY\";\n        const container = parseDraggableFunctionParameter(parameters.container, this);\n        this.containerArray = isArr(container) ? container : null;\n        this.$container = /** @type {HTMLElement} */ container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ container)[0] : doc.body;\n        this.useWin = this.$container === doc.body;\n        /** @type {Window | HTMLElement} */ this.$scrollContainer = this.useWin ? win : this.$container;\n        this.$target = /** @type {HTMLElement} */ isObj(target) ? new DOMProxy(target) : parseTargets(target)[0];\n        this.$trigger = /** @type {HTMLElement} */ parseTargets(trigger ? trigger : target)[0];\n        this.fixed = getTargetValue(this.$target, \"position\") === \"fixed\";\n        // Refreshable parameters\n        this.isFinePointer = true;\n        /** @type {[Number, Number, Number, Number]} */ this.containerPadding = [\n            0,\n            0,\n            0,\n            0\n        ];\n        /** @type {Number} */ this.containerFriction = 0;\n        /** @type {Number} */ this.releaseContainerFriction = 0;\n        /** @type {Number|Array<Number>} */ this.snapX = 0;\n        /** @type {Number|Array<Number>} */ this.snapY = 0;\n        /** @type {Number} */ this.scrollSpeed = 0;\n        /** @type {Number} */ this.scrollThreshold = 0;\n        /** @type {Number} */ this.dragSpeed = 0;\n        /** @type {Number} */ this.maxVelocity = 0;\n        /** @type {Number} */ this.minVelocity = 0;\n        /** @type {Number} */ this.velocityMultiplier = 0;\n        /** @type {Boolean|DraggableCursorParams} */ this.cursor = false;\n        /** @type {Spring} */ this.releaseXSpring = hasSpring ? /** @type {Spring} */ ease : createSpring({\n            mass: setValue(parameters.releaseMass, 1),\n            stiffness: setValue(parameters.releaseStiffness, 80),\n            damping: setValue(parameters.releaseDamping, 20)\n        });\n        /** @type {Spring} */ this.releaseYSpring = hasSpring ? /** @type {Spring} */ ease : createSpring({\n            mass: setValue(parameters.releaseMass, 1),\n            stiffness: setValue(parameters.releaseStiffness, 80),\n            damping: setValue(parameters.releaseDamping, 20)\n        });\n        /** @type {EasingFunction} */ this.releaseEase = customEase || eases.outQuint;\n        /** @type {Boolean} */ this.hasReleaseSpring = hasSpring;\n        /** @type {Callback<this>} */ this.onGrab = parameters.onGrab || noop;\n        /** @type {Callback<this>} */ this.onDrag = parameters.onDrag || noop;\n        /** @type {Callback<this>} */ this.onRelease = parameters.onRelease || noop;\n        /** @type {Callback<this>} */ this.onUpdate = parameters.onUpdate || noop;\n        /** @type {Callback<this>} */ this.onSettle = parameters.onSettle || noop;\n        /** @type {Callback<this>} */ this.onSnap = parameters.onSnap || noop;\n        /** @type {Callback<this>} */ this.onResize = parameters.onResize || noop;\n        /** @type {Callback<this>} */ this.onAfterResize = parameters.onAfterResize || noop;\n        /** @type {[Number, Number]} */ this.disabled = [\n            0,\n            0\n        ];\n        /** @type {AnimatableParams} */ const animatableParams = {};\n        if (modifier) animatableParams.modifier = modifier;\n        if (isUnd(paramX) || paramX === true) {\n            animatableParams[xProp] = 0;\n        } else if (isObj(paramX)) {\n            const paramXObject = /** @type {DraggableAxisParam} */ paramX;\n            const animatableXParams = {};\n            if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n            if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n            animatableParams[xProp] = animatableXParams;\n        } else if (paramX === false) {\n            animatableParams[xProp] = 0;\n            this.disabled[0] = 1;\n        }\n        if (isUnd(paramY) || paramY === true) {\n            animatableParams[yProp] = 0;\n        } else if (isObj(paramY)) {\n            const paramYObject = /** @type {DraggableAxisParam} */ paramY;\n            const animatableYParams = {};\n            if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n            if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n            animatableParams[yProp] = animatableYParams;\n        } else if (paramY === false) {\n            animatableParams[yProp] = 0;\n            this.disabled[1] = 1;\n        }\n        /** @type {AnimatableObject} */ this.animate = /** @type {AnimatableObject} */ new Animatable(this.$target, animatableParams);\n        // Internal props\n        this.xProp = xProp;\n        this.yProp = yProp;\n        this.destX = 0;\n        this.destY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.scroll = {\n            x: 0,\n            y: 0\n        };\n        /** @type {[Number, Number, Number, Number]} */ this.coords = [\n            this.x,\n            this.y,\n            0,\n            0\n        ]; // x, y, temp x, temp y\n        /** @type {[Number, Number]} */ this.snapped = [\n            0,\n            0\n        ]; // x, y\n        /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */ this.pointer = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n        /** @type {[Number, Number]} */ this.scrollView = [\n            0,\n            0\n        ]; // w, h\n        /** @type {[Number, Number, Number, Number]} */ this.dragArea = [\n            0,\n            0,\n            0,\n            0\n        ]; // x, y, w, h\n        /** @type {[Number, Number, Number, Number]} */ this.containerBounds = [\n            -1e12,\n            maxValue,\n            maxValue,\n            -1e12\n        ]; // t, r, b, l\n        /** @type {[Number, Number, Number, Number]} */ this.scrollBounds = [\n            0,\n            0,\n            0,\n            0\n        ]; // t, r, b, l\n        /** @type {[Number, Number, Number, Number]} */ this.targetBounds = [\n            0,\n            0,\n            0,\n            0\n        ]; // t, r, b, l\n        /** @type {[Number, Number]} */ this.window = [\n            0,\n            0\n        ]; // w, h\n        /** @type {[Number, Number, Number]} */ this.velocityStack = [\n            0,\n            0,\n            0\n        ];\n        /** @type {Number} */ this.velocityStackIndex = 0;\n        /** @type {Number} */ this.velocityTime = now();\n        /** @type {Number} */ this.velocity = 0;\n        /** @type {Number} */ this.angle = 0;\n        /** @type {JSAnimation} */ this.cursorStyles = null;\n        /** @type {JSAnimation} */ this.triggerStyles = null;\n        /** @type {JSAnimation} */ this.bodyStyles = null;\n        /** @type {JSAnimation} */ this.targetStyles = null;\n        /** @type {JSAnimation} */ this.touchActionStyles = null;\n        this.transforms = new Transforms(this.$target);\n        this.overshootCoords = {\n            x: 0,\n            y: 0\n        };\n        this.overshootXTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.overshootYTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.updateTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.overshootXTicker.onUpdate = ()=>{\n            if (this.disabled[0]) return;\n            this.updated = true;\n            this.manual = true;\n            this.animate[this.xProp](this.overshootCoords.x, 0);\n        };\n        this.overshootXTicker.onComplete = ()=>{\n            if (this.disabled[0]) return;\n            this.manual = false;\n            this.animate[this.xProp](this.overshootCoords.x, 0);\n        };\n        this.overshootYTicker.onUpdate = ()=>{\n            if (this.disabled[1]) return;\n            this.updated = true;\n            this.manual = true;\n            this.animate[this.yProp](this.overshootCoords.y, 0);\n        };\n        this.overshootYTicker.onComplete = ()=>{\n            if (this.disabled[1]) return;\n            this.manual = false;\n            this.animate[this.yProp](this.overshootCoords.y, 0);\n        };\n        this.updateTicker.onUpdate = ()=>this.update();\n        this.contained = !isUnd(container);\n        this.manual = false;\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.enabled = false;\n        this.initialized = false;\n        this.activeProp = this.disabled[1] ? xProp : yProp;\n        this.animate.animations[this.activeProp].onRender = ()=>{\n            const hasUpdated = this.updated;\n            const hasMoved = this.grabbed && hasUpdated;\n            const hasReleased = !hasMoved && this.released;\n            const x = this.x;\n            const y = this.y;\n            const dx = x - this.coords[2];\n            const dy = y - this.coords[3];\n            this.deltaX = dx;\n            this.deltaY = dy;\n            this.coords[2] = x;\n            this.coords[3] = y;\n            if (hasUpdated) {\n                this.onUpdate(this);\n            }\n            if (!hasReleased) {\n                this.updated = false;\n            } else {\n                this.computeVelocity(dx, dy);\n                this.angle = atan2(dy, dx);\n            }\n        };\n        this.animate.animations[this.activeProp].onComplete = ()=>{\n            if (!this.grabbed && this.released) {\n                // Set eleased to false before calling onSettle to avoid recursion\n                this.released = false;\n            }\n            if (!this.manual) {\n                this.deltaX = 0;\n                this.deltaY = 0;\n                this.velocity = 0;\n                this.velocityStack[0] = 0;\n                this.velocityStack[1] = 0;\n                this.velocityStack[2] = 0;\n                this.velocityStackIndex = 0;\n                this.onSettle(this);\n            }\n        };\n        this.resizeTicker = new Timer({\n            autoplay: false,\n            duration: 150 * globals.timeScale,\n            onComplete: ()=>{\n                this.onResize(this);\n                this.refresh();\n                this.onAfterResize(this);\n            }\n        }).init();\n        this.parameters = parameters;\n        this.resizeObserver = new ResizeObserver(()=>{\n            if (this.initialized) {\n                this.resizeTicker.restart();\n            } else {\n                this.initialized = true;\n            }\n        });\n        this.enable();\n        this.refresh();\n        this.resizeObserver.observe(this.$container);\n        if (!isObj(target)) this.resizeObserver.observe(this.$target);\n    }\n    /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */ computeVelocity(dx, dy) {\n        const prevTime = this.velocityTime;\n        const curTime = now();\n        const elapsed = curTime - prevTime;\n        if (elapsed < 17) return this.velocity;\n        this.velocityTime = curTime;\n        const velocityStack = this.velocityStack;\n        const vMul = this.velocityMultiplier;\n        const minV = this.minVelocity;\n        const maxV = this.maxVelocity;\n        const vi = this.velocityStackIndex;\n        velocityStack[vi] = round(clamp(sqrt(dx * dx + dy * dy) / elapsed * vMul, minV, maxV), 5);\n        const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n        this.velocity = velocity;\n        this.velocityStackIndex = (vi + 1) % 3;\n        return velocity;\n    }\n    /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */ setX(x, muteUpdateCallback = false) {\n        if (this.disabled[0]) return;\n        const v = round(x, 5);\n        this.overshootXTicker.pause();\n        this.manual = true;\n        this.updated = !muteUpdateCallback;\n        this.destX = v;\n        this.snapped[0] = snap(v, this.snapX);\n        this.animate[this.xProp](v, 0);\n        this.manual = false;\n        return this;\n    }\n    /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */ setY(y, muteUpdateCallback = false) {\n        if (this.disabled[1]) return;\n        const v = round(y, 5);\n        this.overshootYTicker.pause();\n        this.manual = true;\n        this.updated = !muteUpdateCallback;\n        this.destY = v;\n        this.snapped[1] = snap(v, this.snapY);\n        this.animate[this.yProp](v, 0);\n        this.manual = false;\n        return this;\n    }\n    get x() {\n        return round(/** @type {Number} */ this.animate[this.xProp](), globals.precision);\n    }\n    set x(x) {\n        this.setX(x, false);\n    }\n    get y() {\n        return round(/** @type {Number} */ this.animate[this.yProp](), globals.precision);\n    }\n    set y(y) {\n        this.setY(y, false);\n    }\n    get progressX() {\n        return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n    }\n    set progressX(x) {\n        this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n    }\n    get progressY() {\n        return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n    }\n    set progressY(y) {\n        this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n    }\n    updateScrollCoords() {\n        const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n        const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        const threshold = this.scrollThreshold;\n        this.scroll.x = sx;\n        this.scroll.y = sy;\n        this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n        this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n        this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n        this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n    }\n    updateBoundingValues() {\n        const $container = this.$container;\n        const cx = this.x;\n        const cy = this.y;\n        const cx2 = this.coords[2];\n        const cy2 = this.coords[3];\n        // Prevents interfering with the scroll area in cases the target is outside of the container\n        // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n        this.coords[2] = 0;\n        this.coords[3] = 0;\n        this.setX(0, true);\n        this.setY(0, true);\n        this.transforms.remove();\n        const iw = this.window[0] = win.innerWidth;\n        const ih = this.window[1] = win.innerHeight;\n        const uw = this.useWin;\n        const sw = $container.scrollWidth;\n        const sh = $container.scrollHeight;\n        const fx = this.fixed;\n        const transformContainerRect = $container.getBoundingClientRect();\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n        this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n        this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n        this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n        this.updateScrollCoords();\n        const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n        this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n        this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n        const containerOverflow = getTargetValue($container, \"overflow\");\n        const visibleOverflow = containerOverflow === \"visible\";\n        const hiddenOverflow = containerOverflow === \"hidden\";\n        this.canScroll = fx ? false : this.contained && ($container === doc.body && visibleOverflow || !hiddenOverflow && !visibleOverflow) && (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) && (!this.containerArray || this.containerArray && !isArr(this.containerArray));\n        if (this.contained) {\n            const sx = this.scroll.x;\n            const sy = this.scroll.y;\n            const canScroll = this.canScroll;\n            const targetRect = this.$target.getBoundingClientRect();\n            const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n            const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n            const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n            const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n            this.targetBounds[0] = round(targetRect.top + sy - (uw ? 0 : top), 0);\n            this.targetBounds[1] = round(targetRect.right + sx - (uw ? iw : right), 0);\n            this.targetBounds[2] = round(targetRect.bottom + sy - (uw ? ih : bottom), 0);\n            this.targetBounds[3] = round(targetRect.left + sx - (uw ? 0 : left), 0);\n            if (this.containerArray) {\n                this.containerBounds[0] = this.containerArray[0] + cpt;\n                this.containerBounds[1] = this.containerArray[1] - cpr;\n                this.containerBounds[2] = this.containerArray[2] - cpb;\n                this.containerBounds[3] = this.containerArray[3] + cpl;\n            } else {\n                this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n                this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n                this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n                this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n            }\n        }\n        this.transforms.revert();\n        // Restore coordinates\n        this.coords[2] = cx2;\n        this.coords[3] = cy2;\n        this.setX(cx, true);\n        this.setY(cy, true);\n    }\n    /**\n   * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n   *\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */ isOutOfBounds(bounds, x, y) {\n        if (!this.contained) return 0;\n        const [bt, br, bb, bl] = bounds;\n        const [dx, dy] = this.disabled;\n        const obx = !dx && x < bl || !dx && x > br;\n        const oby = !dy && y < bt || !dy && y > bb;\n        return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n    }\n    refresh() {\n        const params = this.parameters;\n        const paramX = params.x;\n        const paramY = params.y;\n        const container = parseDraggableFunctionParameter(params.container, this);\n        const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n        const containerPadding = /** @type {[Number, Number, Number, Number]} */ isArr(cp) ? cp : [\n            cp,\n            cp,\n            cp,\n            cp\n        ];\n        const cx = this.x;\n        const cy = this.y;\n        const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n        const cursorStyles = {\n            onHover: \"grab\",\n            onGrab: \"grabbing\"\n        };\n        if (parsedCursorStyles) {\n            const { onHover, onGrab } = /** @type {DraggableCursorParams} */ parsedCursorStyles;\n            if (onHover) cursorStyles.onHover = onHover;\n            if (onGrab) cursorStyles.onGrab = onGrab;\n        }\n        this.containerArray = isArr(container) ? container : null;\n        this.$container = /** @type {HTMLElement} */ container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ container)[0] : doc.body;\n        this.useWin = this.$container === doc.body;\n        /** @type {Window | HTMLElement} */ this.$scrollContainer = this.useWin ? win : this.$container;\n        this.isFinePointer = matchMedia(\"(pointer:fine)\").matches;\n        this.containerPadding = setValue(containerPadding, [\n            0,\n            0,\n            0,\n            0\n        ]);\n        this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n        this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n        this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n        this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n        this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n        this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n        this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n        this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n        this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n        this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n        this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n        this.updateBoundingValues();\n        // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n        // if (ob === 1 || ob === 3) this.progressX = px;\n        // if (ob === 2 || ob === 3) this.progressY = py;\n        // if (this.initialized && this.contained) {\n        //   if (this.progressX !== px) this.progressX = px;\n        //   if (this.progressY !== py) this.progressY = py;\n        // }\n        const [bt, br, bb, bl] = this.containerBounds;\n        this.setX(clamp(cx, bl, br), true);\n        this.setY(clamp(cy, bt, bb), true);\n    }\n    update() {\n        this.updateScrollCoords();\n        if (this.canScroll) {\n            const [cpt, cpr, cpb, cpl] = this.containerPadding;\n            const [sw, sh] = this.scrollView;\n            const daw = this.dragArea[2];\n            const dah = this.dragArea[3];\n            const csx = this.scroll.x;\n            const csy = this.scroll.y;\n            const nsw = this.$container.scrollWidth;\n            const nsh = this.$container.scrollHeight;\n            const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n            const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n            const swd = sw - csw;\n            const shd = sh - csh;\n            // Handle cases where the scrollarea dimensions changes during drag\n            if (this.dragged && swd > 0) {\n                this.coords[0] -= swd;\n                this.scrollView[0] = csw;\n            }\n            if (this.dragged && shd > 0) {\n                this.coords[1] -= shd;\n                this.scrollView[1] = csh;\n            }\n            // Handle autoscroll when target is at the edges of the scroll bounds\n            const s = this.scrollSpeed * 10;\n            const threshold = this.scrollThreshold;\n            const [x, y] = this.coords;\n            const [st, sr, sb, sl] = this.scrollBounds;\n            const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n            const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n            const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n            const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n            if (t || b || l || r) {\n                const [nx, ny] = this.disabled;\n                let scrollX = csx;\n                let scrollY = csy;\n                if (!nx) {\n                    scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n                    this.coords[0] -= csx - scrollX;\n                }\n                if (!ny) {\n                    scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n                    this.coords[1] -= csy - scrollY;\n                }\n                // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n                if (this.useWin) {\n                    this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n                } else {\n                    this.$scrollContainer.scrollTo(scrollX, scrollY);\n                }\n            }\n        }\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const [px1, py1, px2, py2, px3, py3] = this.pointer;\n        this.coords[0] += (px1 - px3) * this.dragSpeed;\n        this.coords[1] += (py1 - py3) * this.dragSpeed;\n        this.pointer[4] = px1;\n        this.pointer[5] = py1;\n        const [cx, cy] = this.coords;\n        const [sx, sy] = this.snapped;\n        const cf = (1 - this.containerFriction) * this.dragSpeed;\n        this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n        this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n        this.computeVelocity(px1 - px3, py1 - py3);\n        this.angle = atan2(py1 - py2, px1 - px2);\n        const [nsx, nsy] = this.snapped;\n        if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n            this.onSnap(this);\n        }\n    }\n    stop() {\n        this.updateTicker.pause();\n        this.overshootXTicker.pause();\n        this.overshootYTicker.pause();\n        // Pauses the in bounds onRelease animations\n        for(let prop in this.animate.animations)this.animate.animations[prop].pause();\n        remove(this, null, \"x\");\n        remove(this, null, \"y\");\n        remove(this, null, \"progressX\");\n        remove(this, null, \"progressY\");\n        remove(this.scroll); // Removes any active animations on the container scroll\n        remove(this.overshootCoords); // Removes active overshoot animations\n        return this;\n    }\n    /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */ scrollInView(duration, gap = 0, ease = eases.inOutQuad) {\n        this.updateScrollCoords();\n        const x = this.destX;\n        const y = this.destY;\n        const scroll = this.scroll;\n        const scrollBounds = this.scrollBounds;\n        const canScroll = this.canScroll;\n        if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n            const [st, sr, sb, sl] = scrollBounds;\n            const t = round(clamp(y - st, -1e12, 0), 0);\n            const r = round(clamp(x - sr, 0, maxValue), 0);\n            const b = round(clamp(y - sb, 0, maxValue), 0);\n            const l = round(clamp(x - sl, -1e12, 0), 0);\n            new JSAnimation(scroll, {\n                x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n                y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n                duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n                ease,\n                onUpdate: ()=>{\n                    this.canScroll = false;\n                    this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n                }\n            }).init().then(()=>{\n                this.canScroll = canScroll;\n            });\n        }\n        return this;\n    }\n    handleHover() {\n        if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n            this.cursorStyles = setTargetValues(this.$trigger, {\n                cursor: /** @type {DraggableCursorParams} */ this.cursor.onHover\n            });\n        }\n    }\n    /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */ animateInView(duration, gap = 0, ease = eases.inOutQuad) {\n        this.stop();\n        this.updateBoundingValues();\n        const x = this.x;\n        const y = this.y;\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n        const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n        const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n        const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n        const ob = this.isOutOfBounds([\n            bt,\n            br,\n            bb,\n            bl\n        ], x, y);\n        if (ob) {\n            const [disabledX, disabledY] = this.disabled;\n            const destX = clamp(snap(x, this.snapX), bl, br);\n            const destY = clamp(snap(y, this.snapY), bt, bb);\n            const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n            if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n            if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n        }\n        return this;\n    }\n    /**\n   * @param {MouseEvent|TouchEvent} e\n   */ handleDown(e) {\n        const $eTarget = /** @type {HTMLElement} */ e.target;\n        if (this.grabbed || /** @type {HTMLInputElement}  */ $eTarget.type === \"range\") return;\n        e.stopPropagation();\n        this.grabbed = true;\n        this.released = false;\n        this.stop();\n        this.updateBoundingValues();\n        const touches = /** @type {TouchEvent} */ e.changedTouches;\n        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ e.clientX;\n        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ e.clientY;\n        const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const cf = (1 - this.containerFriction) * this.dragSpeed;\n        const cx = this.x;\n        const cy = this.y;\n        this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n        this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.pointer[2] = x;\n        this.pointer[3] = y;\n        this.pointer[4] = x;\n        this.pointer[5] = y;\n        this.pointer[6] = x;\n        this.pointer[7] = y;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.angle = 0;\n        if (this.targetStyles) {\n            this.targetStyles.revert();\n            this.targetStyles = null;\n        }\n        const z = /** @type {Number} */ getTargetValue(this.$target, \"zIndex\", false);\n        zIndex = (z > zIndex ? z : zIndex) + 1;\n        this.targetStyles = setTargetValues(this.$target, {\n            zIndex\n        });\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.cursorStyles) {\n            this.cursorStyles.revert();\n            this.cursorStyles = null;\n        }\n        if (this.isFinePointer && this.cursor) {\n            this.bodyStyles = setTargetValues(doc.body, {\n                cursor: /** @type {DraggableCursorParams} */ this.cursor.onGrab\n            });\n        }\n        this.scrollInView(100, 0, eases.out(3));\n        this.onGrab(this);\n        doc.addEventListener(\"touchmove\", this);\n        doc.addEventListener(\"touchend\", this);\n        doc.addEventListener(\"touchcancel\", this);\n        doc.addEventListener(\"mousemove\", this);\n        doc.addEventListener(\"mouseup\", this);\n        doc.addEventListener(\"selectstart\", this);\n    }\n    /**\n   * @param {MouseEvent|TouchEvent} e\n   */ handleMove(e) {\n        if (!this.grabbed) return;\n        const touches = /** @type {TouchEvent} */ e.changedTouches;\n        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ e.clientX;\n        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ e.clientY;\n        const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n        const movedX = x - this.pointer[6];\n        const movedY = y - this.pointer[7];\n        let $parent = /** @type {HTMLElement} */ e.target;\n        let isAtTop = false;\n        let isAtBottom = false;\n        let canTouchScroll = false;\n        while(touches && $parent && $parent !== this.$trigger){\n            const overflowY = getTargetValue($parent, \"overflow-y\");\n            if (overflowY !== \"hidden\" && overflowY !== \"visible\") {\n                const { scrollTop, scrollHeight, clientHeight } = $parent;\n                if (scrollHeight > clientHeight) {\n                    canTouchScroll = true;\n                    isAtTop = scrollTop <= 3;\n                    isAtBottom = scrollTop >= scrollHeight - clientHeight - 3;\n                    break;\n                }\n            }\n            $parent = /** @type {HTMLElement} */ $parent.parentNode;\n        }\n        if (canTouchScroll && (!isAtTop && !isAtBottom || isAtTop && movedY < 0 || isAtBottom && movedY > 0)) {\n            this.pointer[0] = x;\n            this.pointer[1] = y;\n            this.pointer[2] = x;\n            this.pointer[3] = y;\n            this.pointer[4] = x;\n            this.pointer[5] = y;\n            this.pointer[6] = x;\n            this.pointer[7] = y;\n        } else {\n            preventDefault(e);\n            // Needed to prevents click on handleUp\n            if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, {\n                pointerEvents: \"none\"\n            });\n            // Needed to prevent page scroll while dragging on touch devvice\n            this.$trigger.addEventListener(\"touchstart\", preventDefault, {\n                passive: false\n            });\n            this.$trigger.addEventListener(\"touchmove\", preventDefault, {\n                passive: false\n            });\n            this.$trigger.addEventListener(\"touchend\", preventDefault);\n            if (!this.disabled[0] && abs(movedX) > 3 || !this.disabled[1] && abs(movedY) > 3) {\n                this.updateTicker.resume();\n                this.pointer[2] = this.pointer[0];\n                this.pointer[3] = this.pointer[1];\n                this.pointer[0] = x;\n                this.pointer[1] = y;\n                this.dragged = true;\n                this.released = false;\n                this.onDrag(this);\n            }\n        }\n    }\n    handleUp() {\n        if (!this.grabbed) return;\n        this.updateTicker.pause();\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.bodyStyles) {\n            this.bodyStyles.revert();\n            this.bodyStyles = null;\n        }\n        const [disabledX, disabledY] = this.disabled;\n        const [px1, py1, px2, py2, px3, py3] = this.pointer;\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const [sx, sy] = this.snapped;\n        const springX = this.releaseXSpring;\n        const springY = this.releaseYSpring;\n        const releaseEase = this.releaseEase;\n        const hasReleaseSpring = this.hasReleaseSpring;\n        const overshootCoords = this.overshootCoords;\n        const cx = this.x;\n        const cy = this.y;\n        const pv = this.computeVelocity(px1 - px3, py1 - py3);\n        const pa = this.angle = atan2(py1 - py2, px1 - px2);\n        const ds = pv * 150;\n        const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n        const nx = cx + cos(pa) * ds;\n        const ny = cy + sin(pa) * ds;\n        const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n        const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n        const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n        const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n        const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n        let durationX = 0;\n        let durationY = 0;\n        let easeX = releaseEase;\n        let easeY = releaseEase;\n        let longestReleaseDuration = 0;\n        overshootCoords.x = cx;\n        overshootCoords.y = cy;\n        if (!disabledX) {\n            const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n            const distanceX = round(cx - dx, 0);\n            springX.velocity = disabledY && hasReleaseSpring ? distanceX ? ds * directionX / abs(distanceX) : 0 : pv;\n            const { ease, duration, restDuration } = springX;\n            durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n            if (hasReleaseSpring) easeX = ease;\n            if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n        }\n        if (!disabledY) {\n            const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n            const distanceY = round(cy - dy, 0);\n            springY.velocity = disabledX && hasReleaseSpring ? distanceY ? ds * directionY / abs(distanceY) : 0 : pv;\n            const { ease, duration, restDuration } = springY;\n            durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n            if (hasReleaseSpring) easeY = ease;\n            if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n        }\n        if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n            const composition = compositionTypes.blend;\n            new JSAnimation(overshootCoords, {\n                x: {\n                    to: bx,\n                    duration: durationX * .65\n                },\n                y: {\n                    to: by,\n                    duration: durationY * .65\n                },\n                ease: releaseEase,\n                composition\n            }).init();\n            new JSAnimation(overshootCoords, {\n                x: {\n                    to: dx,\n                    duration: durationX\n                },\n                y: {\n                    to: dy,\n                    duration: durationY\n                },\n                ease: releaseEase,\n                composition\n            }).init();\n            this.overshootXTicker.stretch(durationX).restart();\n            this.overshootYTicker.stretch(durationY).restart();\n        } else {\n            if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n            if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n        }\n        this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n        let hasSnapped = false;\n        if (dx !== sx) {\n            this.snapped[0] = dx;\n            if (this.snapX) hasSnapped = true;\n        }\n        if (dy !== sy && this.snapY) {\n            this.snapped[1] = dy;\n            if (this.snapY) hasSnapped = true;\n        }\n        if (hasSnapped) this.onSnap(this);\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = true;\n        this.released = true;\n        // It's important to trigger the callback after the release animations to be able to cancel them\n        this.onRelease(this);\n        this.$trigger.removeEventListener(\"touchstart\", preventDefault);\n        this.$trigger.removeEventListener(\"touchmove\", preventDefault);\n        this.$trigger.removeEventListener(\"touchend\", preventDefault);\n        doc.removeEventListener(\"touchmove\", this);\n        doc.removeEventListener(\"touchend\", this);\n        doc.removeEventListener(\"touchcancel\", this);\n        doc.removeEventListener(\"mousemove\", this);\n        doc.removeEventListener(\"mouseup\", this);\n        doc.removeEventListener(\"selectstart\", this);\n    }\n    reset() {\n        this.stop();\n        this.resizeTicker.pause();\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.setX(0, true);\n        this.setY(0, true);\n        this.coords[0] = 0;\n        this.coords[1] = 0;\n        this.pointer[0] = 0;\n        this.pointer[1] = 0;\n        this.pointer[2] = 0;\n        this.pointer[3] = 0;\n        this.pointer[4] = 0;\n        this.pointer[5] = 0;\n        this.pointer[6] = 0;\n        this.pointer[7] = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.angle = 0;\n        return this;\n    }\n    enable() {\n        if (!this.enabled) {\n            this.enabled = true;\n            this.$target.classList.remove(\"is-disabled\");\n            this.touchActionStyles = setTargetValues(this.$trigger, {\n                touchAction: this.disabled[0] ? \"pan-x\" : this.disabled[1] ? \"pan-y\" : \"none\"\n            });\n            this.$trigger.addEventListener(\"touchstart\", this, {\n                passive: true\n            });\n            this.$trigger.addEventListener(\"mousedown\", this, {\n                passive: true\n            });\n            this.$trigger.addEventListener(\"mouseenter\", this);\n        }\n        return this;\n    }\n    disable() {\n        this.enabled = false;\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.touchActionStyles.revert();\n        if (this.cursorStyles) {\n            this.cursorStyles.revert();\n            this.cursorStyles = null;\n        }\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.bodyStyles) {\n            this.bodyStyles.revert();\n            this.bodyStyles = null;\n        }\n        if (this.targetStyles) {\n            this.targetStyles.revert();\n            this.targetStyles = null;\n        }\n        this.stop();\n        this.$target.classList.add(\"is-disabled\");\n        this.$trigger.removeEventListener(\"touchstart\", this);\n        this.$trigger.removeEventListener(\"mousedown\", this);\n        this.$trigger.removeEventListener(\"mouseenter\", this);\n        doc.removeEventListener(\"touchmove\", this);\n        doc.removeEventListener(\"touchend\", this);\n        doc.removeEventListener(\"touchcancel\", this);\n        doc.removeEventListener(\"mousemove\", this);\n        doc.removeEventListener(\"mouseup\", this);\n        doc.removeEventListener(\"selectstart\", this);\n        return this;\n    }\n    revert() {\n        this.reset();\n        this.disable();\n        this.$target.classList.remove(\"is-disabled\");\n        this.updateTicker.revert();\n        this.overshootXTicker.revert();\n        this.overshootYTicker.revert();\n        this.resizeTicker.revert();\n        this.animate.revert();\n        return this;\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"mousedown\":\n                this.handleDown(/** @type {MouseEvent} */ e);\n                break;\n            case \"touchstart\":\n                this.handleDown(/** @type {TouchEvent} */ e);\n                break;\n            case \"mousemove\":\n                this.handleMove(/** @type {MouseEvent} */ e);\n                break;\n            case \"touchmove\":\n                this.handleMove(/** @type {TouchEvent} */ e);\n                break;\n            case \"mouseup\":\n                this.handleUp();\n                break;\n            case \"touchend\":\n                this.handleUp();\n                break;\n            case \"touchcancel\":\n                this.handleUp();\n                break;\n            case \"mouseenter\":\n                this.handleHover();\n                break;\n            case \"selectstart\":\n                preventDefault(e);\n                break;\n        }\n    }\n}\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */ const createDraggable = (target, parameters)=>new Draggable(target, parameters);\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */ /**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */ /**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */ /**\n * @callback ScopeCleanup\n * @param {Scope} [scope]\n */ /**\n * @callback ScopeConstructor\n * @param {Scope} [scope]\n * @return {ScopeCleanup|void}\n */ /**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanup|void}\n */ class Scope {\n    /** @param {ScopeParams} [parameters] */ constructor(parameters = {}){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const rootParam = parameters.root;\n        /** @type {Document|DOMTarget} */ let root = doc;\n        if (rootParam) {\n            root = /** @type {ReactRef} */ rootParam.current || /** @type {AngularRef} */ rootParam.nativeElement || parseTargets(/** @type {DOMTargetSelector} */ rootParam)[0] || doc;\n        }\n        const scopeDefaults = parameters.defaults;\n        const globalDefault = globals.defaults;\n        const mediaQueries = parameters.mediaQueries;\n        /** @type {DefaultsParams} */ this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n        /** @type {Document|DOMTarget} */ this.root = root;\n        /** @type {Array<ScopeConstructor>} */ this.constructors = [];\n        /** @type {Array<Function>} */ this.revertConstructors = [];\n        /** @type {Array<Revertible>} */ this.revertibles = [];\n        /** @type {Record<String, Function>} */ this.methods = {};\n        /** @type {Record<String, Boolean>} */ this.matches = {};\n        /** @type {Record<String, MediaQueryList>} */ this.mediaQueryLists = {};\n        /** @type {Record<String, any>} */ this.data = {};\n        if (mediaQueries) {\n            for(let mq in mediaQueries){\n                const _mq = win.matchMedia(mediaQueries[mq]);\n                this.mediaQueryLists[mq] = _mq;\n                _mq.addEventListener(\"change\", this);\n            }\n        }\n    }\n    /**\n   * @callback ScoppedCallback\n   * @param {this} scope\n   * @return {any}\n   *\n   * @param {ScoppedCallback} cb\n   * @return {this}\n   */ execute(cb) {\n        let activeScope = globals.scope;\n        let activeRoot = globals.root;\n        let activeDefaults = globals.defaults;\n        globals.scope = this;\n        globals.root = this.root;\n        globals.defaults = this.defaults;\n        const mqs = this.mediaQueryLists;\n        for(let mq in mqs)this.matches[mq] = mqs[mq].matches;\n        const returned = cb(this);\n        globals.scope = activeScope;\n        globals.root = activeRoot;\n        globals.defaults = activeDefaults;\n        return returned;\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        this.execute(()=>{\n            let i = this.revertibles.length;\n            let y = this.revertConstructors.length;\n            while(i--)this.revertibles[i].revert();\n            while(y--)this.revertConstructors[y](this);\n            this.revertibles.length = 0;\n            this.revertConstructors.length = 0;\n            this.constructors.forEach((constructor)=>{\n                const revertConstructor = constructor(this);\n                if (revertConstructor) {\n                    this.revertConstructors.push(revertConstructor);\n                }\n            });\n        });\n        return this;\n    }\n    /**\n   * @callback contructorCallback\n   * @param {this} self\n   *\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {contructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|contructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */ add(a1, a2) {\n        if (isFnc(a1)) {\n            const constructor = /** @type {contructorCallback} */ a1;\n            this.constructors.push(constructor);\n            this.execute(()=>{\n                const revertConstructor = constructor(this);\n                if (revertConstructor) {\n                    this.revertConstructors.push(revertConstructor);\n                }\n            });\n        } else {\n            this.methods[/** @type {String} */ a1] = (...args)=>this.execute(()=>a2(...args));\n        }\n        return this;\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"change\":\n                this.refresh();\n                break;\n        }\n    }\n    revert() {\n        const revertibles = this.revertibles;\n        const revertConstructors = this.revertConstructors;\n        const mqs = this.mediaQueryLists;\n        let i = revertibles.length;\n        let y = revertConstructors.length;\n        while(i--)revertibles[i].revert();\n        while(y--)revertConstructors[y](this);\n        for(let mq in mqs)mqs[mq].removeEventListener(\"change\", this);\n        revertibles.length = 0;\n        revertConstructors.length = 0;\n        this.constructors.length = 0;\n        this.matches = {};\n        this.methods = {};\n        this.mediaQueryLists = {};\n        this.data = {};\n    }\n}\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */ const createScope = (params)=>new Scope(params);\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */ /**\n * @return {Number}\n */ const getMaxViewHeight = ()=>{\n    const $el = document.createElement(\"div\");\n    doc.body.appendChild($el);\n    $el.style.height = \"100lvh\";\n    const height = $el.offsetHeight;\n    doc.body.removeChild($el);\n    return height;\n};\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */ const parseScrollObserverFunctionParameter = (value, scroller)=>value && isFnc(value) ? /** @type {Function} */ value(scroller) : value;\nconst scrollContainers = new Map();\nclass ScrollContainer {\n    /**\n   * @param {HTMLElement} $el\n   */ constructor($el){\n        /** @type {HTMLElement} */ this.element = $el;\n        /** @type {Boolean} */ this.useWin = this.element === doc.body;\n        /** @type {Number} */ this.winWidth = 0;\n        /** @type {Number} */ this.winHeight = 0;\n        /** @type {Number} */ this.width = 0;\n        /** @type {Number} */ this.height = 0;\n        /** @type {Number} */ this.left = 0;\n        /** @type {Number} */ this.top = 0;\n        /** @type {Number} */ this.zIndex = 0;\n        /** @type {Number} */ this.scrollX = 0;\n        /** @type {Number} */ this.scrollY = 0;\n        /** @type {Number} */ this.prevScrollX = 0;\n        /** @type {Number} */ this.prevScrollY = 0;\n        /** @type {Number} */ this.scrollWidth = 0;\n        /** @type {Number} */ this.scrollHeight = 0;\n        /** @type {Number} */ this.velocity = 0;\n        /** @type {Boolean} */ this.backwardX = false;\n        /** @type {Boolean} */ this.backwardY = false;\n        /** @type {Timer} */ this.scrollTicker = new Timer({\n            autoplay: false,\n            onBegin: ()=>this.dataTimer.resume(),\n            onUpdate: ()=>{\n                const backwards = this.backwardX || this.backwardY;\n                forEachChildren(this, (/** @type {ScrollObserver} */ child)=>child.handleScroll(), backwards);\n            },\n            onComplete: ()=>this.dataTimer.pause()\n        }).init();\n        /** @type {Timer} */ this.dataTimer = new Timer({\n            autoplay: false,\n            frameRate: 30,\n            onUpdate: (self)=>{\n                const dt = self.deltaTime;\n                const px = this.prevScrollX;\n                const py = this.prevScrollY;\n                const nx = this.scrollX;\n                const ny = this.scrollY;\n                const dx = px - nx;\n                const dy = py - ny;\n                this.prevScrollX = nx;\n                this.prevScrollY = ny;\n                if (dx) this.backwardX = px > nx;\n                if (dy) this.backwardY = py > ny;\n                this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n            }\n        }).init();\n        /** @type {Timer} */ this.resizeTicker = new Timer({\n            autoplay: false,\n            duration: 250 * globals.timeScale,\n            onComplete: ()=>{\n                this.updateWindowBounds();\n                this.refreshScrollObservers();\n                this.handleScroll();\n            }\n        }).init();\n        /** @type {Timer} */ this.wakeTicker = new Timer({\n            autoplay: false,\n            duration: 500 * globals.timeScale,\n            onBegin: ()=>{\n                this.scrollTicker.resume();\n            },\n            onComplete: ()=>{\n                this.scrollTicker.pause();\n            }\n        }).init();\n        /** @type {ScrollObserver} */ this._head = null;\n        /** @type {ScrollObserver} */ this._tail = null;\n        this.updateScrollCoords();\n        this.updateWindowBounds();\n        this.updateBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n        this.resizeObserver = new ResizeObserver(()=>this.resizeTicker.restart());\n        this.resizeObserver.observe(this.element);\n        (this.useWin ? win : this.element).addEventListener(\"scroll\", this, false);\n    }\n    updateScrollCoords() {\n        const useWin = this.useWin;\n        const $el = this.element;\n        this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n        this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n    }\n    updateWindowBounds() {\n        this.winWidth = win.innerWidth;\n        this.winHeight = getMaxViewHeight();\n    }\n    updateBounds() {\n        const style = getComputedStyle(this.element);\n        const $el = this.element;\n        this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        this.updateWindowBounds();\n        let width, height;\n        if (this.useWin) {\n            width = this.winWidth;\n            height = this.winHeight;\n        } else {\n            const elRect = $el.getBoundingClientRect();\n            width = elRect.width;\n            height = elRect.height;\n            this.top = elRect.top;\n            this.left = elRect.left;\n        }\n        this.width = width;\n        this.height = height;\n    }\n    refreshScrollObservers() {\n        forEachChildren(this, (/** @type {ScrollObserver} */ child)=>{\n            if (child._debug) {\n                child.removeDebug();\n            }\n        });\n        this.updateBounds();\n        forEachChildren(this, (/** @type {ScrollObserver} */ child)=>{\n            child.refresh();\n            if (child._debug) {\n                child.debug();\n            }\n        });\n    }\n    refresh() {\n        this.updateWindowBounds();\n        this.updateBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n    }\n    handleScroll() {\n        this.updateScrollCoords();\n        this.wakeTicker.restart();\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"scroll\":\n                this.handleScroll();\n                break;\n        }\n    }\n    revert() {\n        this.scrollTicker.cancel();\n        this.dataTimer.cancel();\n        this.resizeTicker.cancel();\n        this.wakeTicker.cancel();\n        this.resizeObserver.unobserve(this.element);\n        (this.useWin ? win : this.element).removeEventListener(\"scroll\", this);\n        scrollContainers.delete(this.element);\n    }\n}\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */ const registerAndGetScrollContainer = (target)=>{\n    const $el = /** @type {HTMLElement} */ target ? parseTargets(target)[0] || doc.body : doc.body;\n    let scrollContainer = scrollContainers.get($el);\n    if (!scrollContainer) {\n        scrollContainer = new ScrollContainer($el);\n        scrollContainers.set($el, scrollContainer);\n    }\n    return scrollContainer;\n};\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */ const convertValueToPx = ($el, v, size, under, over)=>{\n    const clampMin = v === \"min\";\n    const clampMax = v === \"max\";\n    const value = v === \"top\" || v === \"left\" || v === \"start\" || clampMin ? 0 : v === \"bottom\" || v === \"right\" || v === \"end\" || clampMax ? \"100%\" : v === \"center\" ? \"50%\" : v;\n    const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n    let px = n;\n    if (u === \"%\") {\n        px = n / 100 * size;\n    } else if (u) {\n        px = convertValueUnit($el, decomposedOriginalValue, \"px\", true).n;\n    }\n    if (clampMax && under < 0) px += under;\n    if (clampMin && over > 0) px += over;\n    return px;\n};\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */ const parseBoundValue = ($el, v, size, under, over)=>{\n    /** @type {Number} */ let value;\n    if (isStr(v)) {\n        const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */ v);\n        if (matchedOperator) {\n            const splitter = matchedOperator[0];\n            const operator = splitter[0];\n            const splitted = /** @type {String} */ v.split(splitter);\n            const clampMin = splitted[0] === \"min\";\n            const clampMax = splitted[0] === \"max\";\n            const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n            const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n            if (clampMin) {\n                const min = getRelativeValue(convertValueToPx($el, \"min\", size), valueBPx, operator);\n                value = min < valueAPx ? valueAPx : min;\n            } else if (clampMax) {\n                const max = getRelativeValue(convertValueToPx($el, \"max\", size), valueBPx, operator);\n                value = max > valueAPx ? valueAPx : max;\n            } else {\n                value = getRelativeValue(valueAPx, valueBPx, operator);\n            }\n        } else {\n            value = convertValueToPx($el, v, size, under, over);\n        }\n    } else {\n        value = /** @type {Number} */ v;\n    }\n    return round(value, 0);\n};\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */ const getAnimationDomTarget = (linked)=>{\n    let $linkedTarget;\n    const linkedTargets = linked.targets;\n    for(let i = 0, l = linkedTargets.length; i < l; i++){\n        const target = linkedTargets[i];\n        if (target[isDomSymbol]) {\n            $linkedTarget = /** @type {HTMLElement} */ target;\n            break;\n        }\n    }\n    return $linkedTarget;\n};\nlet scrollerIndex = 0;\nconst debugColors = [\n    \"#FF4B4B\",\n    \"#FF971B\",\n    \"#FFC730\",\n    \"#F9F640\",\n    \"#7AFF5A\",\n    \"#18FF74\",\n    \"#17E09B\",\n    \"#3CFFEC\",\n    \"#05DBE9\",\n    \"#33B3F1\",\n    \"#638CF9\",\n    \"#C563FE\",\n    \"#FF4FCF\",\n    \"#F93F8A\"\n];\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */ /**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */ /**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */ /**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */ class ScrollObserver {\n    /**\n   * @param {ScrollObserverParams} parameters\n   */ constructor(parameters = {}){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const syncMode = setValue(parameters.sync, \"play pause\");\n        const ease = syncMode ? parseEasings(/** @type {EasingParam} */ syncMode) : null;\n        const isLinear = syncMode && (syncMode === \"linear\" || syncMode === none);\n        const isEase = syncMode && !(ease === none && !isLinear);\n        const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n        const isMethods = syncMode && isStr(syncMode) && !isEase && !isSmooth;\n        const syncMethods = isMethods ? /** @type {String} */ syncMode.split(\" \").map((/** @type {String} */ m)=>()=>{\n                const linked = this.linked;\n                return linked && linked[m] ? linked[m]() : null;\n            }) : null;\n        const biDirSync = isMethods && syncMethods.length > 2;\n        /** @type {Number} */ this.index = scrollerIndex++;\n        /** @type {String|Number} */ this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n        /** @type {ScrollContainer} */ this.container = registerAndGetScrollContainer(parameters.container);\n        /** @type {HTMLElement} */ this.target = null;\n        /** @type {Tickable|WAAPIAnimation} */ this.linked = null;\n        /** @type {Boolean} */ this.repeat = null;\n        /** @type {Boolean} */ this.horizontal = null;\n        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */ this.enter = null;\n        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */ this.leave = null;\n        /** @type {Boolean} */ this.sync = isEase || isSmooth || !!syncMethods;\n        /** @type {EasingFunction} */ this.syncEase = isEase ? ease : null;\n        /** @type {Number} */ this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */ syncMode : null;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnter = parameters.onEnter || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeave = parameters.onLeave || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnterForward = parameters.onEnterForward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeaveForward = parameters.onLeaveForward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnterBackward = parameters.onEnterBackward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeaveBackward = parameters.onLeaveBackward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onUpdate = parameters.onUpdate || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncComplete = parameters.onSyncComplete || noop;\n        /** @type {Boolean} */ this.reverted = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Boolean} */ this.began = false;\n        /** @type {Boolean} */ this.isInView = false;\n        /** @type {Boolean} */ this.forceEnter = false;\n        /** @type {Boolean} */ this.hasEntered = false;\n        /** @type {Array.<Number>} */ this.offsets = [];\n        /** @type {Number} */ this.offset = 0;\n        /** @type {Number} */ this.offsetStart = 0;\n        /** @type {Number} */ this.offsetEnd = 0;\n        /** @type {Number} */ this.distance = 0;\n        /** @type {Number} */ this.prevProgress = 0;\n        /** @type {Array} */ this.thresholds = [\n            \"start\",\n            \"end\",\n            \"end\",\n            \"start\"\n        ];\n        /** @type {[Number, Number, Number, Number]} */ this.coords = [\n            0,\n            0,\n            0,\n            0\n        ];\n        /** @type {JSAnimation} */ this.debugStyles = null;\n        /** @type {HTMLElement} */ this.$debug = null;\n        /** @type {ScrollObserverParams} */ this._params = parameters;\n        /** @type {Boolean} */ this._debug = setValue(parameters.debug, false);\n        /** @type {ScrollObserver} */ this._next = null;\n        /** @type {ScrollObserver} */ this._prev = null;\n        addChild(this.container, this);\n        // Wait for the next frame to add to the container in order to handle calls to link()\n        sync(()=>{\n            if (this.reverted) return;\n            if (!this.target) {\n                const target = /** @type {HTMLElement} */ parseTargets(parameters.target)[0];\n                this.target = target || doc.body;\n                this.refresh();\n            }\n            if (this._debug) this.debug();\n        });\n    }\n    /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */ link(linked) {\n        if (linked) {\n            // Make sure to pause the linked object in case it's added later\n            linked.pause();\n            this.linked = linked;\n            // Try to use a target of the linked object if no target parameters specified\n            if (!this._params.target) {\n                /** @type {HTMLElement} */ let $linkedTarget;\n                if (!isUnd(/** @type {JSAnimation} */ linked.targets)) {\n                    $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ linked);\n                } else {\n                    forEachChildren(/** @type {Timeline} */ linked, (/** @type {JSAnimation} */ child)=>{\n                        if (child.targets && !$linkedTarget) {\n                            $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ child);\n                        }\n                    });\n                }\n                // Fallback to body if no target found\n                this.target = $linkedTarget || doc.body;\n                this.refresh();\n            }\n        }\n        return this;\n    }\n    get velocity() {\n        return this.container.velocity;\n    }\n    get backward() {\n        return this.horizontal ? this.container.backwardX : this.container.backwardY;\n    }\n    get scroll() {\n        return this.horizontal ? this.container.scrollX : this.container.scrollY;\n    }\n    get progress() {\n        const p = (this.scroll - this.offsetStart) / this.distance;\n        return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n    }\n    refresh() {\n        this.reverted = false;\n        const params = this._params;\n        this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n        this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), \"y\") === \"x\";\n        this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), \"end start\");\n        this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), \"start end\");\n        this.updateBounds();\n        this.handleScroll();\n        return this;\n    }\n    removeDebug() {\n        if (this.$debug) {\n            this.$debug.parentNode.removeChild(this.$debug);\n            this.$debug = null;\n        }\n        if (this.debugStyles) {\n            this.debugStyles.revert();\n            this.$debug = null;\n        }\n        return this;\n    }\n    debug() {\n        this.removeDebug();\n        const container = this.container;\n        const isHori = this.horizontal;\n        const $existingDebug = container.element.querySelector(\":scope > .animejs-onscroll-debug\");\n        const $debug = doc.createElement(\"div\");\n        const $thresholds = doc.createElement(\"div\");\n        const $triggers = doc.createElement(\"div\");\n        const color = debugColors[this.index % debugColors.length];\n        const useWin = container.useWin;\n        const containerWidth = useWin ? container.winWidth : container.width;\n        const containerHeight = useWin ? container.winHeight : container.height;\n        const scrollWidth = container.scrollWidth;\n        const scrollHeight = container.scrollHeight;\n        const size = this.container.width > 360 ? 320 : 260;\n        const offLeft = isHori ? 0 : 10;\n        const offTop = isHori ? 10 : 0;\n        const half = isHori ? 24 : size / 2;\n        const labelHeight = isHori ? half : 15;\n        const labelWidth = isHori ? 60 : half;\n        const labelSize = isHori ? labelWidth : labelHeight;\n        const repeat = isHori ? \"repeat-x\" : \"repeat-y\";\n        /**\n     * @param {Number} v\n     * @return {String}\n     */ const gradientOffset = (v)=>isHori ? \"0px \" + v + \"px\" : v + \"px\" + \" 2px\";\n        /**\n     * @param {String} c\n     * @return {String}\n     */ const lineCSS = (c)=>`linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;\n        /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */ const baseCSS = (p, l, t, w, h)=>`position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;\n        $debug.style.cssText = `${baseCSS(\"absolute\", offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}\n      pointer-events: none;\n      z-index: ${this.container.zIndex++};\n      display: flex;\n      flex-direction: ${isHori ? \"column\" : \"row\"};\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\n    `;\n        $thresholds.style.cssText = `${baseCSS(\"sticky\", 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;\n        if (!$existingDebug) {\n            $thresholds.style.cssText += `background:\n        ${lineCSS(\"#FFFF\")}${gradientOffset(half - 10)} / ${isHori ? \"100px 100px\" : \"100px 100px\"} ${repeat},\n        ${lineCSS(\"#FFF8\")}${gradientOffset(half - 10)} / ${isHori ? \"10px 10px\" : \"10px 10px\"} ${repeat};\n      `;\n        }\n        $triggers.style.cssText = `${baseCSS(\"relative\", 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;\n        if (!$existingDebug) {\n            $triggers.style.cssText += `background:\n        ${lineCSS(\"#FFFF\")}${gradientOffset(0)} / ${isHori ? \"100px 10px\" : \"10px 100px\"} ${repeat},\n        ${lineCSS(\"#FFF8\")}${gradientOffset(0)} / ${isHori ? \"10px 0px\" : \"0px 10px\"} ${repeat};\n      `;\n        }\n        const labels = [\n            \" enter: \",\n            \" leave: \"\n        ];\n        this.coords.forEach((v, i)=>{\n            const isView = i > 1;\n            const value = (isView ? 0 : this.offset) + v;\n            const isTail = i % 2;\n            const isFirst = value < labelSize;\n            const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n            const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n            const $label = doc.createElement(\"div\");\n            const $text = doc.createElement(\"div\");\n            const dirProp = isHori ? isFlip ? \"right\" : \"left\" : isFlip ? \"bottom\" : \"top\";\n            const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n            // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n            $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;\n            $label.style.cssText = `${baseCSS(\"absolute\", 0, 0, labelWidth, labelHeight)}\n        display: flex;\n        flex-direction: ${isHori ? \"column\" : \"row\"};\n        justify-content: flex-${isView ? \"start\" : \"end\"};\n        align-items: flex-${isFlip ? \"end\" : \"start\"};\n        border-${dirProp}: 2px ${isTail ? \"solid\" : \"solid\"} ${color};\n      `;\n            $text.style.cssText = `\n        overflow: hidden;\n        max-width: ${size / 2 - 10}px;\n        height: ${labelHeight};\n        margin-${isHori ? isFlip ? \"right\" : \"left\" : isFlip ? \"bottom\" : \"top\"}: -2px;\n        padding: 1px;\n        font-family: ui-monospace, monospace;\n        font-size: 10px;\n        letter-spacing: -.025em;\n        line-height: 9px;\n        font-weight: 600;\n        text-align: ${isHori && isFlip || !isHori && !isView ? \"right\" : \"left\"};\n        white-space: pre;\n        text-overflow: ellipsis;\n        color: ${isTail ? color : \"rgba(0,0,0,.75)\"};\n        background-color: ${isTail ? \"rgba(0,0,0,.65)\" : color};\n        border: 2px solid ${isTail ? color : \"transparent\"};\n        border-${isHori ? isFlip ? \"top-left\" : \"top-right\" : isFlip ? \"top-left\" : \"bottom-left\"}-radius: 5px;\n        border-${isHori ? isFlip ? \"bottom-left\" : \"bottom-right\" : isFlip ? \"top-right\" : \"bottom-right\"}-radius: 5px;\n      `;\n            $label.appendChild($text);\n            let position = value - flipOffset + (isHori ? 1 : 0);\n            $label.style[isHori ? \"left\" : \"top\"] = `${position}px`;\n            // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n            (isView ? $thresholds : $triggers).appendChild($label);\n        });\n        $debug.appendChild($thresholds);\n        $debug.appendChild($triggers);\n        container.element.appendChild($debug);\n        if (!$existingDebug) $debug.classList.add(\"animejs-onscroll-debug\");\n        this.$debug = $debug;\n        const containerPosition = getTargetValue(container.element, \"position\");\n        if (containerPosition === \"static\") {\n            this.debugStyles = setTargetValues(container.element, {\n                position: \"relative \"\n            });\n        }\n    }\n    updateBounds() {\n        if (this._debug) {\n            this.removeDebug();\n        }\n        let stickys;\n        const $target = this.target;\n        const container = this.container;\n        const isHori = this.horizontal;\n        const linked = this.linked;\n        let linkedTime;\n        let $el = $target;\n        let offsetX = 0;\n        let offsetY = 0;\n        /** @type {Element} */ let $offsetParent = $el;\n        if (linked) {\n            linkedTime = linked.currentTime;\n            linked.seek(0, true);\n        }\n        const isContainerStatic = getTargetValue(container.element, \"position\") === \"static\" ? setTargetValues(container.element, {\n            position: \"relative \"\n        }) : false;\n        while($el && $el !== container.element && $el !== doc.body){\n            const isSticky = getTargetValue($el, \"position\") === \"sticky\" ? setTargetValues($el, {\n                position: \"static\"\n            }) : false;\n            if ($el === $offsetParent) {\n                offsetX += $el.offsetLeft || 0;\n                offsetY += $el.offsetTop || 0;\n                $offsetParent = $el.offsetParent;\n            }\n            $el = /** @type {HTMLElement} */ $el.parentElement;\n            if (isSticky) {\n                if (!stickys) stickys = [];\n                stickys.push(isSticky);\n            }\n        }\n        if (isContainerStatic) isContainerStatic.revert();\n        const offset = isHori ? offsetX : offsetY;\n        const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n        const containerSize = isHori ? container.width : container.height;\n        const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n        const maxScroll = scrollSize - containerSize;\n        const enter = this.enter;\n        const leave = this.leave;\n        /** @type {ScrollThresholdValue} */ let enterTarget = \"start\";\n        /** @type {ScrollThresholdValue} */ let leaveTarget = \"end\";\n        /** @type {ScrollThresholdValue} */ let enterContainer = \"end\";\n        /** @type {ScrollThresholdValue} */ let leaveContainer = \"start\";\n        if (isStr(enter)) {\n            const splitted = /** @type {String} */ enter.split(\" \");\n            enterContainer = splitted[0];\n            enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n        } else if (isObj(enter)) {\n            const e = /** @type {ScrollThresholdParam} */ enter;\n            if (!isUnd(e.container)) enterContainer = e.container;\n            if (!isUnd(e.target)) enterTarget = e.target;\n        } else if (isNum(enter)) {\n            enterContainer = /** @type {Number} */ enter;\n        }\n        if (isStr(leave)) {\n            const splitted = /** @type {String} */ leave.split(\" \");\n            leaveContainer = splitted[0];\n            leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n        } else if (isObj(leave)) {\n            const t = /** @type {ScrollThresholdParam} */ leave;\n            if (!isUnd(t.container)) leaveContainer = t.container;\n            if (!isUnd(t.target)) leaveTarget = t.target;\n        } else if (isNum(leave)) {\n            leaveContainer = /** @type {Number} */ leave;\n        }\n        const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n        const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n        const under = parsedEnterTarget + offset - containerSize;\n        const over = parsedLeaveTarget + offset - maxScroll;\n        const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n        const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n        const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n        const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n        const scrollDelta = offsetEnd - offsetStart;\n        this.offsets[0] = offsetX;\n        this.offsets[1] = offsetY;\n        this.offset = offset;\n        this.offsetStart = offsetStart;\n        this.offsetEnd = offsetEnd;\n        this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n        this.thresholds = [\n            enterTarget,\n            leaveTarget,\n            enterContainer,\n            leaveContainer\n        ];\n        this.coords = [\n            parsedEnterTarget,\n            parsedLeaveTarget,\n            parsedEnterContainer,\n            parsedLeaveContainer\n        ];\n        if (stickys) {\n            stickys.forEach((sticky)=>sticky.revert());\n        }\n        if (linked) {\n            linked.seek(linkedTime, true);\n        }\n        if (this._debug) {\n            this.debug();\n        }\n    }\n    handleScroll() {\n        const linked = this.linked;\n        const sync = this.sync;\n        const syncEase = this.syncEase;\n        const syncSmooth = this.syncSmooth;\n        const shouldSeek = linked && (syncEase || syncSmooth);\n        const isHori = this.horizontal;\n        const container = this.container;\n        const scroll = this.scroll;\n        const isBefore = scroll <= this.offsetStart;\n        const isAfter = scroll >= this.offsetEnd;\n        const isInView = !isBefore && !isAfter;\n        const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n        const forceEnter = !this.hasEntered && isOnTheEdge;\n        const $debug = this._debug && this.$debug;\n        let hasUpdated = false;\n        let syncCompleted = false;\n        let p = this.progress;\n        if (isBefore && this.began) {\n            this.began = false;\n        }\n        if (p > 0 && !this.began) {\n            this.began = true;\n        }\n        if (shouldSeek) {\n            const lp = linked.progress;\n            if (syncSmooth && isNum(syncSmooth)) {\n                if (/** @type {Number} */ syncSmooth < 1) {\n                    const step = 0.0001;\n                    const snap = lp < p && p === 1 ? step : lp > p && !p ? -1e-4 : 0;\n                    p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */ syncSmooth), false) + snap, 6);\n                }\n            } else if (syncEase) {\n                p = syncEase(p);\n            }\n            hasUpdated = p !== this.prevProgress;\n            syncCompleted = lp === 1;\n            if (hasUpdated && !syncCompleted && syncSmooth && lp) {\n                container.wakeTicker.restart();\n            }\n        }\n        if ($debug) {\n            const sticky = isHori ? container.scrollY : container.scrollX;\n            $debug.style[isHori ? \"top\" : \"left\"] = sticky + 10 + \"px\";\n        }\n        // Trigger enter callbacks if already in view or when entering the view\n        if (isInView && !this.isInView || forceEnter && !this.forceEnter && !this.hasEntered) {\n            if (isInView) this.isInView = true;\n            if (!this.forceEnter || !this.hasEntered) {\n                if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;\n                this.onSyncEnter(this);\n                this.onEnter(this);\n                if (this.backward) {\n                    this.onSyncEnterBackward(this);\n                    this.onEnterBackward(this);\n                } else {\n                    this.onSyncEnterForward(this);\n                    this.onEnterForward(this);\n                }\n                this.hasEntered = true;\n                if (forceEnter) this.forceEnter = true;\n            } else if (isInView) {\n                this.forceEnter = false;\n            }\n        }\n        if (isInView || !isInView && this.isInView) {\n            hasUpdated = true;\n        }\n        if (hasUpdated) {\n            if (shouldSeek) linked.seek(linked.duration * p);\n            this.onUpdate(this);\n        }\n        if (!isInView && this.isInView) {\n            this.isInView = false;\n            this.onSyncLeave(this);\n            this.onLeave(this);\n            if (this.backward) {\n                this.onSyncLeaveBackward(this);\n                this.onLeaveBackward(this);\n            } else {\n                this.onSyncLeaveForward(this);\n                this.onLeaveForward(this);\n            }\n            if (sync && !syncSmooth) {\n                syncCompleted = true;\n            }\n        }\n        if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n            if (sync) {\n                this.onSyncComplete(this);\n            }\n            this.completed = true;\n            if (!this.repeat && !linked || !this.repeat && linked && linked.completed) {\n                this.revert();\n            }\n        }\n        if (p < 1 && this.completed) {\n            this.completed = false;\n        }\n        this.prevProgress = p;\n    }\n    revert() {\n        if (this.reverted) return;\n        const container = this.container;\n        removeChild(container, this);\n        if (!container._head) {\n            container.revert();\n        }\n        if (this._debug) {\n            this.removeDebug();\n        }\n        this.reverted = true;\n        return this;\n    }\n}\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */ const onScroll = (parameters = {})=>new ScrollObserver(parameters);\n/**\n * @typedef  {Object} StaggerParameters\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */ /**\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {Number|String}\n */ /**\n * @param  {Number|String|[Number|String,Number|String]} val\n * @param  {StaggerParameters} params\n * @return {StaggerFunction}\n */ const stagger = (val, params = {})=>{\n    let values = [];\n    let maxValue = 0;\n    const from = params.from;\n    const reversed = params.reversed;\n    const ease = params.ease;\n    const hasEasing = !isUnd(ease);\n    const hasSpring = hasEasing && !isUnd(/** @type {Spring} */ ease.ease);\n    const staggerEase = hasSpring ? /** @type {Spring} */ ease.ease : hasEasing ? parseEasings(ease) : null;\n    const grid = params.grid;\n    const axis = params.axis;\n    const fromFirst = isUnd(from) || from === 0 || from === \"first\";\n    const fromCenter = from === \"center\";\n    const fromLast = from === \"last\";\n    const isRange = isArr(val);\n    const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n    const val2 = isRange ? parseNumber(val[1]) : 0;\n    const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n    const start = params.start || 0 + (isRange ? val1 : 0);\n    let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n    return (_, i, t, tl)=>{\n        if (fromCenter) fromIndex = (t - 1) / 2;\n        if (fromLast) fromIndex = t - 1;\n        if (!values.length) {\n            for(let index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(abs(fromIndex - index));\n                } else {\n                    const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    const toX = index % grid[0];\n                    const toY = floor(index / grid[0]);\n                    const distanceX = fromX - toX;\n                    const distanceY = fromY - toY;\n                    let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") value = -distanceX;\n                    if (axis === \"y\") value = -distanceY;\n                    values.push(value);\n                }\n                maxValue = max(...values);\n            }\n            if (staggerEase) values = values.map((val)=>staggerEase(val / maxValue) * maxValue);\n            if (reversed) values = values.map((val)=>axis ? val < 0 ? val * -1 : -val : abs(maxValue - val));\n        }\n        const spacing = isRange ? (val2 - val1) / maxValue : val1;\n        const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */ start;\n        /** @type {String|Number} */ let output = offset + (spacing * round(values[i], 2) || 0);\n        if (params.modifier) output = params.modifier(output);\n        if (unitMatch) output = `${output}${unitMatch[2]}`;\n        return output;\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBRUQsK0NBQStDLEdBQy9DLHlDQUF5QyxHQUN6QywyREFBMkQsR0FDM0QsNkVBQTZFLEdBRTdFOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQsa0VBQWtFO0FBQ2xFLDhFQUE4RTtBQUM5RSxvRkFBb0YsR0FFcEYsZ0RBQWdELEdBQ2hELDRDQUE0QyxHQUM1Qyx5Q0FBeUMsR0FDekMscURBQXFELEdBQ3JELDJEQUEyRCxHQUMzRCwyRUFBMkUsR0FDM0UsaURBQWlELEdBQ2pELHdEQUF3RCxHQUN4RCwrQ0FBK0MsR0FDL0Msa0VBQWtFLEdBQ2xFLDJDQUEyQyxHQUUzQzs7Ozs7O0NBTUMsR0FFRDs7OztDQUlDLEdBRUQsMkRBQTJELEdBRTNEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0NDLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FFRCw0RUFBNEUsR0FDNUUsa0VBQWtFLEdBQ2xFLGtFQUFrRSxHQUNsRSwrREFBK0QsR0FFL0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQ7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOztDQUVDLEdBRUQ7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7OztDQUdDLEdBRUQ7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7Ozs7Q0FJQyxH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QixJQUFJaGIsU0FBUyxLQUFLdGlCLFFBQVEsQ0FBQ3c5QjtvQkFDM0IzeUIsT0FBTy9WLElBQUksQ0FBQ2tMO2dCQUNkO2dCQUNBMU8sV0FBV2lHLE9BQU9zVDtZQUNwQjtZQUNBLElBQUlzK0IsYUFBYXQrQixTQUFTQSxPQUFPVyxHQUFHLENBQUN5OUIsQ0FBQUEsTUFBT0UsWUFBWUYsTUFBTTMzQyxZQUFZQTtZQUMxRSxJQUFJOEIsVUFBVXlYLFNBQVNBLE9BQU9XLEdBQUcsQ0FBQ3k5QixDQUFBQSxNQUFPM21CLE9BQU8sTUFBTyxJQUFLMm1CLE1BQU0sQ0FBQyxJQUFJLENBQUNBLE1BQU0veEMsSUFBSTVGLFdBQVcyM0M7UUFDL0Y7UUFDQSxNQUFNL3hCLFVBQVVzeUIsVUFBVSxDQUFDRSxPQUFPRCxJQUFHLElBQUtuNEMsV0FBV200QztRQUNyRCxNQUFNM3NCLFNBQVMzYSxLQUFLK21CLHNCQUFzQi9tQixJQUFJbk0sTUFBTTBuQixPQUFPcGxCLEtBQUssSUFBSTZKLEdBQUdsRyxpQkFBaUIsR0FBRzNELFNBQVMsbUJBQW1CLEdBQUdBO1FBQzFILDBCQUEwQixHQUMxQixJQUFJMHhDLFNBQVNsdEIsU0FBVSxXQUFXbmxCLE1BQU1rVCxNQUFNLENBQUNqSCxFQUFFLEVBQUUsTUFBTztRQUMxRCxJQUFJOFosT0FBTzlwQixRQUFRLEVBQUVvMkMsU0FBU3RzQixPQUFPOXBCLFFBQVEsQ0FBQ28yQztRQUM5QyxJQUFJdDZCLFdBQVdzNkIsU0FBUyxDQUFDLEVBQUVBLE9BQU8sRUFBRXQ2QixTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbEQsT0FBT3M2QjtJQUNUO0FBQ0Y7QUFFeVIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdWJjbGVhci13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmVzbS5qcz9iODVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYW5pbWUuanMgLSBFU01cbiAqIEB2ZXJzaW9uIHY0LjAuMlxuICogQGF1dGhvciBKdWxpYW4gR2FybmllclxuICogQGxpY2Vuc2UgTUlUXG4gKiBAY29weXJpZ2h0IChjKSAyMDI1IEp1bGlhbiBHYXJuaWVyXG4gKiBAc2VlIGh0dHBzOi8vYW5pbWVqcy5jb21cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzUGFyYW1zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7UGVyY2VudGFnZUtleWZyYW1lc3xEdXJhdGlvbktleWZyYW1lc30gW2tleWZyYW1lc11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3BsYXliYWNrUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZnJhbWVSYXRlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8Qm9vbGVhbn0gW2xvb3BdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxTY3JvbGxPYnNlcnZlcn0gW2F1dG9wbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb25WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb25WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7J25vbmUnfCdyZXBsYWNlJ3wnYmxlbmQnfGNvbXBvc2l0aW9uVHlwZXN9IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7KHY6IGFueSkgPT4gYW55fSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25CZWZvcmVVcGRhdGVdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvblVwZGF0ZV1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uUGF1c2VdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkNvbXBsZXRlXVxuICogQHByb3BlcnR5IHsocmVuZGVyYWJsZTogUmVuZGVyYWJsZSkgPT4gdm9pZH0gW29uUmVuZGVyXVxuICovXG5cbi8qKiBAdHlwZWRlZiB7SlNBbmltYXRpb258VGltZWxpbmV9IFJlbmRlcmFibGUgKi9cbi8qKiBAdHlwZWRlZiB7VGltZXJ8UmVuZGVyYWJsZX0gVGlja2FibGUgKi9cbi8qKiBAdHlwZWRlZiB7VGltZXImSlNBbmltYXRpb24mVGltZWxpbmV9IENhbGxiYWNrQXJndW1lbnQgKi9cbi8qKiBAdHlwZWRlZiB7QW5pbWF0YWJsZXxUaWNrYWJsZXxEcmFnZ2FibGV8U2Nyb2xsT2JzZXJ2ZXJ8U2NvcGV9IFJldmVydGlibGUgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmFnZ2FibGVBeGlzUGFyYW1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbWFwVG9dXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtzbmFwXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRHJhZ2dhYmxlQ3Vyc29yUGFyYW1zXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29uSG92ZXJdXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29uR3JhYl1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYWdnYWJsZVBhcmFtc1xuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3Rvcn0gW3RyaWdnZXJdXG4gKiBAcHJvcGVydHkge0RPTVRhcmdldFNlbGVjdG9yfEFycmF5PE51bWJlcj58KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gRE9NVGFyZ2V0U2VsZWN0b3J8QXJyYXk8TnVtYmVyPil9IFtjb250YWluZXJdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQXhpc1BhcmFtfSBbeF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxEcmFnZ2FibGVBeGlzUGFyYW19IFt5XVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge051bWJlcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcnxBcnJheTxOdW1iZXI+KX0gW3NuYXBdXG4gKiBAcHJvcGVydHkge051bWJlcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcnxBcnJheTxOdW1iZXI+KX0gW2NvbnRhaW5lclBhZGRpbmddXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbY29udGFpbmVyRnJpY3Rpb25dXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbcmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW2RyYWdTcGVlZF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtzY3JvbGxTcGVlZF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtzY3JvbGxUaHJlc2hvbGRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbbWluVmVsb2NpdHldXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbbWF4VmVsb2NpdHldXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbdmVsb2NpdHlNdWx0aXBsaWVyXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyZWxlYXNlTWFzc11cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZVN0aWZmbmVzc11cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZURhbXBpbmddXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZWxlYXNlRGFtcGluZ11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtyZWxlYXNlRWFzZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gQm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXMpfSBbY3Vyc29yXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25HcmFiXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25EcmFnXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25SZWxlYXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblNldHRsZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uU25hcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uUmVzaXplXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25BZnRlclJlc2l6ZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTVkdHZW9tZXRyeUVsZW1lbnQgJiB7XG4gKiAgIHNldEF0dHJpYnV0ZShuYW1lOiAnZHJhdycsIHZhbHVlOiBgJHtudW1iZXJ9ICR7bnVtYmVyfWApOiB2b2lkO1xuICogICBkcmF3OiBgJHtudW1iZXJ9ICR7bnVtYmVyfWA7XG4gKiB9fSBEcmF3YWJsZVNWR0dlb21ldHJ5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWFzaW5nRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KCdsaW5lYXInfCdsaW5lYXIoeDEsIHgyIDI1JSwgeDMpJ3wnaW4nfCdvdXQnfCdpbk91dCd8J2luUXVhZCd8J291dFF1YWQnfCdpbk91dFF1YWQnfCdpbkN1YmljJ3wnb3V0Q3ViaWMnfCdpbk91dEN1YmljJ3wnaW5RdWFydCd8J291dFF1YXJ0J3wnaW5PdXRRdWFydCd8J2luUXVpbnQnfCdvdXRRdWludCd8J2luT3V0UXVpbnQnfCdpblNpbmUnfCdvdXRTaW5lJ3wnaW5PdXRTaW5lJ3wnaW5DaXJjJ3wnb3V0Q2lyYyd8J2luT3V0Q2lyYyd8J2luRXhwbyd8J291dEV4cG8nfCdpbk91dEV4cG8nfCdpbkJvdW5jZSd8J291dEJvdW5jZSd8J2luT3V0Qm91bmNlJ3wnaW5CYWNrJ3wnb3V0QmFjayd8J2luT3V0QmFjayd8J2luRWxhc3RpYyd8J291dEVsYXN0aWMnfCdpbk91dEVsYXN0aWMnfCdpcnJlZ3VsYXInfCdjdWJpY0Jlemllcid8J3N0ZXBzJ3wnaW4ocCA9IDEuNjc1KSd8J291dChwID0gMS42NzUpJ3wnaW5PdXQocCA9IDEuNjc1KSd8J2luQmFjayhvdmVyc2hvb3QgPSAxLjcwMTU4KSd8J291dEJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdpbk91dEJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdpbkVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnb3V0RWxhc3RpYyhhbXBsaXR1ZGUgPSAxLCBwZXJpb2QgPSAuMyknfCdpbk91dEVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnaXJyZWd1bGFyKGxlbmd0aCA9IDEwLCByYW5kb21uZXNzID0gMSknfCdjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5MiknfCdzdGVwcyhzdGVwcyA9IDEwKScpfSBFYXNlU3RyaW5nUGFyYW1OYW1lc1xuICovXG5cbi8vIEEgaGFjayB0byBnZXQgYm90aCBlYXNlIG5hbWVzIHN1Z2dlc3Rpb25zIEFORCBhbGxvdyBhbnkgc3RyaW5nc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yOTcyOSNpc3N1ZWNvbW1lbnQtNDYwMzQ2NDIxXG4vKiogQHR5cGVkZWYgeyhTdHJpbmcgJiB7fSl8RWFzZVN0cmluZ1BhcmFtTmFtZXN8RWFzaW5nRnVuY3Rpb258U3ByaW5nfSBFYXNpbmdQYXJhbSAqL1xuXG4vKiogQHR5cGVkZWYge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IERPTVRhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBhbnk+fSBKU1RhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtET01UYXJnZXR8SlNUYXJnZXR9IFRhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtUYXJnZXR8Tm9kZUxpc3R8U3RyaW5nfSBUYXJnZXRTZWxlY3RvciAqL1xuLyoqIEB0eXBlZGVmIHtET01UYXJnZXR8Tm9kZUxpc3R8U3RyaW5nfSBET01UYXJnZXRTZWxlY3RvciAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48RE9NVGFyZ2V0U2VsZWN0b3I+fERPTVRhcmdldFNlbGVjdG9yfSBET01UYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPERPTVRhcmdldD59IERPTVRhcmdldHNBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48SlNUYXJnZXQ+fEpTVGFyZ2V0fSBKU1RhcmdldHNQYXJhbSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48SlNUYXJnZXQ+fSBKU1RhcmdldHNBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48VGFyZ2V0U2VsZWN0b3I+fFRhcmdldFNlbGVjdG9yfSBUYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPFRhcmdldD59IFRhcmdldHNBcnJheSAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge1RhcmdldH0gdGFyZ2V0IC0gVGhlIGFuaW1hdGVkIHRhcmdldFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHRhcmdldCBpbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgYW5pbWF0ZWQgdGFyZ2V0c1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ3xUd2Vlbk9iamVjdFZhbHVlfEFycmF5LjxOdW1iZXJ8U3RyaW5nfFR3ZWVuT2JqZWN0VmFsdWU+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFR3ZWVuTW9kaWZpZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhbmltYXRlZCB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqL1xuXG4vKiogQHR5cGVkZWYge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSBDb2xvckFycmF5ICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBDYWxsYmFja1xuICogQHBhcmFtIHtUfSBzZWxmIC0gUmV0dXJucyBpdHNlbGZcbiAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBbZV1cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gVGlja2FibGVDYWxsYmFja3NcbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyYWJsZUNhbGxiYWNrc1xuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uUmVuZGVyXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHdlZW5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICogQHByb3BlcnR5IHtKU0FuaW1hdGlvbn0gcGFyZW50XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwcm9wZXJ0eSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfE51bWJlcn0gX3ZhbHVlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IF9mdW5jXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBfZWFzZVxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX2Zyb21OdW1iZXJzXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBfdG9OdW1iZXJzXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBfc3RyaW5nc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9mcm9tTnVtYmVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3RvTnVtYmVyXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBfbnVtYmVyc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9udW1iZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBfdW5pdFxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBfbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfY3VycmVudFRpbWVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZGVsYXlcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfdXBkYXRlRHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfc3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2NoYW5nZUR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2Fic29sdXRlU3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge3R3ZWVuVHlwZXN9IF90d2VlblR5cGVcbiAqIEBwcm9wZXJ0eSB7dmFsdWVUeXBlc30gX3ZhbHVlVHlwZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9jb21wb3NpdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9pc092ZXJsYXBwZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfaXNPdmVycmlkZGVuXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3JlbmRlclRyYW5zZm9ybXNcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9wcmV2UmVwXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfbmV4dFJlcFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX3ByZXZBZGRcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9uZXh0QWRkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfcHJldlxuICogQHByb3BlcnR5IHtUd2Vlbn0gX25leHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFR3ZWVuRGVjb21wb3NlZFZhbHVlXG4gKiBAcHJvcGVydHkge051bWJlcn0gdCAtIFR5cGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBuIC0gU2luZ2xlIG51bWJlciB2YWx1ZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHUgLSBWYWx1ZSB1bml0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gbyAtIFZhbHVlIG9wZXJhdG9yXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBkIC0gQXJyYXkgb2YgTnVtYmVycyAoaW4gY2FzZSBvZiBjb21wbGV4IHZhbHVlIHR5cGUpXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBzIC0gU3RyaW5ncyAoaW4gY2FzZSBvZiBjb21wbGV4IHZhbHVlIHR5cGUpXG4gKi9cblxuLyoqIEB0eXBlZGVmIHt7X2hlYWQ6IG51bGx8VHdlZW4sIF90YWlsOiBudWxsfFR3ZWVufX0gVHdlZW5Qcm9wZXJ0eVNpYmxpbmdzICovXG4vKiogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUHJvcGVydHlTaWJsaW5ncz59IFR3ZWVuTG9va3VwcyAqL1xuLyoqIEB0eXBlZGVmIHtXZWFrTWFwLjxUYXJnZXQsIFR3ZWVuTG9va3Vwcz59IFR3ZWVuUmVwbGFjZUxvb2t1cHMgKi9cbi8qKiBAdHlwZWRlZiB7TWFwLjxUYXJnZXQsIFR3ZWVuTG9va3Vwcz59IFR3ZWVuQWRkaXRpdmVMb29rdXBzICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICovXG5cbi8qKlxuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lcj59IFRpbWVyUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfFN0cmluZ3xGdW5jdGlvblZhbHVlfSBUd2VlblBhcmFtVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtVmFsdWV8W1R3ZWVuUGFyYW1WYWx1ZSwgVHdlZW5QYXJhbVZhbHVlXX0gVHdlZW5Qcm9wVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoU3RyaW5nICYge30pfCdub25lJ3wncmVwbGFjZSd8J2JsZW5kJ3xjb21wb3NpdGlvblR5cGVzfSBUd2VlbkNvbXBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUd2VlblBhcmFtc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHdlZW5WYWx1ZXNcbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Qcm9wVmFsdWV9IFt0b11cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Qcm9wVmFsdWV9IFtmcm9tVG9dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7VHdlZW5QYXJhbXNPcHRpb25zICYgVHdlZW5WYWx1ZXN9IFR3ZWVuS2V5VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheS48VHdlZW5LZXlWYWx1ZXxUd2VlblByb3BWYWx1ZT59IEFycmF5U3ludGF4VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtVmFsdWV8QXJyYXlTeW50YXhWYWx1ZXxUd2VlbktleVZhbHVlfSBUd2Vlbk9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtQYXJ0aWFsPHt0bzogVHdlZW5QYXJhbVZhbHVlfEFycmF5LjxUd2VlblBhcmFtVmFsdWU+OyBmcm9tOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47IGZyb21UbzogVHdlZW5QYXJhbVZhbHVlfEFycmF5LjxUd2VlblBhcmFtVmFsdWU+O30+fSBUd2Vlbk9iamVjdFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJjZW50YWdlS2V5ZnJhbWVPcHRpb25zXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblBhcmFtVmFsdWU+fSBQZXJjZW50YWdlS2V5ZnJhbWVQYXJhbXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBQZXJjZW50YWdlS2V5ZnJhbWVQYXJhbXMgJiBQZXJjZW50YWdlS2V5ZnJhbWVPcHRpb25zPn0gUGVyY2VudGFnZUtleWZyYW1lc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5PFJlY29yZDxTdHJpbmcsIFR3ZWVuT3B0aW9ucyB8IFR3ZWVuTW9kaWZpZXIgfCBib29sZWFuPiAmIFR3ZWVuUGFyYW1zT3B0aW9ucz59IER1cmF0aW9uS2V5ZnJhbWVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge1BlcmNlbnRhZ2VLZXlmcmFtZXN8RHVyYXRpb25LZXlmcmFtZXN9IFtrZXlmcmFtZXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcGxheWJhY2tFYXNlXVxuICovXG5cbi8vIFRPRE86IEN1cnJlbnRseSBzZXR0aW5nIFR3ZWVuTW9kaWZpZXIgdG8gdGhlIGludGVyc2VjdGVkIFJlY29yZDw+IG1ha2VzIHRoZSBGdW5jdGlvblZhbHVlIHR5cGUgdGFyZ2V0IHBhcmFtIGFueSBpZiBvbmx5IG9uZSBwYXJhbWV0ZXIgaXMgc2V0XG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2Vlbk9wdGlvbnMgfCBDYWxsYmFjazxKU0FuaW1hdGlvbj4gfCBUd2Vlbk1vZGlmaWVyIHwgYm9vbGVhbiB8IFBlcmNlbnRhZ2VLZXlmcmFtZXMgfCBEdXJhdGlvbktleWZyYW1lcyB8IFNjcm9sbE9ic2VydmVyPiAmIFRpbWVyT3B0aW9ucyAmIEFuaW1hdGlvbk9wdGlvbnMgJiBUd2VlblBhcmFtc09wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxKU0FuaW1hdGlvbj4gJiBSZW5kZXJhYmxlQ2FsbGJhY2tzPEpTQW5pbWF0aW9uPn0gQW5pbWF0aW9uUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lbGluZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RGVmYXVsdHNQYXJhbXN9IFtkZWZhdWx0c11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7VGltZXJPcHRpb25zICYgVGltZWxpbmVPcHRpb25zICYgVGlja2FibGVDYWxsYmFja3M8VGltZWxpbmU+ICYgUmVuZGVyYWJsZUNhbGxiYWNrczxUaW1lbGluZT59IFRpbWVsaW5lUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQW5pbWF0YWJsZVByb3BlcnR5U2V0dGVyXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59IHRvXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkdXJhdGlvbl1cbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEByZXR1cm4ge0FuaW1hdGFibGVPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQW5pbWF0YWJsZVByb3BlcnR5R2V0dGVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QW5pbWF0YWJsZVByb3BlcnR5U2V0dGVyICYgQW5pbWF0YWJsZVByb3BlcnR5R2V0dGVyfSBBbmltYXRhYmxlUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBbmltYXRhYmxlICYgUmVjb3JkPFN0cmluZywgQW5pbWF0YWJsZVByb3BlcnR5Pn0gQW5pbWF0YWJsZU9iamVjdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0YWJsZVByb3BlcnR5UGFyYW1zT3B0aW9uc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFt1bml0XVxuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge1R3ZWVuQ29tcG9zaXRpb259IFtjb21wb3NpdGlvbl1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblBhcmFtVmFsdWUgfCBFYXNpbmdQYXJhbSB8IFR3ZWVuTW9kaWZpZXIgfCBUd2VlbkNvbXBvc2l0aW9uIHwgQW5pbWF0YWJsZVByb3BlcnR5UGFyYW1zT3B0aW9ucz4gJiBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zfSBBbmltYXRhYmxlUGFyYW1zXG4gKi9cblxuXG4vLyBFbnZpcm9ubWVudHNcblxuLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGVjayBpZiB3ZSdyZSBydW5uaW5nIGluc2lkZSBhIHdvcmtlciA/XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyoqIEB0eXBlIHtPYmplY3R8TnVsbH0gKi9cbmNvbnN0IHdpbiA9IGlzQnJvd3NlciA/IHdpbmRvdyA6IG51bGw7XG5cbi8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG5jb25zdCBkb2MgPSBpc0Jyb3dzZXIgPyBkb2N1bWVudCA6IG51bGw7XG5cbi8vIEVudW1zXG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdHdlZW5UeXBlcyA9IHtcbiAgT0JKRUNUOiAwLFxuICBBVFRSSUJVVEU6IDEsXG4gIENTUzogMixcbiAgVFJBTlNGT1JNOiAzLFxuICBDU1NfVkFSOiA0LFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCB2YWx1ZVR5cGVzID0ge1xuICBOVU1CRVI6IDAsXG4gIFVOSVQ6IDEsXG4gIENPTE9SOiAyLFxuICBDT01QTEVYOiAzLFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCB0aWNrTW9kZXMgPSB7XG4gIE5PTkU6IDAsXG4gIEFVVE86IDEsXG4gIEZPUkNFOiAyLFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCBjb21wb3NpdGlvblR5cGVzID0ge1xuICByZXBsYWNlOiAwLFxuICBub25lOiAxLFxuICBibGVuZDogMixcbn07XG5cbi8vIENhY2hlIHN5bWJvbHNcblxuY29uc3QgaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBpc0RvbVN5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgaXNTdmdTeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IHRyYW5zZm9ybXNTeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IG1vcnBoUG9pbnRzU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBwcm94eVRhcmdldFN5bWJvbCA9IFN5bWJvbCgpO1xuXG4vLyBOdW1iZXJzXG5cbmNvbnN0IG1pblZhbHVlID0gMWUtMTE7XG5jb25zdCBtYXhWYWx1ZSA9IDFlMTI7XG5jb25zdCBLID0gMWUzO1xuY29uc3QgbWF4RnBzID0gMTIwO1xuXG4vLyBTdHJpbmdzXG5cbmNvbnN0IGVtcHR5U3RyaW5nID0gJyc7XG5jb25zdCBzaG9ydFRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG5cbnNob3J0VHJhbnNmb3Jtcy5zZXQoJ3gnLCAndHJhbnNsYXRlWCcpO1xuc2hvcnRUcmFuc2Zvcm1zLnNldCgneScsICd0cmFuc2xhdGVZJyk7XG5zaG9ydFRyYW5zZm9ybXMuc2V0KCd6JywgJ3RyYW5zbGF0ZVonKTtcblxuY29uc3QgdmFsaWRUcmFuc2Zvcm1zID0gW1xuICAndHJhbnNsYXRlWCcsXG4gICd0cmFuc2xhdGVZJyxcbiAgJ3RyYW5zbGF0ZVonLFxuICAncm90YXRlJyxcbiAgJ3JvdGF0ZVgnLFxuICAncm90YXRlWScsXG4gICdyb3RhdGVaJyxcbiAgJ3NjYWxlJyxcbiAgJ3NjYWxlWCcsXG4gICdzY2FsZVknLFxuICAnc2NhbGVaJyxcbiAgJ3NrZXcnLFxuICAnc2tld1gnLFxuICAnc2tld1knLFxuICAncGVyc3BlY3RpdmUnLFxuICAnbWF0cml4JyxcbiAgJ21hdHJpeDNkJyxcbl07XG5cbmNvbnN0IHRyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3MgPSB2YWxpZFRyYW5zZm9ybXMucmVkdWNlKChhLCB2KSA9PiAoey4uLmEsIFt2XTogdiArICcoJ30pLCB7fSk7XG5cbi8vIEZ1bmN0aW9uc1xuXG4vKiogQHJldHVybiB7dm9pZH0gKi9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gUmVnZXhcblxuY29uc3QgaGV4VGVzdFJneCA9IC8oXiMoW1xcZGEtZl17M30pezEsMn0kKXwoXiMoW1xcZGEtZl17NH0pezEsMn0kKS9pO1xuY29uc3QgcmdiRXhlY1JneCA9IC9yZ2JcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKS9pO1xuY29uc3QgcmdiYUV4ZWNSZ3ggPSAvcmdiYVxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccypcXCkvaTtcbmNvbnN0IGhzbEV4ZWNSZ3ggPSAvaHNsXFwoXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKyklXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKyklXFxzKlxcKS9pO1xuY29uc3QgaHNsYUV4ZWNSZ3ggPSAvaHNsYVxcKFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspXFxzKlxcKS9pO1xuLy8gZXhwb3J0IGNvbnN0IGRpZ2l0V2l0aEV4cG9uZW50Umd4ID0gL1stK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/L2c7XG5jb25zdCBkaWdpdFdpdGhFeHBvbmVudFJneCA9IC9bLStdP1xcZCpcXC4/XFxkKyg/OmVbLStdP1xcZCk/L2dpO1xuLy8gZXhwb3J0IGNvbnN0IHVuaXRzRXhlY1JneCA9IC9eKFstK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/KSsoW2Etel0rfCUpJC9pO1xuY29uc3QgdW5pdHNFeGVjUmd4ID0gL14oWy0rXT9cXGQqXFwuP1xcZCsoPzplWy0rXT9cXGQrKT8pKFthLXpdK3wlKSQvaTtcbmNvbnN0IGxvd2VyQ2FzZVJneCA9IC8oW2Etel0pKFtBLVpdKS9nO1xuY29uc3QgdHJhbnNmb3Jtc0V4ZWNSZ3ggPSAvKFxcdyspKFxcKFteKV0rXFwpKykvZzsgLy8gTWF0Y2ggaW5saW5lIHRyYW5zZm9ybXMgd2l0aCBjYWNsKCkgdmFsdWVzLCByZXR1cm5zIHRoZSB2YWx1ZSB3cmFwcGVkIGluICgpXG5jb25zdCByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3ggPSAvKFxcKj18XFwrPXwtPSkvO1xuXG5cblxuXG4vKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGlkOiBudWxsLFxuICBrZXlmcmFtZXM6IG51bGwsXG4gIHBsYXliYWNrRWFzZTogbnVsbCxcbiAgcGxheWJhY2tSYXRlOiAxLFxuICBmcmFtZVJhdGU6IG1heEZwcyxcbiAgbG9vcDogMCxcbiAgcmV2ZXJzZWQ6IGZhbHNlLFxuICBhbHRlcm5hdGU6IGZhbHNlLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgZHVyYXRpb246IEssXG4gIGRlbGF5OiAwLFxuICBsb29wRGVsYXk6IDAsXG4gIGVhc2U6ICdvdXQoMiknLFxuICBjb21wb3NpdGlvbjogY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlLFxuICBtb2RpZmllcjogdiA9PiB2LFxuICBvbkJlZ2luOiBub29wLFxuICBvbkJlZm9yZVVwZGF0ZTogbm9vcCxcbiAgb25VcGRhdGU6IG5vb3AsXG4gIG9uTG9vcDogbm9vcCxcbiAgb25QYXVzZTogbm9vcCxcbiAgb25Db21wbGV0ZTogbm9vcCxcbiAgb25SZW5kZXI6IG5vb3AsXG59O1xuXG5jb25zdCBnbG9iYWxzID0ge1xuICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICBkZWZhdWx0cyxcbiAgLyoqIEB0eXBlIHtEb2N1bWVudHxET01UYXJnZXR9ICovXG4gIHJvb3Q6IGRvYyxcbiAgLyoqIEB0eXBlIHtTY29wZX0gKi9cbiAgc2NvcGU6IG51bGwsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICBwcmVjaXNpb246IDQsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aW1lU2NhbGU6IDEsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aWNrVGhyZXNob2xkOiAyMDAsXG59O1xuXG5jb25zdCBnbG9iYWxWZXJzaW9ucyA9IHsgdmVyc2lvbjogJzQuMC4yJywgZW5naW5lOiBudWxsIH07XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgaWYgKCF3aW4uQW5pbWVKUykgd2luLkFuaW1lSlMgPSBbXTtcbiAgd2luLkFuaW1lSlMucHVzaChnbG9iYWxWZXJzaW9ucyk7XG59XG5cbi8vIFN0cmluZ3NcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCB0b0xvd2VyQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZShsb3dlckNhc2VSZ3gsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogUHJpb3JpdGl6ZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHJlZ2V4IHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN1YlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3Qgc3RyaW5nU3RhcnRzV2l0aCA9IChzdHIsIHN1YikgPT4gc3RyLmluZGV4T2Yoc3ViKSA9PT0gMDtcblxuLy8gVGltZVxuLy8gTm90ZTogRGF0ZS5ub3cgaXMgdXNlZCBpbnN0ZWFkIG9mIHBlcmZvcm1hbmNlLm5vdyBzaW5jZSBpdCBpcyBwcmVjaXNlIGVub3VnaCBmb3IgdGltaW5ncyBjYWxjdWxhdGlvbnMsIHBlcmZvcm1zIHNsaWdodGx5IGZhc3RlciBhbmQgd29ya3MgaW4gTm9kZS5qcyBlbnZpcm9uZW1lbnQuXG5jb25zdCBub3cgPSBEYXRlLm5vdztcblxuLy8gVHlwZXMgY2hlY2tlcnNcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBSZWNvcmQ8U3RyaW5nLCBhbnk+fSAqL1xuY29uc3QgaXNPYmogPSBhID0+IGEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBOdW1iZXJ9ICovXG5jb25zdCBpc051bSA9IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInICYmICFpc05hTihhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU3RyaW5nfSAqL1xuY29uc3QgaXNTdHIgPSBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJztcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgRnVuY3Rpb259ICovXG5jb25zdCBpc0ZuYyA9IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIHVuZGVmaW5lZH0gKi9cbmNvbnN0IGlzVW5kID0gYSA9PiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIG51bGwgfCB1bmRlZmluZWR9ICovXG5jb25zdCBpc05pbCA9IGEgPT4gaXNVbmQoYSkgfHwgYSA9PT0gbnVsbDtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU1ZHRWxlbWVudH0gKi9cbmNvbnN0IGlzU3ZnID0gYSA9PiBpc0Jyb3dzZXIgJiYgYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIZXggPSBhID0+IGhleFRlc3RSZ3gudGVzdChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc1JnYiA9IGEgPT4gc3RyaW5nU3RhcnRzV2l0aChhLCAncmdiJyk7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIc2wgPSBhID0+IHN0cmluZ1N0YXJ0c1dpdGgoYSwgJ2hzbCcpO1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7Qm9vbGVhbn0gKi9cbmNvbnN0IGlzQ29sID0gYSA9PiBpc0hleChhKSB8fCBpc1JnYihhKSB8fCBpc0hzbChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc0tleSA9IGEgPT4gIWdsb2JhbHMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoYSk7XG5cbi8vIE51bWJlclxuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZU51bWJlciA9IHN0ciA9PiBpc1N0cihzdHIpID9cbiAgcGFyc2VGbG9hdCgvKiogQHR5cGUge1N0cmluZ30gKi8oc3RyKSkgOlxuICAvKiogQHR5cGUge051bWJlcn0gKi8oc3RyKTtcblxuLy8gTWF0aFxuXG5jb25zdCBwb3cgPSBNYXRoLnBvdztcbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5jb25zdCBzaW4gPSBNYXRoLnNpbjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBleHAgPSBNYXRoLmV4cDtcbmNvbnN0IGNlaWwgPSBNYXRoLmNlaWw7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBhc2luID0gTWF0aC5hc2luO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBfcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wID0gKHYsIG1pbiwgbWF4KSA9PiB2IDwgbWluID8gbWluIDogdiA+IG1heCA/IG1heCA6IHY7XG5cbmNvbnN0IHBvd0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgcm91bmQgPSAodiwgZGVjaW1hbExlbmd0aCkgPT4ge1xuICBpZiAoZGVjaW1hbExlbmd0aCA8IDApIHJldHVybiB2O1xuICBpZiAoIWRlY2ltYWxMZW5ndGgpIHJldHVybiBfcm91bmQodik7XG4gIGxldCBwID0gcG93Q2FjaGVbZGVjaW1hbExlbmd0aF07XG4gIGlmICghcCkgcCA9IHBvd0NhY2hlW2RlY2ltYWxMZW5ndGhdID0gMTAgKiogZGVjaW1hbExlbmd0aDtcbiAgcmV0dXJuIF9yb3VuZCh2ICogcCkgLyBwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheTxOdW1iZXI+fSBpbmNyZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgc25hcCA9ICh2LCBpbmNyZW1lbnQpID0+IGlzQXJyKGluY3JlbWVudCkgPyBpbmNyZW1lbnQucmVkdWNlKChjbG9zZXN0LCBjdikgPT4gKGFicyhjdiAtIHYpIDwgYWJzKGNsb3Nlc3QgLSB2KSA/IGN2IDogY2xvc2VzdCkpIDogaW5jcmVtZW50ID8gX3JvdW5kKHYgLyBpbmNyZW1lbnQpICogaW5jcmVtZW50IDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBpbnRlcnBvbGF0ZSA9IChzdGFydCwgZW5kLCBwcm9ncmVzcykgPT4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcHJvZ3Jlc3M7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wSW5maW5pdHkgPSB2ID0+IHYgPT09IEluZmluaXR5ID8gbWF4VmFsdWUgOiB2ID09PSAtSW5maW5pdHkgPyAtMWUxMiA6IHY7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVRpbWUgPSB2ID0+IHYgPD0gbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGNsYW1wSW5maW5pdHkocm91bmQodiwgMTEpKTtcblxuLy8gQXJyYXlzXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VFtdfSBhXG4gKiBAcmV0dXJuIHtUW119XG4gKi9cbmNvbnN0IGNsb25lQXJyYXkgPSBhID0+IGlzQXJyKGEpID8gWyAuLi5hIF0gOiBhO1xuXG4vLyBPYmplY3RzXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBVXG4gKiBAcGFyYW0ge1R9IG8xXG4gKiBAcGFyYW0ge1V9IG8yXG4gKiBAcmV0dXJuIHtUICYgVX1cbiAqL1xuY29uc3QgbWVyZ2VPYmplY3RzID0gKG8xLCBvMikgPT4ge1xuICBjb25zdCBtZXJnZWQgPSAvKiogQHR5cGUge1QgJiBVfSAqLyh7IC4uLm8xIH0pO1xuICBmb3IgKGxldCBwIGluIG8yKSB7XG4gICAgY29uc3QgbzFwID0gLyoqIEB0eXBlIHtUICYgVX0gKi8obzEpW3BdO1xuICAgIG1lcmdlZFtwXSA9IGlzVW5kKG8xcCkgPyAvKiogQHR5cGUge1QgJiBVfSAqLyhvMilbcF0gOiBvMXA7XG4gIH0gIHJldHVybiBtZXJnZWQ7XG59O1xuXG4vLyBMaW5rZWQgbGlzdHNcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJzZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldlByb3BdXG4gKiBAcGFyYW0ge1N0cmluZ30gW25leHRQcm9wXVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaENoaWxkcmVuID0gKHBhcmVudCwgY2FsbGJhY2ssIHJldmVyc2UsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGxldCBuZXh0ID0gcGFyZW50Ll9oZWFkO1xuICBsZXQgYWRqdXN0ZWROZXh0UHJvcCA9IG5leHRQcm9wO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG5leHQgPSBwYXJlbnQuX3RhaWw7XG4gICAgYWRqdXN0ZWROZXh0UHJvcCA9IHByZXZQcm9wO1xuICB9XG4gIHdoaWxlIChuZXh0KSB7XG4gICAgY29uc3QgY3VycmVudE5leHQgPSBuZXh0W2FkanVzdGVkTmV4dFByb3BdO1xuICAgIGNhbGxiYWNrKG5leHQpO1xuICAgIG5leHQgPSBjdXJyZW50TmV4dDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtICB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtICB7U3RyaW5nfSBbcHJldlByb3BdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtuZXh0UHJvcF1cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHJlbW92ZUNoaWxkID0gKHBhcmVudCwgY2hpbGQsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGNvbnN0IHByZXYgPSBjaGlsZFtwcmV2UHJvcF07XG4gIGNvbnN0IG5leHQgPSBjaGlsZFtuZXh0UHJvcF07XG4gIHByZXYgPyBwcmV2W25leHRQcm9wXSA9IG5leHQgOiBwYXJlbnQuX2hlYWQgPSBuZXh0O1xuICBuZXh0ID8gbmV4dFtwcmV2UHJvcF0gPSBwcmV2IDogcGFyZW50Ll90YWlsID0gcHJldjtcbiAgY2hpbGRbcHJldlByb3BdID0gbnVsbDtcbiAgY2hpbGRbbmV4dFByb3BdID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSAge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbc29ydE1ldGhvZF1cbiAqIEBwYXJhbSAge1N0cmluZ30gcHJldlByb3BcbiAqIEBwYXJhbSAge1N0cmluZ30gbmV4dFByb3BcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IGFkZENoaWxkID0gKHBhcmVudCwgY2hpbGQsIHNvcnRNZXRob2QsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGxldCBwcmV2ID0gcGFyZW50Ll90YWlsO1xuICB3aGlsZSAocHJldiAmJiBzb3J0TWV0aG9kICYmIHNvcnRNZXRob2QocHJldiwgY2hpbGQpKSBwcmV2ID0gcHJldltwcmV2UHJvcF07XG4gIGNvbnN0IG5leHQgPSBwcmV2ID8gcHJldltuZXh0UHJvcF0gOiBwYXJlbnQuX2hlYWQ7XG4gIHByZXYgPyBwcmV2W25leHRQcm9wXSA9IGNoaWxkIDogcGFyZW50Ll9oZWFkID0gY2hpbGQ7XG4gIG5leHQgPyBuZXh0W3ByZXZQcm9wXSA9IGNoaWxkIDogcGFyZW50Ll90YWlsID0gY2hpbGQ7XG4gIGNoaWxkW3ByZXZQcm9wXSA9IHByZXY7XG4gIGNoaWxkW25leHRQcm9wXSA9IG5leHQ7XG59O1xuXG4vKlxuICogQmFzZSBjbGFzcyB0byBjb250cm9sIGZyYW1lcmF0ZSBhbmQgcGxheWJhY2sgcmF0ZS5cbiAqIEluaGVyaXRlZCBieSBFbmdpbmUsIFRpbWVyLCBBbmltYXRpb24gYW5kIFRpbWVsaW5lLlxuICovXG5jbGFzcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lID0gMCkge1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fbGFzdFRpbWUgPSBpbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcmFtZUR1cmF0aW9uID0gcm91bmQoSyAvIG1heEZwcywgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZnBzID0gbWF4RnBzO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3NwZWVkID0gMTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFR3ZWVufSAqL1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7VGlja2FibGV8VHdlZW59ICovXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICBnZXQgZnBzKCkge1xuICAgIHJldHVybiB0aGlzLl9mcHM7XG4gIH1cblxuICBzZXQgZnBzKGZyYW1lUmF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzRnJhbWVEdXJhdGlvbiA9IHRoaXMuX2ZyYW1lRHVyYXRpb247XG4gICAgY29uc3QgZnIgPSArZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZwcyA9IGZyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGZyO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSByb3VuZChLIC8gZnBzLCAwKTtcbiAgICB0aGlzLl9mcHMgPSBmcHM7XG4gICAgdGhpcy5fZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5fc2NoZWR1bGVkVGltZSArPSBmcmFtZUR1cmF0aW9uIC0gcHJldmlvdXNGcmFtZUR1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZDtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBjb25zdCBwYnIgPSArcGxheWJhY2tSYXRlO1xuICAgIHRoaXMuX3NwZWVkID0gcGJyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IHBicjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybiB7dGlja01vZGVzfVxuICAgKi9cbiAgcmVxdWVzdFRpY2sodGltZSkge1xuICAgIGNvbnN0IHNjaGVkdWxlZFRpbWUgPSB0aGlzLl9zY2hlZHVsZWRUaW1lO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gdGhpcy5fZWxhcHNlZFRpbWU7XG4gICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gKHRpbWUgLSBlbGFwc2VkVGltZSk7XG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgdGltZSBpcyBsb3dlciB0aGFuIHRoZSBzY2hlZHVsZWQgdGltZVxuICAgIC8vIHRoaXMgbWVhbnMgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgdG8gaGl0IG9uZSBmcmFtZUR1cmF0aW9uXG4gICAgLy8gc28gc2tpcCB0aGF0IGZyYW1lXG4gICAgaWYgKGVsYXBzZWRUaW1lIDwgc2NoZWR1bGVkVGltZSkgcmV0dXJuIHRpY2tNb2Rlcy5OT05FO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSB0aGlzLl9mcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IGZyYW1lRGVsdGEgPSBlbGFwc2VkVGltZSAtIHNjaGVkdWxlZFRpbWU7XG4gICAgLy8gRW5zdXJlcyB0aGF0IF9zY2hlZHVsZWRUaW1lIHByb2dyZXNzZXMgaW4gc3RlcHMgb2YgYXQgbGVhc3QgMSBmcmFtZUR1cmF0aW9uLlxuICAgIC8vIFNraXBzIGFoZWFkIGlmIHRoZSBhY3R1YWwgZWxhcHNlZCB0aW1lIGlzIGhpZ2hlci5cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lICs9IGZyYW1lRGVsdGEgPCBmcmFtZUR1cmF0aW9uID8gZnJhbWVEdXJhdGlvbiA6IGZyYW1lRGVsdGE7XG4gICAgcmV0dXJuIHRpY2tNb2Rlcy5BVVRPO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb21wdXRlRGVsdGFUaW1lKHRpbWUpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWUgLSB0aGlzLl9sYXN0VGltZTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IGRlbHRhO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZTtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cblxufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge3RpY2tNb2Rlc30gdGlja01vZGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmVuZGVyID0gKHRpY2thYmxlLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGUpID0+IHtcblxuICBjb25zdCBwYXJlbnQgPSB0aWNrYWJsZS5wYXJlbnQ7XG4gIGNvbnN0IGR1cmF0aW9uID0gdGlja2FibGUuZHVyYXRpb247XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHRpY2thYmxlLmNvbXBsZXRlZDtcbiAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aWNrYWJsZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgY29uc3QgaXRlcmF0aW9uQ291bnQgPSB0aWNrYWJsZS5pdGVyYXRpb25Db3VudDtcbiAgY29uc3QgX2N1cnJlbnRJdGVyYXRpb24gPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbjtcbiAgY29uc3QgX2xvb3BEZWxheSA9IHRpY2thYmxlLl9sb29wRGVsYXk7XG4gIGNvbnN0IF9yZXZlcnNlZCA9IHRpY2thYmxlLl9yZXZlcnNlZDtcbiAgY29uc3QgX2FsdGVybmF0ZSA9IHRpY2thYmxlLl9hbHRlcm5hdGU7XG4gIGNvbnN0IF9oYXNDaGlsZHJlbiA9IHRpY2thYmxlLl9oYXNDaGlsZHJlbjtcbiAgY29uc3QgdGlja2FibGVEZWxheSA9IHRpY2thYmxlLl9kZWxheTtcbiAgY29uc3QgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lID0gdGlja2FibGUuX2N1cnJlbnRUaW1lOyAvLyBUT0RPOiByZW5hbWUgLl9jdXJyZW50VGltZSB0byAuX2Fic29sdXRlQ3VycmVudFRpbWVcblxuICBjb25zdCB0aWNrYWJsZUVuZFRpbWUgPSB0aWNrYWJsZURlbGF5ICsgaXRlcmF0aW9uRHVyYXRpb247XG4gIGNvbnN0IHRpY2thYmxlQWJzb2x1dGVUaW1lID0gdGltZSAtIHRpY2thYmxlRGVsYXk7XG4gIGNvbnN0IHRpY2thYmxlUHJldlRpbWUgPSBjbGFtcCh0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWUsIC10aWNrYWJsZURlbGF5LCBkdXJhdGlvbik7XG4gIGNvbnN0IHRpY2thYmxlQ3VycmVudFRpbWUgPSBjbGFtcCh0aWNrYWJsZUFic29sdXRlVGltZSwgLXRpY2thYmxlRGVsYXksIGR1cmF0aW9uKTtcbiAgY29uc3QgZGVsdGFUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWUgLSB0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWU7XG4gIGNvbnN0IGlzQ3VycmVudFRpbWVBYm92ZVplcm8gPSB0aWNrYWJsZUN1cnJlbnRUaW1lID4gMDtcbiAgY29uc3QgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID0gdGlja2FibGVDdXJyZW50VGltZSA+PSBkdXJhdGlvbjtcbiAgY29uc3QgaXNTZXR0ZXIgPSBkdXJhdGlvbiA8PSBtaW5WYWx1ZTtcbiAgY29uc3QgZm9yY2VkVGljayA9IHRpY2tNb2RlID09PSB0aWNrTW9kZXMuRk9SQ0U7XG5cbiAgbGV0IGlzT2RkID0gMDtcbiAgbGV0IGl0ZXJhdGlvbkVsYXBzZWRUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWU7XG4gIC8vIFJlbmRlciBjaGVja3NcbiAgLy8gVXNlZCB0byBhbHNvIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIHJlbmRlcmVkIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIG9uUmVuZGVyIGNhbGxiYWNrIG9uIHRoZSBwYXJlbnQgdGltZXJcbiAgbGV0IGhhc1JlbmRlcmVkID0gMDtcblxuICAvLyBFeGVjdXRlIHRoZSBcImV4cGVuc2l2ZVwiIGl0ZXJhdGlvbnMgY2FsY3VsYXRpb25zIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMSkge1xuICAgIC8vIGJpdHdpc2UgTk9UIG9wZXJhdG9yIHNlZW1zIHRvIGJlIGdlbmVyYWxseSBmYXN0ZXIgdGhhbiBNYXRoLmZsb29yKCkgYWNyb3NzIGJyb3dzZXJzXG4gICAgY29uc3QgY3VycmVudEl0ZXJhdGlvbiA9IH5+KHRpY2thYmxlQ3VycmVudFRpbWUgLyAoaXRlcmF0aW9uRHVyYXRpb24gKyAoaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gMCA6IF9sb29wRGVsYXkpKSk7XG4gICAgdGlja2FibGUuX2N1cnJlbnRJdGVyYXRpb24gPSBjbGFtcChjdXJyZW50SXRlcmF0aW9uLCAwLCBpdGVyYXRpb25Db3VudCk7XG4gICAgLy8gUHJldmVudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIGdvIGFib3ZlIHRoZSBtYXggaXRlcmF0aW9ucyB3aGVuIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxuICAgIGlmIChpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uLS07XG4gICAgaXNPZGQgPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbiAlIDI7XG4gICAgaXRlcmF0aW9uRWxhcHNlZFRpbWUgPSB0aWNrYWJsZUN1cnJlbnRUaW1lICUgKGl0ZXJhdGlvbkR1cmF0aW9uICsgX2xvb3BEZWxheSkgfHwgMDtcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiBleGFjdGx5IG9uZSBvZiBfcmV2ZXJzZWQgYW5kIChfYWx0ZXJuYXRlICYmIGlzT2RkKSBpcyB0cnVlXG4gIGNvbnN0IGlzUmV2ZXJzZWQgPSBfcmV2ZXJzZWQgXiAoX2FsdGVybmF0ZSAmJiBpc09kZCk7XG4gIGNvbnN0IF9lYXNlID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqLyh0aWNrYWJsZSkuX2Vhc2U7XG4gIGxldCBpdGVyYXRpb25UaW1lID0gaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gaXNSZXZlcnNlZCA/IDAgOiBkdXJhdGlvbiA6IGlzUmV2ZXJzZWQgPyBpdGVyYXRpb25EdXJhdGlvbiAtIGl0ZXJhdGlvbkVsYXBzZWRUaW1lIDogaXRlcmF0aW9uRWxhcHNlZFRpbWU7XG4gIGlmIChfZWFzZSkgaXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvbkR1cmF0aW9uICogX2Vhc2UoaXRlcmF0aW9uVGltZSAvIGl0ZXJhdGlvbkR1cmF0aW9uKSB8fCAwO1xuICBjb25zdCBpc1J1bm5pbmdCYWNrd2FyZHMgPSAocGFyZW50ID8gcGFyZW50LmJhY2t3YXJkcyA6IHRpY2thYmxlQWJzb2x1dGVUaW1lIDwgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lKSA/ICFpc1JldmVyc2VkIDogISFpc1JldmVyc2VkO1xuXG4gIHRpY2thYmxlLl9jdXJyZW50VGltZSA9IHRpY2thYmxlQWJzb2x1dGVUaW1lO1xuICB0aWNrYWJsZS5faXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvblRpbWU7XG4gIHRpY2thYmxlLmJhY2t3YXJkcyA9IGlzUnVubmluZ0JhY2t3YXJkcztcblxuICBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiAhdGlja2FibGUuYmVnYW4pIHtcbiAgICB0aWNrYWJsZS5iZWdhbiA9IHRydWU7XG4gICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICB0aWNrYWJsZS5vbkJlZ2luKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGlja2FibGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gMCkge1xuICAgIHRpY2thYmxlLmJlZ2FuID0gZmFsc2U7XG4gIH1cblxuICAvLyBPbmx5IHRyaWdnZXJzIG9uTG9vcCBmb3IgdGlja2FibGUgd2l0aG91dCBjaGlsZHJlbiwgb3RoZXJ3aXNlIGNhbGwgdGhlIHRoZSBvbkxvb3AgY2FsbGJhY2sgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgLy8gTWFrZSBzdXJlIHRvIHRyaWdnZXIgdGhlIG9uTG9vcCBiZWZvcmUgcmVuZGVyaW5nIHRvIGFsbG93IC5yZWZyZXNoKCkgdG8gcGlja3VwIHRoZSBjdXJyZW50IHZhbHVlc1xuICBpZiAoIW11dGVDYWxsYmFja3MgJiYgIV9oYXNDaGlsZHJlbiAmJiBpc0N1cnJlbnRUaW1lQWJvdmVaZXJvICYmIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uICE9PSBfY3VycmVudEl0ZXJhdGlvbikge1xuICAgIHRpY2thYmxlLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gIH1cblxuICBpZiAoXG4gICAgZm9yY2VkVGljayB8fFxuICAgIHRpY2tNb2RlID09PSB0aWNrTW9kZXMuQVVUTyAmJiAoXG4gICAgICB0aW1lID49IHRpY2thYmxlRGVsYXkgJiYgdGltZSA8PSB0aWNrYWJsZUVuZFRpbWUgfHwgLy8gTm9ybWFsIHJlbmRlclxuICAgICAgdGltZSA8PSB0aWNrYWJsZURlbGF5ICYmIHRpY2thYmxlUHJldlRpbWUgPiB0aWNrYWJsZURlbGF5IHx8IC8vIFBsYXloZWFkIGlzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0IHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGluaXRpYWwgc3RhdGVcbiAgICAgIHRpbWUgPj0gdGlja2FibGVFbmRUaW1lICYmIHRpY2thYmxlUHJldlRpbWUgIT09IGR1cmF0aW9uIC8vIFBsYXloZWFkIGlzIGFmdGVyIHRoZSBhbmltYXRpb24gZW5kIHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGVuZCBzdGF0ZVxuICAgICkgfHxcbiAgICBpdGVyYXRpb25UaW1lID49IHRpY2thYmxlRW5kVGltZSAmJiB0aWNrYWJsZVByZXZUaW1lICE9PSBkdXJhdGlvbiB8fFxuICAgIGl0ZXJhdGlvblRpbWUgPD0gdGlja2FibGVEZWxheSAmJiB0aWNrYWJsZVByZXZUaW1lID4gMCB8fFxuICAgIHRpbWUgPD0gdGlja2FibGVQcmV2VGltZSAmJiB0aWNrYWJsZVByZXZUaW1lID09PSBkdXJhdGlvbiAmJiBjb21wbGV0ZWQgfHwgLy8gRm9yY2UgYSByZW5kZXIgaWYgYSBzZWVrIG9jY3VycyBvbiBhbiBjb21wbGV0ZWQgYW5pbWF0aW9uXG4gICAgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uICYmICFjb21wbGV0ZWQgJiYgaXNTZXR0ZXIgLy8gVGhpcyBwcmV2ZW50cyAwIGR1cmF0aW9uIHRpY2thYmxlcyB0byBiZSBza2lwcGVkXG4gICkge1xuXG4gICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIHtcbiAgICAgIC8vIFRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYmVmb3JlIHJlbmRlcmluZ1xuICAgICAgdGlja2FibGUuY29tcHV0ZURlbHRhVGltZSh0aWNrYWJsZVByZXZUaW1lKTtcbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykgdGlja2FibGUub25CZWZvcmVVcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHR3ZWVucyByZW5kZXJpbmdcbiAgICBpZiAoIV9oYXNDaGlsZHJlbikge1xuXG4gICAgICAvLyBUaW1lIGhhcyBqdW1wZWQgbW9yZSB0aGFuIGdsb2JhbHMudGlja1RocmVzaG9sZCBzbyBjb25zaWRlciB0aGlzIHRpY2sgbWFudWFsXG4gICAgICBjb25zdCBmb3JjZWRSZW5kZXIgPSBmb3JjZWRUaWNrIHx8IChpc1J1bm5pbmdCYWNrd2FyZHMgPyBkZWx0YVRpbWUgKiAtMSA6IGRlbHRhVGltZSkgPj0gZ2xvYmFscy50aWNrVGhyZXNob2xkO1xuICAgICAgY29uc3QgYWJzb2x1dGVUaW1lID0gdGlja2FibGUuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApICsgdGlja2FibGVEZWxheSArIGl0ZXJhdGlvblRpbWU7XG5cbiAgICAgIC8vIE9ubHkgQW5pbWF0aW9uIGNhbiBoYXZlIHR3ZWVucywgVGltZXIgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgIGxldCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHRpY2thYmxlKS5faGVhZCk7XG4gICAgICBsZXQgdHdlZW5UYXJnZXQ7XG4gICAgICBsZXQgdHdlZW5TdHlsZTtcbiAgICAgIGxldCB0d2VlblRhcmdldFRyYW5zZm9ybXM7XG4gICAgICBsZXQgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllcztcbiAgICAgIGxldCB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcblxuICAgICAgd2hpbGUgKHR3ZWVuKSB7XG5cbiAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5DdXJyZW50VGltZSA9IHR3ZWVuLl9jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgdHdlZW5DaGFuZ2VEdXJhdGlvbiA9IHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5BYnNFbmRUaW1lID0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICsgdHdlZW4uX2NoYW5nZUR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0d2Vlbk5leHRSZXAgPSB0d2Vlbi5fbmV4dFJlcDtcbiAgICAgICAgY29uc3QgdHdlZW5QcmV2UmVwID0gdHdlZW4uX3ByZXZSZXA7XG4gICAgICAgIGNvbnN0IHR3ZWVuSGFzQ29tcG9zaXRpb24gPSB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmU7XG5cbiAgICAgICAgaWYgKChmb3JjZWRSZW5kZXIgfHwgKFxuICAgICAgICAgICAgKHR3ZWVuQ3VycmVudFRpbWUgIT09IHR3ZWVuQ2hhbmdlRHVyYXRpb24gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuQWJzRW5kVGltZSArICh0d2Vlbk5leHRSZXAgPyB0d2Vlbk5leHRSZXAuX2RlbGF5IDogMCkpICYmXG4gICAgICAgICAgICAodHdlZW5DdXJyZW50VGltZSAhPT0gMCB8fCBhYnNvbHV0ZVRpbWUgPj0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lKVxuICAgICAgICAgICkpICYmICghdHdlZW5IYXNDb21wb3NpdGlvbiB8fCAoXG4gICAgICAgICAgICAhdHdlZW4uX2lzT3ZlcnJpZGRlbiAmJlxuICAgICAgICAgICAgKCF0d2Vlbi5faXNPdmVybGFwcGVkIHx8IGFic29sdXRlVGltZSA8PSB0d2VlbkFic0VuZFRpbWUpICYmXG4gICAgICAgICAgICAoIXR3ZWVuTmV4dFJlcCB8fCAodHdlZW5OZXh0UmVwLl9pc092ZXJyaWRkZW4gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuTmV4dFJlcC5fYWJzb2x1dGVTdGFydFRpbWUpKSAmJlxuICAgICAgICAgICAgKCF0d2VlblByZXZSZXAgfHwgKHR3ZWVuUHJldlJlcC5faXNPdmVycmlkZGVuIHx8IChhYnNvbHV0ZVRpbWUgPj0gKHR3ZWVuUHJldlJlcC5fYWJzb2x1dGVTdGFydFRpbWUgKyB0d2VlblByZXZSZXAuX2NoYW5nZUR1cmF0aW9uKSArIHR3ZWVuLl9kZWxheSkpKVxuICAgICAgICAgICkpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5OZXdUaW1lID0gdHdlZW4uX2N1cnJlbnRUaW1lID0gY2xhbXAoaXRlcmF0aW9uVGltZSAtIHR3ZWVuLl9zdGFydFRpbWUsIDAsIHR3ZWVuQ2hhbmdlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvZ3Jlc3MgPSB0d2Vlbi5fZWFzZSh0d2Vlbk5ld1RpbWUgLyB0d2Vlbi5fdXBkYXRlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuTW9kaWZpZXIgPSB0d2Vlbi5fbW9kaWZpZXI7XG4gICAgICAgICAgY29uc3QgdHdlZW5WYWx1ZVR5cGUgPSB0d2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IHR3ZWVuLl90d2VlblR5cGU7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc09iamVjdCA9IHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5PQkpFQ1Q7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc051bWJlciA9IHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLk5VTUJFUjtcbiAgICAgICAgICAvLyBPbmx5IHJvdW5kIHRoZSBpbi1iZXR3ZWVuIGZyYW1lcyB2YWx1ZXMgaWYgdGhlIGZpbmFsIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICAgICAgY29uc3QgdHdlZW5QcmVjaXNpb24gPSAodHdlZW5Jc051bWJlciAmJiB0d2VlbklzT2JqZWN0KSB8fCB0d2VlblByb2dyZXNzID09PSAwIHx8IHR3ZWVuUHJvZ3Jlc3MgPT09IDEgPyAtMSA6IGdsb2JhbHMucHJlY2lzaW9uO1xuXG4gICAgICAgICAgLy8gUmVjb21wb3NlIHR3ZWVuIHZhbHVlXG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBsZXQgbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKHR3ZWVuSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbiApKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0d2VlblZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyB0aGUgdmFsdWVzIHNwZWVkIHVwIHN0cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgICAgbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7bnVtYmVyfSR7dHdlZW4uX3VuaXR9YDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR3ZWVuLl9mcm9tTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHRuID0gdHdlZW4uX3RvTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihpbnRlcnBvbGF0ZShmblswXSwgdG5bMF0sIHR3ZWVuUHJvZ3Jlc3MpKSksIDAsIDI1NSksIDApO1xuICAgICAgICAgICAgY29uc3QgZyA9IHJvdW5kKGNsYW1wKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0d2Vlbk1vZGlmaWVyKGludGVycG9sYXRlKGZuWzFdLCB0blsxXSwgdHdlZW5Qcm9ncmVzcykpKSwgMCwgMjU1KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIoaW50ZXJwb2xhdGUoZm5bMl0sIHRuWzJdLCB0d2VlblByb2dyZXNzKSkpLCAwLCAyNTUpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZShmblszXSwgdG5bM10sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKSwgMCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDtcbiAgICAgICAgICAgIGlmICh0d2Vlbkhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5zID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgICAgIG5zWzBdID0gcjtcbiAgICAgICAgICAgICAgbnNbMV0gPSBnO1xuICAgICAgICAgICAgICBuc1syXSA9IGI7XG4gICAgICAgICAgICAgIG5zWzNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHdlZW4uX3N0cmluZ3NbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbCA9IHR3ZWVuLl90b051bWJlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZSh0d2Vlbi5fZnJvbU51bWJlcnNbal0sIHR3ZWVuLl90b051bWJlcnNbal0sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHR3ZWVuLl9zdHJpbmdzW2ogKyAxXTtcbiAgICAgICAgICAgICAgdmFsdWUgKz0gYCR7cyA/IG4gKyBzIDogbn1gO1xuICAgICAgICAgICAgICBpZiAodHdlZW5IYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLl9udW1iZXJzW2pdID0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBhZGRpdGl2ZSB0d2VlbnMgYW5kIEFuaW1hdGFibGVzXG4gICAgICAgICAgaWYgKHR3ZWVuSGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHR3ZWVuLl9udW1iZXIgPSBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbFJlbmRlciAmJiB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Jc09iamVjdCkge1xuICAgICAgICAgICAgICB0d2VlblRhcmdldFt0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc2V0QXR0cmlidXRlKHR3ZWVuUHJvcGVydHksIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5TdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgICAgICAgIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuVGFyZ2V0ICE9PSB0d2VlblRhcmdldFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3JtcyA9IHR3ZWVuVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgLy8gTk9URTogUmVmZXJlbmNpbmcgdGhlIGNhY2hlZFRyYW5zZm9ybXMgaW4gdGhlIHR3ZWVuIHByb3BlcnR5IGRpcmVjdGx5IGNhbiBiZSBhIGxpdHRsZSBiaXQgZmFzdGVyIGJ1dCBhcHBlYXJzIHRvIGluY3JlYXNlIG1lbW9yeSB1c2FnZS5cbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllc1t0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlW3R3ZWVuUHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkNTU19WQVIpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlLnNldFByb3BlcnR5KHR3ZWVuUHJvcGVydHksLyoqIEB0eXBlIHtTdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIGhhc1JlbmRlcmVkID0gMTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2VkIGZvciBjb21wb3NpbmcgdGltZWxpbmUgdHdlZW5zIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGEgcmVhbCByZW5kZXJcbiAgICAgICAgICAgIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogUG9zc2libGUgaW1wcm92ZW1lbnQ6IFVzZSB0cmFuc2xhdGUoeCx5KSAvIHRyYW5zbGF0ZTNkKHgseSx6KSBzeW50YXhcbiAgICAgICAgLy8gdG8gcmVkdWNlIG1lbW9yeSB1c2FnZSBvbiBzdHJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgaWYgKHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgJiYgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMpIHtcbiAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN0ciArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV19JHt0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzW2tleV19KSBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0d2VlblN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuID0gdHdlZW4uX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiBoYXNSZW5kZXJlZCkge1xuICAgICAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyh0aWNrYWJsZSkub25SZW5kZXIoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8odGlja2FibGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgaXNDdXJyZW50VGltZUFib3ZlWmVybykge1xuICAgICAgdGlja2FibGUub25VcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gRW5kIHR3ZWVucyByZW5kZXJpbmdcblxuICAvLyBIYW5kbGUgc2V0dGVycyBvbiB0aW1lbGluZSBkaWZmZXJlbnRseSBhbmQgYWxsb3cgcmUtdHJpZ2VyaW5nIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gc2Vla2luZyBiYWNrd2FyZHNcbiAgaWYgKHBhcmVudCAmJiBpc1NldHRlcikge1xuICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiAoXG4gICAgICAocGFyZW50LmJlZ2FuICYmICFpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPj0gZHVyYXRpb24gJiYgIWNvbXBsZXRlZCkgfHxcbiAgICAgIChpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gbWluVmFsdWUgJiYgY29tcGxldGVkKVxuICAgICkpIHtcbiAgICAgIHRpY2thYmxlLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgdGlja2FibGUuY29tcGxldGVkID0gIWlzUnVubmluZ0JhY2t3YXJkcztcbiAgICB9XG4gIC8vIElmIGN1cnJlbnRUaW1lIGlzIGJvdGggYWJvdmUgMCBhbmQgYXQgbGVhc3QgZXF1YWxzIHRvIGR1cmF0aW9uLCBoYW5kbGVzIG5vcm1hbCBvbkNvbXBsZXRlIG9yIGluZmluaXRlIGxvb3BzXG4gIH0gZWxzZSBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiBpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHtcbiAgICBpZiAoaXRlcmF0aW9uQ291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBPZmZzZXQgdGhlIHRpY2thYmxlIF9zdGFydFRpbWUgd2l0aCBpdHMgZHVyYXRpb24gdG8gcmVzZXQgX2N1cnJlbnRUaW1lIHRvIDAgYW5kIGNvbnRpbnVlIHRoZSBpbmZpbml0ZSB0aW1lclxuICAgICAgdGlja2FibGUuX3N0YXJ0VGltZSArPSB0aWNrYWJsZS5kdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uID49IGl0ZXJhdGlvbkNvdW50IC0gMSkge1xuICAgICAgLy8gQnkgc2V0dGluZyBwYXVzZWQgdG8gdHJ1ZSwgd2UgdGVsbCB0aGUgZW5naW5lIGxvb3AgdG8gbm90IHJlbmRlciB0aGlzIHRpY2thYmxlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGxpc3Qgb24gdGhlIG5leHQgdGlja1xuICAgICAgdGlja2FibGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghY29tcGxldGVkICYmICFfaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRpY2thYmxlIGhhcyBjaGlsZHJlbiwgdHJpZ2dlcnMgb25Db21wbGV0ZSgpIG9ubHkgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBjb21wbGV0ZWQgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgICAgICAgdGlja2FibGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICAgICAgdGlja2FibGUub25Db21wbGV0ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gICAgICAgICAgdGlja2FibGUuX3Jlc29sdmUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBjb21wbGV0ZWQgZmxhZyB0byBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHRpY2thYmxlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gTk9URTogaGFzUmVuZGVyZWQgKiBkaXJlY3Rpb24gKG5lZ2F0aXZlIGZvciBiYWNrd2FyZHMpIHRoaXMgd2F5IHdlIGNhbiByZW1vdmUgdGhlIHRpY2thYmxlLmJhY2t3YXJkcyBwcm9wZXJ0eSBjb21wbGV0bHkgP1xuICByZXR1cm4gaGFzUmVuZGVyZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge051bWJlcn0gdGlja01vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHRpY2sgPSAodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSkgPT4ge1xuICBjb25zdCBfY3VycmVudEl0ZXJhdGlvbiA9IHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uO1xuICByZW5kZXIodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSk7XG4gIGlmICh0aWNrYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0bCA9IC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKHRpY2thYmxlKTtcbiAgICBjb25zdCB0bElzUnVubmluZ0JhY2t3YXJkcyA9IHRsLmJhY2t3YXJkcztcbiAgICBjb25zdCB0bENoaWxkcmVuVGltZSA9IGludGVybmFsUmVuZGVyID8gdGltZSA6IHRsLl9pdGVyYXRpb25UaW1lO1xuICAgIGNvbnN0IHRsQ2lsZHJlblRpY2tUaW1lID0gbm93KCk7XG5cbiAgICBsZXQgdGxDaGlsZHJlbkhhc1JlbmRlcmVkID0gMDtcbiAgICBsZXQgdGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHRpbWVsaW5lIGhhcyBsb29wZWQgZm9yd2FyZCwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VycyBjaGlsZHJlbiBza2lwcGVkIGNhbGxiYWNrc1xuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGwuX2N1cnJlbnRJdGVyYXRpb24gIT09IF9jdXJyZW50SXRlcmF0aW9uKSB7XG4gICAgICBjb25zdCB0bEl0ZXJhdGlvbkR1cmF0aW9uID0gdGwuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgIGlmICghdGxJc1J1bm5pbmdCYWNrd2FyZHMpIHtcbiAgICAgICAgICAvLyBGb3JjZSBhbiBpbnRlcm5hbCByZW5kZXIgdG8gdHJpZ2dlciB0aGUgY2FsbGJhY2tzIGlmIHRoZSBjaGlsZCBoYXMgbm90IGNvbXBsZXRlZCBvbiBsb29wXG4gICAgICAgICAgaWYgKCFjaGlsZC5jb21wbGV0ZWQgJiYgIWNoaWxkLmJhY2t3YXJkcyAmJiBjaGlsZC5fY3VycmVudFRpbWUgPCBjaGlsZC5pdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyKGNoaWxkLCB0bEl0ZXJhdGlvbkR1cmF0aW9uLCBtdXRlQ2FsbGJhY2tzLCAxLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGVpciBiZWdhbiBhbmQgY29tcGxldGVkIGZsYWdzIHRvIGFsbG93IHJldHJpZ2VyaW5nIGNhbGxiYWNrcyBvbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICBjaGlsZC5iZWdhbiA9IGZhbHNlO1xuICAgICAgICAgIGNoaWxkLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyYXRpb24gPSBjaGlsZC5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjaGlsZFN0YXJ0VGltZSA9IGNoaWxkLl9vZmZzZXQgKyBjaGlsZC5fZGVsYXk7XG4gICAgICAgICAgY29uc3QgY2hpbGRFbmRUaW1lID0gY2hpbGRTdGFydFRpbWUgKyBjaGlsZER1cmF0aW9uO1xuICAgICAgICAgIC8vIFRyaWdnZXJzIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIG9uIHJldmVyc2UgZm9yIGNoaWxkcmVuIG9uIHRoZSBlZGdlcyBvZiB0aGUgdGltZWxpbmVcbiAgICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgY2hpbGREdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAoIWNoaWxkU3RhcnRUaW1lIHx8IGNoaWxkRW5kVGltZSA9PT0gdGxJdGVyYXRpb25EdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGNoaWxkLm9uQ29tcGxldGUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHRsLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgfVxuXG4gICAgZm9yRWFjaENoaWxkcmVuKHRsLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRUaW1lID0gcm91bmQoKHRsQ2hpbGRyZW5UaW1lIC0gY2hpbGQuX29mZnNldCkgKiBjaGlsZC5fc3BlZWQsIDEyKTsgLy8gUm91bmRpbmcgaXMgbmVlZGVkIHdoZW4gdXNpbmcgc2Vjb25kc1xuICAgICAgY29uc3QgY2hpbGRUaWNrTW9kZSA9IGNoaWxkLl9mcHMgPCB0bC5fZnBzID8gY2hpbGQucmVxdWVzdFRpY2sodGxDaWxkcmVuVGlja1RpbWUpIDogdGlja01vZGU7XG4gICAgICB0bENoaWxkcmVuSGFzUmVuZGVyZWQgKz0gcmVuZGVyKGNoaWxkLCBjaGlsZFRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCBjaGlsZFRpY2tNb2RlKTtcbiAgICAgIGlmICghY2hpbGQuY29tcGxldGVkICYmIHRsQ2hpbGRyZW5IYXZlQ29tcGxldGVkKSB0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0sIHRsSXNSdW5uaW5nQmFja3dhcmRzKTtcblxuICAgIC8vIFJlbmRlcnMgb24gdGltZWxpbmUgYXJlIHRyaWdnZXJlZCBieSBpdHMgY2hpbGRyZW4gc28gaXQgbmVlZHMgdG8gYmUgc2V0IGFmdGVyIHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgdGxDaGlsZHJlbkhhc1JlbmRlcmVkKSB0bC5vblJlbmRlcigvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG5cbiAgICAvLyBUcmlnZ2VycyB0aGUgdGltZWxpbmUgb25Db21wbGV0ZSgpIG9uY2UgYWxsIGNoaW5kcmVuIGFsbCBjb21wbGV0ZWQgYW5kIHRoZSBjdXJyZW50IHRpbWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmICh0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCAmJiB0bC5fY3VycmVudFRpbWUgPj0gdGwuZHVyYXRpb24pIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF1c2VkIGZsYWcgaXMgZmFsc2UgaW4gY2FzZSBpdCBoYXMgYmVlbiBza2lwcGVkIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgIHRsLnBhdXNlZCA9IHRydWU7XG4gICAgICBpZiAoIXRsLmNvbXBsZXRlZCkge1xuICAgICAgICB0bC5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHtcbiAgICAgICAgICB0bC5vbkNvbXBsZXRlKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGwpKTtcbiAgICAgICAgICB0bC5fcmVzb2x2ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG5cbmNvbnN0IGFkZGl0aXZlID0ge1xuICBhbmltYXRpb246IG51bGwsXG4gIHVwZGF0ZTogbm9vcCxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgQWRkaXRpdmVBbmltYXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZGVsYXlcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9oZWFkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfdGFpbFxuICovXG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW5BZGRpdGl2ZUxvb2t1cHN9IGxvb2t1cHNcbiAqIEByZXR1cm4ge0FkZGl0aXZlQW5pbWF0aW9ufVxuICovXG5jb25zdCBhZGRBZGRpdGl2ZUFuaW1hdGlvbiA9IGxvb2t1cHMgPT4ge1xuICBsZXQgYW5pbWF0aW9uID0gYWRkaXRpdmUuYW5pbWF0aW9uO1xuICBpZiAoIWFuaW1hdGlvbikge1xuICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgIGR1cmF0aW9uOiBtaW5WYWx1ZSxcbiAgICAgIGNvbXB1dGVEZWx0YVRpbWU6IG5vb3AsXG4gICAgICBfb2Zmc2V0OiAwLFxuICAgICAgX2RlbGF5OiAwLFxuICAgICAgX2hlYWQ6IG51bGwsXG4gICAgICBfdGFpbDogbnVsbCxcbiAgICB9O1xuICAgIGFkZGl0aXZlLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICBhZGRpdGl2ZS51cGRhdGUgPSAoKSA9PiB7XG4gICAgICBsb29rdXBzLmZvckVhY2gocHJvcGVydHlBbmltYXRpb24gPT4ge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydHlBbmltYXRpb24pIHtcbiAgICAgICAgICBjb25zdCB0d2VlbnMgPSBwcm9wZXJ0eUFuaW1hdGlvbltwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIGNvbnN0IGxvb2t1cFR3ZWVuID0gdHdlZW5zLl9oZWFkO1xuICAgICAgICAgIGlmIChsb29rdXBUd2Vlbikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gbG9va3VwVHdlZW4uX3ZhbHVlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aXZlVmFsdWVzID0gdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVggfHwgdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gY2xvbmVBcnJheShsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnMpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhZGRpdGl2ZVZhbHVlID0gbG9va3VwVHdlZW4uX2Zyb21OdW1iZXI7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0d2VlbnMuX3RhaWw7XG4gICAgICAgICAgICB3aGlsZSAodHdlZW4gJiYgdHdlZW4gIT09IGxvb2t1cFR3ZWVuKSB7XG4gICAgICAgICAgICAgIGlmIChhZGRpdGl2ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHdlZW4uX251bWJlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSBhZGRpdGl2ZVZhbHVlc1tpXSArPSB0d2Vlbi5fbnVtYmVyc1tpXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRpdGl2ZVZhbHVlICs9IHR3ZWVuLl9udW1iZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHdlZW4gPSB0d2Vlbi5fcHJldkFkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb2t1cFR3ZWVuLl90b051bWJlciA9IGFkZGl0aXZlVmFsdWU7XG4gICAgICAgICAgICBsb29rdXBUd2Vlbi5fdG9OdW1iZXJzID0gYWRkaXRpdmVWYWx1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIFRPRE86IEF2b2lkIHBvbHltb3JwaGlzbSBoZXJlLCBpZGVhbHkgdGhlIGFkZGl0aXZlIGFuaW1hdGlvbiBzaG91bGQgYmUgYSByZWd1bGFyIGFuaW1hdGlvbiB3aXRoIGEgaGlnaGVyIHByaW9yaXR5IGluIHRoZSByZW5kZXIgbG9vcFxuICAgICAgcmVuZGVyKGFuaW1hdGlvbiwgMSwgMSwgMCwgdGlja01vZGVzLkZPUkNFKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBhbmltYXRpb247XG59O1xuXG5jb25zdCBlbmdpbmVUaWNrTWV0aG9kID0gaXNCcm93c2VyID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0SW1tZWRpYXRlO1xuY29uc3QgZW5naW5lQ2FuY2VsTWV0aG9kID0gaXNCcm93c2VyID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhckltbWVkaWF0ZTtcblxuY2xhc3MgRW5naW5lIGV4dGVuZHMgQ2xvY2sge1xuXG4gIC8qKiBAcGFyYW0ge051bWJlcn0gW2luaXRUaW1lXSAqL1xuICBjb25zdHJ1Y3Rvcihpbml0VGltZSkge1xuICAgIHN1cGVyKGluaXRUaW1lKTtcbiAgICB0aGlzLnVzZURlZmF1bHRNYWluTG9vcCA9IHRydWU7XG4gICAgdGhpcy5wYXVzZU9uRG9jdW1lbnRIaWRkZW4gPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7RGVmYXVsdHNQYXJhbXN9ICovXG4gICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIHRoaXMucGF1c2VkID0gaXNCcm93c2VyICYmIGRvYy5oaWRkZW4gPyB0cnVlICA6IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfE5vZGVKUy5JbW1lZGlhdGV9ICovXG4gICAgdGhpcy5yZXFJZCA9IG51bGw7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX2N1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdFRpY2sodGltZSkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZURlbHRhVGltZSh0aW1lKTtcbiAgICAgIGNvbnN0IGVuZ2luZVNwZWVkID0gdGhpcy5fc3BlZWQ7XG4gICAgICBjb25zdCBlbmdpbmVGcHMgPSB0aGlzLl9mcHM7XG4gICAgICBsZXQgYWN0aXZlVGlja2FibGUgPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aGlzLl9oZWFkKTtcbiAgICAgIHdoaWxlIChhY3RpdmVUaWNrYWJsZSkge1xuICAgICAgICBjb25zdCBuZXh0VGlja2FibGUgPSBhY3RpdmVUaWNrYWJsZS5fbmV4dDtcbiAgICAgICAgaWYgKCFhY3RpdmVUaWNrYWJsZS5wYXVzZWQpIHtcbiAgICAgICAgICB0aWNrKFxuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUsXG4gICAgICAgICAgICAodGltZSAtIGFjdGl2ZVRpY2thYmxlLl9zdGFydFRpbWUpICogYWN0aXZlVGlja2FibGUuX3NwZWVkICogZW5naW5lU3BlZWQsXG4gICAgICAgICAgICAwLCAvLyAhbXV0ZUNhbGxiYWNrc1xuICAgICAgICAgICAgMCwgLy8gIWludGVybmFsUmVuZGVyXG4gICAgICAgICAgICBhY3RpdmVUaWNrYWJsZS5fZnBzIDwgZW5naW5lRnBzID8gYWN0aXZlVGlja2FibGUucmVxdWVzdFRpY2sodGltZSkgOiB0aWNrTW9kZXMuQVVUT1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQodGhpcywgYWN0aXZlVGlja2FibGUpO1xuICAgICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gISF0aGlzLl90YWlsO1xuICAgICAgICAgIGFjdGl2ZVRpY2thYmxlLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGFjdGl2ZVRpY2thYmxlLmNvbXBsZXRlZCAmJiAhYWN0aXZlVGlja2FibGUuX2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRpY2thYmxlID0gbmV4dFRpY2thYmxlO1xuICAgICAgfVxuICAgICAgYWRkaXRpdmUudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgd2FrZSgpIHtcbiAgICBpZiAodGhpcy51c2VEZWZhdWx0TWFpbkxvb3AgJiYgIXRoaXMucmVxSWQgJiYgIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLnJlcUlkID0gZW5naW5lVGlja01ldGhvZCh0aWNrRW5naW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIGtpbGxFbmdpbmUoKTtcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSByZXR1cm47XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VGlja2FibGV9ICovY2hpbGQpID0+IGNoaWxkLnJlc2V0VGltZSgpKTtcbiAgICByZXR1cm4gdGhpcy53YWtlKCk7XG4gIH1cblxuICAvLyBHZXR0ZXIgYW5kIHNldHRlciBmb3Igc3BlZWRcbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZCAqIChnbG9iYWxzLnRpbWVTY2FsZSA9PT0gMSA/IDEgOiBLKTtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICB0aGlzLl9zcGVlZCA9IHBsYXliYWNrUmF0ZSAqIGdsb2JhbHMudGltZVNjYWxlO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQuc3BlZWQgPSBjaGlsZC5fc3BlZWQpO1xuICB9XG5cbiAgLy8gR2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHRpbWVVbml0XG4gIGdldCB0aW1lVW5pdCgpIHtcbiAgICByZXR1cm4gZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAnbXMnIDogJ3MnO1xuICB9O1xuXG4gIHNldCB0aW1lVW5pdCh1bml0KSB7XG4gICAgY29uc3Qgc2Vjb25kc1NjYWxlID0gMC4wMDE7XG4gICAgY29uc3QgaXNTZWNvbmQgPSB1bml0ID09PSAncyc7XG4gICAgY29uc3QgbmV3U2NhbGUgPSBpc1NlY29uZCA/IHNlY29uZHNTY2FsZSA6IDE7XG4gICAgaWYgKGdsb2JhbHMudGltZVNjYWxlICE9PSBuZXdTY2FsZSkge1xuICAgICAgZ2xvYmFscy50aW1lU2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgIGdsb2JhbHMudGlja1RocmVzaG9sZCA9IDIwMCAqIG5ld1NjYWxlO1xuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpc1NlY29uZCA/IHNlY29uZHNTY2FsZSA6IEs7XG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICh0aGlzLmRlZmF1bHRzLmR1cmF0aW9uKSAqPSBzY2FsZUZhY3RvcjtcbiAgICAgIHRoaXMuX3NwZWVkICo9IHNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlciBhbmQgc2V0dGVyIGZvciBwcmVjaXNpb25cbiAgZ2V0IHByZWNpc2lvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFscy5wcmVjaXNpb247XG4gIH1cblxuICBzZXQgcHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIGdsb2JhbHMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB9XG5cbn1cbmNvbnN0IGVuZ2luZSA9IC8qI19fUFVSRV9fKi8oKCkgPT4ge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgRW5naW5lKG5vdygpKTtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGdsb2JhbFZlcnNpb25zLmVuZ2luZSA9IGVuZ2luZTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmICghZW5naW5lLnBhdXNlT25Eb2N1bWVudEhpZGRlbikgcmV0dXJuO1xuICAgICAgZG9jLmhpZGRlbiA/IGVuZ2luZS5wYXVzZSgpIDogZW5naW5lLnJlc3VtZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmdpbmU7XG59KSgpO1xuXG5cbmNvbnN0IHRpY2tFbmdpbmUgPSAoKSA9PiB7XG4gIGlmIChlbmdpbmUuX2hlYWQpIHtcbiAgICBlbmdpbmUucmVxSWQgPSBlbmdpbmVUaWNrTWV0aG9kKHRpY2tFbmdpbmUpO1xuICAgIGVuZ2luZS51cGRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBlbmdpbmUucmVxSWQgPSAwO1xuICB9XG59O1xuXG5jb25zdCBraWxsRW5naW5lID0gKCkgPT4ge1xuICBlbmdpbmVDYW5jZWxNZXRob2QoLyoqIEB0eXBlIHtOb2RlSlMuSW1tZWRpYXRlICYgTnVtYmVyfSAqLyhlbmdpbmUucmVxSWQpKTtcbiAgZW5naW5lLnJlcUlkID0gMDtcbiAgcmV0dXJuIGVuZ2luZTtcbn07XG5cblxuXG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlSW5saW5lVHJhbnNmb3JtcyA9ICh0YXJnZXQsIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpID0+IHtcbiAgY29uc3QgaW5saW5lVHJhbnNmb3JtcyA9IHRhcmdldC5zdHlsZS50cmFuc2Zvcm07XG4gIGxldCBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZTtcbiAgaWYgKGlubGluZVRyYW5zZm9ybXMpIHtcbiAgICBjb25zdCBjYWNoZWRUcmFuc2Zvcm1zID0gdGFyZ2V0W3RyYW5zZm9ybXNTeW1ib2xdO1xuICAgIGxldCB0OyB3aGlsZSAodCA9IHRyYW5zZm9ybXNFeGVjUmd4LmV4ZWMoaW5saW5lVHJhbnNmb3JtcykpIHtcbiAgICAgIGNvbnN0IGlubGluZVByb3BlcnR5TmFtZSA9IHRbMV07XG4gICAgICAvLyBjb25zdCBpbmxpbmVQcm9wZXJ0eVZhbHVlID0gdFsyXTtcbiAgICAgIGNvbnN0IGlubGluZVByb3BlcnR5VmFsdWUgPSB0WzJdLnNsaWNlKDEsIC0xKTtcbiAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5saW5lUHJvcGVydHlOYW1lXSA9IGlubGluZVByb3BlcnR5VmFsdWU7XG4gICAgICBpZiAoaW5saW5lUHJvcGVydHlOYW1lID09PSBwcm9wTmFtZSkge1xuICAgICAgICBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSA9IGlubGluZVByb3BlcnR5VmFsdWU7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZXcgcGFyc2VkIGlubGluZSBzdHlsZXMgaWYgYW5pbWF0aW9uSW5saW5lU3R5bGVzIGlzIHByb3ZpZGVkXG4gICAgICAgIGlmIChhbmltYXRpb25JbmxpbmVTdHlsZXMpIHtcbiAgICAgICAgICBhbmltYXRpb25JbmxpbmVTdHlsZXNbcHJvcE5hbWVdID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5saW5lVHJhbnNmb3JtcyAmJiAhaXNVbmQoaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUpID8gaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUgOlxuICAgIHN0cmluZ1N0YXJ0c1dpdGgocHJvcE5hbWUsICdzY2FsZScpID8gJzEnIDpcbiAgICBzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSA/ICcwZGVnJyA6ICcwcHgnO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW18VGFyZ2V0c1BhcmFtfSB2XG4gKiBAcmV0dXJuIHtOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUxpc3Qodikge1xuICBjb25zdCBuID0gaXNTdHIodikgPyBnbG9iYWxzLnJvb3QucXVlcnlTZWxlY3RvckFsbCh2KSA6IHY7XG4gIGlmIChuIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbiBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7RE9NVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7SlNUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0pTVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtUYXJnZXRzQXJyYXl9XG4gKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfEpTVGFyZ2V0c1BhcmFtfFRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICBpZiAoaXNOaWwodGFyZ2V0cykpIHJldHVybiAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi8oW10pO1xuICBpZiAoaXNBcnIodGFyZ2V0cykpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSB0YXJnZXRzLmZsYXQoSW5maW5pdHkpO1xuICAgIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqL1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZmxhdHRlbmVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGZsYXR0ZW5lZFtpXTtcbiAgICAgIGlmICghaXNOaWwoaXRlbSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZUxpc3QgPSBnZXROb2RlTGlzdChpdGVtKTtcbiAgICAgICAgaWYgKG5vZGVMaXN0KSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbm9kZUxpc3QubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViSXRlbSA9IG5vZGVMaXN0W2pdO1xuICAgICAgICAgICAgaWYgKCFpc05pbChzdWJJdGVtKSkge1xuICAgICAgICAgICAgICBsZXQgaXNEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDAsIGtsID0gcGFyc2VkLmxlbmd0aDsgayA8IGtsOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkW2tdID09PSBzdWJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICBpc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHN1Ykl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpc0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHBhcnNlZC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkW2pdID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgIGlzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGlmICghaXNCcm93c2VyKSByZXR1cm4gLyoqIEB0eXBlIHtKU1RhcmdldHNBcnJheX0gKi8oW3RhcmdldHNdKTtcbiAgY29uc3Qgbm9kZUxpc3QgPSBnZXROb2RlTGlzdCh0YXJnZXRzKTtcbiAgaWYgKG5vZGVMaXN0KSByZXR1cm4gLyoqIEB0eXBlIHtET01UYXJnZXRzQXJyYXl9ICovKEFycmF5LmZyb20obm9kZUxpc3QpKTtcbiAgcmV0dXJuIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqLyhbdGFyZ2V0c10pO1xufVxuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtET01UYXJnZXRzQXJyYXl9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtKU1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7SlNUYXJnZXRzQXJyYXl9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge1RhcmdldHNBcnJheX1cbiAqXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW18SlNUYXJnZXRzUGFyYW18VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIGNvbnN0IHBhcnNlZFRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyc2VkVGFyZ2V0c0xlbmd0aCA9IHBhcnNlZFRhcmdldHNBcnJheS5sZW5ndGg7XG4gIGlmIChwYXJzZWRUYXJnZXRzTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRUYXJnZXRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHBhcnNlZFRhcmdldHNBcnJheVtpXTtcbiAgICAgIGlmICghdGFyZ2V0W2lzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbF0pIHtcbiAgICAgICAgdGFyZ2V0W2lzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1N2Z1R5cGUgPSBpc1N2Zyh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpc0RvbSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLm5vZGVUeXBlIHx8IGlzU3ZnVHlwZTtcbiAgICAgICAgaWYgKGlzRG9tKSB7XG4gICAgICAgICAgdGFyZ2V0W2lzRG9tU3ltYm9sXSA9IHRydWU7XG4gICAgICAgICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSA9IGlzU3ZnVHlwZTtcbiAgICAgICAgICB0YXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkVGFyZ2V0c0FycmF5O1xufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gcGF0aFxuICogQHJldHVybiB7U1ZHR2VvbWV0cnlFbGVtZW50fHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgZ2V0UGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcGFyc2VUYXJnZXRzKHBhdGgpO1xuICBjb25zdCAkcGFyc2VkU3ZnID0gLyoqIEB0eXBlIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICovKHBhcnNlZFRhcmdldHNbMF0pO1xuICBpZiAoISRwYXJzZWRTdmcgfHwgIWlzU3ZnKCRwYXJzZWRTdmcpKSByZXR1cm47XG4gIHJldHVybiAkcGFyc2VkU3ZnO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHBhdGgyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBtb3JwaFRvID0gKHBhdGgyLCBwcmVjaXNpb24gPSAuMzMpID0+ICgkcGF0aDEpID0+IHtcbiAgY29uc3QgJHBhdGgyID0gLyoqIEB0eXBlIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICovKGdldFBhdGgocGF0aDIpKTtcbiAgaWYgKCEkcGF0aDIpIHJldHVybjtcbiAgY29uc3QgaXNQYXRoID0gJHBhdGgxLnRhZ05hbWUgPT09ICdwYXRoJztcbiAgY29uc3Qgc2VwYXJhdG9yID0gaXNQYXRoID8gJyAnIDogJywnO1xuICBjb25zdCBwcmV2aW91c1BvaW50cyA9ICRwYXRoMVttb3JwaFBvaW50c1N5bWJvbF07XG4gIGlmIChwcmV2aW91c1BvaW50cykgJHBhdGgxLnNldEF0dHJpYnV0ZShpc1BhdGggPyAnZCcgOiAncG9pbnRzJywgcHJldmlvdXNQb2ludHMpO1xuXG4gIGxldCB2MSA9ICcnLCB2MiA9ICcnO1xuXG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdjEgPSAkcGF0aDEuZ2V0QXR0cmlidXRlKGlzUGF0aCA/ICdkJyA6ICdwb2ludHMnKTtcbiAgICB2MiA9ICRwYXRoMi5nZXRBdHRyaWJ1dGUoaXNQYXRoID8gJ2QnIDogJ3BvaW50cycpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlbmd0aDEgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJHBhdGgxKS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGNvbnN0IGxlbmd0aDIgPSAkcGF0aDIuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBjb25zdCBtYXhQb2ludHMgPSBNYXRoLm1heChNYXRoLmNlaWwobGVuZ3RoMSAqIHByZWNpc2lvbiksIE1hdGguY2VpbChsZW5ndGgyICogcHJlY2lzaW9uKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhQb2ludHM7IGkrKykge1xuICAgICAgY29uc3QgdCA9IGkgLyAobWF4UG9pbnRzIC0gMSk7XG4gICAgICBjb25zdCBwb2ludE9uUGF0aDEgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJHBhdGgxKS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aDEgKiB0KTtcbiAgICAgIGNvbnN0IHBvaW50T25QYXRoMiA9ICRwYXRoMi5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aDIgKiB0KTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGlzUGF0aCA/IChpID09PSAwID8gJ00nIDogJ0wnKSA6ICcnO1xuICAgICAgdjEgKz0gcHJlZml4ICsgcm91bmQocG9pbnRPblBhdGgxLngsIDMpICsgc2VwYXJhdG9yICsgcG9pbnRPblBhdGgxLnkgKyAnICc7XG4gICAgICB2MiArPSBwcmVmaXggKyByb3VuZChwb2ludE9uUGF0aDIueCwgMykgKyBzZXBhcmF0b3IgKyBwb2ludE9uUGF0aDIueSArICcgJztcbiAgICB9XG4gIH1cblxuICAkcGF0aDFbbW9ycGhQb2ludHNTeW1ib2xdID0gdjI7XG5cbiAgcmV0dXJuIFt2MSwgdjJdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gWyRlbF1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0U2NhbGVGYWN0b3IgPSAkZWwgPT4ge1xuICBsZXQgc2NhbGVGYWN0b3IgPSAxO1xuICBpZiAoJGVsICYmICRlbC5nZXRDVE0pIHtcbiAgICBjb25zdCBjdG0gPSAkZWwuZ2V0Q1RNKCk7XG4gICAgaWYgKGN0bSkge1xuICAgICAgY29uc3Qgc2NhbGVYID0gc3FydChjdG0uYSAqIGN0bS5hICsgY3RtLmIgKiBjdG0uYik7XG4gICAgICBjb25zdCBzY2FsZVkgPSBzcXJ0KGN0bS5jICogY3RtLmMgKyBjdG0uZCAqIGN0bS5kKTtcbiAgICAgIHNjYWxlRmFjdG9yID0gKHNjYWxlWCArIHNjYWxlWSkgLyAyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NhbGVGYWN0b3I7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSB0aGF0IHdyYXBzIGFuIFNWR0dlb21ldHJ5RWxlbWVudCBhbmQgYWRkcyBkcmF3aW5nIGZ1bmN0aW9uYWxpdHkuXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJGVsIC0gVGhlIFNWRyBlbGVtZW50IHRvIHRyYW5zZm9ybSBpbnRvIGEgZHJhd2FibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0aW5nIHBvc2l0aW9uICgwLTEpXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gRW5kaW5nIHBvc2l0aW9uICgwLTEpXG4gKiBAcmV0dXJuIHtEcmF3YWJsZVNWR0dlb21ldHJ5fSAtIFJldHVybnMgYSBwcm94eSB0aGF0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgZWxlbWVudCdzIHR5cGUgd2l0aCBhZGRpdGlvbmFsICdkcmF3JyBhdHRyaWJ1dGUgZnVuY3Rpb25hbGl0eVxuICovXG5jb25zdCBjcmVhdGVEcmF3YWJsZVByb3h5ID0gKCRlbCwgc3RhcnQsIGVuZCkgPT4ge1xuICBjb25zdCBwYXRoTGVuZ3RoID0gSztcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKCRlbCk7XG4gIGNvbnN0IHN0cm9rZUxpbmVDYXAgPSBjb21wdXRlZFN0eWxlcy5zdHJva2VMaW5lY2FwO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0ICRzY2FsbGVkID0gY29tcHV0ZWRTdHlsZXMudmVjdG9yRWZmZWN0ID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJyA/ICRlbCA6IG51bGw7XG4gIGxldCBjdXJyZW50Q2FwID0gc3Ryb2tlTGluZUNhcDtcblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSgkZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgaWYgKHByb3BlcnR5ID09PSBwcm94eVRhcmdldFN5bWJvbCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3NldEF0dHJpYnV0ZScpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdkcmF3Jykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IHYxID0gK3ZhbHVlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gK3ZhbHVlc1sxXTtcbiAgICAgICAgICAgIC8vIFRPVE86IEJlbmNobWFyayBpZiBwZXJmb3JtaW5nIHR3byBzbGljZXMgaXMgbW9yZSBwZXJmb3JtYW50IHRoYW4gb25lIHNwbGl0XG4gICAgICAgICAgICAvLyBjb25zdCBzcGFjZUluZGV4ID0gdmFsdWUuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgLy8gY29uc3QgdjEgPSByb3VuZCgrdmFsdWUuc2xpY2UoMCwgc3BhY2VJbmRleCksIHByZWNpc2lvbik7XG4gICAgICAgICAgICAvLyBjb25zdCB2MiA9IHJvdW5kKCt2YWx1ZS5zbGljZShzcGFjZUluZGV4ICsgMSksIHByZWNpc2lvbik7XG4gICAgICAgICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGdldFNjYWxlRmFjdG9yKCRzY2FsbGVkKTtcbiAgICAgICAgICAgIGNvbnN0IG9zID0gdjEgKiAtMWUzICogc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBjb25zdCBkMSA9ICh2MiAqIHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvcikgKyBvcztcbiAgICAgICAgICAgIGNvbnN0IGQyID0gKHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvciArXG4gICAgICAgICAgICAgICAgICAgICAgKCh2MSA9PT0gMCAmJiB2MiA9PT0gMSkgfHwgKHYxID09PSAxICYmIHYyID09PSAwKSA/IDAgOiAxMCAqIHNjYWxlRmFjdG9yKSAtIGQxKTtcbiAgICAgICAgICAgIGlmIChzdHJva2VMaW5lQ2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FwID0gdjEgPT09IHYyID8gJ2J1dHQnIDogc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYXAgIT09IG5ld0NhcCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zdHJva2VMaW5lY2FwID0gYCR7bmV3Q2FwfWA7XG4gICAgICAgICAgICAgICAgY3VycmVudENhcCA9IG5ld0NhcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBgJHtvc31gKTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBgJHtkMX0gJHtkMn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodmFsdWUsIHRhcmdldCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBSZWZsZWN0LmFwcGx5KHZhbHVlLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCRlbC5nZXRBdHRyaWJ1dGUoJ3BhdGhMZW5ndGgnKSAhPT0gYCR7cGF0aExlbmd0aH1gKSB7XG4gICAgJGVsLnNldEF0dHJpYnV0ZSgncGF0aExlbmd0aCcsIGAke3BhdGhMZW5ndGh9YCk7XG4gICAgcHJveHkuc2V0QXR0cmlidXRlKCdkcmF3JywgYCR7c3RhcnR9ICR7ZW5kfWApO1xuICB9XG5cbiAgcmV0dXJuIC8qKiBAdHlwZSB7RHJhd2FibGVTVkdHZW9tZXRyeX0gKi8ocHJveHkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGRyYXdhYmxlIHByb3hpZXMgZm9yIG11bHRpcGxlIFNWRyBlbGVtZW50cy5cbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSBzZWxlY3RvciAtIENTUyBzZWxlY3RvciwgU1ZHIGVsZW1lbnQsIG9yIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydGluZyBwb3NpdGlvbiAoMC0xKVxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9MF0gLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0FycmF5PERyYXdhYmxlU1ZHR2VvbWV0cnk+fSAtIEFycmF5IG9mIHByb3hpZWQgZWxlbWVudHMgd2l0aCBkcmF3aW5nIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgY3JlYXRlRHJhd2FibGUgPSAoc2VsZWN0b3IsIHN0YXJ0ID0gMCwgZW5kID0gMCkgPT4ge1xuICBjb25zdCBlbHMgPSBwYXJzZVRhcmdldHMoc2VsZWN0b3IpO1xuICByZXR1cm4gZWxzLm1hcCgkZWwgPT4gY3JlYXRlRHJhd2FibGVQcm94eShcbiAgICAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJGVsKSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSk7XG59O1xuXG4vLyBNb3Rpb24gcGF0aCBhbmltYXRpb25cblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9bG9va3VwXG4gKiBAcmV0dXJuIHtET01Qb2ludH1cbiAqL1xuY29uc3QgZ2V0UGF0aFBvaW50ID0gKCRwYXRoLCBwcm9ncmVzcywgbG9va3VwID0gMCkgPT4ge1xuICByZXR1cm4gJHBhdGguZ2V0UG9pbnRBdExlbmd0aChwcm9ncmVzcyArIGxvb2t1cCA+PSAxID8gcHJvZ3Jlc3MgKyBsb29rdXAgOiAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICRwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFByb3BlcnR5XG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBnZXRQYXRoUHJvZ2VzcyA9ICgkcGF0aCwgcGF0aFByb3BlcnR5KSA9PiB7XG4gIHJldHVybiAkZWwgPT4ge1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gKygkcGF0aC5nZXRUb3RhbExlbmd0aCgpKTtcbiAgICBjb25zdCBpblN2ZyA9ICRlbFtpc1N2Z1N5bWJvbF07XG4gICAgY29uc3QgY3RtID0gJHBhdGguZ2V0Q1RNKCk7XG4gICAgLyoqIEB0eXBlIHtUd2Vlbk9iamVjdFZhbHVlfSAqL1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IHRvdGFsTGVuZ3RoLFxuICAgICAgLyoqIEB0eXBlIHtUd2Vlbk1vZGlmaWVyfSAqL1xuICAgICAgbW9kaWZpZXI6IHByb2dyZXNzID0+IHtcbiAgICAgICAgaWYgKHBhdGhQcm9wZXJ0eSA9PT0gJ2EnKSB7XG4gICAgICAgICAgY29uc3QgcDAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAtMSk7XG4gICAgICAgICAgY29uc3QgcDEgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAxKTtcbiAgICAgICAgICByZXR1cm4gYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIFBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAwKTtcbiAgICAgICAgICByZXR1cm4gcGF0aFByb3BlcnR5ID09PSAneCcgP1xuICAgICAgICAgICAgaW5TdmcgfHwgIWN0bSA/IHAueCA6IHAueCAqIGN0bS5hICsgcC55ICogY3RtLmMgKyBjdG0uZSA6XG4gICAgICAgICAgICBpblN2ZyB8fCAhY3RtID8gcC55IDogcC54ICogY3RtLmIgKyBwLnkgKiBjdG0uZCArIGN0bS5mXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHBhdGhcbiAqL1xuY29uc3QgY3JlYXRlTW90aW9uUGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCAkcGF0aCA9IGdldFBhdGgocGF0aCk7XG4gIGlmICghJHBhdGgpIHJldHVybjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3gnKSxcbiAgICB0cmFuc2xhdGVZOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3knKSxcbiAgICByb3RhdGU6IGdldFBhdGhQcm9nZXNzKCRwYXRoLCAnYScpLFxuICB9XG59O1xuXG4vLyBDaGVjayBmb3IgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuXG5jb25zdCBjc3NSZXNlcnZlZFByb3BlcnRpZXMgPSBbJ29wYWNpdHknLCAncm90YXRlJywgJ292ZXJmbG93JywgJ2NvbG9yJ107XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRTVkdBdHRyaWJ1dGUgPSAoZWwsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAvLyBSZXR1cm4gZWFybHkgYW5kIHVzZSBDU1Mgb3BhY2l0eSBhbmltYXRpb24gaW5zdGVhZCAoYWxyZWFkeSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZXMgKG9wYWNpdHk6IDEgaW5zdGVhZCBvZiAwKSkgYW5kIHJvdGF0ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHRyYW5zZm9ybVxuICBpZiAoY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3BlcnR5TmFtZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUpIHx8IHByb3BlcnR5TmFtZSBpbiBlbCkge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzY2FsZScpIHsgLy8gU2NhbGVcbiAgICAgIGNvbnN0IGVsUGFyZW50Tm9kZSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwpLnBhcmVudE5vZGUpO1xuICAgICAgLy8gT25seSBjb25zaWRlciBzY2FsZSBhcyBhIHZhbGlkIFNWRyBhdHRyaWJ1dGUgb24gZmlsdGVyIGVsZW1lbnRcbiAgICAgIHJldHVybiBlbFBhcmVudE5vZGUgJiYgZWxQYXJlbnROb2RlLnRhZ05hbWUgPT09ICdmaWx0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3Qgc3ZnID0ge1xuICBtb3JwaFRvLFxuICBjcmVhdGVNb3Rpb25QYXRoLFxuICBjcmVhdGVEcmF3YWJsZSxcbn07XG5cblxuXG5cbi8qKlxuICogUkdCIC8gUkdCQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gcmdiVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IHJnYlRvUmdiYSA9IHJnYlZhbHVlID0+IHtcbiAgY29uc3QgcmdiYSA9IHJnYkV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSkgfHwgcmdiYUV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSk7XG4gIGNvbnN0IGEgPSAhaXNVbmQocmdiYVs0XSkgPyArcmdiYVs0XSA6IDE7XG4gIHJldHVybiBbXG4gICAgK3JnYmFbMV0sXG4gICAgK3JnYmFbMl0sXG4gICAgK3JnYmFbM10sXG4gICAgYVxuICBdXG59O1xuXG4vKipcbiAqIEhFWDMgLyBIRVgzQSAvIEhFWDYgLyBIRVg2QSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaGV4VmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhleFRvUmdiYSA9IGhleFZhbHVlID0+IHtcbiAgY29uc3QgaGV4TGVuZ3RoID0gaGV4VmFsdWUubGVuZ3RoO1xuICBjb25zdCBpc1Nob3J0ID0gaGV4TGVuZ3RoID09PSA0IHx8IGhleExlbmd0aCA9PT0gNTtcbiAgcmV0dXJuIFtcbiAgICArKCcweCcgKyBoZXhWYWx1ZVsxXSArIGhleFZhbHVlW2lzU2hvcnQgPyAxIDogMl0pLFxuICAgICsoJzB4JyArIGhleFZhbHVlW2lzU2hvcnQgPyAyIDogM10gKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMiA6IDRdKSxcbiAgICArKCcweCcgKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMyA6IDVdICsgaGV4VmFsdWVbaXNTaG9ydCA/IDMgOiA2XSksXG4gICAgKChoZXhMZW5ndGggPT09IDUgfHwgaGV4TGVuZ3RoID09PSA5KSA/ICsoKygnMHgnICsgaGV4VmFsdWVbaXNTaG9ydCA/IDQgOiA3XSArIGhleFZhbHVlW2lzU2hvcnQgPyA0IDogOF0pIC8gMjU1KS50b0ZpeGVkKDMpIDogMSlcbiAgXVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBcbiAqIEBwYXJhbSAge051bWJlcn0gcVxuICogQHBhcmFtICB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGh1ZTJyZ2IgPSAocCwgcSwgdCkgPT4ge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIHJldHVybiB0IDwgMSAvIDYgPyBwICsgKHEgLSBwKSAqIDYgKiB0IDpcbiAgICAgICAgIHQgPCAxIC8gMiA/IHEgOlxuICAgICAgICAgdCA8IDIgLyAzID8gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDYgOlxuICAgICAgICAgcDtcbn07XG5cbi8qKlxuICogSFNMIC8gSFNMQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaHNsVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhzbFRvUmdiYSA9IGhzbFZhbHVlID0+IHtcbiAgY29uc3QgaHNsYSA9IGhzbEV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSkgfHwgaHNsYUV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSk7XG4gIGNvbnN0IGggPSAraHNsYVsxXSAvIDM2MDtcbiAgY29uc3QgcyA9ICtoc2xhWzJdIC8gMTAwO1xuICBjb25zdCBsID0gK2hzbGFbM10gLyAxMDA7XG4gIGNvbnN0IGEgPSAhaXNVbmQoaHNsYVs0XSkgPyAraHNsYVs0XSA6IDE7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcSA9IGwgPCAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSByb3VuZChodWUycmdiKHAsIHEsIGggKyAxIC8gMykgKiAyNTUsIDApO1xuICAgIGcgPSByb3VuZChodWUycmdiKHAsIHEsIGgpICogMjU1LCAwKTtcbiAgICBiID0gcm91bmQoaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpICogMjU1LCAwKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufTtcblxuLyoqXG4gKiBBbGwgaW4gb25lIGNvbG9yIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIGEgY29sb3Igc3RyaW5nIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgUkdCQSB2YWx1ZXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sb3JTdHJpbmdcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5ID0gY29sb3JTdHJpbmcgPT4ge1xuICByZXR1cm4gaXNSZ2IoY29sb3JTdHJpbmcpID8gcmdiVG9SZ2JhKGNvbG9yU3RyaW5nKSA6XG4gICAgICAgICBpc0hleChjb2xvclN0cmluZykgPyBoZXhUb1JnYmEoY29sb3JTdHJpbmcpIDpcbiAgICAgICAgIGlzSHNsKGNvbG9yU3RyaW5nKSA/IGhzbFRvUmdiYShjb2xvclN0cmluZykgOlxuICAgICAgICAgWzAsIDAsIDAsIDFdO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgRFxuICogQHBhcmFtIHtUfHVuZGVmaW5lZH0gdGFyZ2V0VmFsdWVcbiAqIEBwYXJhbSB7RH0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJuIHtUfER9XG4gKi9cbmNvbnN0IHNldFZhbHVlID0gKHRhcmdldFZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzVW5kKHRhcmdldFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHRhcmdldFZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlblByb3BWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtzdG9yZV1cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgZ2V0RnVuY3Rpb25WYWx1ZSA9ICh2YWx1ZSwgdGFyZ2V0LCBpbmRleCwgdG90YWwsIHN0b3JlKSA9PiB7XG4gIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkodGFyZ2V0LCBpbmRleCwgdG90YWwpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gMCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQgLyBOYU4gLyBudWxsIC8gZmFsc2UgLyAwXG4gICAgICByZXR1cm4gIWlzTmFOKCtjb21wdXRlZCkgPyArY29tcHV0ZWQgOiBjb21wdXRlZCB8fCAwO1xuICAgIH07XG4gICAgaWYgKHN0b3JlKSB7XG4gICAgICBzdG9yZS5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7dHdlZW5UeXBlc31cbiAqL1xuY29uc3QgZ2V0VHdlZW5UeXBlID0gKHRhcmdldCwgcHJvcCkgPT4ge1xuICByZXR1cm4gIXRhcmdldFtpc0RvbVN5bWJvbF0gPyB0d2VlblR5cGVzLk9CSkVDVCA6XG4gICAgLy8gSGFuZGxlIFNWRyBhdHRyaWJ1dGVzXG4gICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSAmJiBpc1ZhbGlkU1ZHQXR0cmlidXRlKHRhcmdldCwgcHJvcCkgPyB0d2VlblR5cGVzLkFUVFJJQlVURSA6XG4gICAgLy8gSGFuZGxlIENTUyBUcmFuc2Zvcm0gcHJvcGVydGllcyBkaWZmZXJlbnRseSB0aGFuIENTUyB0byBhbGxvdyBpbmRpdmlkdWFsIGFuaW1hdGlvbnNcbiAgICB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMocHJvcCkgfHwgc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wKSA/IHR3ZWVuVHlwZXMuVFJBTlNGT1JNIDpcbiAgICAvLyBDU1MgdmFyaWFibGVzXG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wLCAnLS0nKSA/IHR3ZWVuVHlwZXMuQ1NTX1ZBUiA6XG4gICAgLy8gQWxsIG90aGVyIENTUyBwcm9wZXJ0aWVzXG4gICAgcHJvcCBpbiAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KS5zdHlsZSA/IHR3ZWVuVHlwZXMuQ1NTIDpcbiAgICAvLyBIYW5kbGUgb3RoZXIgRE9NIEF0dHJpYnV0ZXNcbiAgICBwcm9wIGluIHRhcmdldCA/IHR3ZWVuVHlwZXMuT0JKRUNUIDpcbiAgICB0d2VlblR5cGVzLkFUVFJJQlVURTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGdldENTU1ZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVTdHlsZXMgPSB0YXJnZXQuc3R5bGVbcHJvcE5hbWVdO1xuICBpZiAoaW5saW5lU3R5bGVzICYmIGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVTdHlsZXM7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBpbmxpbmVTdHlsZXMgfHwgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRbcHJveHlUYXJnZXRTeW1ib2xdIHx8IHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gJzAnIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHt0d2VlblR5cGVzfSBbdHdlZW5UeXBlXVxuICogQHBhcmFtIHtPYmplY3R8dm9pZH0gW2FuaW1hdGlvbklubGluZVN0eWxlc11cbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSAhaXNVbmQodHdlZW5UeXBlKSA/IHR3ZWVuVHlwZSA6IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgcmV0dXJuIHR5cGUgPT09IHR3ZWVuVHlwZXMuT0JKRUNUID8gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwIDpcbiAgICAgICAgIHR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFID8gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuZ2V0QXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICB0eXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSA/IHBhcnNlSW5saW5lVHJhbnNmb3JtcygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KSwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgOlxuICAgICAgICAgdHlwZSA9PT0gdHdlZW5UeXBlcy5DU1NfVkFSID8gZ2V0Q1NTVmFsdWUoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpLnRyaW1TdGFydCgpIDpcbiAgICAgICAgIGdldENTU1ZhbHVlKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBwcm9wTmFtZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSAge1N0cmluZ30gb3BlcmF0b3JcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0UmVsYXRpdmVWYWx1ZSA9ICh4LCB5LCBvcGVyYXRvcikgPT4ge1xuICByZXR1cm4gb3BlcmF0b3IgPT09ICctJyA/IHggLSB5IDpcbiAgICAgICAgIG9wZXJhdG9yID09PSAnKycgPyB4ICsgeSA6XG4gICAgICAgICB4ICogeTtcbn07XG5cbi8qKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gKi9cbmNvbnN0IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gICAgdDogdmFsdWVUeXBlcy5OVU1CRVIsXG4gICAgbjogMCxcbiAgICB1OiBudWxsLFxuICAgIG86IG51bGwsXG4gICAgZDogbnVsbCxcbiAgICBzOiBudWxsLFxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9IHJhd1ZhbHVlXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlUmF3VmFsdWUgPSAocmF3VmFsdWUsIHRhcmdldE9iamVjdCkgPT4ge1xuICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5OVU1CRVI7XG4gIHRhcmdldE9iamVjdC5uID0gMDtcbiAgdGFyZ2V0T2JqZWN0LnUgPSBudWxsO1xuICB0YXJnZXRPYmplY3QubyA9IG51bGw7XG4gIHRhcmdldE9iamVjdC5kID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LnMgPSBudWxsO1xuICBpZiAoIXJhd1ZhbHVlKSByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICBjb25zdCBudW0gPSArcmF3VmFsdWU7XG4gIGlmICghaXNOYU4obnVtKSkge1xuICAgIC8vIEl0J3MgYSBudW1iZXJcbiAgICB0YXJnZXRPYmplY3QubiA9IG51bTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIGxldCBzdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8ocmF3VmFsdWUpLnRyaW0oKTtcbiAgICBsZXQgc3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHJhd1ZhbHVlKTtcbiAgICAvLyBQYXJzaW5nIG9wZXJhdG9ycyAoKz0sIC09LCAqPSkgbWFudWFsbHkgaXMgbXVjaCBmYXN0ZXIgdGhhbiB1c2luZyByZWdleCBoZXJlXG4gICAgaWYgKHN0clsxXSA9PT0gJz0nKSB7XG4gICAgICB0YXJnZXRPYmplY3QubyA9IHN0clswXTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgICB9XG4gICAgLy8gU2tpcCBleGVjIHJlZ2V4IGlmIHRoZSB2YWx1ZSB0eXBlIGlzIGNvbXBsZXggb3IgY29sb3IgdG8gYXZvaWQgbG9uZyByZWdleCBiYWNrdHJhY2tpbmdcbiAgICBjb25zdCB1bml0TWF0Y2ggPSBzdHIuaW5jbHVkZXMoJyAnKSA/IGZhbHNlIDogdW5pdHNFeGVjUmd4LmV4ZWMoc3RyKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICAvLyBIYXMgYSBudW1iZXIgYW5kIGEgdW5pdFxuICAgICAgdGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICB0YXJnZXRPYmplY3QubiA9ICt1bml0TWF0Y2hbMV07XG4gICAgICB0YXJnZXRPYmplY3QudSA9IHVuaXRNYXRjaFsyXTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRPYmplY3Qubykge1xuICAgICAgLy8gSGFzIGFuIG9wZXJhdG9yICgrPSwgLT0sICo9KVxuICAgICAgdGFyZ2V0T2JqZWN0Lm4gPSArc3RyO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9IGVsc2UgaWYgKGlzQ29sKHN0cikpIHtcbiAgICAgIC8vIElzIGEgY29sb3JcbiAgICAgIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gY29udmVydENvbG9yU3RyaW5nVmFsdWVzVG9SZ2JhQXJyYXkoc3RyKTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElzIGEgbW9yZSBjb21wbGV4IHN0cmluZyAoZ2VuZXJhbGx5IHN2ZyBjb29yZHMsIGNhbGMoKSBvciBmaWx0ZXJzIENTUyB2YWx1ZXMpXG4gICAgICBjb25zdCBtYXRjaGVkTnVtYmVycyA9IHN0ci5tYXRjaChkaWdpdFdpdGhFeHBvbmVudFJneCk7XG4gICAgICB0YXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gbWF0Y2hlZE51bWJlcnMgPyBtYXRjaGVkTnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdO1xuICAgICAgdGFyZ2V0T2JqZWN0LnMgPSBzdHIuc3BsaXQoZGlnaXRXaXRoRXhwb25lbnRSZ3gpIHx8IFtdO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW59IHR3ZWVuXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlVHdlZW5WYWx1ZSA9ICh0d2VlbiwgdGFyZ2V0T2JqZWN0KSA9PiB7XG4gIHRhcmdldE9iamVjdC50ID0gdHdlZW4uX3ZhbHVlVHlwZTtcbiAgdGFyZ2V0T2JqZWN0Lm4gPSB0d2Vlbi5fdG9OdW1iZXI7XG4gIHRhcmdldE9iamVjdC51ID0gdHdlZW4uX3VuaXQ7XG4gIHRhcmdldE9iamVjdC5vID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LmQgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICB0YXJnZXRPYmplY3QucyA9IGNsb25lQXJyYXkodHdlZW4uX3N0cmluZ3MpO1xuICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xufTtcblxuY29uc3QgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcblxuXG5cblxuY29uc3QgbG9va3VwcyA9IHtcbiAgLyoqIEB0eXBlIHtUd2VlblJlcGxhY2VMb29rdXBzfSAqL1xuICBfcmVwOiBuZXcgV2Vha01hcCgpLFxuICAvKiogQHR5cGUge1R3ZWVuQWRkaXRpdmVMb29rdXBzfSAqL1xuICBfYWRkOiBuZXcgTWFwKCksXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGxvb2t1cFxuICogQHJldHVybiB7VHdlZW5Qcm9wZXJ0eVNpYmxpbmdzfVxuICovXG5jb25zdCBnZXRUd2VlblNpYmxpbmdzID0gKHRhcmdldCwgcHJvcGVydHksIGxvb2t1cCA9ICdfcmVwJykgPT4ge1xuICBjb25zdCBsb29rdXBNYXAgPSBsb29rdXBzW2xvb2t1cF07XG4gIGxldCB0YXJnZXRMb29rdXAgPSBsb29rdXBNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TG9va3VwKSB7XG4gICAgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbG9va3VwTWFwLnNldCh0YXJnZXQsIHRhcmdldExvb2t1cCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldExvb2t1cFtwcm9wZXJ0eV0gPyB0YXJnZXRMb29rdXBbcHJvcGVydHldIDogdGFyZ2V0TG9va3VwW3Byb3BlcnR5XSA9IHtcbiAgICBfaGVhZDogbnVsbCxcbiAgICBfdGFpbDogbnVsbCxcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gcFxuICogQHBhcmFtICB7VHdlZW59IGNcbiAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufVxuICovXG5jb25zdCBhZGRUd2VlblNvcnRNZXRob2QgPSAocCwgYykgPT4ge1xuICByZXR1cm4gcC5faXNPdmVycmlkZGVuIHx8IHAuX2Fic29sdXRlU3RhcnRUaW1lID4gYy5fYWJzb2x1dGVTdGFydFRpbWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG4gKi9cbmNvbnN0IG92ZXJyaWRlVHdlZW4gPSB0d2VlbiA9PiB7XG4gIHR3ZWVuLl9pc092ZXJsYXBwZWQgPSAxO1xuICB0d2Vlbi5faXNPdmVycmlkZGVuID0gMTtcbiAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gIHR3ZWVuLl9jdXJyZW50VGltZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEBwYXJhbSAge1R3ZWVuUHJvcGVydHlTaWJsaW5nc30gc2libGluZ3NcbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCBjb21wb3NlVHdlZW4gPSAodHdlZW4sIHNpYmxpbmdzKSA9PiB7XG5cbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvblR5cGUgPSB0d2Vlbi5fY29tcG9zaXRpb247XG5cbiAgLy8gSGFuZGxlIHJlcGxhY2VkIHR3ZWVuc1xuXG4gIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlKSB7XG5cbiAgICBjb25zdCB0d2VlbkFic1N0YXJ0VGltZSA9IHR3ZWVuLl9hYnNvbHV0ZVN0YXJ0VGltZTtcblxuICAgIGFkZENoaWxkKHNpYmxpbmdzLCB0d2VlbiwgYWRkVHdlZW5Tb3J0TWV0aG9kLCAnX3ByZXZSZXAnLCAnX25leHRSZXAnKTtcblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdHdlZW4uX3ByZXZSZXA7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByZXZpb3VzIHNpYmxpbmdzIGZvciBjb21wb3NpdGlvbiByZXBsYWNlIHR3ZWVuc1xuXG4gICAgaWYgKHByZXZTaWJsaW5nKSB7XG5cbiAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBwcmV2U2libGluZy5wYXJlbnQ7XG4gICAgICBjb25zdCBwcmV2QWJzRW5kVGltZSA9IHByZXZTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl9jaGFuZ2VEdXJhdGlvbjtcblxuICAgICAgLy8gSGFuZGxlIGxvb3BlZCBhbmltYXRpb25zIHR3ZWVuXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHR3ZWVuIGlzIGZyb20gYSBkaWZmZXJlbnQgYW5pbWF0aW9uXG4gICAgICAgIHR3ZWVuLnBhcmVudC5pZCAhPT0gcHJldlBhcmVudC5pZCAmJlxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYW5pbWF0aW9uIGhhcyBsb29wc1xuICAgICAgICBwcmV2UGFyZW50Lml0ZXJhdGlvbkNvdW50PiAxICYmXG4gICAgICAgIC8vIENoZWNrIGlmIF9hYnNvbHV0ZUNoYW5nZUVuZFRpbWUgb2YgbGFzdCBsb29wIG92ZXJsYXBzIHRoZSBjdXJyZW50IHR3ZWVuXG4gICAgICAgIHByZXZBYnNFbmRUaW1lICsgKHByZXZQYXJlbnQuZHVyYXRpb24gLSBwcmV2UGFyZW50Lml0ZXJhdGlvbkR1cmF0aW9uKSA+IHR3ZWVuQWJzU3RhcnRUaW1lXG4gICAgICApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIG9ubHkgb3ZlcnJpZGUgdGhlIGl0ZXJhdGlvbnMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgdHdlZW5cbiAgICAgICAgb3ZlcnJpZGVUd2VlbihwcmV2U2libGluZyk7XG5cbiAgICAgICAgbGV0IHByZXZQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLl9wcmV2UmVwO1xuXG4gICAgICAgIC8vIElmIHRoZSB0d2VlbiB3YXMgcGFydCBvZiBhIHNldCBvZiBrZXlmcmFtZXMsIG92ZXJyaWRlIGl0cyBzaWJsaW5nc1xuICAgICAgICB3aGlsZSAocHJldlByZXZTaWJsaW5nICYmIHByZXZQcmV2U2libGluZy5wYXJlbnQuaWQgPT09IHByZXZQYXJlbnQuaWQpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZQcmV2U2libGluZyk7XG4gICAgICAgICAgcHJldlByZXZTaWJsaW5nID0gcHJldlByZXZTaWJsaW5nLl9wcmV2UmVwO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgY29uc3QgYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgPSB0d2VlbkFic1N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheTtcblxuICAgICAgaWYgKHByZXZBYnNFbmRUaW1lID4gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUpIHtcblxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlU3RhcnRUaW1lID0gcHJldlNpYmxpbmcuX3N0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJldlRMT2Zmc2V0ID0gcHJldkFic0VuZFRpbWUgLSAocHJldkNoYW5nZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl91cGRhdGVEdXJhdGlvbik7XG5cbiAgICAgICAgcHJldlNpYmxpbmcuX2NoYW5nZUR1cmF0aW9uID0gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgLSBwcmV2VExPZmZzZXQgLSBwcmV2Q2hhbmdlU3RhcnRUaW1lO1xuICAgICAgICBwcmV2U2libGluZy5fY3VycmVudFRpbWUgPSBwcmV2U2libGluZy5fY2hhbmdlRHVyYXRpb247XG4gICAgICAgIHByZXZTaWJsaW5nLl9pc092ZXJsYXBwZWQgPSAxO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZy5fY2hhbmdlRHVyYXRpb24gPCBtaW5WYWx1ZSkge1xuICAgICAgICAgIG92ZXJyaWRlVHdlZW4ocHJldlNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFBhdXNlIChhbmQgY2FuY2VsKSB0aGUgcGFyZW50IGlmIGl0IG9ubHkgY29udGFpbnMgb3ZlcmxhcHBlZCB0d2VlbnNcblxuICAgICAgbGV0IHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgIGZvckVhY2hDaGlsZHJlbihwcmV2UGFyZW50LCAoLyoqIEB0eXBlIFR3ZWVuICovdCkgPT4ge1xuICAgICAgICBpZiAoIXQuX2lzT3ZlcmxhcHBlZCkgcGF1c2VQcmV2UGFyZW50QW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2UGFyZW50VEwgPSBwcmV2UGFyZW50LnBhcmVudDtcbiAgICAgICAgaWYgKHByZXZQYXJlbnRUTCkge1xuICAgICAgICAgIGxldCBwYXVzZVByZXZQYXJlbnRUTCA9IHRydWU7XG4gICAgICAgICAgZm9yRWFjaENoaWxkcmVuKHByZXZQYXJlbnRUTCwgKC8qKiBAdHlwZSBKU0FuaW1hdGlvbiAqL2EpID0+IHtcbiAgICAgICAgICAgIGlmIChhICE9PSBwcmV2UGFyZW50KSB7XG4gICAgICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihhLCAoLyoqIEB0eXBlIFR3ZWVuICovdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdC5faXNPdmVybGFwcGVkKSBwYXVzZVByZXZQYXJlbnRUTCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGF1c2VQcmV2UGFyZW50VEwpIHtcbiAgICAgICAgICAgIHByZXZQYXJlbnRUTC5jYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlBhcmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAvLyBQcmV2aW91c2x5LCBjYWxsaW5nIC5jYW5jZWwoKSBvbiBhIHRpbWVsaW5lIGNoaWxkIHdvdWxkIGFmZmVjdCB0aGUgcmVuZGVyIG9yZGVyIG9mIG90aGVyIGNoaWxkcmVuXG4gICAgICAgICAgLy8gV29ya2VkIGFyb3VuZCB0aGlzIGJ5IG1hcmtpbmcgaXQgYXMgLmNvbXBsZXRlZCBhbmQgdXNpbmcgLnBhdXNlKCkgZm9yIHNhZmUgcmVtb3ZhbCBpbiB0aGUgZW5naW5lIGxvb3BcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgc2luY2UgdGltZWxpbmUgdHdlZW4gY29tcG9zaXRpb24gaXMgbm93IGhhbmRsZWQgc2VwYXJhdGx5XG4gICAgICAgICAgLy8gS2VlcGluZyB0aGlzIGhlcmUgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgIC8vIHByZXZQYXJlbnQuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwcmV2UGFyZW50LnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGxldCBuZXh0U2libGluZyA9IHR3ZWVuLl9uZXh0UmVwO1xuXG4gICAgLy8gLy8gQWxsIHRoZSBuZXh0IHNpYmxpbmdzIGFyZSBhdXRvbWF0aWNhbGx5IG92ZXJyaWRkZW5cblxuICAgIC8vIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPj0gdHdlZW5BYnNTdGFydFRpbWUpIHtcbiAgICAvLyAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgIC8vICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAvLyAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyBpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcuX2Fic29sdXRlU3RhcnRUaW1lIDwgdHdlZW5BYnNTdGFydFRpbWUpIHtcbiAgICAvLyAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgIC8vICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2codHdlZW4uaWQsIG5leHRTaWJsaW5nLmlkKTtcbiAgICAvLyAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgLy8gSGFuZGxlIGFkZGl0aXZlIHR3ZWVucyBjb21wb3NpdGlvblxuXG4gIH0gZWxzZSBpZiAodHdlZW5Db21wb3NpdGlvblR5cGUgPT09IGNvbXBvc2l0aW9uVHlwZXMuYmxlbmQpIHtcblxuICAgIGNvbnN0IGFkZGl0aXZlVHdlZW5TaWJsaW5ncyA9IGdldFR3ZWVuU2libGluZ3ModHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgJ19hZGQnKTtcbiAgICBjb25zdCBhZGRpdGl2ZUFuaW1hdGlvbiA9IGFkZEFkZGl0aXZlQW5pbWF0aW9uKGxvb2t1cHMuX2FkZCk7XG5cbiAgICBsZXQgbG9va3VwVHdlZW4gPSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX2hlYWQ7XG5cbiAgICBpZiAoIWxvb2t1cFR3ZWVuKSB7XG4gICAgICBsb29rdXBUd2VlbiA9IHsgLi4udHdlZW4gfTtcbiAgICAgIGxvb2t1cFR3ZWVuLl9jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICAgIGxvb2t1cFR3ZWVuLl91cGRhdGVEdXJhdGlvbiA9IG1pblZhbHVlO1xuICAgICAgbG9va3VwVHdlZW4uX3N0YXJ0VGltZSA9IDA7XG4gICAgICBsb29rdXBUd2Vlbi5fbnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX2Zyb21OdW1iZXJzKTtcbiAgICAgIGxvb2t1cFR3ZWVuLl9udW1iZXIgPSAwO1xuICAgICAgbG9va3VwVHdlZW4uX25leHQgPSBudWxsO1xuICAgICAgbG9va3VwVHdlZW4uX3ByZXYgPSBudWxsO1xuICAgICAgYWRkQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCBsb29rdXBUd2Vlbik7XG4gICAgICBhZGRDaGlsZChhZGRpdGl2ZUFuaW1hdGlvbiwgbG9va3VwVHdlZW4pO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlcyBvZiBUTyB0byBGUk9NIGFuZCBzZXQgVE8gdG8gMFxuXG4gICAgY29uc3QgdG9OdW1iZXIgPSB0d2Vlbi5fdG9OdW1iZXI7XG4gICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlciAtIHRvTnVtYmVyO1xuICAgIHR3ZWVuLl90b051bWJlciA9IDA7XG4gICAgdHdlZW4uX251bWJlcnMgPSBjbG9uZUFycmF5KHR3ZWVuLl9mcm9tTnVtYmVycyk7XG4gICAgdHdlZW4uX251bWJlciA9IDA7XG4gICAgbG9va3VwVHdlZW4uX2Zyb21OdW1iZXIgPSB0b051bWJlcjtcblxuICAgIGlmICh0d2Vlbi5fdG9OdW1iZXJzKSB7XG4gICAgICBjb25zdCB0b051bWJlcnMgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICAgICAgaWYgKHRvTnVtYmVycykge1xuICAgICAgICB0b051bWJlcnMuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICB0d2Vlbi5fZnJvbU51bWJlcnNbaV0gPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnNbaV0gLSB2YWx1ZTtcbiAgICAgICAgICB0d2Vlbi5fdG9OdW1iZXJzW2ldID0gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnMgPSB0b051bWJlcnM7XG4gICAgfVxuXG4gICAgYWRkQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCB0d2VlbiwgbnVsbCwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG5cbiAgfVxuXG4gIHJldHVybiB0d2VlbjtcblxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCByZW1vdmVUd2VlblNsaWJsaW5ncyA9IHR3ZWVuID0+IHtcbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgIGNvbnN0IHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICBjb25zdCByZXBsYWNlVHdlZW5zTG9va3VwID0gbG9va3Vwcy5fcmVwO1xuICAgIGNvbnN0IHJlcGxhY2VUYXJnZXRQcm9wcyA9IHJlcGxhY2VUd2VlbnNMb29rdXAuZ2V0KHR3ZWVuVGFyZ2V0KTtcbiAgICBjb25zdCB0d2VlblJlcGxhY2VTaWJsaW5ncyA9IHJlcGxhY2VUYXJnZXRQcm9wc1t0d2VlblByb3BlcnR5XTtcbiAgICByZW1vdmVDaGlsZCh0d2VlblJlcGxhY2VTaWJsaW5ncywgdHdlZW4sICdfcHJldlJlcCcsICdfbmV4dFJlcCcpO1xuICAgIGlmICh0d2VlbkNvbXBvc2l0aW9uID09PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG4gICAgICBjb25zdCBhZGRUd2VlbnNMb29rdXAgPSBsb29rdXBzLl9hZGQ7XG4gICAgICBjb25zdCBhZGRUYXJnZXRQcm9wcyA9IGFkZFR3ZWVuc0xvb2t1cC5nZXQodHdlZW5UYXJnZXQpO1xuICAgICAgaWYgKCFhZGRUYXJnZXRQcm9wcykgcmV0dXJuO1xuICAgICAgY29uc3QgYWRkaXRpdmVUd2VlblNpYmxpbmdzID0gYWRkVGFyZ2V0UHJvcHNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICBjb25zdCBhZGRpdGl2ZUFuaW1hdGlvbiA9IGFkZGl0aXZlLmFuaW1hdGlvbjtcbiAgICAgIHJlbW92ZUNoaWxkKGFkZGl0aXZlVHdlZW5TaWJsaW5ncywgdHdlZW4sICdfcHJldkFkZCcsICdfbmV4dEFkZCcpO1xuICAgICAgLy8gSWYgb25seSBvbmUgdHdlZW4gaXMgbGVmdCBpbiB0aGUgYWRkaXRpdmUgbG9va3VwLCBpdCdzIHRoZSB0d2VlbiBsb29rdXBcbiAgICAgIGNvbnN0IGxvb2t1cFR3ZWVuID0gYWRkaXRpdmVUd2VlblNpYmxpbmdzLl9oZWFkO1xuICAgICAgaWYgKGxvb2t1cFR3ZWVuICYmIGxvb2t1cFR3ZWVuID09PSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX3RhaWwpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCBsb29rdXBUd2VlbiwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG4gICAgICAgIHJlbW92ZUNoaWxkKGFkZGl0aXZlQW5pbWF0aW9uLCBsb29rdXBUd2Vlbik7XG4gICAgICAgIGxldCBzaG91bGRDbGVhbiA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gYWRkVGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICBpZiAoYWRkVGFyZ2V0UHJvcHNbcHJvcF0uX2hlYWQpIHtcbiAgICAgICAgICAgIHNob3VsZENsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENsZWFuKSB7XG4gICAgICAgICAgYWRkVHdlZW5zTG9va3VwLmRlbGV0ZSh0d2VlblRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR3ZWVuO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtUaW1lcn0gdGltZXJcbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCByZXNldFRpbWVyUHJvcGVydGllcyA9IHRpbWVyID0+IHtcbiAgdGltZXIucGF1c2VkID0gdHJ1ZTtcbiAgdGltZXIuYmVnYW4gPSBmYWxzZTtcbiAgdGltZXIuY29tcGxldGVkID0gZmFsc2U7XG4gIHJldHVybiB0aW1lcjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGltZXJ9IHRpbWVyXG4gKiBAcmV0dXJuIHtUaW1lcn1cbiAqL1xuY29uc3QgcmV2aXZlVGltZXIgPSB0aW1lciA9PiB7XG4gIGlmICghdGltZXIuX2NhbmNlbGxlZCkgcmV0dXJuIHRpbWVyO1xuICBpZiAodGltZXIuX2hhc0NoaWxkcmVuKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRpbWVyLCByZXZpdmVUaW1lcik7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRpbWVyLCAoLyoqIEB0eXBlIHtUd2Vlbn0gdHdlZW4qL3R3ZWVuKSA9PiB7XG4gICAgICBpZiAodHdlZW4uX2NvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmUpIHtcbiAgICAgICAgY29tcG9zZVR3ZWVuKHR3ZWVuLCBnZXRUd2VlblNpYmxpbmdzKHR3ZWVuLnRhcmdldCwgdHdlZW4ucHJvcGVydHkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aW1lci5fY2FuY2VsbGVkID0gMDtcbiAgcmV0dXJuIHRpbWVyO1xufTtcblxubGV0IHRpbWVySWQgPSAwO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdXNlZCB0byBjcmVhdGUgVGltZXJzLCBBbmltYXRpb25zIGFuZCBUaW1lbGluZXNcbiAqL1xuY2xhc3MgVGltZXIgZXh0ZW5kcyBDbG9jayB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICogQHBhcmFtIHtUaW1lbGluZX0gW3BhcmVudF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRQb3NpdGlvbl1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSwgcGFyZW50ID0gbnVsbCwgcGFyZW50UG9zaXRpb24gPSAwKSB7XG5cbiAgICBzdXBlcigwKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZGVsYXksXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHJldmVyc2VkLFxuICAgICAgYWx0ZXJuYXRlLFxuICAgICAgbG9vcCxcbiAgICAgIGxvb3BEZWxheSxcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgZnJhbWVSYXRlLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uTG9vcCxcbiAgICAgIG9uUGF1c2UsXG4gICAgICBvbkJlZ2luLFxuICAgICAgb25CZWZvcmVVcGRhdGUsXG4gICAgICBvblVwZGF0ZSxcbiAgICB9ID0gcGFyYW1ldGVycztcblxuICAgIGlmIChnbG9iYWxzLnNjb3BlKSBnbG9iYWxzLnNjb3BlLnJldmVydGlibGVzLnB1c2godGhpcyk7XG5cbiAgICBjb25zdCB0aW1lckluaXRUaW1lID0gcGFyZW50ID8gMCA6IGVuZ2luZS5fZWxhcHNlZFRpbWU7XG4gICAgY29uc3QgdGltZXJEZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgdGltZXJEZWxheSA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhpc0ZuYyhkZWxheSkgfHwgaXNVbmQoZGVsYXkpID8gdGltZXJEZWZhdWx0cy5kZWxheSA6ICtkZWxheSk7XG4gICAgY29uc3QgdGltZXJEdXJhdGlvbiA9IGlzRm5jKGR1cmF0aW9uKSB8fCBpc1VuZChkdXJhdGlvbikgPyBJbmZpbml0eSA6ICtkdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lckxvb3AgPSBzZXRWYWx1ZShsb29wLCB0aW1lckRlZmF1bHRzLmxvb3ApO1xuICAgIGNvbnN0IHRpbWVyTG9vcERlbGF5ID0gc2V0VmFsdWUobG9vcERlbGF5LCB0aW1lckRlZmF1bHRzLmxvb3BEZWxheSk7XG4gICAgY29uc3QgdGltZXJJdGVyYXRpb25Db3VudCA9IHRpbWVyTG9vcCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvb3AgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0aW1lckxvb3ApIDwgMCA/IEluZmluaXR5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRpbWVyTG9vcCkgKyAxO1xuXG4gICAgbGV0IG9mZnNldFBvc2l0aW9uID0gMDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG9mZnNldFBvc2l0aW9uID0gcGFyZW50UG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byB0aWNrIHRoZSBlbmdpbmUgb25jZSBpZiBzdXNwZW5kZWQgdG8gYXZvaWQgYmlnIGdhcHMgd2l0aCB0aGUgZm9sbG93aW5nIG9mZnNldFBvc2l0aW9uIGNhbGN1bGF0aW9uXG4gICAgICBpZiAoZW5naW5lLnBhdXNlZCkge1xuICAgICAgICBlbmdpbmUucmVxdWVzdFRpY2soc3RhcnRUaW1lKTtcbiAgICAgICAgc3RhcnRUaW1lID0gZW5naW5lLl9lbGFwc2VkVGltZTtcbiAgICAgIH1cbiAgICAgIG9mZnNldFBvc2l0aW9uID0gc3RhcnRUaW1lIC0gZW5naW5lLl9zdGFydFRpbWU7XG4gICAgfVxuXG4gICAgLy8gVGltZXIncyBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pZCA9ICFpc1VuZChpZCkgPyBpZCA6ICsrdGltZXJJZDtcbiAgICAvKiogQHR5cGUge1RpbWVsaW5lfSAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8vIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0aW1lclxuICAgIHRoaXMuZHVyYXRpb24gPSBjbGFtcEluZmluaXR5KCgodGltZXJEdXJhdGlvbiArIHRpbWVyTG9vcERlbGF5KSAqIHRpbWVySXRlcmF0aW9uQ291bnQpIC0gdGltZXJMb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25CZWdpbiA9IG9uQmVnaW4gfHwgdGltZXJEZWZhdWx0cy5vbkJlZ2luO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vbkJlZm9yZVVwZGF0ZSA9IG9uQmVmb3JlVXBkYXRlIHx8IHRpbWVyRGVmYXVsdHMub25CZWZvcmVVcGRhdGU7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGUgfHwgdGltZXJEZWZhdWx0cy5vblVwZGF0ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Mb29wID0gb25Mb29wIHx8IHRpbWVyRGVmYXVsdHMub25Mb29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblBhdXNlID0gb25QYXVzZSB8fCB0aW1lckRlZmF1bHRzLm9uUGF1c2U7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IHRpbWVyRGVmYXVsdHMub25Db21wbGV0ZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGltZXJEdXJhdGlvbjsgLy8gRHVyYXRpb24gb2Ygb25lIGxvb3BcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gdGltZXJJdGVyYXRpb25Db3VudDsgLy8gTnVtYmVyIG9mIGxvb3BzXG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX2F1dG9wbGF5ID0gcGFyZW50ID8gZmFsc2UgOiBzZXRWYWx1ZShhdXRvcGxheSwgdGltZXJEZWZhdWx0cy5hdXRvcGxheSk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0UG9zaXRpb247XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lckRlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xvb3BEZWxheSA9IHRpbWVyTG9vcERlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2l0ZXJhdGlvblRpbWUgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24gPSAwOyAvLyBDdXJyZW50IGxvb3AgaW5kZXhcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3JldmVyc2VkID0gK3NldFZhbHVlKHJldmVyc2VkLCB0aW1lckRlZmF1bHRzLnJldmVyc2VkKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9yZXZlcnNlID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fYWx0ZXJuYXRlID0gc2V0VmFsdWUoYWx0ZXJuYXRlLCB0aW1lckRlZmF1bHRzLmFsdGVybmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcblxuICAgIC8vIENsb2NrJ3MgcGFyYW1ldGVyc1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lckluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcHMgPSBzZXRWYWx1ZShmcmFtZVJhdGUsIHRpbWVyRGVmYXVsdHMuZnJhbWVSYXRlKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBsYXliYWNrUmF0ZSwgdGltZXJEZWZhdWx0cy5wbGF5YmFja1JhdGUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9jYW5jZWxsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxsZWQgICovXG4gIHNldCBjYW5jZWxsZWQoY2FuY2VsbGVkKSB7XG4gICAgY2FuY2VsbGVkID8gdGhpcy5jYW5jZWwoKSA6IHRoaXMucmVzZXQoMSkucGxheSgpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9jdXJyZW50VGltZSwgZ2xvYmFscy5wcmVjaXNpb24pLCAtdGhpcy5fZGVsYXksIHRoaXMuZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgIGNvbnN0IHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0aW1lIGp1bXBzIG9uIGEgcnVubmluZyBpbnN0YW5jZVxuICAgIHRoaXMucGF1c2UoKS5zZWVrKCt0aW1lKTtcbiAgICBpZiAoIXBhdXNlZCkgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25DdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gcm91bmQodGhpcy5faXRlcmF0aW9uVGltZSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgaXRlcmF0aW9uQ3VycmVudFRpbWUodGltZSkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgdGltZTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uLCA1KSwgMCwgMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzICAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5kdXJhdGlvbiAqIHByb2dyZXNzO1xuICB9XG5cbiAgZ2V0IGl0ZXJhdGlvblByb2dyZXNzKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9pdGVyYXRpb25UaW1lIC8gdGhpcy5pdGVyYXRpb25EdXJhdGlvbiwgNSksIDAsIDEpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAgKi9cbiAgc2V0IGl0ZXJhdGlvblByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAoaXRlcmF0aW9uRHVyYXRpb24gKiB0aGlzLl9jdXJyZW50SXRlcmF0aW9uKSArIChpdGVyYXRpb25EdXJhdGlvbiAqIHByb2dyZXNzKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50SXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50SXRlcmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRpb25Db3VudCAgKi9cbiAgc2V0IGN1cnJlbnRJdGVyYXRpb24oaXRlcmF0aW9uQ291bnQpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gKHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gKiBjbGFtcCgraXRlcmF0aW9uQ291bnQsIDAsIHRoaXMuaXRlcmF0aW9uQ291bnQgLSAxKSk7XG4gIH1cblxuICBnZXQgcmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcmV2ZXJzZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSByZXZlcnNlICAqL1xuICBzZXQgcmV2ZXJzZWQocmV2ZXJzZSkge1xuICAgIHJldmVyc2UgPyB0aGlzLnJldmVyc2UoKSA6IHRoaXMucGxheSgpO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiBzdXBlci5zcGVlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge051bWJlcn0gcGxheWJhY2tSYXRlICAqL1xuICBzZXQgc3BlZWQocGxheWJhY2tSYXRlKSB7XG4gICAgc3VwZXIuc3BlZWQgPSBwbGF5YmFja1JhdGU7XG4gICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVybmFsUmVuZGVyXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXNldChpbnRlcm5hbFJlbmRlciA9IDApIHtcbiAgICAvLyBJZiBjYW5jZWxsZWQsIHJldml2ZSB0aGUgdGltZXIgYmVmb3JlIHJlbmRlcmluZyBpbiBvcmRlciB0byBoYXZlIHByb3BlcnRseSBjb21wb3NlZCB0d2VlbnMgc2libGluZ3NcbiAgICByZXZpdmVUaW1lcih0aGlzKTtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZWQgJiYgIXRoaXMuX3JldmVyc2UpIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAvLyBSZW5kZXJpbmcgYmVmb3JlIHVwZGF0aW5nIHRoZSBjb21wbGV0ZWQgZmxhZyB0byBwcmV2ZW50IHNraXBzIGFuZCB0byBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBvdmVycmlkZGVuXG4gICAgLy8gU2V0dGluZyB0aGUgaXRlcmF0aW9uVGltZSBhdCB0aGUgZW5kIHRvIGZvcmNlIHRoZSByZW5kZXJpbmcgdG8gaGFwcGVuZCBiYWNrd2FyZHMsIG90aGVyd2lzZSBjYWxsaW5nIC5yZXNldCgpIG9uIFRpbWVsaW5lcyBtaWdodCBub3QgcmVuZGVyIGNoaWxkcmVuIGluIHRoZSByaWdodCBvcmRlclxuICAgIC8vIE5PVEU6IFRoaXMgaXMgb25seSByZXF1aXJlZCBmb3IgVGltZWxpbmVzIGFuZCBtaWdodCBiZSBiZXR0ZXIgdG8gbW92ZSB0byB0aGUgVGltZWxpbmUgY2xhc3M/XG4gICAgdGhpcy5faXRlcmF0aW9uVGltZSA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgLy8gU2V0IHRpY2tNb2RlIHRvIHRpY2tNb2Rlcy5GT1JDRSB0byBmb3JjZSByZW5kZXJpbmdcbiAgICB0aWNrKHRoaXMsIDAsIDEsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIC8vIFJlc2V0IHRpbWVyIHByb3BlcnRpZXMgYWZ0ZXIgcmV2aXZlIC8gcmVuZGVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJvcHMgYXJlIG5vdCB1cGRhdGVkIGFnYWluXG4gICAgcmVzZXRUaW1lclByb3BlcnRpZXModGhpcyk7XG4gICAgLy8gQWxzbyByZXNldCBjaGlsZHJlbiBwcm9wZXJ0aWVzXG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgcmVzZXRUaW1lclByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVybmFsUmVuZGVyXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBpbml0KGludGVybmFsUmVuZGVyID0gMCkge1xuICAgIHRoaXMuZnBzID0gdGhpcy5fZnBzO1xuICAgIHRoaXMuc3BlZWQgPSB0aGlzLl9zcGVlZDtcbiAgICAvLyBNYW51YWxseSBjYWxsaW5nIC5pbml0KCkgb24gdGltZWxpbmVzIHNob3VsZCByZW5kZXIgYWxsIGNoaWxkcmVuIGludGlhbCBzdGF0ZVxuICAgIC8vIEZvcmNlcyBhbGwgY2hpbGRyZW4gdG8gcmVuZGVyIG9uY2UgdGhlbiByZW5kZXIgdG8gMCB3aGVuIHJlc2V0ZWRcbiAgICBpZiAoIWludGVybmFsUmVuZGVyICYmIHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICB0aWNrKHRoaXMsIHRoaXMuZHVyYXRpb24sIDEsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KGludGVybmFsUmVuZGVyKTtcbiAgICAvLyBNYWtlIHN1cmUgdG8gc2V0IGF1dG9wbGF5IHRvIGZhbHNlIHRvIGNoaWxkIHRpbWVycyBzbyBpdCBkb2Vzbid0IGF0dGVtcHQgdG8gYXV0b3BsYXkgLyBsaW5rXG4gICAgY29uc3QgYXV0b3BsYXkgPSB0aGlzLl9hdXRvcGxheTtcbiAgICBpZiAoYXV0b3BsYXkgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgfSBlbHNlIGlmIChhdXRvcGxheSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8oYXV0b3BsYXkpLmxpbmtlZCkpIHtcbiAgICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKGF1dG9wbGF5KS5saW5rKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXNldFRpbWUoKSB7XG4gICAgY29uc3QgdGltZVNjYWxlID0gMSAvICh0aGlzLl9zcGVlZCAqIGVuZ2luZS5fc3BlZWQpO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5vdygpIC0gKHRoaXMuX2N1cnJlbnRUaW1lICsgdGhpcy5fZGVsYXkpICogdGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMub25QYXVzZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKCF0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAvLyBXZSBjYW4gc2FmZWx5IGltZWRpYXRseSByZW5kZXIgYSB0aW1lciB0aGF0IGhhcyBubyBkdXJhdGlvbiBhbmQgbm8gY2hpbGRyZW5cbiAgICBpZiAodGhpcy5kdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAhdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIHRpY2sodGhpcywgbWluVmFsdWUsIDAsIDAsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICBhZGRDaGlsZChlbmdpbmUsIHRoaXMpO1xuICAgICAgICBlbmdpbmUuX2hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VGltZSgpO1xuICAgICAgLy8gRm9yY2VzIHRoZSB0aW1lciB0byBhZHZhbmNlIGJ5IGF0IGxlYXN0IG9uZSBmcmFtZSB3aGVuIHRoZSBuZXh0IHRpY2sgb2NjdXJzXG4gICAgICB0aGlzLl9zdGFydFRpbWUgLT0gMTI7XG4gICAgICBlbmdpbmUud2FrZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc2V0KDApLnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcGFyYW0gIHtCb29sZWFufE51bWJlcn0gW211dGVDYWxsYmFja3NdXG4gICAqIEBwYXJhbSAge0Jvb2xlYW58TnVtYmVyfSBbaW50ZXJuYWxSZW5kZXJdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSAwLCBpbnRlcm5hbFJlbmRlciA9IDApIHtcbiAgICAvLyBSZWNvbXBvc2UgdGhlIHR3ZWVuIHNpYmxpbmdzIGluIGNhc2UgdGhlIHRpbWVyIGhhcyBiZWVuIGNhbmNlbGxlZFxuICAgIHJldml2ZVRpbWVyKHRoaXMpO1xuICAgIC8vIElmIHlvdSBzZWVrIGEgY29tcGxldGVkIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIHRoZSBuZXh0IHBsYXkgd2lsbCBzdGFydHMgYXQgMFxuICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XG4gICAgY29uc3QgaXNQYXVzZWQgPSB0aGlzLnBhdXNlZDtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLy8gdGltZXIsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZVxuICAgIHRpY2sodGhpcywgdGltZSArIHRoaXMuX2RlbGF5LCB+fm11dGVDYWxsYmFja3MsIH5+aW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgICByZXR1cm4gaXNQYXVzZWQgPyB0aGlzIDogdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBhbHRlcm5hdGUoKSB7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLl9yZXZlcnNlZDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuaXRlcmF0aW9uQ291bnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBpdGVyYXRpb25zIHBvc3NpYmxlIGdpdmVuIHRoZSBpdGVyYXRpb24gZHVyYXRpb25cbiAgICBjb25zdCBpdGVyYXRpb25zID0gY291bnQgPT09IEluZmluaXR5ID8gZmxvb3IobWF4VmFsdWUgLyBkdXJhdGlvbikgOiBjb3VudDtcbiAgICB0aGlzLl9yZXZlcnNlZCA9ICsodGhpcy5fYWx0ZXJuYXRlICYmICEoaXRlcmF0aW9ucyAlIDIpID8gcmV2ZXJzZWQgOiAhcmV2ZXJzZWQpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHtcbiAgICAgIC8vIEhhbmRsZSBpbmZpbml0ZSBsb29wcyB0byBsb29wIG9uIHRoZW1zZWxmXG4gICAgICB0aGlzLml0ZXJhdGlvblByb2dyZXNzID0gdGhpcy5fcmV2ZXJzZWQgPyAxIC0gdGhpcy5pdGVyYXRpb25Qcm9ncmVzcyA6IHRoaXMuaXRlcmF0aW9uUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VlaygoZHVyYXRpb24gKiBpdGVyYXRpb25zKSAtIHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXZlcnNlKCkge1xuICAgIGlmICghdGhpcy5fcmV2ZXJzZWQpIHRoaXMuYWx0ZXJuYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvLyBUT0RPOiBNb3ZlIGFsbCB0aGUgYW5pbWF0aW9uIC8gdHdlZW5zIC8gY2hpbGRyZW4gcmVsYXRlZCBjb2RlIHRvIEFuaW1hdGlvbiAvIFRpbWVsaW5lXG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL2NoaWxkKSA9PiBjaGlsZC5jYW5jZWwoKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCByZW1vdmVUd2VlblNsaWJsaW5ncyk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxlZCA9IDE7XG4gICAgLy8gUGF1c2luZyB0aGUgdGltZXIgcmVtb3ZlcyBpdCBmcm9tIHRoZSBlbmdpbmVcbiAgICByZXR1cm4gdGhpcy5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGNvbnN0IG5vcm1saXplZER1cmF0aW9uID0gbm9ybWFsaXplVGltZShuZXdEdXJhdGlvbik7XG4gICAgaWYgKGN1cnJlbnREdXJhdGlvbiA9PT0gbm9ybWxpemVkRHVyYXRpb24pIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IG5ld0R1cmF0aW9uIC8gY3VycmVudER1cmF0aW9uO1xuICAgIGNvbnN0IGlzU2V0dGVyID0gbmV3RHVyYXRpb24gPD0gbWluVmFsdWU7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGlzU2V0dGVyID8gbWluVmFsdWUgOiBub3JtbGl6ZWREdXJhdGlvbjtcbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gaXNTZXR0ZXIgPyBtaW5WYWx1ZSA6IG5vcm1hbGl6ZVRpbWUodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgdGhpcy5fb2Zmc2V0ICo9IHRpbWVTY2FsZTtcbiAgICB0aGlzLl9kZWxheSAqPSB0aW1lU2NhbGU7XG4gICAgdGhpcy5fbG9vcERlbGF5ICo9IHRpbWVTY2FsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gLyoqXG4gICAqIENhbmNlbHMgdGhlIHRpbWVyIGJ5IHNlZWtpbmcgaXQgYmFjayB0byAwIGFuZCByZXZlcnRpbmcgdGhlIGF0dGFjaGVkIHNjcm9sbGVyIGlmIG5lY2Vzc2FyeVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHRpY2sodGhpcywgMCwgMSwgMCwgdGlja01vZGVzLkFVVE8pO1xuICAgIGNvbnN0IGFwID0gLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8odGhpcy5fYXV0b3BsYXkpO1xuICAgIGlmIChhcCAmJiBhcC5saW5rZWQgJiYgYXAubGlua2VkID09PSB0aGlzKSBhcC5yZXZlcnQoKTtcbiAgICByZXR1cm4gdGhpcy5jYW5jZWwoKTtcbiAgfVxuXG4gLyoqXG4gICAqIEltZWRpYXRseSBjb21wbGV0ZXMgdGhlIHRpbWVyLCBjYW5jZWxzIGl0IGFuZCB0cmlnZ2VycyB0aGUgb25Db21wbGV0ZSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKS5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYWxsYmFjazx0aGlzPn0gW2NhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdGhlbihjYWxsYmFjayA9IG5vb3ApIHtcbiAgICBjb25zdCB0aGVuID0gdGhpcy50aGVuO1xuICAgIGNvbnN0IG9uUmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgIC8vIHRoaXMudGhlbiA9IG51bGwgcHJldmVudHMgaW5maW5pdGUgcmVjdXJzaW9uIGlmIHJldHVybmVkIGJ5IGFuIGFzeW5jIGZ1bmN0aW9uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllcm9yZy9hbmltZS1iZXRhL2lzc3Vlcy8yNlxuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlc29sdmUgaW1lZGlhdGx5IGlmIHRoZSB0aW1lciBoYXMgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCkgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtUaW1lclBhcmFtc30gW3BhcmFtZXRlcnNdXG4gKiBAcmV0dXJuIHtUaW1lcn1cbiAqL1xuY29uc3QgY3JlYXRlVGltZXIgPSBwYXJhbWV0ZXJzID0+IG5ldyBUaW1lcihwYXJhbWV0ZXJzLCBudWxsLCAwKS5pbml0KCk7XG5cblxuXG5cbi8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG5jb25zdCBub25lID0gdCA9PiB0O1xuXG4vLyBDdWJpYyBCZXppZXIgc29sdmVyIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNlIMKpIEdhw6t0YW4gUmVuYXVkZWF1XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBhVFxuICogQHBhcmFtICB7TnVtYmVyfSBhQTFcbiAqIEBwYXJhbSAge051bWJlcn0gYUEyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNhbGNCZXppZXIgPSAoYVQsIGFBMSwgYUEyKSA9PiAoKCgxIC0gMyAqIGFBMiArIDMgKiBhQTEpICogYVQgKyAoMyAqIGFBMiAtIDYgKiBhQTEpKSAqIGFUICsgKDMgKiBhQTEpKSAqIGFUO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gYVhcbiAqIEBwYXJhbSAge051bWJlcn0gbVgxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1YMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBiaW5hcnlTdWJkaXZpZGUgPSAoYVgsIG1YMSwgbVgyKSA9PiB7XG4gIGxldCBhQSA9IDAsIGFCID0gMSwgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKGFicyhjdXJyZW50WCkgPiAuMDAwMDAwMSAmJiArK2kgPCAxMDApO1xuICByZXR1cm4gY3VycmVudFQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gW21YMV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21YMl1cbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMl1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGN1YmljQmV6aWVyID0gKG1YMSA9IDAuNSwgbVkxID0gMC4wLCBtWDIgPSAwLjUsIG1ZMiA9IDEuMCkgPT4gKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSA/IG5vbmUgOlxuICB0ID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOlxuICBjYWxjQmV6aWVyKGJpbmFyeVN1YmRpdmlkZSh0LCBtWDEsIG1YMiksIG1ZMSwgbVkyKTtcblxuLyoqXG4gKiBTdGVwcyBlYXNlIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuICogT25seSBjb3ZlcnMgJ2VuZCcgYW5kICdzdGFydCcganVtcHRlcm1zXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0ZXBzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZnJvbVN0YXJ0XVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IHN0ZXBzID0gKHN0ZXBzID0gMTAsIGZyb21TdGFydCkgPT4ge1xuICBjb25zdCByb3VuZE1ldGhvZCA9IGZyb21TdGFydCA/IGNlaWwgOiBmbG9vcjtcbiAgcmV0dXJuIHQgPT4gcm91bmRNZXRob2QoY2xhbXAodCwgMCwgMSkgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTtcbn07XG5cbi8qKlxuICogV2l0aG91dCBwYXJhbWV0ZXJzLCB0aGUgbGluZWFyIGZ1bmN0aW9uIGNyZWF0ZXMgYSBub24tZWFzZWQgdHJhbnNpdGlvbi5cbiAqIFBhcmFtZXRlcnMsIGlmIHVzZWQsIGNyZWF0ZXMgYSBwaWVjZXdpc2UgbGluZWFyIGVhc2luZyBieSBpbnRlcnBvbGF0aW5nIGxpbmVhcmx5IGJldHdlZW4gdGhlIHNwZWNpZmllZCBwb2ludHMuXG4gKiBAcGFyYW0gIHsuLi5TdHJpbmd8TnVtYmVyfSBbYXJnc10gLSBQb2ludHNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBsaW5lYXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIGlmICghYXJnc0xlbmd0aCkgcmV0dXJuIG5vbmU7XG4gIGNvbnN0IHRvdGFsUG9pbnRzID0gYXJnc0xlbmd0aCAtIDE7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbdG90YWxQb2ludHNdO1xuICBjb25zdCB4UG9pbnRzID0gWzBdO1xuICBjb25zdCB5UG9pbnRzID0gW3BhcnNlTnVtYmVyKGZpcnN0QXJnKV07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxQb2ludHM7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgY29uc3Qgc3BsaXRWYWx1ZSA9IGlzU3RyKGFyZykgP1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhhcmcpLnRyaW0oKS5zcGxpdCgnICcpIDpcbiAgICBbYXJnXTtcbiAgICBjb25zdCB2YWx1ZSA9IHNwbGl0VmFsdWVbMF07XG4gICAgY29uc3QgcGVyY2VudCA9IHNwbGl0VmFsdWVbMV07XG4gICAgeFBvaW50cy5wdXNoKCFpc1VuZChwZXJjZW50KSA/IHBhcnNlTnVtYmVyKHBlcmNlbnQpIC8gMTAwIDogaSAvIHRvdGFsUG9pbnRzKTtcbiAgICB5UG9pbnRzLnB1c2gocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICB5UG9pbnRzLnB1c2gocGFyc2VOdW1iZXIobGFzdEFyZykpO1xuICB4UG9pbnRzLnB1c2goMSk7XG4gIHJldHVybiBmdW5jdGlvbiBlYXNlTGluZWFyKHQpIHtcbiAgICBmb3IgKGxldCBpID0gMSwgbCA9IHhQb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50WCA9IHhQb2ludHNbaV07XG4gICAgICBpZiAodCA8PSBjdXJyZW50WCkge1xuICAgICAgICBjb25zdCBwcmV2WCA9IHhQb2ludHNbaSAtIDFdO1xuICAgICAgICBjb25zdCBwcmV2WSA9IHlQb2ludHNbaSAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlkgKyAoeVBvaW50c1tpXSAtIHByZXZZKSAqICh0IC0gcHJldlgpIC8gKGN1cnJlbnRYIC0gcHJldlgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geVBvaW50c1t5UG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHJhbmRvbSBzdGVwc1xuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXSAtIFRoZSBudW1iZXIgb2Ygc3RlcHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3JhbmRvbW5lc3NdIC0gSG93IHN0cm9uZyB0aGUgcmFuZG9tbmVzcyBpc1xuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IGlycmVndWxhciA9IChsZW5ndGggPSAxMCwgcmFuZG9tbmVzcyA9IDEpID0+IHtcbiAgY29uc3QgdmFsdWVzID0gWzBdO1xuICBjb25zdCB0b3RhbCA9IGxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWw7IGkrKykge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB2YWx1ZXNbaSAtIDFdO1xuICAgIGNvbnN0IHNwYWNpbmcgPSBpIC8gdG90YWw7XG4gICAgY29uc3Qgc2VnbWVudEVuZCA9IChpICsgMSkgLyB0b3RhbDtcbiAgICBjb25zdCByYW5kb21WYXJpYXRpb24gPSBzcGFjaW5nICsgKHNlZ21lbnRFbmQgLSBzcGFjaW5nKSAqIE1hdGgucmFuZG9tKCk7XG4gICAgLy8gTWl4IHRoZSBldmVuIHNwYWNpbmcgYW5kIHJhbmRvbSB2YXJpYXRpb24gYmFzZWQgb24gdGhlIHJhbmRvbW5lc3MgcGFyYW1ldGVyXG4gICAgY29uc3QgcmFuZG9tVmFsdWUgPSBzcGFjaW5nICogKDEgLSByYW5kb21uZXNzKSArIHJhbmRvbVZhcmlhdGlvbiAqIHJhbmRvbW5lc3M7XG4gICAgdmFsdWVzLnB1c2goY2xhbXAocmFuZG9tVmFsdWUsIHByZXZpb3VzVmFsdWUsIDEpKTtcbiAgfVxuICB2YWx1ZXMucHVzaCgxKTtcbiAgcmV0dXJuIGxpbmVhciguLi52YWx1ZXMpO1xufTtcblxuLy8gRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2UgwqkgUm9iZXJ0IFBlbm5lclxuXG4vKipcbiAqIEBjYWxsYmFjayBQb3dlckVhc2luZ1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbcG93ZXI9MS42NzVdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBCYWNrRWFzaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvdmVyc2hvb3Q9MS43MDE1OF1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsYXN0aWNFYXNpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2FtcGxpdHVkZT0xXVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbcGVyaW9kPS4zXVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWFzZUZhY3RvcnlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BhcmFtQV1cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BhcmFtQl1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufE51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGVkZWYge1Bvd2VyRWFzaW5nfEJhY2tFYXNpbmd8RWxhc3RpY0Vhc2luZ30gRWFzZXNGYWN0b3J5ICovXG5cbmNvbnN0IGhhbGZQSSA9IFBJIC8gMjtcbmNvbnN0IGRvdWJsZVBJID0gUEkgKiAyO1xuLyoqIEB0eXBlIHtQb3dlckVhc2luZ30gKi9cbmNvbnN0IGVhc2VJblBvd2VyID0gKHAgPSAxLjY4KSA9PiB0ID0+IHBvdyh0LCArcCk7XG5cbi8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgRWFzZXNGYWN0b3J5fEVhc2luZ0Z1bmN0aW9uPn0gKi9cbmNvbnN0IGVhc2VJbkZ1bmN0aW9ucyA9IHtcbiAgW2VtcHR5U3RyaW5nXTogZWFzZUluUG93ZXIsXG4gIFF1YWQ6IGVhc2VJblBvd2VyKDIpLFxuICBDdWJpYzogZWFzZUluUG93ZXIoMyksXG4gIFF1YXJ0OiBlYXNlSW5Qb3dlcig0KSxcbiAgUXVpbnQ6IGVhc2VJblBvd2VyKDUpLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBTaW5lOiB0ID0+IDEgLSBjb3ModCAqIGhhbGZQSSksXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIENpcmM6IHQgPT4gMSAtIHNxcnQoMSAtIHQgKiB0KSxcbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgRXhwbzogdCA9PiB0ID8gcG93KDIsIDEwICogdCAtIDEwKSA6IDAsXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIEJvdW5jZTogdCA9PiB7XG4gICAgbGV0IHBvdzIsIGIgPSA0O1xuICAgIHdoaWxlICh0IDwgKChwb3cyID0gcG93KDIsIC0tYikpIC0gMSkgLyAxMSk7XG4gICAgcmV0dXJuIDEgLyBwb3coNCwgMyAtIGIpIC0gNy41NjI1ICogcG93KChwb3cyICogMyAtIDIpIC8gMjIgLSB0LCAyKTtcbiAgfSxcbiAgLyoqIEB0eXBlIHtCYWNrRWFzaW5nfSAqL1xuICBCYWNrOiAob3ZlcnNob290ID0gMS43MDE1OCkgPT4gdCA9PiAoK292ZXJzaG9vdCArIDEpICogdCAqIHQgKiB0IC0gK292ZXJzaG9vdCAqIHQgKiB0LFxuICAvKiogQHR5cGUge0VsYXN0aWNFYXNpbmd9ICovXG4gIEVsYXN0aWM6IChhbXBsaXR1ZGUgPSAxLCBwZXJpb2QgPSAuMykgPT4ge1xuICAgIGNvbnN0IGEgPSBjbGFtcCgrYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgY29uc3QgcCA9IGNsYW1wKCtwZXJpb2QsIG1pblZhbHVlLCAyKTtcbiAgICBjb25zdCBzID0gKHAgLyBkb3VibGVQSSkgKiBhc2luKDEgLyBhKTtcbiAgICBjb25zdCBlID0gZG91YmxlUEkgLyBwO1xuICAgIHJldHVybiB0ID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAtYSAqIHBvdygyLCAtMTAgKiAoMSAtIHQpKSAqIHNpbigoKDEgLSB0KSAtIHMpICogZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2VUeXBlXG4gKiBAcGFyYW0ge0Vhc2luZ0Z1bmN0aW9ufSBFYXNlXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2VUeXBlPn0gKi9cbmNvbnN0IGVhc2VUeXBlcyA9IHtcbiAgaW46IGVhc2VJbiA9PiB0ID0+IGVhc2VJbih0KSxcbiAgb3V0OiBlYXNlSW4gPT4gdCA9PiAxIC0gZWFzZUluKDEgLSB0KSxcbiAgaW5PdXQ6IGVhc2VJbiA9PiB0ID0+IHQgPCAuNSA/IGVhc2VJbih0ICogMikgLyAyIDogMSAtIGVhc2VJbih0ICogLTIgKyAyKSAvIDIsXG4gIG91dEluOiBlYXNlSW4gPT4gdCA9PiB0IDwgLjUgPyAoMSAtIGVhc2VJbigxIC0gdCAqIDIpKSAvIDIgOiAoZWFzZUluKHQgKiAyIC0gMSkgKyAxKSAvIDIsXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0gIHtSZWNvcmQ8U3RyaW5nLCBFYXNlc0ZhY3Rvcnl8RWFzaW5nRnVuY3Rpb24+fSBlYXNlc0Z1bmN0aW9uc1xuICogQHBhcmFtICB7T2JqZWN0fSBlYXNlc0xvb2t1cHNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBwYXJzZUVhc2VTdHJpbmcgPSAoc3RyaW5nLCBlYXNlc0Z1bmN0aW9ucywgZWFzZXNMb29rdXBzKSA9PiB7XG4gIGlmIChlYXNlc0xvb2t1cHNbc3RyaW5nXSkgcmV0dXJuIGVhc2VzTG9va3Vwc1tzdHJpbmddO1xuICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA8PSAtMSkge1xuICAgIGNvbnN0IGhhc1BhcmFtcyA9IGVhc2VUeXBlc1tzdHJpbmddIHx8IHN0cmluZy5pbmNsdWRlcygnQmFjaycpIHx8IHN0cmluZy5pbmNsdWRlcygnRWxhc3RpYycpO1xuICAgIGNvbnN0IHBhcnNlZEZuID0gLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi8oaGFzUGFyYW1zID8gLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl9ICovKGVhc2VzRnVuY3Rpb25zW3N0cmluZ10pKCkgOiBlYXNlc0Z1bmN0aW9uc1tzdHJpbmddKTtcbiAgICByZXR1cm4gcGFyc2VkRm4gPyBlYXNlc0xvb2t1cHNbc3RyaW5nXSA9IHBhcnNlZEZuIDogbm9uZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzcGxpdCA9IHN0cmluZy5zbGljZSgwLCAtMSkuc3BsaXQoJygnKTtcbiAgICBjb25zdCBwYXJzZWRGbiA9IC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlc0Z1bmN0aW9uc1tzcGxpdFswXV0pO1xuICAgIHJldHVybiBwYXJzZWRGbiA/IGVhc2VzTG9va3Vwc1tzdHJpbmddID0gcGFyc2VkRm4oLi4uc3BsaXRbMV0uc3BsaXQoJywnKSkgOiBub25lO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBFYXNlc0Z1bmN0aW9uc1xuICogQHByb3BlcnR5IHt0eXBlb2YgbGluZWFyfSBsaW5lYXJcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGlycmVndWxhcn0gaXJyZWd1bGFyXG4gKiBAcHJvcGVydHkge3R5cGVvZiBzdGVwc30gc3RlcHNcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGN1YmljQmV6aWVyfSBjdWJpY0JlemllclxuICogQHByb3BlcnR5IHtQb3dlckVhc2luZ30gaW5cbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IG91dFxuICogQHByb3BlcnR5IHtQb3dlckVhc2luZ30gaW5PdXRcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IG91dEluXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0UXVhZFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5RdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkN1YmljXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRDdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRDdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5DdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5RdWFydFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0UXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0UXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluUXVpbnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRJblF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0U2luZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5TaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkNpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dENpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0Q2lyY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5DaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0RXhwb1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5FeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0Qm91bmNlXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dEJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7QmFja0Vhc2luZ30gaW5CYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IG91dEJhY2tcbiAqIEBwcm9wZXJ0eSB7QmFja0Vhc2luZ30gaW5PdXRCYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IG91dEluQmFja1xuICogQHByb3BlcnR5IHtFbGFzdGljRWFzaW5nfSBpbkVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gb3V0RWxhc3RpY1xuICogQHByb3BlcnR5IHtFbGFzdGljRWFzaW5nfSBpbk91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gb3V0SW5FbGFzdGljXG4gKi9cblxuY29uc3QgZWFzZXMgPSAoLyojX19QVVJFX18qLyAoKCkgPT4ge1xuICBjb25zdCBsaXN0ID0geyBsaW5lYXIsIGlycmVndWxhciwgc3RlcHMsIGN1YmljQmV6aWVyIH07XG4gIGZvciAobGV0IHR5cGUgaW4gZWFzZVR5cGVzKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBlYXNlSW5GdW5jdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVhc2VJbiA9IGVhc2VJbkZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgIGNvbnN0IGVhc2VUeXBlID0gZWFzZVR5cGVzW3R5cGVdO1xuICAgICAgbGlzdFt0eXBlICsgbmFtZV0gPSAvKiogQHR5cGUge0Vhc2VzRmFjdG9yeXxFYXNpbmdGdW5jdGlvbn0gKi8oXG4gICAgICAgIG5hbWUgPT09IGVtcHR5U3RyaW5nIHx8IG5hbWUgPT09ICdCYWNrJyB8fCBuYW1lID09PSAnRWxhc3RpYycgP1xuICAgICAgICAoYSwgYikgPT4gZWFzZVR5cGUoLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl9ICovKGVhc2VJbikoYSwgYikpIDpcbiAgICAgICAgZWFzZVR5cGUoLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi8oZWFzZUluKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0Vhc2VzRnVuY3Rpb25zfSAqLyhsaXN0KTtcbn0pKCkpO1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi9cbmNvbnN0IEpTRWFzZXNMb29rdXBzID0geyBsaW5lYXI6IG5vbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0gIHtFYXNpbmdQYXJhbX0gZWFzZVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IHBhcnNlRWFzaW5ncyA9IGVhc2UgPT4gaXNGbmMoZWFzZSkgPyBlYXNlIDpcbiAgaXNTdHIoZWFzZSkgPyBwYXJzZUVhc2VTdHJpbmcoLyoqIEB0eXBlIHtTdHJpbmd9ICovKGVhc2UpLCBlYXNlcywgSlNFYXNlc0xvb2t1cHMpIDpcbiAgbm9uZTtcblxuXG5cblxuY29uc3QgcHJvcGVydHlOYW1lc0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHt0d2VlblR5cGVzfSB0d2VlblR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3Qgc2FuaXRpemVQcm9wZXJ0eU5hbWUgPSAocHJvcGVydHlOYW1lLCB0YXJnZXQsIHR3ZWVuVHlwZSkgPT4ge1xuICBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgIGNvbnN0IHQgPSBzaG9ydFRyYW5zZm9ybXMuZ2V0KHByb3BlcnR5TmFtZSk7XG4gICAgcmV0dXJuIHQgPyB0IDogcHJvcGVydHlOYW1lO1xuICB9IGVsc2UgaWYgKFxuICAgIHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MgfHxcbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlcyB3aGVyZSBwcm9wZXJ0aWVzIGxpa2UgXCJzdHJva2VEYXNob2Zmc2V0XCIgbmVlZHMgdG8gYmUgc2V0IGFzIFwic3Ryb2tlLWRhc2hvZmZzZXRcIlxuICAgIC8vIGJ1dCBwcm9wZXJ0aWVzIGxpa2UgXCJiYXNlRnJlcXVlbmN5XCIgc2hvdWxkIHN0YXkgaW4gbG93ZXJDYW1lbENhc2VcbiAgICAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkFUVFJJQlVURSAmJiAoaXNTdmcodGFyZ2V0KSAmJiBwcm9wZXJ0eU5hbWUgaW4gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuc3R5bGUpKVxuICApIHtcbiAgICBjb25zdCBjYWNoZWRQcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzQ2FjaGVbcHJvcGVydHlOYW1lXTtcbiAgICBpZiAoY2FjaGVkUHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvcGVydHlOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb3dlckNhc2VOYW1lID0gcHJvcGVydHlOYW1lID8gdG9Mb3dlckNhc2UocHJvcGVydHlOYW1lKSA6IHByb3BlcnR5TmFtZTtcbiAgICAgIHByb3BlcnR5TmFtZXNDYWNoZVtwcm9wZXJ0eU5hbWVdID0gbG93ZXJDYXNlTmFtZTtcbiAgICAgIHJldHVybiBsb3dlckNhc2VOYW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcGVydHlOYW1lO1xuICB9XG59O1xuXG5cblxuXG5jb25zdCBhbmdsZVVuaXRzTWFwID0geyAnZGVnJzogMSwgJ3JhZCc6IDE4MCAvIFBJLCAndHVybic6IDM2MCB9O1xuY29uc3QgY29udmVydGVkVmFsdWVzQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXR9IGVsXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gZGVjb21wb3NlZFZhbHVlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVuaXRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm4ge1R3ZWVuRGVjb21wb3NlZFZhbHVlfVxuICovXG5jb25zdCBjb252ZXJ0VmFsdWVVbml0ID0gKGVsLCBkZWNvbXBvc2VkVmFsdWUsIHVuaXQsIGZvcmNlID0gZmFsc2UpID0+IHtcbiAgY29uc3QgY3VycmVudFVuaXQgPSBkZWNvbXBvc2VkVmFsdWUudTtcbiAgY29uc3QgY3VycmVudE51bWJlciA9IGRlY29tcG9zZWRWYWx1ZS5uO1xuICBpZiAoZGVjb21wb3NlZFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCAmJiBjdXJyZW50VW5pdCA9PT0gdW5pdCkgeyAvLyBUT0RPOiBDaGVjayBpZiBjaGVja2luZyBhZ2FpbnN0IHRoZSBzYW1lIHVuaXQgc3RyaW5nIGlzIG5lY2Vzc2FyeVxuICAgIHJldHVybiBkZWNvbXBvc2VkVmFsdWU7XG4gIH1cbiAgY29uc3QgY2FjaGVkS2V5ID0gY3VycmVudE51bWJlciArIGN1cnJlbnRVbml0ICsgdW5pdDtcbiAgY29uc3QgY2FjaGVkID0gY29udmVydGVkVmFsdWVzQ2FjaGVbY2FjaGVkS2V5XTtcbiAgaWYgKCFpc1VuZChjYWNoZWQpICYmICFmb3JjZSkge1xuICAgIGRlY29tcG9zZWRWYWx1ZS5uID0gY2FjaGVkO1xuICB9IGVsc2Uge1xuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBpZiAoY3VycmVudFVuaXQgaW4gYW5nbGVVbml0c01hcCkge1xuICAgICAgY29udmVydGVkVmFsdWUgPSBjdXJyZW50TnVtYmVyICogYW5nbGVVbml0c01hcFtjdXJyZW50VW5pdF0gLyBhbmdsZVVuaXRzTWFwW3VuaXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiYXNlbGluZSA9IDEwMDtcbiAgICAgIGNvbnN0IHRlbXBFbCA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhlbC5jbG9uZU5vZGUoKSk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IHBhcmVudEVsID0gKHBhcmVudE5vZGUgJiYgKHBhcmVudE5vZGUgIT09IGRvYykpID8gcGFyZW50Tm9kZSA6IGRvYy5ib2R5O1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgICAgIGNvbnN0IGVsU3R5bGUgPSB0ZW1wRWwuc3R5bGU7XG4gICAgICBlbFN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyBjdXJyZW50VW5pdDtcbiAgICAgIGNvbnN0IGN1cnJlbnRVbml0V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0ZW1wRWwpLm9mZnNldFdpZHRoIHx8IGJhc2VsaW5lO1xuICAgICAgZWxTdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgdW5pdDtcbiAgICAgIGNvbnN0IG5ld1VuaXRXaWR0aCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHRlbXBFbCkub2Zmc2V0V2lkdGggfHwgYmFzZWxpbmU7XG4gICAgICBjb25zdCBmYWN0b3IgPSBjdXJyZW50VW5pdFdpZHRoIC8gbmV3VW5pdFdpZHRoO1xuICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgICAgIGNvbnZlcnRlZFZhbHVlID0gZmFjdG9yICogY3VycmVudE51bWJlcjtcbiAgICB9XG4gICAgZGVjb21wb3NlZFZhbHVlLm4gPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBjb252ZXJ0ZWRWYWx1ZXNDYWNoZVtjYWNoZWRLZXldID0gY29udmVydGVkVmFsdWU7XG4gIH1cbiAgZGVjb21wb3NlZFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVDtcbiAgZGVjb21wb3NlZFZhbHVlLnUgPSB1bml0O1xuICByZXR1cm4gZGVjb21wb3NlZFZhbHVlO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlbmRlcmFibGV9IFRcbiAqIEBwYXJhbSB7VH0gcmVuZGVyYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgY2xlYW5JbmxpbmVTdHlsZXMgPSByZW5kZXJhYmxlID0+IHtcbiAgLy8gQWxsb3cgY2xlYW5JbmxpbmVTdHlsZXMoKSB0byBiZSBjYWxsZWQgb24gdGltZWxpbmVzXG4gIGlmIChyZW5kZXJhYmxlLl9oYXNDaGlsZHJlbikge1xuICAgIGZvckVhY2hDaGlsZHJlbihyZW5kZXJhYmxlLCBjbGVhbklubGluZVN0eWxlcywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocmVuZGVyYWJsZSk7XG4gICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgZm9yRWFjaENoaWxkcmVuKGFuaW1hdGlvbiwgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgIGNvbnN0IHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuICAgICAgaWYgKHR3ZWVuVGFyZ2V0W2lzRG9tU3ltYm9sXSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5saW5lZFZhbHVlID0gYW5pbWF0aW9uLl9pbmxpbmVTdHlsZXNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICAgIGlmICh0d2Vlbi5fdHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICBpZiAoaXNVbmQob3JpZ2luYWxJbmxpbmVkVmFsdWUpIHx8IG9yaWdpbmFsSW5saW5lZFZhbHVlID09PSBlbXB0eVN0cmluZykge1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlZFRyYW5zZm9ybXNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbdHdlZW5Qcm9wZXJ0eV0gPSBvcmlnaW5hbElubGluZWRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGNhY2hlZFRyYW5zZm9ybXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0YXJnZXRTdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBjYWNoZWRUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHRyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3Nba2V5XSArIGNhY2hlZFRyYW5zZm9ybXNba2V5XSArICcpICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0U3R5bGUudHJhbnNmb3JtID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmQob3JpZ2luYWxJbmxpbmVkVmFsdWUpIHx8IG9yaWdpbmFsSW5saW5lZFZhbHVlID09PSBlbXB0eVN0cmluZykge1xuICAgICAgICAgICAgdGFyZ2V0U3R5bGUucmVtb3ZlUHJvcGVydHkodHdlZW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFN0eWxlW3R3ZWVuUHJvcGVydHldID0gb3JpZ2luYWxJbmxpbmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24uX3RhaWwgPT09IHR3ZWVuKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgIGlmICh0LmdldEF0dHJpYnV0ZSAmJiB0LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB9ICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmFibGU7XG59O1xuXG4vLyBEZWZpbmVzIGRlY29tcG9zZWQgdmFsdWVzIHRhcmdldCBvYmplY3RzIG9ubHkgb25jZSBhbmQgbXV0YXRlIHRoZWlyIHByb3BlcnRpZXMgbGF0ZXIgdG8gYXZvaWQgR0Ncbi8vIFRPRE86IE1heWJlIG1vdmUgdGhlIG9iamVjdHMgY3JlYXRpb24gdG8gdmFsdWVzLmpzIGFuZCB1c2UgdGhlIGRlY29tcG9zZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGJhc2Ugb2JqZWN0XG5jb25zdCBmcm9tVGFyZ2V0T2JqZWN0ID0gY3JlYXRlRGVjb21wb3NlZFZhbHVlVGFyZ2V0T2JqZWN0KCk7XG5jb25zdCB0b1RhcmdldE9iamVjdCA9IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCgpO1xuY29uc3QgdG9GdW5jdGlvblN0b3JlID0geyBmdW5jOiBudWxsIH07XG5jb25zdCBrZXlmcmFtZXNUYXJnZXRBcnJheSA9IFtudWxsXTtcbmNvbnN0IGZhc3RTZXRWYWx1ZXNBcnJheSA9IFtudWxsLCBudWxsXTtcbi8qKiBAdHlwZSB7VHdlZW5LZXlWYWx1ZX0gKi9cbmNvbnN0IGtleU9iamVjdFRhcmdldCA9IHsgdG86IG51bGwgfTtcblxubGV0IHR3ZWVuSWQgPSAwO1xubGV0IGtleWZyYW1lcztcbi8qKiBAdHlwZSB7VHdlZW5QYXJhbXNPcHRpb25zICYgVHdlZW5WYWx1ZXN9ICovXG5sZXQga2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7RHVyYXRpb25LZXlmcmFtZXMgfCBQZXJjZW50YWdlS2V5ZnJhbWVzfSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7QW5pbWF0aW9uUGFyYW1zfSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtBbmltYXRpb25QYXJhbXN9XG4gKi9cbmNvbnN0IGdlbmVyYXRlS2V5ZnJhbWVzID0gKGtleWZyYW1lcywgcGFyYW1ldGVycykgPT4ge1xuICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICBpZiAoaXNBcnIoa2V5ZnJhbWVzKSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBbXS5jb25jYXQoLi4uLyoqIEB0eXBlIHtEdXJhdGlvbktleWZyYW1lc30gKi8oa2V5ZnJhbWVzKS5tYXAoa2V5ID0+IE9iamVjdC5rZXlzKGtleSkpKS5maWx0ZXIoaXNLZXkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICAgIGNvbnN0IHByb3BBcnJheSA9IC8qKiBAdHlwZSB7RHVyYXRpb25LZXlmcmFtZXN9ICovKGtleWZyYW1lcykubWFwKGtleSA9PiB7XG4gICAgICAgIC8qKiBAdHlwZSB7VHdlZW5LZXlWYWx1ZX0gKi9cbiAgICAgICAgY29uc3QgbmV3S2V5ID0ge307XG4gICAgICAgIGZvciAobGV0IHAgaW4ga2V5KSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSAvKiogQHR5cGUge1R3ZWVuUHJvcFZhbHVlfSAqLyhrZXlbcF0pO1xuICAgICAgICAgIGlmIChpc0tleShwKSkge1xuICAgICAgICAgICAgaWYgKHAgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIG5ld0tleS50byA9IGtleVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICAgIH0pO1xuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSAvKiogQHR5cGUge0FycmF5U3ludGF4VmFsdWV9ICovKHByb3BBcnJheSk7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzZXRWYWx1ZShwYXJhbWV0ZXJzLmR1cmF0aW9uLCBnbG9iYWxzLmRlZmF1bHRzLmR1cmF0aW9uKSk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGtleWZyYW1lcylcbiAgICAubWFwKGtleSA9PiB7IHJldHVybiB7bzogcGFyc2VGbG9hdChrZXkpIC8gMTAwLCBwOiBrZXlmcmFtZXNba2V5XX0gfSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5vIC0gYi5vKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGtleS5vO1xuICAgICAgY29uc3QgcHJvcCA9IGtleS5wO1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wKSB7XG4gICAgICAgIGlmIChpc0tleShuYW1lKSkge1xuICAgICAgICAgIGxldCBwcm9wQXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhwcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgICAgICBpZiAoIXByb3BBcnJheSkgcHJvcEFycmF5ID0gcHJvcGVydGllc1tuYW1lXSA9IFtdO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gb2Zmc2V0ICogdG90YWxEdXJhdGlvbjtcbiAgICAgICAgICBsZXQgbGVuZ3RoID0gcHJvcEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBsZXQgcHJldktleSA9IHByb3BBcnJheVtsZW5ndGggLSAxXTtcbiAgICAgICAgICBjb25zdCBrZXlPYmogPSB7IHRvOiBwcm9wW25hbWVdIH07XG4gICAgICAgICAgbGV0IGR1clByb2dyZXNzID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkdXJQcm9ncmVzcyArPSBwcm9wQXJyYXlbaV0uZHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGtleU9iai5mcm9tID0gcHJldktleS50bztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3AuZWFzZSkge1xuICAgICAgICAgICAga2V5T2JqLmVhc2UgPSBwcm9wLmVhc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU9iai5kdXJhdGlvbiA9IGR1cmF0aW9uIC0gKGxlbmd0aCA/IGR1clByb2dyZXNzIDogMCk7XG4gICAgICAgICAgcHJvcEFycmF5LnB1c2goa2V5T2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9KTtcblxuICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgY29uc3QgcHJvcEFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8ocHJvcGVydGllc1tuYW1lXSk7XG4gICAgICBsZXQgcHJldkVhc2U7XG4gICAgICAvLyBsZXQgZHVyUHJvZ3Jlc3MgPSAwXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BBcnJheVtpXTtcbiAgICAgICAgLy8gRW11bGF0ZSBXQVBQSSBlYXNpbmcgcGFyYW1ldGVyIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFYXNlID0gcHJvcC5lYXNlO1xuICAgICAgICBwcm9wLmVhc2UgPSBwcmV2RWFzZSA/IHByZXZFYXNlIDogdW5kZWZpbmVkO1xuICAgICAgICBwcmV2RWFzZSA9IGN1cnJlbnRFYXNlO1xuICAgICAgICAvLyBkdXJQcm9ncmVzcyArPSBwcm9wLmR1cmF0aW9uO1xuICAgICAgICAvLyBpZiAoaSA9PT0gbCAtIDEgJiYgZHVyUHJvZ3Jlc3MgIT09IHRvdGFsRHVyYXRpb24pIHtcbiAgICAgICAgLy8gICBwcm9wQXJyYXkucHVzaCh7IGZyb206IHByb3AudG8sIGVhc2U6IHByb3AuZWFzZSwgZHVyYXRpb246IHRvdGFsRHVyYXRpb24gLSBkdXJQcm9ncmVzcyB9KVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoIXByb3BBcnJheVswXS5kdXJhdGlvbikge1xuICAgICAgICBwcm9wQXJyYXkuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuY2xhc3MgSlNBbmltYXRpb24gZXh0ZW5kcyBUaW1lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGlvblBhcmFtc30gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge1RpbWVsaW5lfSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudFBvc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmYXN0U2V0PWZhbHNlXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4PTBdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoPTBdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0YXJnZXRzLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBvc2l0aW9uLFxuICAgIGZhc3RTZXQgPSBmYWxzZSxcbiAgICBpbmRleCA9IDAsXG4gICAgbGVuZ3RoID0gMFxuICApIHtcblxuICAgIHN1cGVyKC8qKiBAdHlwZSB7VGltZXJQYXJhbXMmQW5pbWF0aW9uUGFyYW1zfSAqLyhwYXJhbWV0ZXJzKSwgcGFyZW50LCBwYXJlbnRQb3NpdGlvbik7XG5cbiAgICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpO1xuICAgIGNvbnN0IHRhcmdldHNMZW5ndGggPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIC8vIElmIHRoZSBwYXJhbWV0ZXJzIG9iamVjdCBjb250YWlucyBhIFwia2V5ZnJhbWVzXCIgcHJvcGVydHksIGNvbnZlcnQgYWxsIHRoZSBrZXlmcmFtZXMgdmFsdWVzIHRvIHJlZ3VsYXIgcHJvcGVydGllc1xuXG4gICAgY29uc3Qga2ZQYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8ocGFyYW1ldGVycykua2V5ZnJhbWVzO1xuICAgIGNvbnN0IHBhcmFtcyA9IC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqLyhrZlBhcmFtcyA/IG1lcmdlT2JqZWN0cyhnZW5lcmF0ZUtleWZyYW1lcygvKiogQHR5cGUge0R1cmF0aW9uS2V5ZnJhbWVzfSAqLyhrZlBhcmFtcyksIHBhcmFtZXRlcnMpLCBwYXJhbWV0ZXJzKSA6IHBhcmFtZXRlcnMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgZGVsYXksXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2UsXG4gICAgICBwbGF5YmFja0Vhc2UsXG4gICAgICBtb2RpZmllcixcbiAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgb25SZW5kZXIsXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGNvbnN0IGFuaW1EZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgYW5pbWFQbGF5YmFja0Vhc2UgPSBzZXRWYWx1ZShwbGF5YmFja0Vhc2UsIGFuaW1EZWZhdWx0cy5wbGF5YmFja0Vhc2UpO1xuICAgIGNvbnN0IGFuaW1FYXNlID0gYW5pbWFQbGF5YmFja0Vhc2UgPyBwYXJzZUVhc2luZ3MoYW5pbWFQbGF5YmFja0Vhc2UpIDogbnVsbDtcbiAgICBjb25zdCBoYXNTcHJpbmcgPSAhaXNVbmQoZWFzZSkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgICBjb25zdCB0RWFzaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpLmVhc2UgOiBzZXRWYWx1ZShlYXNlLCBhbmltRWFzZSA/ICdsaW5lYXInIDogYW5pbURlZmF1bHRzLmVhc2UpO1xuICAgIGNvbnN0IHREdXJhdGlvbiA9IGhhc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5kdXJhdGlvbiA6IHNldFZhbHVlKGR1cmF0aW9uLCBhbmltRGVmYXVsdHMuZHVyYXRpb24pO1xuICAgIGNvbnN0IHREZWxheSA9IHNldFZhbHVlKGRlbGF5LCBhbmltRGVmYXVsdHMuZGVsYXkpO1xuICAgIGNvbnN0IHRNb2RpZmllciA9IG1vZGlmaWVyIHx8IGFuaW1EZWZhdWx0cy5tb2RpZmllcjtcbiAgICAvLyBJZiBubyBjb21wb3NpdGlvbiBpcyBkZWZpbmVkIGFuZCB0aGUgdGFyZ2V0cyBsZW5ndGggaXMgaGlnaCAoPj0gMTAwMCkgc2V0IHRoZSBjb21wb3NpdGlvbiB0byAnbm9uZScgKDApIGZvciBmYXN0ZXIgdHdlZW4gY3JlYXRpb25cbiAgICBjb25zdCB0Q29tcG9zaXRpb24gPSBpc1VuZChjb21wb3NpdGlvbikgJiYgdGFyZ2V0c0xlbmd0aCA+PSBLID8gY29tcG9zaXRpb25UeXBlcy5ub25lIDogIWlzVW5kKGNvbXBvc2l0aW9uKSA/IGNvbXBvc2l0aW9uIDogYW5pbURlZmF1bHRzLmNvbXBvc2l0aW9uO1xuICAgIC8vIFRPRE86IERvIG5vdCBjcmVhdGUgYW4gZW1wdHkgb2JqZWN0IHVudGlsIHdlIGtub3cgdGhlIGFuaW1hdGlvbiB3aWxsIGdlbmVyYXRlIGlubGluZSBzdHlsZXNcbiAgICBjb25zdCBhbmltSW5saW5lU3R5bGVzID0ge307XG4gICAgLy8gY29uc3QgYWJzb2x1dGVPZmZzZXRUaW1lID0gdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0VGltZSA9IHRoaXMuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApO1xuXG4gICAgbGV0IGl0ZXJhdGlvbkR1cmF0aW9uID0gTmFOO1xuICAgIGxldCBpdGVyYXRpb25EZWxheSA9IE5hTjtcbiAgICBsZXQgYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoID0gMDtcbiAgICBsZXQgc2hvdWxkVHJpZ2dlclJlbmRlciA9IDA7XG5cbiAgICBmb3IgKGxldCB0YXJnZXRJbmRleCA9IDA7IHRhcmdldEluZGV4IDwgdGFyZ2V0c0xlbmd0aDsgdGFyZ2V0SW5kZXgrKykge1xuXG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXJzZWRUYXJnZXRzW3RhcmdldEluZGV4XTtcbiAgICAgIGNvbnN0IHRpID0gaW5kZXggfHwgdGFyZ2V0SW5kZXg7XG4gICAgICBjb25zdCB0bCA9IGxlbmd0aCB8fCB0YXJnZXRzTGVuZ3RoO1xuXG4gICAgICBsZXQgbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggPSBOYU47XG4gICAgICBsZXQgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoID0gTmFOO1xuXG4gICAgICBmb3IgKGxldCBwIGluIHBhcmFtcykge1xuXG4gICAgICAgIGlmIChpc0tleShwKSkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5UeXBlID0gZ2V0VHdlZW5UeXBlKHRhcmdldCwgcCk7XG5cbiAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHNhbml0aXplUHJvcGVydHlOYW1lKHAsIHRhcmdldCwgdHdlZW5UeXBlKTtcblxuICAgICAgICAgIGxldCBwcm9wVmFsdWUgPSBwYXJhbXNbcF07XG5cbiAgICAgICAgICBjb25zdCBpc1Byb3BWYWx1ZUFycmF5ID0gaXNBcnIocHJvcFZhbHVlKTtcblxuICAgICAgICAgIGlmIChmYXN0U2V0ICYmICFpc1Byb3BWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMF0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSBmYXN0U2V0VmFsdWVzQXJyYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogQWxsb3cgbmVzdGVkIGtleWZyYW1lcyBpbnNpZGUgT2JqZWN0VmFsdWUgdmFsdWUgKHByb3A6IHsgdG86IFsuNSwgMSwgLjc1LCAyLCAzXSB9KVxuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwcm9wZXJ0eSB2YWx1ZXMgdG8gdmFsaWQga2V5ZnJhbWUgc3ludGF4OlxuICAgICAgICAgIC8vIFt4LCB5XSB0byBbe3RvOiBbeCwgeV19XSBvciB7dG86IHh9IHRvIFt7dG86IHh9XSBvciBrZWVwIGtleXMgc3ludGF4IFt7fSwge30sIHt9Li4uXVxuICAgICAgICAgIC8vIGNvbnN0IGtleWZyYW1lcyA9IGlzQXJyKHByb3BWYWx1ZSkgPyBwcm9wVmFsdWUubGVuZ3RoID09PSAyICYmICFpc09iaihwcm9wVmFsdWVbMF0pID8gW3sgdG86IHByb3BWYWx1ZSB9XSA6IHByb3BWYWx1ZSA6IFtwcm9wVmFsdWVdO1xuICAgICAgICAgIGlmIChpc1Byb3BWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHByb3BWYWx1ZSkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaXNOb3RPYmplY3RWYWx1ZSA9ICFpc09iaihwcm9wVmFsdWVbMF0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCBbeCwgeV0gdG8gW3t0bzogW3gsIHldfV1cbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PT0gMiAmJiBpc05vdE9iamVjdFZhbHVlKSB7XG4gICAgICAgICAgICAgIGtleU9iamVjdFRhcmdldC50byA9IC8qKiBAdHlwZSB7VHdlZW5QYXJhbVZhbHVlfSAqLygvKiogQHR5cGUge3Vua25vd259ICovKHByb3BWYWx1ZSkpO1xuICAgICAgICAgICAgICBrZXlmcmFtZXNUYXJnZXRBcnJheVswXSA9IGtleU9iamVjdFRhcmdldDtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzVGFyZ2V0QXJyYXk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFt4LCB5LCB6XSB0byBbW3gsIHldLCB6XVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJheUxlbmd0aCA+IDIgJiYgaXNOb3RPYmplY3RWYWx1ZSkge1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48TnVtYmVyPn0gKi8ocHJvcFZhbHVlKS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMF0gPSB2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzFdID0gdjtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcy5wdXNoKGZhc3RTZXRWYWx1ZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPSAvKiogQHR5cGUge0FycmF5LjxUd2VlbktleVZhbHVlPn0gKi8ocHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ZnJhbWVzVGFyZ2V0QXJyYXlbMF0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBrZXlmcmFtZXNUYXJnZXRBcnJheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc2libGluZ3MgPSBudWxsO1xuICAgICAgICAgIGxldCBwcmV2VHdlZW4gPSBudWxsO1xuICAgICAgICAgIGxldCBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lID0gTmFOO1xuICAgICAgICAgIGxldCBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lID0gMDtcbiAgICAgICAgICBsZXQgdHdlZW5JbmRleCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGxldCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgdHdlZW5JbmRleCA8IGw7IHR3ZWVuSW5kZXgrKykge1xuXG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1t0d2VlbkluZGV4XTtcblxuICAgICAgICAgICAgaWYgKGlzT2JqKGtleWZyYW1lKSkge1xuICAgICAgICAgICAgICBrZXkgPSBrZXlmcmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGtleU9iamVjdFRhcmdldC50byA9IC8qKiBAdHlwZSB7VHdlZW5QYXJhbVZhbHVlfSAqLyhrZXlmcmFtZSk7XG4gICAgICAgICAgICAgIGtleSA9IGtleU9iamVjdFRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9GdW5jdGlvblN0b3JlLmZ1bmMgPSBudWxsO1xuXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFRvVmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKGtleS50bywgdGFyZ2V0LCB0aSwgdGwsIHRvRnVuY3Rpb25TdG9yZSk7XG5cbiAgICAgICAgICAgIGxldCB0d2VlblRvVmFsdWU7XG4gICAgICAgICAgICAvLyBBbGxvd3MgZnVuY3Rpb24gYmFzZWQgdmFsdWVzIHRvIHJldHVybiBhbiBvYmplY3Qgc3ludGF4IHZhbHVlICh7dG86IHZ9KVxuICAgICAgICAgICAgaWYgKGlzT2JqKGNvbXB1dGVkVG9WYWx1ZSkgJiYgIWlzVW5kKGNvbXB1dGVkVG9WYWx1ZS50bykpIHtcbiAgICAgICAgICAgICAga2V5ID0gY29tcHV0ZWRUb1ZhbHVlO1xuICAgICAgICAgICAgICB0d2VlblRvVmFsdWUgPSBjb21wdXRlZFRvVmFsdWUudG87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0d2VlblRvVmFsdWUgPSBjb21wdXRlZFRvVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0d2VlbkZyb21WYWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUoa2V5LmZyb20sIHRhcmdldCwgdGksIHRsKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUVhc2luZyA9IGtleS5lYXNlO1xuICAgICAgICAgICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGtleUVhc2luZykgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhrZXlFYXNpbmcpLmVhc2UpO1xuICAgICAgICAgICAgLy8gRWFzaW5nIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5IGFuZCBkb24ndCBhY2NlcHQgZnVuY3Rpb24gYmFzZWQgdmFsdWUgdG8gcHJldmVudCBoYXZpbmcgdG8gcGFzcyBhIGZ1bmN0aW9uIHdyYXBwZXIgdGhhdCByZXR1cm5zIGFuIG90aGVyIGZ1bmN0aW9uIGFsbCB0aGUgdGltZVxuICAgICAgICAgICAgY29uc3QgdHdlZW5FYXNpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5lYXNlIDoga2V5RWFzaW5nIHx8IHRFYXNpbmc7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGVmYXVsdCBpbmRpdmlkdWFsIGtleWZyYW1lIGR1cmF0aW9uIGJ5IGRpdmlkaW5nIHRoZSB0bCBvZiBrZXlmcmFtZXNcbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuRHVyYXRpb24gPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5kdXJhdGlvbiA6IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmR1cmF0aW9uLCAobCA+IDEgPyBnZXRGdW5jdGlvblZhbHVlKHREdXJhdGlvbiwgdGFyZ2V0LCB0aSwgdGwpIC8gbCA6IHREdXJhdGlvbikpLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgICAgICAgICBjb25zdCB0d2VlbkRlbGF5ID0gZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShrZXkuZGVsYXksICghdHdlZW5JbmRleCA/IHREZWxheSA6IDApKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRDb21wb3NpdGlvbiA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmNvbXBvc2l0aW9uLCB0Q29tcG9zaXRpb24pLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICBjb25zdCB0d2VlbkNvbXBvc2l0aW9uID0gaXNOdW0oY29tcHV0ZWRDb21wb3NpdGlvbikgPyBjb21wdXRlZENvbXBvc2l0aW9uIDogY29tcG9zaXRpb25UeXBlc1tjb21wdXRlZENvbXBvc2l0aW9uXTtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgYWNjZXB0IGZ1bmN0aW9uIGJhc2VkIHZhbHVlIHRvIHByZXZlbnQgaGF2aW5nIHRvIHBhc3MgYSBmdW5jdGlvbiB3cmFwcGVyXG4gICAgICAgICAgICBjb25zdCB0d2Vlbk1vZGlmaWVyID0ga2V5Lm1vZGlmaWVyIHx8IHRNb2RpZmllcjtcbiAgICAgICAgICAgIGNvbnN0IGhhc0Zyb212YWx1ZSA9ICFpc1VuZCh0d2VlbkZyb21WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNUb1ZhbHVlID0gIWlzVW5kKHR3ZWVuVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBpc0Zyb21Ub0FycmF5ID0gaXNBcnIodHdlZW5Ub1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnJvbVRvVmFsdWUgPSBpc0Zyb21Ub0FycmF5IHx8IChoYXNGcm9tdmFsdWUgJiYgaGFzVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCB0d2VlblN0YXJ0VGltZSA9IHByZXZUd2VlbiA/IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgKyB0d2VlbkRlbGF5IDogdHdlZW5EZWxheTtcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlU3RhcnRUaW1lID0gYWJzb2x1dGVPZmZzZXRUaW1lICsgdHdlZW5TdGFydFRpbWU7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGEgb25SZW5kZXIgY2FsbGJhY2sgaWYgdGhlIGFuaW1hdGlvbiBjb250YWlucyBhdCBsZWFzdCBvbmUgZnJvbSB2YWx1ZSBhbmQgYXV0b3BsYXkgaXMgc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICBpZiAoIXNob3VsZFRyaWdnZXJSZW5kZXIgJiYgKGhhc0Zyb212YWx1ZSB8fCBpc0Zyb21Ub0FycmF5KSkgc2hvdWxkVHJpZ2dlclJlbmRlciA9IDE7XG5cbiAgICAgICAgICAgIGxldCBwcmV2U2libGluZyA9IHByZXZUd2VlbjtcblxuICAgICAgICAgICAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgICAgICAgICAgICBpZiAoIXNpYmxpbmdzKSBzaWJsaW5ncyA9IGdldFR3ZWVuU2libGluZ3ModGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgIGxldCBuZXh0U2libGluZyA9IHNpYmxpbmdzLl9oZWFkO1xuICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRyb3VnaCBhbGwgdGhlIG5leHQgc2libGluZ3MgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgd2l0aCBhbiBlcXVhbCBvciBpbmZlcmlvciBzdGFydCB0aW1lXG4gICAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZyAmJiAhbmV4dFNpYmxpbmcuX2lzT3ZlcnJpZGRlbiAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPD0gYWJzb2x1dGVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuX25leHRSZXA7XG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFsbCB0aGUgbmV4dCBzaWJsaW5ncyBpZiB0aGUgbmV4dCBzaWJsaW5nIHN0YXJ0cyBhdCB0aGUgc2FtZSB0aW1lIG9mIGFmdGVyIGFzIHRoZSBuZXcgdHdlZW4gc3RhcnQgdGltZVxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPj0gYWJzb2x1dGVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuZHMgYm90aCB0aGUgY3VycmVudCB3aGlsZSBsb29wIGFuZCB0aGUgdXBwZXIgb25lIG9uY2UgYWxsIHRoZSBuZXh0IHNpYmxsaW5ncyBoYXZlIGJlZW4gb3ZlcnJpZGVuXG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuX25leHRSZXA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29tcG9zZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChpc0Zyb21Ub1ZhbHVlKSB7XG4gICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKGlzRnJvbVRvQXJyYXkgPyBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuVG9WYWx1ZVswXSwgdGFyZ2V0LCB0aSwgdGwpIDogdHdlZW5Gcm9tVmFsdWUsIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShpc0Zyb21Ub0FycmF5ID8gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlblRvVmFsdWVbMV0sIHRhcmdldCwgdGksIHRsLCB0b0Z1bmN0aW9uU3RvcmUpIDogdHdlZW5Ub1ZhbHVlLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcuX3ZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuVU5JVDtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC51ID0gcHJldlNpYmxpbmcuX3VuaXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgICBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnUgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS51O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGhhc1RvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZSh0d2VlblRvVmFsdWUsIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VUd2VlblZhbHVlKHByZXZUd2VlbiwgdG9UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGdldCBhbmQgcGFyc2UgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIHRoZSB0d2VlbiBpcyBwYXJ0IG9mIGEgdGltZWxpbmUgYW5kIGhhcyBhIHByZXZpb3VzIHNpYmxpbmcgcGFydCBvZiB0aGUgc2FtZSB0aW1lbGluZVxuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUocGFyZW50ICYmIHByZXZTaWJsaW5nICYmIHByZXZTaWJsaW5nLnBhcmVudC5wYXJlbnQgPT09IHBhcmVudCA/IHByZXZTaWJsaW5nLl92YWx1ZSA6XG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoYXNGcm9tdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZSh0d2VlbkZyb21WYWx1ZSwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUd2Vlbikge1xuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlVHdlZW5WYWx1ZShwcmV2VHdlZW4sIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShwYXJlbnQgJiYgcHJldlNpYmxpbmcgJiYgcHJldlNpYmxpbmcucGFyZW50LnBhcmVudCA9PT0gcGFyZW50ID8gcHJldlNpYmxpbmcuX3ZhbHVlIDpcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZ2V0IGFuZCBwYXJzZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIHR3ZWVuIGlzIHBhcnQgb2YgYSB0aW1lbGluZSBhbmQgaGFzIGEgcHJldmlvdXMgc2libGluZyBwYXJ0IG9mIHRoZSBzYW1lIHRpbWVsaW5lXG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLCBmcm9tVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAoZnJvbVRhcmdldE9iamVjdC5vKSB7XG4gICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QubiA9IGdldFJlbGF0aXZlVmFsdWUoXG4gICAgICAgICAgICAgICAgIXByZXZTaWJsaW5nID8gZGVjb21wb3NlUmF3VmFsdWUoXG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWVcbiAgICAgICAgICAgICAgICApLm4gOiBwcmV2U2libGluZy5fdG9OdW1iZXIsXG4gICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3Qub1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9UYXJnZXRPYmplY3Qubykge1xuICAgICAgICAgICAgICB0b1RhcmdldE9iamVjdC5uID0gZ2V0UmVsYXRpdmVWYWx1ZShmcm9tVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWYWx1ZXMgb21vZ2VuaXNhdGlvbiBpbiBjYXNlcyBvZiB0eXBlIGRpZmZlcmVuY2UgYmV0d2VlbiBcImZyb21cIiBhbmQgXCJ0b1wiXG4gICAgICAgICAgICBpZiAoZnJvbVRhcmdldE9iamVjdC50ICE9PSB0b1RhcmdldE9iamVjdC50KSB7XG4gICAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV4VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RDb21wbGV4VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBub3RDb21wbGV4VmFsdWUudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgICAgICAgICAgICBub3RDb21wbGV4VmFsdWUucyA9IGNsb25lQXJyYXkoY29tcGxleFZhbHVlLnMpO1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS5kID0gY29tcGxleFZhbHVlLmQubWFwKCgpID0+IG5vdENvbXBsZXhWYWx1ZS5uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bml0VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RVbml0VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBub3RVbml0VmFsdWUudCA9IHZhbHVlVHlwZXMuVU5JVDtcbiAgICAgICAgICAgICAgICBub3RVbml0VmFsdWUudSA9IHVuaXRWYWx1ZS51O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT0xPUiB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT0xPUiA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RDb2xvclZhbHVlID0gZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdENvbG9yVmFsdWUudCA9IHZhbHVlVHlwZXMuQ09MT1I7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS5zID0gY29sb3JWYWx1ZS5zO1xuICAgICAgICAgICAgICAgIG5vdENvbG9yVmFsdWUuZCA9IFswLCAwLCAwLCAxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVbml0IGNvbnZlcnNpb25cbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnUgIT09IHRvVGFyZ2V0T2JqZWN0LnUpIHtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlVG9Db252ZXJ0ID0gdG9UYXJnZXRPYmplY3QudSA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgdmFsdWVUb0NvbnZlcnQgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCB2YWx1ZVRvQ29udmVydCwgdG9UYXJnZXRPYmplY3QudSA/IHRvVGFyZ2V0T2JqZWN0LnUgOiBmcm9tVGFyZ2V0T2JqZWN0LnUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgICAgLy8gY29udmVydFZhbHVlVW5pdCh0YXJnZXQsIHRvLnUgPyBmcm9tIDogdG8sIHRvLnUgPyB0by51IDogZnJvbS51KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCBpbiBub24gZXhpc3RpbmcgY29tcGxleCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0b1RhcmdldE9iamVjdC5kICYmIGZyb21UYXJnZXRPYmplY3QuZCAmJiAodG9UYXJnZXRPYmplY3QuZC5sZW5ndGggIT09IGZyb21UYXJnZXRPYmplY3QuZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvbmdlc3RWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QuZC5sZW5ndGggPiB0b1RhcmdldE9iamVjdC5kLmxlbmd0aCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgY29uc3Qgc2hvcnRlc3RWYWx1ZSA9IGxvbmdlc3RWYWx1ZSA9PT0gZnJvbVRhcmdldE9iamVjdCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgbiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIDAgZm9yIGRlZmF1bHQgY29tcGxleCB2YWx1ZXNcbiAgICAgICAgICAgICAgc2hvcnRlc3RWYWx1ZS5kID0gbG9uZ2VzdFZhbHVlLmQubWFwKChfLCBpKSA9PiBpc1VuZChzaG9ydGVzdFZhbHVlLmRbaV0pID8gMCA6IHNob3J0ZXN0VmFsdWUuZFtpXSk7XG4gICAgICAgICAgICAgIHNob3J0ZXN0VmFsdWUucyA9IGNsb25lQXJyYXkobG9uZ2VzdFZhbHVlLnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUd2VlbiBmYWN0b3J5XG5cbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgICAgICAgY29uc3QgdHdlZW5VcGRhdGVEdXJhdGlvbiA9IHJvdW5kKCt0d2VlbkR1cmF0aW9uIHx8IG1pblZhbHVlLCAxMik7XG5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7VHdlZW59ICovXG4gICAgICAgICAgICBjb25zdCB0d2VlbiA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgICBpZDogdHdlZW5JZCsrLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICBfdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIF9mdW5jOiB0b0Z1bmN0aW9uU3RvcmUuZnVuYyxcbiAgICAgICAgICAgICAgX2Vhc2U6IHBhcnNlRWFzaW5ncyh0d2VlbkVhc2luZyksXG4gICAgICAgICAgICAgIF9mcm9tTnVtYmVyczogY2xvbmVBcnJheShmcm9tVGFyZ2V0T2JqZWN0LmQpLFxuICAgICAgICAgICAgICBfdG9OdW1iZXJzOiBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LmQpLFxuICAgICAgICAgICAgICBfc3RyaW5nczogY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5zKSxcbiAgICAgICAgICAgICAgX2Zyb21OdW1iZXI6IGZyb21UYXJnZXRPYmplY3QubixcbiAgICAgICAgICAgICAgX3RvTnVtYmVyOiB0b1RhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICBfbnVtYmVyczogY2xvbmVBcnJheShmcm9tVGFyZ2V0T2JqZWN0LmQpLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW4gYW5kIGFuaW1hdGFibGVzXG4gICAgICAgICAgICAgIF9udW1iZXI6IGZyb21UYXJnZXRPYmplY3QubiwgLy8gRm9yIGFkZGl0aXZlIHR3ZWVuIGFuZCBhbmltYXRhYmxlc1xuICAgICAgICAgICAgICBfdW5pdDogdG9UYXJnZXRPYmplY3QudSxcbiAgICAgICAgICAgICAgX21vZGlmaWVyOiB0d2Vlbk1vZGlmaWVyLFxuICAgICAgICAgICAgICBfY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICAgIF9zdGFydFRpbWU6IHR3ZWVuU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBfZGVsYXk6ICt0d2VlbkRlbGF5LFxuICAgICAgICAgICAgICBfdXBkYXRlRHVyYXRpb246IHR3ZWVuVXBkYXRlRHVyYXRpb24sXG4gICAgICAgICAgICAgIF9jaGFuZ2VEdXJhdGlvbjogdHdlZW5VcGRhdGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2Fic29sdXRlU3RhcnRUaW1lOiBhYnNvbHV0ZVN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgLy8gTk9URTogSW52ZXN0aWdhdGUgYml0IHBhY2tpbmcgdG8gc3RvcmVzIEVOVU0gLyBCT09MXG4gICAgICAgICAgICAgIF90d2VlblR5cGU6IHR3ZWVuVHlwZSxcbiAgICAgICAgICAgICAgX3ZhbHVlVHlwZTogdG9UYXJnZXRPYmplY3QudCxcbiAgICAgICAgICAgICAgX2NvbXBvc2l0aW9uOiB0d2VlbkNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgICBfaXNPdmVybGFwcGVkOiAwLFxuICAgICAgICAgICAgICBfaXNPdmVycmlkZGVuOiAwLFxuICAgICAgICAgICAgICBfcmVuZGVyVHJhbnNmb3JtczogMCxcbiAgICAgICAgICAgICAgX3ByZXZSZXA6IG51bGwsIC8vIEZvciByZXBsYWNlZCB0d2VlblxuICAgICAgICAgICAgICBfbmV4dFJlcDogbnVsbCwgLy8gRm9yIHJlcGxhY2VkIHR3ZWVuXG4gICAgICAgICAgICAgIF9wcmV2QWRkOiBudWxsLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW5cbiAgICAgICAgICAgICAgX25leHRBZGQ6IG51bGwsIC8vIEZvciBhZGRpdGl2ZSB0d2VlblxuICAgICAgICAgICAgICBfcHJldjogbnVsbCxcbiAgICAgICAgICAgICAgX25leHQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgICAgICAgICAgIGNvbXBvc2VUd2Vlbih0d2Vlbiwgc2libGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSkpIHtcbiAgICAgICAgICAgICAgZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3VuZGluZyBpcyBuZWNlc3NhcnkgaGVyZSB0byBtaW5pbWl6ZSBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgICAgICAgICAgIGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgPSByb3VuZCh0d2VlblN0YXJ0VGltZSArIHR3ZWVuVXBkYXRlRHVyYXRpb24sIDEyKTtcbiAgICAgICAgICAgIHByZXZUd2VlbiA9IHR3ZWVuO1xuICAgICAgICAgICAgYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoKys7XG5cbiAgICAgICAgICAgIGFkZENoaWxkKHRoaXMsIHR3ZWVuKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gdGltaW5ncyB3aXRoIHRoZSBhZGRlZCB0d2VlbnMgcHJvcGVydGllc1xuXG4gICAgICAgICAgaWYgKGlzTmFOKGl0ZXJhdGlvbkRlbGF5KSB8fCBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lIDwgaXRlcmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRlbGF5ID0gZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNOYU4oaXRlcmF0aW9uRHVyYXRpb24pIHx8IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgPiBpdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgaXRlcmF0aW9uRHVyYXRpb24gPSBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IEZpbmQgYSB3YXkgdG8gaW5saW5lIHR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zID0gMSBoZXJlXG4gICAgICAgICAgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICAgICAgICAgIGxhc3RUcmFuc2Zvcm1Hcm91cEluZGV4ID0gYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoIC0gdHdlZW5JbmRleDtcbiAgICAgICAgICAgIGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCA9IGFuaW1hdGlvbkFuaW1hdGlvbkxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBfcmVuZGVyVHJhbnNmb3JtcyB0byBsYXN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byBjb3JyZWN0bHkgcmVuZGVyIHRoZSB0cmFuc2Zvcm1zIGxpc3RcbiAgICAgIGlmICghaXNOYU4obGFzdFRyYW5zZm9ybUdyb3VwSW5kZXgpKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICAgICAgaWYgKGkgPj0gbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggJiYgaSA8IGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCkge1xuICAgICAgICAgICAgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgICAgaWYgKHR3ZWVuLl9jb21wb3NpdGlvbiA9PT0gY29tcG9zaXRpb25UeXBlcy5ibGVuZCkge1xuICAgICAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYWRkaXRpdmUuYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi9hZGRpdGl2ZVR3ZWVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVHdlZW4uaWQgPT09IHR3ZWVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICBhZGRpdGl2ZVR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRzTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5vIHRhcmdldCBmb3VuZC4gTWFrZSBzdXJlIHRoZSBlbGVtZW50IHlvdSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSBpcyBhY2Nlc3NpYmxlIGJlZm9yZSBjcmVhdGluZyB5b3VyIGFuaW1hdGlvbi5gKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlcmF0aW9uRGVsYXkpIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAvLyBJZiAoc3RhcnRUaW1lIC0gZGVsYXkpIGVxdWFscyAwLCB0aGlzIG1lYW5zIHRoZSB0d2VlbiBpcyBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGFuaW1hdGlvbiBzbyB3ZSBuZWVkIHRvIHRyaW0gdGhlIGRlbGF5IHRvb1xuICAgICAgICBpZiAoISh0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KSkge1xuICAgICAgICAgIHR3ZWVuLl9kZWxheSAtPSBpdGVyYXRpb25EZWxheTtcbiAgICAgICAgfVxuICAgICAgICB0d2Vlbi5fc3RhcnRUaW1lIC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgICAgfSk7XG4gICAgICBpdGVyYXRpb25EdXJhdGlvbiAtPSBpdGVyYXRpb25EZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0aW9uRGVsYXkgPSAwO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnRzIGl0ZXJhdGlvbkR1cmF0aW9uIHRvIGJlIE5hTiBpZiBubyB2YWxpZCBhbmltYXRhYmxlIHByb3BzIGhhdmUgYmVlbiBwcm92aWRlZFxuICAgIC8vIFByZXZlbnRzIF9pdGVyYXRpb25Db3VudCB0byBiZSBOYU4gaWYgbm8gdmFsaWQgYW5pbWF0YWJsZSBwcm9wcyBoYXZlIGJlZW4gcHJvdmlkZWRcbiAgICBpZiAoIWl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IG1pblZhbHVlO1xuICAgICAgdGhpcy5pdGVyYXRpb25Db3VudCA9IDA7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqL1xuICAgIHRoaXMudGFyZ2V0cyA9IHBhcnNlZFRhcmdldHM7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IGl0ZXJhdGlvbkR1cmF0aW9uID09PSBtaW5WYWx1ZSA/IG1pblZhbHVlIDogY2xhbXBJbmZpbml0eSgoKGl0ZXJhdGlvbkR1cmF0aW9uICsgdGhpcy5fbG9vcERlbGF5KSAqIHRoaXMuaXRlcmF0aW9uQ291bnQpIC0gdGhpcy5fbG9vcERlbGF5KSB8fCBtaW5WYWx1ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZW5kZXIgPSBvblJlbmRlciB8fCBhbmltRGVmYXVsdHMub25SZW5kZXI7XG4gICAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgICB0aGlzLl9lYXNlID0gYW5pbUVhc2U7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSBpdGVyYXRpb25EZWxheTtcbiAgICAvLyBOT1RFOiBJJ20ga2VlcGluZyBkZWxheSB2YWx1ZXMgc2VwYXJhdGVkIGZyb20gb2Zmc2V0cyBpbiB0aW1lbGluZXMgYmVjYXVzZSBkZWxheXMgY2FuIG92ZXJyaWRlIHByZXZpb3VzIHR3ZWVucyBhbmQgaXQgY291bGQgYmUgY29uZnVzaW5nIHRvIGRlYnVnIGEgdGltZWxpbmUgd2l0aCBvdmVycmlkZGVuIHR3ZWVucyBhbmQgbm8gYXNzb2NpYXRlZCB2aXNpYmxlIGRlbGF5cy5cbiAgICAvLyB0aGlzLl9kZWxheSA9IHBhcmVudCA/IDAgOiBpdGVyYXRpb25EZWxheTtcbiAgICAvLyB0aGlzLl9vZmZzZXQgKz0gcGFyZW50ID8gaXRlcmF0aW9uRGVsYXkgOiAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvKiogQHR5cGUge3t9fSAqL1xuICAgIHRoaXMuX2lubGluZVN0eWxlcyA9IGFuaW1JbmxpbmVTdHlsZXM7XG5cbiAgICBpZiAoIXRoaXMuX2F1dG9wbGF5ICYmIHNob3VsZFRyaWdnZXJSZW5kZXIpIHRoaXMub25SZW5kZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBuZXdEdXJhdGlvblxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc3RyZXRjaChuZXdEdXJhdGlvbikge1xuICAgIGNvbnN0IGN1cnJlbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgaWYgKGN1cnJlbnREdXJhdGlvbiA9PT0gbm9ybWFsaXplVGltZShuZXdEdXJhdGlvbikpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IG5ld0R1cmF0aW9uIC8gY3VycmVudER1cmF0aW9uO1xuICAgIC8vIE5PVEU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGUgc3RyZXRjaCBvZiBhbiBhbmltYXRpb24gYWZ0ZXIgc3RyZXRjaCA9IDBcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgdHdlZW4uX3VwZGF0ZUR1cmF0aW9uID0gbm9ybWFsaXplVGltZSh0d2Vlbi5fdXBkYXRlRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgICAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbm9ybWFsaXplVGltZSh0d2Vlbi5fY2hhbmdlRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lICo9IHRpbWVTY2FsZTtcbiAgICAgIHR3ZWVuLl9zdGFydFRpbWUgKj0gdGltZVNjYWxlO1xuICAgICAgdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICo9IHRpbWVTY2FsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuc3RyZXRjaChuZXdEdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICBjb25zdCBvZ1ZhbHVlID0gZ2V0T3JpZ2luYWxBbmltYXRhYmxlVmFsdWUodHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgdHdlZW4uX3R3ZWVuVHlwZSk7XG4gICAgICBkZWNvbXBvc2VSYXdWYWx1ZShvZ1ZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgICB0d2Vlbi5fZnJvbU51bWJlcnMgPSBjbG9uZUFycmF5KGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLmQpO1xuICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgaWYgKHR3ZWVuLl9mdW5jKSB7XG4gICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuLl9mdW5jKCksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgdHdlZW4uX3RvTnVtYmVycyA9IGNsb25lQXJyYXkodG9UYXJnZXRPYmplY3QuZCk7XG4gICAgICAgIHR3ZWVuLl9zdHJpbmdzID0gY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5zKTtcbiAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gdG9UYXJnZXRPYmplY3QubjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIGFuaW1hdGlvbiBhbmQgcmV2ZXJ0IGFsbCB0aGUgdmFsdWVzIGFmZmVjdGVkIGJ5IHRoaXMgYW5pbWF0aW9uIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXZlcnQoKSB7XG4gICAgc3VwZXIucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIGNsZWFuSW5saW5lU3R5bGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbGxiYWNrPHRoaXM+fSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRoZW4oY2FsbGJhY2spO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBhbmltYXRlID0gKHRhcmdldHMsIHBhcmFtZXRlcnMpID0+IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBwYXJhbWV0ZXJzLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuXG5cblxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVhc2luZyBmdW5jdGlvbiBpbnRvIGEgdmFsaWQgQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvbiBzdHJpbmdcbiAqIEBwYXJhbSB7RWFzaW5nRnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9MTAwXVxuICogQHJldHVybnMge3N0cmluZ30gQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvblxuICovXG5jb25zdCBlYXNpbmdUb0xpbmVhciA9IChmbiwgc2FtcGxlcyA9IDEwMCkgPT4ge1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2FtcGxlczsgaSsrKSBwb2ludHMucHVzaChmbihpIC8gc2FtcGxlcykpO1xuICByZXR1cm4gYGxpbmVhcigke3BvaW50cy5qb2luKCcsICcpfSlgO1xufTtcblxuY29uc3QgV0FBUElFYXNlc0xvb2t1cHMgPSB7XG4gIGluOiAnZWFzZS1pbicsXG4gIG91dDogJ2Vhc2Utb3V0JyxcbiAgaW5PdXQ6ICdlYXNlLWluLW91dCcsXG59O1xuXG5jb25zdCBXQUFQSWVhc2VzID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSB7fTtcbiAgZm9yIChsZXQgdHlwZSBpbiBlYXNlVHlwZXMpIGxpc3RbdHlwZV0gPSBhID0+IGVhc2VUeXBlc1t0eXBlXShlYXNlSW5Qb3dlcihhKSk7XG4gIHJldHVybiAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi8obGlzdCk7XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBlYXNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlV0FBUElFYXNpbmcgPSAoZWFzZSkgPT4ge1xuICBsZXQgcGFyc2VkRWFzZSA9IFdBQVBJRWFzZXNMb29rdXBzW2Vhc2VdO1xuICBpZiAocGFyc2VkRWFzZSkgcmV0dXJuIHBhcnNlZEVhc2U7XG4gIHBhcnNlZEVhc2UgPSAnbGluZWFyJztcbiAgaWYgKGlzU3RyKGVhc2UpKSB7XG4gICAgaWYgKFxuICAgICAgc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnbGluZWFyJykgfHxcbiAgICAgIHN0cmluZ1N0YXJ0c1dpdGgoZWFzZSwgJ2N1YmljLScpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdzdGVwcycpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdlYXNlJylcbiAgICApIHtcbiAgICAgIHBhcnNlZEVhc2UgPSBlYXNlO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnY3ViaWNCJykpIHtcbiAgICAgIHBhcnNlZEVhc2UgPSB0b0xvd2VyQ2FzZShlYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VFYXNlU3RyaW5nKGVhc2UsIFdBQVBJZWFzZXMsIFdBQVBJRWFzZXNMb29rdXBzKTtcbiAgICAgIGlmIChpc0ZuYyhwYXJzZWQpKSBwYXJzZWRFYXNlID0gcGFyc2VkID09PSBub25lID8gJ2xpbmVhcicgOiBlYXNpbmdUb0xpbmVhcihwYXJzZWQpO1xuICAgIH1cbiAgICBXQUFQSUVhc2VzTG9va3Vwc1tlYXNlXSA9IHBhcnNlZEVhc2U7XG4gIH0gZWxzZSBpZiAoaXNGbmMoZWFzZSkpIHtcbiAgICBjb25zdCBlYXNpbmcgPSBlYXNpbmdUb0xpbmVhcihlYXNlKTtcbiAgICBpZiAoZWFzaW5nKSBwYXJzZWRFYXNlID0gZWFzaW5nO1xuICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKSB7XG4gICAgcGFyc2VkRWFzZSA9IGVhc2luZ1RvTGluZWFyKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkRWFzZTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ8QXJyYXk8U3RyaW5nPnxBcnJheTxOdW1iZXI+fSBXQUFQSVR3ZWVuVmFsdWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXQUFQSUZ1bmN0aW9udmFsdWVcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSB0YXJnZXQgLSBUaGUgYW5pbWF0ZWQgdGFyZ2V0XG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgdGFyZ2V0IGluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gVGhlIHRvdGFsIG51bWJlciBvZiBhbmltYXRlZCB0YXJnZXRzXG4gKiBAcmV0dXJuIHtXQUFQSVR3ZWVuVmFsdWV9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7V0FBUElUd2VlblZhbHVlfFdBQVBJRnVuY3Rpb252YWx1ZXxBcnJheTxTdHJpbmd8TnVtYmVyfFdBQVBJRnVuY3Rpb252YWx1ZT59IFdBQVBJS2V5ZnJhbWVWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhbmltYXRpb246IFdBQVBJQW5pbWF0aW9uKSA9PiB2b2lkfSBXQUFQSUNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXQUFQSVR3ZWVuT3B0aW9uc1xuICogQHByb3BlcnR5IHtXQUFQSUtleWZyYW1lVmFsdWV9IFt0b11cbiAqIEBwcm9wZXJ0eSB7V0FBUElLZXlmcmFtZVZhbHVlfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb252YWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvbnZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q29tcG9zaXRlT3BlcmF0aW9ufSBbY29tcG9zaXRpb25dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXQUFQSUFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEJvb2xlYW59IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbUmV2ZXJzZWRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtBbHRlcm5hdGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58U2Nyb2xsT2JzZXJ2ZXJ9IFthdXRvcGxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvbnZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge051bWJlcnxXQUFQSUZ1bmN0aW9udmFsdWV9IFtkZWxheV1cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHByb3BlcnR5IHtDb21wb3NpdGVPcGVyYXRpb259IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7V0FBUElDYWxsYmFja30gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPFN0cmluZywgV0FBUElLZXlmcmFtZVZhbHVlIHwgV0FBUElBbmltYXRpb25PcHRpb25zIHwgQm9vbGVhbiB8IFNjcm9sbE9ic2VydmVyIHwgV0FBUElDYWxsYmFjayB8IEVhc2luZ1BhcmFtIHwgV0FBUElUd2Vlbk9wdGlvbnM+ICYgV0FBUElBbmltYXRpb25PcHRpb25zfSBXQUFQSUFuaW1hdGlvblBhcmFtc1xuICovXG5cbmNvbnN0IHRyYW5zZm9ybXNTaG9ydGhhbmRzID0gWyd4JywgJ3knLCAneiddO1xuY29uc3QgY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyA9IFtcbiAgJ3BlcnNwZWN0aXZlJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICdtYXJnaW4nLFxuICAncGFkZGluZycsXG4gICd0b3AnLFxuICAncmlnaHQnLFxuICAnYm90dG9tJyxcbiAgJ2xlZnQnLFxuICAnYm9yZGVyV2lkdGgnLFxuICAnZm9udFNpemUnLFxuICAnYm9yZGVyUmFkaXVzJyxcbiAgLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHNcbl07XG5cbmNvbnN0IHZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSBbLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHMsIC4uLnZhbGlkVHJhbnNmb3Jtcy5maWx0ZXIodCA9PiBbJ1gnLCAnWScsICdaJ10uc29tZShheGlzID0+IHQuZW5kc1dpdGgoYXhpcykpKV07XG5cbi8vIFNldHRpbmcgaXQgdG8gdHJ1ZSBpbiBjYXNlIENTUy5yZWdpc3RlclByb3BlcnR5IGlzIG5vdCBzdXBwb3J0ZWQgd2lsbCBhdXRvbWF0aWNhbGx5IHNraXAgdGhlIHJlZ2lzdHJhdGlvbiBhbmQgZmFsbGJhY2sgdG8gbm8gYW5pbWF0aW9uXG5sZXQgdHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkID0gaXNCcm93c2VyICYmIChpc1VuZChDU1MpIHx8ICFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChDU1MsICdyZWdpc3RlclByb3BlcnR5JykpO1xuXG5jb25zdCByZWdpc3RlclRyYW5zZm9ybXNQcm9wZXJ0aWVzID0gKCkgPT4ge1xuICBpZiAodHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkKSByZXR1cm47XG4gIHZhbGlkVHJhbnNmb3Jtcy5mb3JFYWNoKHQgPT4ge1xuICAgIGNvbnN0IGlzU2tldyA9IHN0cmluZ1N0YXJ0c1dpdGgodCwgJ3NrZXcnKTtcbiAgICBjb25zdCBpc1NjYWxlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAnc2NhbGUnKTtcbiAgICBjb25zdCBpc1JvdGF0ZSA9IHN0cmluZ1N0YXJ0c1dpdGgodCwgJ3JvdGF0ZScpO1xuICAgIGNvbnN0IGlzVHJhbnNsYXRlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAndHJhbnNsYXRlJyk7XG4gICAgY29uc3QgaXNBbmdsZSA9IGlzUm90YXRlIHx8IGlzU2tldztcbiAgICBjb25zdCBzeW50YXggPSBpc0FuZ2xlID8gJzxhbmdsZT4nIDogaXNTY2FsZSA/IFwiPG51bWJlcj5cIiA6IGlzVHJhbnNsYXRlID8gXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XCIgOiBcIipcIjtcbiAgICB0cnkge1xuICAgICAgQ1NTLnJlZ2lzdGVyUHJvcGVydHkoe1xuICAgICAgICBuYW1lOiAnLS0nICsgdCxcbiAgICAgICAgc3ludGF4LFxuICAgICAgICBpbmhlcml0czogZmFsc2UsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogaXNUcmFuc2xhdGUgPyAnMHB4JyA6IGlzQW5nbGUgPyAnMGRlZycgOiBpc1NjYWxlID8gJzEnIDogJzAnLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7fSAgfSk7XG4gIHRyYW5zZm9ybXNQcm9wZXJ0aWVzUmVnaXN0ZXJlZCA9IHRydWU7XG59O1xuXG5jb25zdCBXQUFQSUFuaW1hdGlvbnNMb29rdXBzID0ge1xuICBfaGVhZDogbnVsbCxcbiAgX3RhaWw6IG51bGwsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldXG4gKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbcGFyZW50XVxuICovXG5jb25zdCByZW1vdmVXQUFQSUFuaW1hdGlvbiA9ICgkZWwsIHByb3BlcnR5LCBwYXJlbnQpID0+IHtcbiAgbGV0IG5leHRMb29rdXAgPSBXQUFQSUFuaW1hdGlvbnNMb29rdXBzLl9oZWFkO1xuICB3aGlsZSAobmV4dExvb2t1cCkge1xuICAgIGNvbnN0IG5leHQgPSBuZXh0TG9va3VwLl9uZXh0O1xuICAgIGNvbnN0IG1hdGNoVGFyZ2V0ID0gbmV4dExvb2t1cC4kZWwgPT09ICRlbDtcbiAgICBjb25zdCBtYXRjaFByb3BlcnR5ID0gIXByb3BlcnR5IHx8IG5leHRMb29rdXAucHJvcGVydHkgPT09IHByb3BlcnR5O1xuICAgIGNvbnN0IG1hdGNoUGFyZW50ID0gIXBhcmVudCB8fCBuZXh0TG9va3VwLnBhcmVudCA9PT0gcGFyZW50O1xuICAgIGlmIChtYXRjaFRhcmdldCAmJiBtYXRjaFByb3BlcnR5ICYmIG1hdGNoUGFyZW50KSB7XG4gICAgICBjb25zdCBhbmltID0gbmV4dExvb2t1cC5hbmltYXRpb247XG4gICAgICB0cnkgeyBhbmltLmNvbW1pdFN0eWxlcygpOyB9IGNhdGNoIHt9ICAgICAgYW5pbS5jYW5jZWwoKTtcbiAgICAgIHJlbW92ZUNoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIG5leHRMb29rdXApO1xuICAgICAgY29uc3QgbG9va3VwUGFyZW50ID0gbmV4dExvb2t1cC5wYXJlbnQ7XG4gICAgICBpZiAobG9va3VwUGFyZW50KSB7XG4gICAgICAgIGxvb2t1cFBhcmVudC5fY29tcGxldGVkKys7XG4gICAgICAgIGlmIChsb29rdXBQYXJlbnQuYW5pbWF0aW9ucy5sZW5ndGggPT09IGxvb2t1cFBhcmVudC5fY29tcGxldGVkKSB7XG4gICAgICAgICAgbG9va3VwUGFyZW50LmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFsb29rdXBQYXJlbnQubXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgbG9va3VwUGFyZW50LnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBsb29rdXBQYXJlbnQub25Db21wbGV0ZShsb29rdXBQYXJlbnQpO1xuICAgICAgICAgICAgbG9va3VwUGFyZW50Ll9yZXNvbHZlKGxvb2t1cFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRMb29rdXAgPSBuZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb259IHBhcmVudFxuICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1Byb3BlcnR5SW5kZXhlZEtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dW4ge0FuaW1hdGlvbn1cbiAqL1xuY29uc3QgYWRkV0FBUElBbmltYXRpb24gPSAocGFyZW50LCAkZWwsIHByb3BlcnR5LCBrZXlmcmFtZXMsIHBhcmFtcykgPT4ge1xuICBjb25zdCBhbmltYXRpb24gPSAkZWwuYW5pbWF0ZShrZXlmcmFtZXMsIHBhcmFtcyk7XG4gIGNvbnN0IGFuaW1Ub3RhbER1cmF0aW9uID0gcGFyYW1zLmRlbGF5ICsgKCtwYXJhbXMuZHVyYXRpb24gKiBwYXJhbXMuaXRlcmF0aW9ucyk7XG4gIGFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBwYXJlbnQuX3NwZWVkO1xuICBpZiAocGFyZW50LnBhdXNlZCkgYW5pbWF0aW9uLnBhdXNlKCk7XG4gIGlmIChwYXJlbnQuZHVyYXRpb24gPCBhbmltVG90YWxEdXJhdGlvbikge1xuICAgIHBhcmVudC5kdXJhdGlvbiA9IGFuaW1Ub3RhbER1cmF0aW9uO1xuICAgIHBhcmVudC5jb250cm9sQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICB9XG4gIHBhcmVudC5hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eSk7XG4gIGFkZENoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIHsgcGFyZW50LCBhbmltYXRpb24sICRlbCwgcHJvcGVydHksIF9uZXh0OiBudWxsLCBfcHJldjogbnVsbCB9KTtcbiAgY29uc3QgaGFuZGxlUmVtb3ZlID0gKCkgPT4geyByZW1vdmVXQUFQSUFuaW1hdGlvbigkZWwsIHByb3BlcnR5LCBwYXJlbnQpOyB9O1xuICBhbmltYXRpb24ub25yZW1vdmUgPSBoYW5kbGVSZW1vdmU7XG4gIGFuaW1hdGlvbi5vbmZpbmlzaCA9IGhhbmRsZVJlbW92ZTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB2YWx1ZVxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSB0YXJnZXRzTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVR3ZWVuVmFsdWUgPSAocHJvcE5hbWUsIHZhbHVlLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpID0+IHtcbiAgbGV0IHYgPSBnZXRGdW5jdGlvblZhbHVlKC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gIGlmICghaXNOdW0odikpIHJldHVybiB2O1xuICBpZiAoY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wTmFtZSkgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpKSByZXR1cm4gYCR7dn1weGA7XG4gIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSkgcmV0dXJuIGAke3Z9ZGVnYDtcbiAgcmV0dXJuIGAke3Z9YDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gZnJvbVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB0b1xuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRhcmdldHNMZW5ndGhcbiAqIEByZXR1cm4ge1dBQVBJVHdlZW5WYWx1ZX1cbiAqL1xuY29uc3QgcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSA9ICgkZWwsIHByb3BOYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCkgPT4ge1xuICAvKiogQHR5cGUge1dBQVBJVHdlZW5WYWx1ZX0gKi9cbiAgbGV0IHR3ZWVuVmFsdWUgPSAnMCc7XG4gIGNvbnN0IGNvbXB1dGVkVG8gPSAhaXNVbmQodG8pID8gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdG8sICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgOiBnZXRDb21wdXRlZFN0eWxlKCRlbClbcHJvcE5hbWVdO1xuICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgY29uc3QgY29tcHV0ZWRGcm9tID0gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgZnJvbSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICB0d2VlblZhbHVlID0gW2NvbXB1dGVkRnJvbSwgY29tcHV0ZWRUb107XG4gIH0gZWxzZSB7XG4gICAgdHdlZW5WYWx1ZSA9IGlzQXJyKHRvKSA/IHRvLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdiwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgOiBjb21wdXRlZFRvO1xuICB9XG4gIHJldHVybiB0d2VlblZhbHVlO1xufTtcblxuY2xhc3MgV0FBUElBbmltYXRpb24ge1xuLyoqXG4gKiBAcGFyYW0ge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtXQUFQSUFuaW1hdGlvblBhcmFtc30gcGFyYW1zXG4gKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0cywgcGFyYW1zKSB7XG5cbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuXG4gICAgcmVnaXN0ZXJUcmFuc2Zvcm1zUHJvcGVydGllcygpO1xuXG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICBjb25zdCB0YXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICBpZiAoIXRhcmdldHNMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gdGFyZ2V0IGZvdW5kLiBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgeW91J3JlIHRyeWluZyB0byBhbmltYXRlIGlzIGFjY2Vzc2libGUgYmVmb3JlIGNyZWF0aW5nIHlvdXIgYW5pbWF0aW9uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGVhc2UgPSBzZXRWYWx1ZShwYXJhbXMuZWFzZSwgcGFyc2VXQUFQSUVhc2luZyhnbG9iYWxzLmRlZmF1bHRzLmVhc2UpKTtcbiAgICBjb25zdCBzcHJpbmcgPSAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSAmJiBlYXNlO1xuICAgIGNvbnN0IGF1dG9wbGF5ID0gc2V0VmFsdWUocGFyYW1zLmF1dG9wbGF5LCBnbG9iYWxzLmRlZmF1bHRzLmF1dG9wbGF5KTtcbiAgICBjb25zdCBzY3JvbGwgPSBhdXRvcGxheSAmJiAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyhhdXRvcGxheSkubGluayA/IGF1dG9wbGF5IDogZmFsc2U7XG4gICAgY29uc3QgYWx0ZXJuYXRlID0gcGFyYW1zLmFsdGVybmF0ZSAmJiAvKiogQHR5cGUge0Jvb2xlYW59ICovKHBhcmFtcy5hbHRlcm5hdGUpID09PSB0cnVlO1xuICAgIGNvbnN0IHJldmVyc2VkID0gcGFyYW1zLnJldmVyc2VkICYmIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi8ocGFyYW1zLnJldmVyc2VkKSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBsb29wID0gc2V0VmFsdWUocGFyYW1zLmxvb3AsIGdsb2JhbHMuZGVmYXVsdHMubG9vcCk7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLygobG9vcCA9PT0gdHJ1ZSB8fCBsb29wID09PSBJbmZpbml0eSkgPyBJbmZpbml0eSA6IGlzTnVtKGxvb3ApID8gbG9vcCArIDEgOiAxKTtcbiAgICAvKiogQHR5cGUge1BsYXliYWNrRGlyZWN0aW9ufSAqL1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFsdGVybmF0ZSA/IHJldmVyc2VkID8gJ2FsdGVybmF0ZS1yZXZlcnNlJyA6ICdhbHRlcm5hdGUnIDogcmV2ZXJzZWQgPyAncmV2ZXJzZScgOiAnbm9ybWFsJztcbiAgICAvKiogQHR5cGUge0ZpbGxNb2RlfSAqL1xuICAgIGNvbnN0IGZpbGwgPSAnZm9yd2FyZHMnO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xuICAgIGNvbnN0IGVhc2luZyA9IHBhcnNlV0FBUElFYXNpbmcoZWFzZSk7XG4gICAgY29uc3QgdGltZVNjYWxlID0gKGdsb2JhbHMudGltZVNjYWxlID09PSAxID8gMSA6IEspO1xuXG4gICAgLyoqIEB0eXBlIHtET01UYXJnZXRzQXJyYXl9XSAqL1xuICAgIHRoaXMudGFyZ2V0cyA9IHBhcnNlZFRhcmdldHM7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxnbG9iYWxUaGlzLkFuaW1hdGlvbj59XSAqL1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259XSAqL1xuICAgIHRoaXMuY29udHJvbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBwYXJhbXMub25Db21wbGV0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5wYXVzZWQgPSAhYXV0b3BsYXkgfHwgc2Nyb2xsICE9PSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXZlcnNlZCA9IHJldmVyc2VkO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbnxTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLmF1dG9wbGF5ID0gYXV0b3BsYXk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3BlZWQgPSBzZXRWYWx1ZShwYXJhbXMucGxheWJhY2tSYXRlLCBnbG9iYWxzLmRlZmF1bHRzLnBsYXliYWNrUmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbiAgICB0aGlzLl9yZXNvbHZlID0gbm9vcDsgLy8gVXNlZCBieSAudGhlbigpXG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY29tcGxldGVkID0gMDtcbiAgICAvKiogQHR5cGUge0FycmF5PE9iamVjdD59XSAqL1xuICAgIHRoaXMuX2lubGluZVN0eWxlcyA9IHBhcnNlZFRhcmdldHMubWFwKCRlbCA9PiAkZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcblxuICAgIHBhcnNlZFRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiB7XG5cbiAgICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSAkZWxbdHJhbnNmb3Jtc1N5bWJvbF07XG5cbiAgICAgIGNvbnN0IGhhc0luZGl2aWR1YWxUcmFuc2Zvcm1zID0gdmFsaWRJbmRpdmlkdWFsVHJhbnNmb3Jtcy5zb21lKHQgPT4gcGFyYW1zLmhhc093blByb3BlcnR5KHQpKTtcblxuICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IChzcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oc3ByaW5nKS5kdXJhdGlvbiA6IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUocGFyYW1zLmR1cmF0aW9uLCBnbG9iYWxzLmRlZmF1bHRzLmR1cmF0aW9uKSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgKiB0aW1lU2NhbGU7XG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShwYXJhbXMuZGVsYXksIGdsb2JhbHMuZGVmYXVsdHMuZGVsYXkpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpICogdGltZVNjYWxlO1xuICAgICAgLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovXG4gICAgICBjb25zdCBjb21wb3NpdGUgPSAvKiogQHR5cGUge0NvbXBvc2l0ZU9wZXJhdGlvbn0gKi8oc2V0VmFsdWUocGFyYW1zLmNvbXBvc2l0aW9uLCAncmVwbGFjZScpKTtcblxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFpc0tleShuYW1lKSkgY29udGludWU7XG4gICAgICAgIC8qKiBAdHlwZSB7UHJvcGVydHlJbmRleGVkS2V5ZnJhbWVzfSAqL1xuICAgICAgICBjb25zdCBrZXlmcmFtZXMgPSB7fTtcbiAgICAgICAgLyoqIEB0eXBlIHtLZXlmcmFtZUFuaW1hdGlvbk9wdGlvbnN9ICovXG4gICAgICAgIGNvbnN0IHR3ZWVuUGFyYW1zID0geyBpdGVyYXRpb25zLCBkaXJlY3Rpb24sIGZpbGwsIGVhc2luZywgZHVyYXRpb24sIGRlbGF5LCBjb21wb3NpdGUgfTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5ID0gaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMgPyB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMobmFtZSkgPyBuYW1lIDogc2hvcnRUcmFuc2Zvcm1zLmdldChuYW1lKSA6IGZhbHNlO1xuICAgICAgICBsZXQgcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgdHdlZW5PcHRpb25zID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8ocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgY29uc3QgdHdlZW5PcHRpb25zRWFzZSA9IHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5lYXNlLCBlYXNlKTtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnNTcHJpbmcgPSAvKiogQHR5cGUge1NwcmluZ30gKi8odHdlZW5PcHRpb25zRWFzZSkuZWFzZSAmJiB0d2Vlbk9wdGlvbnNFYXNlO1xuICAgICAgICAgIGNvbnN0IHRvID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8odHdlZW5PcHRpb25zKS50bztcbiAgICAgICAgICBjb25zdCBmcm9tID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8odHdlZW5PcHRpb25zKS5mcm9tO1xuICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmR1cmF0aW9uID0gKHR3ZWVuT3B0aW9uc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyh0d2Vlbk9wdGlvbnNTcHJpbmcpLmR1cmF0aW9uIDogZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZSh0d2Vlbk9wdGlvbnMuZHVyYXRpb24sIGR1cmF0aW9uKSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgKiB0aW1lU2NhbGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZGVsYXkgPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5kZWxheSwgZGVsYXkpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpICogdGltZVNjYWxlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmNvbXBvc2l0ZSA9IC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqLyhzZXRWYWx1ZSh0d2Vlbk9wdGlvbnMuY29tcG9zaXRpb24sIGNvbXBvc2l0ZSkpO1xuICAgICAgICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmVhc2luZyA9IHBhcnNlV0FBUElFYXNpbmcodHdlZW5PcHRpb25zRWFzZSk7XG4gICAgICAgICAgcGFyc2VkUHJvcGVydHlWYWx1ZSA9IHBhcnNlSW5kaXZpZHVhbFR3ZWVuVmFsdWUoJGVsLCBuYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgaWYgKGluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAga2V5ZnJhbWVzW2AtLSR7aW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5fWBdID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5XSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tuYW1lXSA9IHBhcnNlSW5kaXZpZHVhbFR3ZWVuVmFsdWUoJGVsLCBuYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFdBQVBJQW5pbWF0aW9uKHRoaXMsICRlbCwgbmFtZSwga2V5ZnJhbWVzLCB0d2VlblBhcmFtcyk7XG4gICAgICAgICAgaWYgKCFpc1VuZChmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgJGVsLnN0eWxlW25hbWVdID0ga2V5ZnJhbWVzW25hbWVdWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYC0tJHtpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHl9YDtcbiAgICAgICAgICAgICAgJGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwga2V5ZnJhbWVzW2tleV1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZWRQcm9wZXJ0eVZhbHVlID0gaXNBcnIocHJvcGVydHlWYWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShuYW1lLCB2LCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVR3ZWVuVmFsdWUobmFtZSwgLyoqIEB0eXBlIHthbnl9ICovKHByb3BlcnR5VmFsdWUpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpO1xuICAgICAgICAgIGlmIChpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tgLS0ke2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eX1gXSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICBjYWNoZWRUcmFuc2Zvcm1zW2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eV0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbbmFtZV0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRXQUFQSUFuaW1hdGlvbih0aGlzLCAkZWwsIG5hbWUsIGtleWZyYW1lcywgdHdlZW5QYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybXMgPSBlbXB0eVN0cmluZztcbiAgICAgICAgZm9yIChsZXQgdCBpbiBjYWNoZWRUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgdHJhbnNmb3JtcyArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW3RdfXZhcigtLSR7dH0pKSBgO1xuICAgICAgICB9XG4gICAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8odGhpcy5hdXRvcGxheSkubGluayh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGZvckVhY2hDYWxsYmFja1xuICAgKiBAcGFyYW0ge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSBhbmltYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2ZvckVhY2hDYWxsYmFja3xTdHJpbmd9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSBpc1N0cihjYWxsYmFjaykgPyBhID0+IGFbY2FsbGJhY2tdKCkgOiBjYWxsYmFjaztcbiAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZCAqL1xuICBzZXQgc3BlZWQoc3BlZWQpIHtcbiAgICB0aGlzLl9zcGVlZCA9ICtzcGVlZDtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLnBsYXliYWNrUmF0ZSA9IHNwZWVkKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCBjb250cm9sQW5pbWF0aW9uID0gdGhpcy5jb250cm9sQW5pbWF0aW9uO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGdsb2JhbHMudGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlZCA/IHRoaXMuZHVyYXRpb24gOiBjb250cm9sQW5pbWF0aW9uID8gK2NvbnRyb2xBbmltYXRpb24uY3VycmVudFRpbWUgKiAodGltZVNjYWxlID09PSAxID8gMSA6IHRpbWVTY2FsZSkgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICovXG4gIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgY29uc3QgdCA9IHRpbWUgKiAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG4gICAgdGhpcy5mb3JFYWNoKGFuaW0gPT4ge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gcGxheVN0YXRlIGlzIG5vdCAncGF1c2VkJyBpbiBvcmRlciB0byBwcm9wZXJseSB0cmlnZ2VyIGFuIG9uZmluaXNoIGNhbGxiYWNrLlxuICAgICAgLy8gVGhlIFwicGF1c2VkXCIgcGxheSBzdGF0ZSBzdXBlcnNlZGVzIHRoZSBcImZpbmlzaGVkXCIgcGxheSBzdGF0ZTsgaWYgdGhlIGFuaW1hdGlvbiBpcyBib3RoIHBhdXNlZCBhbmQgZmluaXNoZWQsIHRoZSBcInBhdXNlZFwiIHN0YXRlIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlIHJlcG9ydGVkLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9maW5pc2hfZXZlbnRcbiAgICAgIGlmICh0ID49IHRoaXMuZHVyYXRpb24pIGFuaW0ucGxheSgpO1xuICAgICAgYW5pbS5jdXJyZW50VGltZSA9IHQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLmN1cnJlbnRUaW1lID0gcHJvZ3Jlc3MgKiB0aGlzLmR1cmF0aW9uIHx8IDApO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gVE9ETzogU3RvcmUgdGhlIGN1cnJlbnQgdGltZSwgYW5kIHNlZWsgYmFjayB0byB0aGUgbGFzdCBwb3NpdGlvblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BsYXknKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BhdXNlJyk7XG4gIH1cblxuICBhbHRlcm5hdGUoKSB7XG4gICAgdGhpcy5yZXZlcnNlZCA9ICF0aGlzLnJldmVyc2VkO1xuICAgIHRoaXMuZm9yRWFjaCgncmV2ZXJzZScpO1xuICAgIGlmICh0aGlzLnBhdXNlZCkgdGhpcy5mb3JFYWNoKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldmVyc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAvKipcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gbXV0ZUNhbGxiYWNrc1xuICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgIGlmIChtdXRlQ2FsbGJhY2tzKSB0aGlzLm11dGVDYWxsYmFja3MgPSB0cnVlO1xuICAgIGlmICh0aW1lIDwgdGhpcy5kdXJhdGlvbikgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHRoaXMucGF1c2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3RhcnQoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zZWVrKDAsIHRydWUpLnJlc3VtZSgpO1xuICB9XG5cbiAgY29tbWl0U3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ2NvbW1pdFN0eWxlcycpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmZvckVhY2goJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiAkZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuX2lubGluZVN0eWxlc1tpXSkgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtXQUFQSUNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IHRoZW4gPSB0aGlzLnRoZW47XG4gICAgY29uc3Qgb25SZXNvbHZlID0gKCkgPT4ge1xuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVkKSB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCB3YWFwaSA9IHtcbi8qKlxuICogQHBhcmFtIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb25QYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7V0FBUElBbmltYXRpb259XG4gKi9cbiAgYW5pbWF0ZTogKHRhcmdldHMsIHBhcmFtcykgPT4gbmV3IFdBQVBJQW5pbWF0aW9uKHRhcmdldHMsIHBhcmFtcyksXG4gIGNvbnZlcnRFYXNlOiBlYXNpbmdUb0xpbmVhclxufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtDYWxsYmFjazxUaW1lcj59IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBzeW5jID0gKGNhbGxiYWNrID0gbm9vcCkgPT4ge1xuICByZXR1cm4gbmV3IFRpbWVyKHsgZHVyYXRpb246IDEgKiBnbG9iYWxzLnRpbWVTY2FsZSwgb25Db21wbGV0ZTogY2FsbGJhY2sgfSwgbnVsbCwgMCkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0U2VsZWN0b3J9IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgcHJvcE5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHByb3BOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICB1bml0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHByb3BOYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIHVuaXRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19ICAgdGFyZ2V0U2VsZWN0b3JcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfEJvb2xlYW59IFt1bml0XVxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXRTZWxlY3RvciwgcHJvcE5hbWUsIHVuaXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRTZWxlY3Rvcik7XG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHJldHVybjtcbiAgY29uc3QgWyB0YXJnZXQgXSA9IHRhcmdldHM7XG4gIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgY29uc3Qgbm9ybWFsaXplUHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwcm9wTmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpO1xuICBsZXQgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgbm9ybWFsaXplUHJvcE5hbWUpO1xuICBpZiAoaXNVbmQodW5pdCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZWNvbXBvc2VSYXdWYWx1ZShvcmlnaW5hbFZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSIHx8IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgaWYgKHVuaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSwgLyoqIEB0eXBlIHtTdHJpbmd9ICovKHVuaXQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBgJHtyb3VuZChjb252ZXJ0ZWRWYWx1ZS5uLCBnbG9iYWxzLnByZWNpc2lvbil9JHtjb252ZXJ0ZWRWYWx1ZS51fWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSAgICB0YXJnZXRzXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBzZXRUYXJnZXRWYWx1ZXMgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4ge1xuICBpZiAoaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgcGFyYW1ldGVycy5kdXJhdGlvbiA9IG1pblZhbHVlO1xuICAvLyBEbyBub3Qgb3ZlcnJpZGVzIGN1cnJlbnRseSBhY3RpdmUgdHdlZW5zIGJ5IGRlZmF1bHRcbiAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IHNldFZhbHVlKHBhcmFtZXRlcnMuY29tcG9zaXRpb24sIGNvbXBvc2l0aW9uVHlwZXMubm9uZSk7XG4gIC8vIFNraXAgaW5pdCgpIGFuZCBmb3JjZSByZW5kZXJpbmcgYnkgcGxheWluZyB0aGUgYW5pbWF0aW9uXG4gIHJldHVybiBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywgcGFyYW1ldGVycywgbnVsbCwgMCwgdHJ1ZSkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNBcnJheX0gdGFyZ2V0c0FycmF5XG4gKiBAcGFyYW0gIHtKU0FuaW1hdGlvbn0gICAgYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtwcm9wZXJ0eU5hbWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbiA9ICh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbiwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGxldCB0d2VlbnNNYXRjaGVzVGFyZ2V0cyA9IGZhbHNlO1xuICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgaWYgKHRhcmdldHNBcnJheS5pbmNsdWRlcyh0d2VlblRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHR3ZWVuTmFtZSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgICAgY29uc3QgdHdlZW5UeXBlID0gdHdlZW4uX3R3ZWVuVHlwZTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZVByb3BOYW1lID0gc2FuaXRpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lLCB0d2VlblRhcmdldCwgdHdlZW5UeXBlKTtcbiAgICAgIGlmICghbm9ybWFsaXplUHJvcE5hbWUgfHwgbm9ybWFsaXplUHJvcE5hbWUgJiYgbm9ybWFsaXplUHJvcE5hbWUgPT09IHR3ZWVuTmFtZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gZmxhZyB0aGUgcHJldmlvdXMgQ1NTIHRyYW5zZm9ybSB0d2VlbiB0byByZW5kZXJUcmFuc2Zvcm1cbiAgICAgICAgaWYgKHR3ZWVuLnBhcmVudC5fdGFpbCA9PT0gdHdlZW4gJiZcbiAgICAgICAgICAgIHR3ZWVuLl90d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNICYmXG4gICAgICAgICAgICB0d2Vlbi5fcHJldiAmJlxuICAgICAgICAgICAgdHdlZW4uX3ByZXYuX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdHdlZW4uX3ByZXYuX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIHR3ZWVuIGZyb20gdGhlIHNlbGVjdGVkIGFuaW1hdGlvblxuICAgICAgICByZW1vdmVDaGlsZChhbmltYXRpb24sIHR3ZWVuKTtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSB0d2VlbiBmcm9tIGl0cyBzaWJsaW5ncyB0byBtYWtlIHN1cmUgYmxlbmRlZCB0d2VlbnMgYXJlIGNvcnJlY3RsbHkgcmVtb3ZlZFxuICAgICAgICByZW1vdmVUd2VlblNsaWJsaW5ncyh0d2Vlbik7XG4gICAgICAgIHR3ZWVuc01hdGNoZXNUYXJnZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuICByZXR1cm4gdHdlZW5zTWF0Y2hlc1RhcmdldHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtICB7UmVuZGVyYWJsZXxXQUFQSUFuaW1hdGlvbn0gW3JlbmRlcmFibGVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICBbcHJvcGVydHlOYW1lXVxuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICovXG5jb25zdCByZW1vdmUgPSAodGFyZ2V0cywgcmVuZGVyYWJsZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGNvbnN0IHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfHR5cGVvZiBlbmdpbmV9ICoqLyhyZW5kZXJhYmxlID8gcmVuZGVyYWJsZSA6IGVuZ2luZSk7XG4gIGNvbnN0IHdhYXBpQW5pbWF0aW9uID0gcmVuZGVyYWJsZSAmJiAvKiogQHR5cGUge1dBQVBJQW5pbWF0aW9ufSAqLyhyZW5kZXJhYmxlKS5jb250cm9sQW5pbWF0aW9uICYmIC8qKiBAdHlwZSB7V0FBUElBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRhcmdldHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gICovKHRhcmdldHNBcnJheVtpXSk7XG4gICAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eU5hbWUsIHdhYXBpQW5pbWF0aW9uKTtcbiAgfVxuICBsZXQgcmVtb3ZlTWF0Y2hlcztcbiAgaWYgKHBhcmVudC5faGFzQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICAgIGZvckVhY2hDaGlsZHJlbihwYXJlbnQsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQuX2hhc0NoaWxkcmVuKSB7XG4gICAgICAgIHJlbW92ZU1hdGNoZXMgPSByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbih0YXJnZXRzQXJyYXksIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgaWYgbm8gdHdlZW5zIGFuZCBubyBjaGlsZHJlbiBsZWZ0IGFmdGVyIHRoZSByZW1vdmFsXG4gICAgICAgIGlmIChyZW1vdmVNYXRjaGVzICYmICFjaGlsZC5faGVhZCkge1xuICAgICAgICAgIGNoaWxkLmNhbmNlbCgpO1xuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGl0ZXJhdGlvbkR1cmF0aW9uIHZhbHVlIHRvIGhhbmRsZSBvbkNvbXBsZXRlIHdpdGggbGFzdCBjaGlsZCBpbiByZW5kZXIoKVxuICAgICAgICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgICAgICAgIGlmIChjaGlsZER1ciA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRvIGFsc28gcmVtb3ZlIGVuZ2luZSdzIGNoaWxkcmVuIHRhcmdldHNcbiAgICAgIC8vIE5PVEU6IEF2b2lkIHJlY3Vyc2lvbj9cbiAgICAgIGlmIChjaGlsZC5faGVhZCkge1xuICAgICAgICByZW1vdmUodGFyZ2V0cywgY2hpbGQsIHByb3BlcnR5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgICAvLyBVcGRhdGUgaXRlcmF0aW9uRHVyYXRpb24gdmFsdWUgdG8gaGFuZGxlIG9uQ29tcGxldGUgd2l0aCBsYXN0IGNoaWxkIGluIHJlbmRlcigpXG4gICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24pKSB7XG4gICAgICAvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlTWF0Y2hlcyA9IHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uKFxuICAgICAgdGFyZ2V0c0FycmF5LFxuICAgICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocGFyZW50KSxcbiAgICAgIHByb3BlcnR5TmFtZVxuICAgICk7XG4gIH1cblxuICBpZiAocmVtb3ZlTWF0Y2hlcyAmJiAhcGFyZW50Ll9oZWFkKSB7XG4gICAgcGFyZW50Ll9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICAgIC8vIENhbmNlbCB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyB0d2VlbnMgYW5kIG5vIGNoaWxkcmVuIGxlZnQgYWZ0ZXIgdGhlIHJlbW92YWxcbiAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSAuY2FuY2VsKCkgbWV0aG9kIGV4aXN0IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIHRoZSBlbmdpbmUgaXRzZWxmXG4gICAgaWYgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwpIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwoKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzQXJyYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gbWluXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heFxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVjaW1hbExlbmd0aF1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmFuZG9tID0gKG1pbiwgbWF4LCBkZWNpbWFsTGVuZ3RoKSA9PiB7IGNvbnN0IG0gPSAxMCAqKiAoZGVjaW1hbExlbmd0aCB8fCAwKTsgcmV0dXJuIGZsb29yKChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArICgxIC8gbSkpICsgbWluKSAqIG0pIC8gbSB9O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcmFuZG9tUGljayA9IGl0ZW1zID0+IGl0ZW1zW3JhbmRvbSgwLCBpdGVtcy5sZW5ndGggLSAxKV07XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NodWZmbGUvXG4gKiBAcGFyYW0gIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzaHVmZmxlID0gaXRlbXMgPT4ge1xuICBsZXQgbSA9IGl0ZW1zLmxlbmd0aCwgdCwgaTtcbiAgd2hpbGUgKG0pIHsgaSA9IHJhbmRvbSgwLCAtLW0pOyB0ID0gaXRlbXNbbV07IGl0ZW1zW21dID0gaXRlbXNbaV07IGl0ZW1zW2ldID0gdDsgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gZGVjaW1hbExlbmd0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCByb3VuZFBhZCA9ICh2LCBkZWNpbWFsTGVuZ3RoKSA9PiAoK3YpLnRvRml4ZWQoZGVjaW1hbExlbmd0aCk7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBwYWRTdGFydCA9ICh2LCB0b3RhbExlbmd0aCwgcGFkU3RyaW5nKSA9PiBgJHt2fWAucGFkU3RhcnQodG90YWxMZW5ndGgsIHBhZFN0cmluZyk7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBwYWRFbmQgPSAodiwgdG90YWxMZW5ndGgsIHBhZFN0cmluZykgPT4gYCR7dn1gLnBhZEVuZCh0b3RhbExlbmd0aCwgcGFkU3RyaW5nKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gbWluXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCB3cmFwID0gKHYsIG1pbiwgbWF4KSA9PiAoKCh2IC0gbWluKSAlIChtYXggLSBtaW4pICsgKG1heCAtIG1pbikpICUgKG1heCAtIG1pbikpICsgbWluO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gaW5Mb3dcbiAqIEBwYXJhbSAge051bWJlcn0gaW5IaWdoXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG91dExvd1xuICogQHBhcmFtICB7TnVtYmVyfSBvdXRIaWdoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IG1hcFJhbmdlID0gKHZhbHVlLCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpID0+IG91dExvdyArICgodmFsdWUgLSBpbkxvdykgLyAoaW5IaWdoIC0gaW5Mb3cpKSAqIChvdXRIaWdoIC0gb3V0TG93KTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZGVnVG9SYWQgPSBkZWdyZWVzID0+IGRlZ3JlZXMgKiBQSSAvIDE4MDtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmFkVG9EZWcgPSByYWRpYW5zID0+IHJhZGlhbnMgKiAxODAgLyBQSTtcblxuLyoqXG4gKiBodHRwczovL3d3dy5yb3J5ZHJpc2NvbGwuY29tLzIwMTYvMDMvMDcvZnJhbWUtcmF0ZS1pbmRlcGVuZGVudC1kYW1waW5nLXVzaW5nLWxlcnAvXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBhbW91bnRcbiAqIEBwYXJhbSAge1JlbmRlcmFibGV8Qm9vbGVhbn0gW3JlbmRlcmFibGVdXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGxlcnAgPSAoc3RhcnQsIGVuZCwgYW1vdW50LCByZW5kZXJhYmxlKSA9PiB7XG4gIGxldCBkdCA9IEsgLyBnbG9iYWxzLmRlZmF1bHRzLmZyYW1lUmF0ZTtcbiAgaWYgKHJlbmRlcmFibGUgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgdGlja2VyID0gLyoqIEB0eXBlIFJlbmRlcmFibGUgKi9cbiAgICAgICAgICAgICAgICAgICAocmVuZGVyYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAoZW5naW5lLl9oYXNDaGlsZHJlbiAmJiBlbmdpbmUpO1xuICAgIGlmICh0aWNrZXIgJiYgdGlja2VyLmRlbHRhVGltZSkge1xuICAgICAgZHQgPSB0aWNrZXIuZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuICBjb25zdCB0ID0gMSAtIE1hdGguZXhwKC1hbW91bnQgKiBkdCAqIC4xKTtcbiAgcmV0dXJuICFhbW91bnQgPyBzdGFydCA6IGFtb3VudCA9PT0gMSA/IGVuZCA6ICgxIC0gdCkgKiBzdGFydCArIHQgKiBlbmQ7XG59O1xuXG4vLyBDaGFpbi1hYmxlIHV0aWxpdGllc1xuXG4vKipcbiAqIEBjYWxsYmFjayBVdGlsaXR5RnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqXG4gKiBAcGFyYW0ge1V0aWxpdHlGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGFzdD0wXVxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uKE51bWJlcnxTdHJpbmcpKTogZnVuY3Rpb24oTnVtYmVyfFN0cmluZyk6IChOdW1iZXJ8U3RyaW5nKX1cbiAqL1xuY29uc3QgY3VycnkgPSAoZm4sIGxhc3QgPSAwKSA9PiAoLi4uYXJncykgPT4gbGFzdCA/IHYgPT4gZm4oLi4uYXJncywgdikgOiB2ID0+IGZuKHYsIC4uLmFyZ3MpO1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpfVxuICovXG5jb25zdCBjaGFpbiA9IGZuID0+IHtcbiAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBuZXcgUHJveHkobm9vcCwge1xuICAgICAgYXBwbHk6IChfLCBfXywgW3ZdKSA9PiByZXN1bHQodiksXG4gICAgICBnZXQ6IChfLCBwcm9wKSA9PiBjaGFpbigvKipAcGFyYW0gey4uLk51bWJlcnxTdHJpbmd9IG5leHRBcmdzICovKC4uLm5leHRBcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRSZXN1bHQgPSB1dGlsc1twcm9wXSguLi5uZXh0QXJncyk7XG4gICAgICAgIHJldHVybiAoLyoqQHR5cGUge051bWJlcnxTdHJpbmd9ICovdikgPT4gbmV4dFJlc3VsdChyZXN1bHQodikpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1V0aWxpdHlGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmlnaHRdXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpOiBVdGlsaXR5RnVuY3Rpb259XG4gKi9cbmNvbnN0IG1ha2VDaGFpbmFibGUgPSAoZm4sIHJpZ2h0ID0gMCkgPT4gKC4uLmFyZ3MpID0+IChhcmdzLmxlbmd0aCA8IGZuLmxlbmd0aCA/IGNoYWluKGN1cnJ5KGZuLCByaWdodCkpIDogZm4pKC4uLmFyZ3MpO1xuXG4vKipcbiAqIEBjYWxsYmFjayBDaGFpbmVkVXRpbHNSZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYWluYWJsZVV0aWxzXG4gKiBAcHJvcGVydHkge0NoYWluZWRDbGFtcH0gY2xhbXBcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJvdW5kfSByb3VuZFxuICogQHByb3BlcnR5IHtDaGFpbmVkU25hcH0gc25hcFxuICogQHByb3BlcnR5IHtDaGFpbmVkV3JhcH0gd3JhcFxuICogQHByb3BlcnR5IHtDaGFpbmVkSW50ZXJwb2xhdGV9IGludGVycG9sYXRlXG4gKiBAcHJvcGVydHkge0NoYWluZWRNYXBSYW5nZX0gbWFwUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJvdW5kUGFkfSByb3VuZFBhZFxuICogQHByb3BlcnR5IHtDaGFpbmVkUGFkU3RhcnR9IHBhZFN0YXJ0XG4gKiBAcHJvcGVydHkge0NoYWluZWRQYWRFbmR9IHBhZEVuZFxuICogQHByb3BlcnR5IHtDaGFpbmVkRGVnVG9SYWR9IGRlZ1RvUmFkXG4gKiBAcHJvcGVydHkge0NoYWluZWRSYWRUb0RlZ30gcmFkVG9EZWdcbiAqXG4gKiBAdHlwZWRlZiB7Q2hhaW5hYmxlVXRpbHMgJiBDaGFpbmVkVXRpbHNSZXN1bHR9IENoYWluYWJsZVV0aWxcbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZENsYW1wXG4gKiBAcGFyYW0ge051bWJlcn0gbWluXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUm91bmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFsTGVuZ3RoXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkU25hcFxuICogQHBhcmFtIHtOdW1iZXJ9IGluY3JlbWVudFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRJbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkTWFwUmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbkxvd1xuICogQHBhcmFtIHtOdW1iZXJ9IGluSGlnaFxuICogQHBhcmFtIHtOdW1iZXJ9IG91dExvd1xuICogQHBhcmFtIHtOdW1iZXJ9IG91dEhpZ2hcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRSb3VuZFBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRQYWRTdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUGFkRW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRTdHJpbmdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWREZWdUb1JhZFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFJhZFRvRGVnXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICovXG5cbmNvbnN0IHV0aWxzID0ge1xuICAkOiByZWdpc3RlclRhcmdldHMsXG4gIGdldDogZ2V0VGFyZ2V0VmFsdWUsXG4gIHNldDogc2V0VGFyZ2V0VmFsdWVzLFxuICByZW1vdmUsXG4gIGNsZWFuSW5saW5lU3R5bGVzLFxuICByYW5kb20sXG4gIHJhbmRvbVBpY2ssXG4gIHNodWZmbGUsXG4gIGxlcnAsXG4gIHN5bmMsXG4gIGNsYW1wOiAvKiogQHR5cGUge3R5cGVvZiBjbGFtcCAmIENoYWluZWRDbGFtcH0gKi8obWFrZUNoYWluYWJsZShjbGFtcCkpLFxuICByb3VuZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmQgJiBDaGFpbmVkUm91bmR9ICovKG1ha2VDaGFpbmFibGUocm91bmQpKSxcbiAgc25hcDogLyoqIEB0eXBlIHt0eXBlb2Ygc25hcCAmIENoYWluZWRTbmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHNuYXApKSxcbiAgd3JhcDogLyoqIEB0eXBlIHt0eXBlb2Ygd3JhcCAmIENoYWluZWRXcmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHdyYXApKSxcbiAgaW50ZXJwb2xhdGU6IC8qKiBAdHlwZSB7dHlwZW9mIGludGVycG9sYXRlICYgQ2hhaW5lZEludGVycG9sYXRlfSAqLyhtYWtlQ2hhaW5hYmxlKGludGVycG9sYXRlLCAxKSksXG4gIG1hcFJhbmdlOiAvKiogQHR5cGUge3R5cGVvZiBtYXBSYW5nZSAmIENoYWluZWRNYXBSYW5nZX0gKi8obWFrZUNoYWluYWJsZShtYXBSYW5nZSkpLFxuICByb3VuZFBhZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmRQYWQgJiBDaGFpbmVkUm91bmRQYWR9ICovKG1ha2VDaGFpbmFibGUocm91bmRQYWQpKSxcbiAgcGFkU3RhcnQ6IC8qKiBAdHlwZSB7dHlwZW9mIHBhZFN0YXJ0ICYgQ2hhaW5lZFBhZFN0YXJ0fSAqLyhtYWtlQ2hhaW5hYmxlKHBhZFN0YXJ0KSksXG4gIHBhZEVuZDogLyoqIEB0eXBlIHt0eXBlb2YgcGFkRW5kICYgQ2hhaW5lZFBhZEVuZH0gKi8obWFrZUNoYWluYWJsZShwYWRFbmQpKSxcbiAgZGVnVG9SYWQ6IC8qKiBAdHlwZSB7dHlwZW9mIGRlZ1RvUmFkICYgQ2hhaW5lZERlZ1RvUmFkfSAqLyhtYWtlQ2hhaW5hYmxlKGRlZ1RvUmFkKSksXG4gIHJhZFRvRGVnOiAvKiogQHR5cGUge3R5cGVvZiByYWRUb0RlZyAmIENoYWluZWRSYWRUb0RlZ30gKi8obWFrZUNoYWluYWJsZShyYWRUb0RlZykpLFxufTtcblxuXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfFN0cmluZ3xGdW5jdGlvbn0gVGltZVBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBUaW1lbGluZSdzIGNoaWxkcmVuIG9mZnNldHMgcG9zaXRpb25zIHBhcnNlclxuICogQHBhcmFtICB7VGltZWxpbmV9IHRpbWVsaW5lXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRQcmV2Q2hpbGRPZmZzZXQgPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBpZiAoc3RyaW5nU3RhcnRzV2l0aCh0aW1lUG9zaXRpb24sICc8JykpIHtcbiAgICBjb25zdCBnb1RvUHJldkFuaW1hdGlvbk9mZnNldCA9IHRpbWVQb3NpdGlvblsxXSA9PT0gJzwnO1xuICAgIGNvbnN0IHByZXZBbmltYXRpb24gPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aW1lbGluZS5fdGFpbCk7XG4gICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZBbmltYXRpb24gPyBwcmV2QW5pbWF0aW9uLl9vZmZzZXQgKyBwcmV2QW5pbWF0aW9uLl9kZWxheSA6IDA7XG4gICAgcmV0dXJuIGdvVG9QcmV2QW5pbWF0aW9uT2Zmc2V0ID8gcHJldk9mZnNldCA6IHByZXZPZmZzZXQgKyBwcmV2QW5pbWF0aW9uLmR1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0aW1lbGluZVxuICogQHBhcmFtICB7VGltZVBvc2l0aW9ufSBbdGltZVBvc2l0aW9uXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZVRpbWVsaW5lUG9zaXRpb24gPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBsZXQgdGxEdXJhdGlvbiA9IHRpbWVsaW5lLml0ZXJhdGlvbkR1cmF0aW9uO1xuICBpZiAodGxEdXJhdGlvbiA9PT0gbWluVmFsdWUpIHRsRHVyYXRpb24gPSAwO1xuICBpZiAoaXNVbmQodGltZVBvc2l0aW9uKSkgcmV0dXJuIHRsRHVyYXRpb247XG4gIGlmIChpc051bSgrdGltZVBvc2l0aW9uKSkgcmV0dXJuICt0aW1lUG9zaXRpb247XG4gIGNvbnN0IHRpbWVQb3NTdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8odGltZVBvc2l0aW9uKTtcbiAgY29uc3QgdGxMYWJlbHMgPSB0aW1lbGluZSA/IHRpbWVsaW5lLmxhYmVscyA6IG51bGw7XG4gIGNvbnN0IGhhc0xhYmVscyA9ICFpc05pbCh0bExhYmVscyk7XG4gIGNvbnN0IHByZXZPZmZzZXQgPSBnZXRQcmV2Q2hpbGRPZmZzZXQodGltZWxpbmUsIHRpbWVQb3NTdHIpO1xuICBjb25zdCBoYXNTaWJsaW5nID0gIWlzVW5kKHByZXZPZmZzZXQpO1xuICBjb25zdCBtYXRjaGVkUmVsYXRpdmVPcGVyYXRvciA9IHJlbGF0aXZlVmFsdWVzRXhlY1JneC5leGVjKHRpbWVQb3NTdHIpO1xuICBpZiAobWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3IpIHtcbiAgICBjb25zdCBmdWxsT3BlcmF0b3IgPSBtYXRjaGVkUmVsYXRpdmVPcGVyYXRvclswXTtcbiAgICBjb25zdCBzcGxpdCA9IHRpbWVQb3NTdHIuc3BsaXQoZnVsbE9wZXJhdG9yKTtcbiAgICBjb25zdCBsYWJlbE9mZnNldCA9IGhhc0xhYmVscyAmJiBzcGxpdFswXSA/IHRsTGFiZWxzW3NwbGl0WzBdXSA6IHRsRHVyYXRpb247XG4gICAgY29uc3QgcGFyc2VkT2Zmc2V0ID0gaGFzU2libGluZyA/IHByZXZPZmZzZXQgOiBoYXNMYWJlbHMgPyBsYWJlbE9mZnNldCA6IHRsRHVyYXRpb247XG4gICAgY29uc3QgcGFyc2VkTnVtZXJpY2FsT2Zmc2V0ID0gK3NwbGl0WzFdO1xuICAgIHJldHVybiBnZXRSZWxhdGl2ZVZhbHVlKHBhcnNlZE9mZnNldCwgcGFyc2VkTnVtZXJpY2FsT2Zmc2V0LCBmdWxsT3BlcmF0b3JbMF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNTaWJsaW5nID8gcHJldk9mZnNldCA6XG4gICAgICAgICAgIGhhc0xhYmVscyA/ICFpc1VuZCh0bExhYmVsc1t0aW1lUG9zU3RyXSkgPyB0bExhYmVsc1t0aW1lUG9zU3RyXSA6XG4gICAgICAgICAgIHRsRHVyYXRpb24gOiB0bER1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGltZWxpbmV9IHRsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVsaW5lVG90YWxEdXJhdGlvbih0bCkge1xuICByZXR1cm4gY2xhbXBJbmZpbml0eSgoKHRsLml0ZXJhdGlvbkR1cmF0aW9uICsgdGwuX2xvb3BEZWxheSkgKiB0bC5pdGVyYXRpb25Db3VudCkgLSB0bC5fbG9vcERlbGF5KSB8fCBtaW5WYWx1ZTtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge1RpbWVyUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7VGltZWxpbmV9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IGNoaWxkUGFyYW1zXG4gKiBAcGFyYW0gIHtUaW1lbGluZX0gdGxcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSAge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXVxuICogQHJldHVybiB7VGltZWxpbmV9XG4gKlxuICogQHBhcmFtICB7VGltZXJQYXJhbXN8QW5pbWF0aW9uUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSBbdGFyZ2V0c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXVxuICovXG5mdW5jdGlvbiBhZGRUbENoaWxkKGNoaWxkUGFyYW1zLCB0bCwgdGltZVBvc2l0aW9uLCB0YXJnZXRzLCBpbmRleCwgbGVuZ3RoKSB7XG4gIGNvbnN0IGlzU2V0dGVyID0gaXNOdW0oY2hpbGRQYXJhbXMuZHVyYXRpb24pICYmIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhjaGlsZFBhcmFtcy5kdXJhdGlvbikgPD0gbWluVmFsdWU7XG4gIC8vIE9mZnNldCB0aGUgdGwgcG9zaXRpb24gd2l0aCAtbWluVmFsdWUgZm9yIDAgZHVyYXRpb24gYW5pbWF0aW9ucyBvciAuc2V0KCkgY2FsbHMgaW4gb3JkZXIgdG8gYWxpZ24gdGhlaXIgZW5kIHZhbHVlIHdpdGggdGhlIGRlZmluZWQgcG9zaXRpb25cbiAgY29uc3QgYWRqdXN0ZWRQb3NpdGlvbiA9IGlzU2V0dGVyID8gdGltZVBvc2l0aW9uIC0gbWluVmFsdWUgOiB0aW1lUG9zaXRpb247XG4gIHRpY2sodGwsIGFkanVzdGVkUG9zaXRpb24sIDEsIDEsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgY29uc3QgdGxDaGlsZCA9IHRhcmdldHMgP1xuICAgIG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqLyhjaGlsZFBhcmFtcyksIHRsLCBhZGp1c3RlZFBvc2l0aW9uLCBmYWxzZSwgaW5kZXgsIGxlbmd0aCkgOlxuICAgIG5ldyBUaW1lcigvKiogQHR5cGUge1RpbWVyUGFyYW1zfSAqLyhjaGlsZFBhcmFtcyksIHRsLCBhZGp1c3RlZFBvc2l0aW9uKTtcbiAgdGxDaGlsZC5pbml0KDEpO1xuICAvLyBUT0RPOiBNaWdodCBiZSBiZXR0ZXIgdG8gaW5zZXJ0IGF0IGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gc3RhcnRUaW1lP1xuICBhZGRDaGlsZCh0bCwgdGxDaGlsZCk7XG4gIGZvckVhY2hDaGlsZHJlbih0bCwgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9jaGlsZCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgIGlmIChjaGlsZER1ciA+IHRsLml0ZXJhdGlvbkR1cmF0aW9uKSB0bC5pdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICB9KTtcbiAgdGwuZHVyYXRpb24gPSBnZXRUaW1lbGluZVRvdGFsRHVyYXRpb24odGwpO1xuICByZXR1cm4gdGw7XG59XG5cbmNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgVGltZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIHN1cGVyKC8qKiBAdHlwZSB7VGltZXJQYXJhbXMmVGltZWxpbmVQYXJhbXN9ICovKHBhcmFtZXRlcnMpLCBudWxsLCAwKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDsgLy8gVEwgZHVyYXRpb24gc3RhcnRzIGF0IDAgYW5kIGdyb3dzIHdoZW4gYWRkaW5nIGNoaWxkcmVuXG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBOdW1iZXI+fSAqL1xuICAgIHRoaXMubGFiZWxzID0ge307XG4gICAgY29uc3QgZGVmYXVsdHNQYXJhbXMgPSBwYXJhbWV0ZXJzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGdsb2JhbERlZmF1bHRzID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0c1BhcmFtcyA/IG1lcmdlT2JqZWN0cyhkZWZhdWx0c1BhcmFtcywgZ2xvYmFsRGVmYXVsdHMpIDogZ2xvYmFsRGVmYXVsdHM7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uUmVuZGVyID0gcGFyYW1ldGVycy5vblJlbmRlciB8fCBnbG9iYWxEZWZhdWx0cy5vblJlbmRlcjtcbiAgICBjb25zdCB0bFBsYXliYWNrRWFzZSA9IHNldFZhbHVlKHBhcmFtZXRlcnMucGxheWJhY2tFYXNlLCBnbG9iYWxEZWZhdWx0cy5wbGF5YmFja0Vhc2UpO1xuICAgIHRoaXMuX2Vhc2UgPSB0bFBsYXliYWNrRWFzZSA/IHBhcnNlRWFzaW5ncyh0bFBsYXliYWNrRWFzZSkgOiBudWxsO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gYTFcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IGEyXG4gICAqIEBwYXJhbSB7VGltZVBvc2l0aW9ufSBbYTNdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBhMVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW2EyXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbXxUaW1lclBhcmFtc30gYTFcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN8VGltZVBvc2l0aW9ufSBhMlxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW2EzXVxuICAgKi9cbiAgYWRkKGExLCBhMiwgYTMpIHtcbiAgICBjb25zdCBpc0FuaW0gPSBpc09iaihhMik7XG4gICAgY29uc3QgaXNUaW1lciA9IGlzT2JqKGExKTtcbiAgICBpZiAoaXNBbmltIHx8IGlzVGltZXIpIHtcbiAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIGlmIChpc0FuaW0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRQYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oYTIpO1xuICAgICAgICAvLyBDaGVjayBmb3IgZnVuY3Rpb24gZm9yIGNoaWxkcmVuIHN0YWdnZXIgcG9zaXRpb25zXG4gICAgICAgIGlmIChpc0ZuYyhhMykpIHtcbiAgICAgICAgICBjb25zdCBzdGFnZ2VyZWRQb3NpdGlvbiA9IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovKGEzKTtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtUYXJnZXRzUGFyYW19ICovKGExKSk7XG4gICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBkdXJhdGlvbiBiZWZvcmUgYWRkaW5nIG5ldyBjaGlsZHJlbiB0aGF0IHdpbGwgY2hhbmdlIHRoZSBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IHRsRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgIC8vIFN0b3JlIGluaXRpYWwgX2l0ZXJhdGlvbkR1cmF0aW9uIGJlZm9yZSBhZGRpbmcgbmV3IGNoaWxkcmVuIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGR1cmF0aW9uXG4gICAgICAgICAgY29uc3QgdGxJdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGlkIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmRleGVzIHRvIHRoZSBuZXcgYW5pbWF0aW9ucyBpZHNcbiAgICAgICAgICBjb25zdCBpZCA9IGNoaWxkUGFyYW1zLmlkO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICBjb25zdCBwYXJzZWRMZW5ndGggPSBwYXJzZWRUYXJnZXRzQXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHBhcnNlZFRhcmdldHNBcnJheS5mb3JFYWNoKCgvKiogQHR5cGUge1RhcmdldH0gKi90YXJnZXQpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJhbWV0ZXIgb2JqZWN0IGZvciBlYWNoIHN0YWdnZXJlZCBjaGlsZHJlblxuICAgICAgICAgICAgY29uc3Qgc3RhZ2dlcmVkQ2hpbGRQYXJhbXMgPSB7IC4uLmNoaWxkUGFyYW1zIH07XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lIGl0ZXJhdGlvbiBiZWZvcmUgZWFjaCBzdGFnZ2VyIHRvIHByZXZlbnQgd3Jvbmcgc3RhcnQgdmFsdWUgY2FsY3VsYXRpb25cbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSB0bER1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IHRsSXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICBpZiAoIWlzVW5kKGlkKSkgc3RhZ2dlcmVkQ2hpbGRQYXJhbXMuaWQgPSBpZCArICctJyArIGk7XG4gICAgICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgICAgICBzdGFnZ2VyZWRDaGlsZFBhcmFtcyxcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgc3RhZ2dlcmVkUG9zaXRpb24odGFyZ2V0LCBpLCBwYXJzZWRMZW5ndGgsIHRoaXMpLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIHBhcnNlZExlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgICAgY2hpbGRQYXJhbXMsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRoaXMsIGEzKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7VGFyZ2V0c1BhcmFtfSAqLyhhMSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhIFRpbWVyXG4gICAgICAgIGFkZFRsQ2hpbGQoXG4gICAgICAgICAgLyoqIEB0eXBlIFRpbWVyUGFyYW1zICovKGExKSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLC8qKiBAdHlwZSBUaW1lUG9zaXRpb24gKi8oYTIpKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmluaXQoMSk7IC8vIDEgPSBpbnRlcm5hbFJlbmRlclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtUaWNrYWJsZX0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7Z2xvYmFsVGhpcy5BbmltYXRpb259IFtzeW5jZWRdXG4gICAqIEBwYXJhbSB7VGltZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAcGFyYW0ge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufGdsb2JhbFRoaXMuQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKi9cbiAgc3luYyhzeW5jZWQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHN5bmNlZCkgfHwgc3luY2VkICYmIGlzVW5kKHN5bmNlZC5wYXVzZSkpIHJldHVybiB0aGlzO1xuICAgIHN5bmNlZC5wYXVzZSgpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gKygvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqLyhzeW5jZWQpLmVmZmVjdCA/IC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259ICovKHN5bmNlZCkuZWZmZWN0LmdldFRpbWluZygpLmR1cmF0aW9uIDogLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi8oc3luY2VkKS5kdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHN5bmNlZCwgeyBjdXJyZW50VGltZTogWzAsIGR1cmF0aW9uXSwgZHVyYXRpb24sIGVhc2U6ICdsaW5lYXInIH0sIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7QW5pbWF0aW9uUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSAge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0KHRhcmdldHMsIHBhcmFtZXRlcnMsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHBhcmFtZXRlcnMpKSByZXR1cm4gdGhpcztcbiAgICBwYXJhbWV0ZXJzLmR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICByZXR1cm4gdGhpcy5hZGQodGFyZ2V0cywgcGFyYW1ldGVycywgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2s8VGltZXI+fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgY2FsbChjYWxsYmFjaywgcG9zaXRpb24pIHtcbiAgICBpZiAoaXNVbmQoY2FsbGJhY2spIHx8IGNhbGxiYWNrICYmICFpc0ZuYyhjYWxsYmFjaykpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLmFkZCh7IGR1cmF0aW9uOiAwLCBvbkNvbXBsZXRlOiAoKSA9PiBjYWxsYmFjayh0aGlzKSB9LCBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsTmFtZVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKi9cbiAgbGFiZWwobGFiZWxOYW1lLCBwb3NpdGlvbikge1xuICAgIGlmIChpc1VuZChsYWJlbE5hbWUpIHx8IGxhYmVsTmFtZSAmJiAhaXNTdHIobGFiZWxOYW1lKSkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxOYW1lXSA9IHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLC8qKiBAdHlwZSBUaW1lUG9zaXRpb24gKi8ocG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbcHJvcGVydHlOYW1lXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVtb3ZlKHRhcmdldHMsIHByb3BlcnR5TmFtZSkge1xuICAgIHJlbW92ZSh0YXJnZXRzLCB0aGlzLCBwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IGNoaWxkLnN0cmV0Y2goY2hpbGQuZHVyYXRpb24gKiB0aW1lU2NhbGUpKTtcbiAgICBmb3IgKGxldCBsYWJlbE5hbWUgaW4gbGFiZWxzKSBsYWJlbHNbbGFiZWxOYW1lXSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmV0Y2gobmV3RHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnJlZnJlc2gpIGNoaWxkLnJlZnJlc2goKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHN1cGVyLnJldmVydCgpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4gY2hpbGQucmV2ZXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gY2xlYW5JbmxpbmVTdHlsZXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc3VwZXIudGhlbihjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICovXG5jb25zdCBjcmVhdGVUaW1lbGluZSA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVsaW5lKHBhcmFtZXRlcnMpLmluaXQoKTtcblxuXG5cblxuY2xhc3MgQW5pbWF0YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldHMsIHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuICAgIC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqL1xuICAgIGNvbnN0IGdsb2JhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICBpZiAoaXNVbmQodGFyZ2V0cykgfHwgaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBwYXJhbVZhbHVlID0gcGFyYW1ldGVyc1twcm9wTmFtZV07XG4gICAgICBpZiAoaXNLZXkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbFBhcmFtc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IGlzT2JqVmFsdWUgPSBpc09iaihwcm9wVmFsdWUpO1xuICAgICAgLyoqIEB0eXBlIHtUd2VlblBhcmFtc09wdGlvbnN9ICovXG4gICAgICBsZXQgcHJvcFBhcmFtcyA9IHt9O1xuICAgICAgbGV0IHRvID0gJys9MCc7XG4gICAgICBpZiAoaXNPYmpWYWx1ZSkge1xuICAgICAgICBjb25zdCB1bml0ID0gcHJvcFZhbHVlLnVuaXQ7XG4gICAgICAgIGlmIChpc1N0cih1bml0KSkgdG8gKz0gdW5pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXJhbXMuZHVyYXRpb24gPSBwcm9wVmFsdWU7XG4gICAgICB9XG4gICAgICBwcm9wUGFyYW1zW3Byb3BOYW1lXSA9IGlzT2JqVmFsdWUgPyBtZXJnZU9iamVjdHMoeyB0byB9LCBwcm9wVmFsdWUpIDogdG87XG4gICAgICBjb25zdCBhbmltUGFyYW1zID0gbWVyZ2VPYmplY3RzKGdsb2JhbFBhcmFtcywgcHJvcFBhcmFtcyk7XG4gICAgICBhbmltUGFyYW1zLmNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgYW5pbVBhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW3Byb3BOYW1lXSA9IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBhbmltUGFyYW1zLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB0aGlzLnRhcmdldHMucHVzaCguLi5hbmltYXRpb24udGFyZ2V0cyk7XG4gICAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQcm9wZXJ0eX0gKi9cbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gKHRvLCBkdXJhdGlvbiwgZWFzZSkgPT4ge1xuICAgICAgICBjb25zdCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKGFuaW1hdGlvbi5faGVhZCk7XG4gICAgICAgIGlmIChpc1VuZCh0bykgJiYgdHdlZW4pIHtcbiAgICAgICAgICBjb25zdCBudW1iZXJzID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgaWYgKG51bWJlcnMgJiYgbnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXJyKHRvKSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHRvKS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kKHR3ZWVuLl9udW1iZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzW2ldID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuLl9tb2RpZmllcih0d2Vlbi5fbnVtYmVyc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyc1tpXSA9IHRvW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpKTtcbiAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmQoZWFzZSkpIHR3ZWVuLl9lYXNlID0gcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgICAgICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGR1cmF0aW9uKSkgYW5pbWF0aW9uLnN0cmV0Y2goZHVyYXRpb24pO1xuICAgICAgICAgIGFuaW1hdGlvbi5yZXNldCgxKS5yZXN1bWUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vb3A7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbcHJvcE5hbWVdLnJldmVydCgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0FuaW1hdGFibGVPYmplY3R9XG4gKi9cbmNvbnN0IGNyZWF0ZUFuaW1hdGFibGUgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4gLyoqIEB0eXBlIHtBbmltYXRhYmxlT2JqZWN0fSAqLyhuZXcgQW5pbWF0YWJsZSh0YXJnZXRzLCBwYXJhbWV0ZXJzKSk7XG5cblxuXG5cbi8qXG4gKiBTcHJpbmcgZWFzZSBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG4gKiBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cblxuY2xhc3MgU3ByaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIHRoaXMudGltZVN0ZXAgPSAuMDI7IC8vIEludGVydmFsIGZlZCB0byB0aGUgc29sdmVyIHRvIGNhbGN1bGF0ZSBkdXJhdGlvblxuICAgIHRoaXMucmVzdFRocmVzaG9sZCA9IC4wMDA1OyAvLyBWYWx1ZXMgYmVsb3cgdGhpcyB0aHJlc2hvbGQgYXJlIGNvbnNpZGVyZWQgcmVzdGluZyBwb3NpdGlvblxuICAgIHRoaXMucmVzdER1cmF0aW9uID0gMjAwOyAvLyBEdXJhdGlvbiBpbiBtcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSBzcHJpbmcgaXMgcmVzdGluZyBhZnRlciByZWFjaGluZyByZXN0VGhyZXNob2xkXG4gICAgdGhpcy5tYXhEdXJhdGlvbiA9IDYwMDAwOyAvLyBUaGUgbWF4aW11bSBhbGxvd2VkIHNwcmluZyBkdXJhdGlvbiBpbiBtcyAoZGVmYXVsdCAxIG1pbilcbiAgICB0aGlzLm1heFJlc3RTdGVwcyA9IHRoaXMucmVzdER1cmF0aW9uIC8gdGhpcy50aW1lU3RlcCAvIEs7IC8vIEhvdyBtYW55IHN0ZXBzIGFsbG93ZWQgYWZ0ZXIgcmVhY2hpbmcgcmVzdFRocmVzaG9sZCBiZWZvcmUgc3RvcHBpbmcgdGhlIGR1cmF0aW9uIGNhbGN1bGF0aW9uXG4gICAgdGhpcy5tYXhJdGVyYXRpb25zID0gdGhpcy5tYXhEdXJhdGlvbiAvIHRoaXMudGltZVN0ZXAgLyBLOyAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gaXRlcmF0aW9ucyBhbGxvd2VkIGJhc2VkIG9uIG1heER1cmF0aW9uXG4gICAgdGhpcy5tID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy5tYXNzLCAxKSwgMCwgSyk7XG4gICAgdGhpcy5zID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy5zdGlmZm5lc3MsIDEwMCksIDEsIEspO1xuICAgIHRoaXMuZCA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMuZGFtcGluZywgMTApLCAuMSwgSyk7XG4gICAgdGhpcy52ID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy52ZWxvY2l0eSwgMCksIC0xZTMsIEspO1xuICAgIHRoaXMudzAgPSAwO1xuICAgIHRoaXMuemV0YSA9IDA7XG4gICAgdGhpcy53ZCA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLnNvbHZlckR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuZWFzZSA9IHQgPT4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHRoaXMuc29sdmUodCAqIHRoaXMuc29sdmVyRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgc29sdmUodGltZSkge1xuICAgIGNvbnN0IHsgemV0YSwgdzAsIHdkLCBiIH0gPSB0aGlzO1xuICAgIGxldCB0ID0gdGltZTtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHQgPSBleHAoLXQgKiB6ZXRhICogdzApICogKDEgKiBjb3Mod2QgKiB0KSArIGIgKiBzaW4od2QgKiB0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSAoMSArIGIgKiB0KSAqIGV4cCgtdCAqIHcwKTtcbiAgICB9XG4gICAgcmV0dXJuIDEgLSB0O1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBjb25zdCB7IG1heFJlc3RTdGVwcywgbWF4SXRlcmF0aW9ucywgcmVzdFRocmVzaG9sZCwgdGltZVN0ZXAsIG0sIGQsIHMsIHYgfSA9IHRoaXM7XG4gICAgY29uc3QgdzAgPSB0aGlzLncwID0gY2xhbXAoc3FydChzIC8gbSksIG1pblZhbHVlLCBLKTtcbiAgICBjb25zdCB6ZXRhID0gdGhpcy56ZXRhID0gZCAvICgyICogc3FydChzICogbSkpO1xuICAgIGNvbnN0IHdkID0gdGhpcy53ZCA9IHpldGEgPCAxID8gdzAgKiBzcXJ0KDEgLSB6ZXRhICogemV0YSkgOiAwO1xuICAgIHRoaXMuYiA9IHpldGEgPCAxID8gKHpldGEgKiB3MCArIC12KSAvIHdkIDogLXYgKyB3MDtcbiAgICBsZXQgc29sdmVyVGltZSA9IDA7XG4gICAgbGV0IHJlc3RTdGVwcyA9IDA7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlIChyZXN0U3RlcHMgPCBtYXhSZXN0U3RlcHMgJiYgaXRlcmF0aW9ucyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmIChhYnMoMSAtIHRoaXMuc29sdmUoc29sdmVyVGltZSkpIDwgcmVzdFRocmVzaG9sZCkge1xuICAgICAgICByZXN0U3RlcHMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RTdGVwcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNvbHZlckR1cmF0aW9uID0gc29sdmVyVGltZTtcbiAgICAgIHNvbHZlclRpbWUgKz0gdGltZVN0ZXA7XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfVxuICAgIHRoaXMuZHVyYXRpb24gPSByb3VuZCh0aGlzLnNvbHZlckR1cmF0aW9uICogSywgMCkgKiBnbG9iYWxzLnRpbWVTY2FsZTtcbiAgfVxuXG4gIGdldCBtYXNzKCkge1xuICAgIHJldHVybiB0aGlzLm07XG4gIH1cblxuICBzZXQgbWFzcyh2KSB7XG4gICAgdGhpcy5tID0gY2xhbXAoc2V0VmFsdWUodiwgMSksIDAsIEspO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICB9XG5cbiAgZ2V0IHN0aWZmbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG5cbiAgc2V0IHN0aWZmbmVzcyh2KSB7XG4gICAgdGhpcy5zID0gY2xhbXAoc2V0VmFsdWUodiwgMTAwKSwgMSwgSyk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgZGFtcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kO1xuICB9XG5cbiAgc2V0IGRhbXBpbmcodikge1xuICAgIHRoaXMuZCA9IGNsYW1wKHNldFZhbHVlKHYsIDEwKSwgLjEsIEspO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICB9XG5cbiAgZ2V0IHZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH1cblxuICBzZXQgdmVsb2NpdHkodikge1xuICAgIHRoaXMudiA9IGNsYW1wKHNldFZhbHVlKHYsIDApLCAtMWUzLCBLKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm5zIHtTcHJpbmd9XG4gKi9cbmNvbnN0IGNyZWF0ZVNwcmluZyA9IChwYXJhbWV0ZXJzKSA9PiBuZXcgU3ByaW5nKHBhcmFtZXRlcnMpO1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGVcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSBlID0+IHtcbiAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuY2xhc3MgRE9NUHJveHkge1xuICAvKiogQHBhcmFtIHtPYmplY3R9IGVsICovXG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2xhc3NMaXN0ID0ge1xuICAgICAgYWRkOiBub29wLFxuICAgICAgcmVtb3ZlOiBub29wLFxuICAgIH07XG4gIH1cblxuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuZWwueCB8fCAwIH07XG4gIHNldCB4KHYpIHsgdGhpcy5lbC54ID0gdjsgfTtcblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuZWwueSB8fCAwIH07XG4gIHNldCB5KHYpIHsgdGhpcy5lbC55ID0gdjsgfTtcblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsLndpZHRoIHx8IDAgfTtcbiAgc2V0IHdpZHRoKHYpIHsgdGhpcy5lbC53aWR0aCA9IHY7IH07XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZWwuaGVpZ2h0IHx8IDAgfTtcbiAgc2V0IGhlaWdodCh2KSB7IHRoaXMuZWwuaGVpZ2h0ID0gdjsgfTtcblxuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgcmlnaHQ6IHRoaXMueCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICBsZWZ0OiB0aGlzLnggKyB0aGlzLndpZHRoLFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NVGFyZ2V0fERPTVByb3h5fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIHRoaXMuaW5saW5lVHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMucG9pbnQgPSBuZXcgRE9NUG9pbnQoKTtcbiAgICB0aGlzLmludmVyc2VkTWF0cml4ID0gdGhpcy5nZXRNYXRyaXgoKS5pbnZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7RE9NUG9pbnR9XG4gICAqL1xuICBub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgdGhpcy5wb2ludC54ID0geDtcbiAgICB0aGlzLnBvaW50LnkgPSB5O1xuICAgIHJldHVybiB0aGlzLnBvaW50Lm1hdHJpeFRyYW5zZm9ybSh0aGlzLmludmVyc2VkTWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgVHJhdmVyc2VQYXJlbnRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmF2ZXJzZVBhcmVudHNDYWxsYmFja30gY2JcbiAgICovXG4gIHRyYXZlcnNlVXAoY2IpIHtcbiAgICBsZXQgJGVsID0gLyoqIEB0eXBlIHtET01UYXJnZXR8RG9jdW1lbnR9ICovKHRoaXMuJGVsLnBhcmVudEVsZW1lbnQpLCBpID0gMDtcbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gZG9jKSB7XG4gICAgICBjYigvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsKSwgaSk7XG4gICAgICAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGdldE1hdHJpeCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgRE9NTWF0cml4KCk7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCRlbCA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoJGVsKS50cmFuc2Zvcm07XG4gICAgICBpZiAodHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxNYXRyaXggPSBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybVZhbHVlKTtcbiAgICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLnRyYXZlcnNlVXAoKCRlbCwgaSkgPT4ge1xuICAgICAgdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldID0gJGVsLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCgkZWwsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN0ID0gdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldO1xuICAgICAgaWYgKGN0ID09PSAnJykge1xuICAgICAgICAkZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IGN0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBcnJheTxOdW1iZXI+fERPTVRhcmdldFNlbGVjdG9yfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9IFRcbiAqIEBwYXJhbSB7VCB8ICgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgZHJhZ2dhYmxlKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoZHJhZ2dhYmxlKSA6IHZhbHVlO1xuXG5sZXQgekluZGV4ID0gMDtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRcbiAgICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmIChnbG9iYWxzLnNjb3BlKSBnbG9iYWxzLnNjb3BlLnJldmVydGlibGVzLnB1c2godGhpcyk7XG4gICAgY29uc3QgcGFyYW1YID0gcGFyYW1ldGVycy54O1xuICAgIGNvbnN0IHBhcmFtWSA9IHBhcmFtZXRlcnMueTtcbiAgICBjb25zdCB0cmlnZ2VyID0gcGFyYW1ldGVycy50cmlnZ2VyO1xuICAgIGNvbnN0IG1vZGlmaWVyID0gcGFyYW1ldGVycy5tb2RpZmllcjtcbiAgICBjb25zdCBlYXNlID0gcGFyYW1ldGVycy5yZWxlYXNlRWFzZTtcbiAgICBjb25zdCBjdXN0b21FYXNlID0gZWFzZSAmJiBwYXJzZUVhc2luZ3MoZWFzZSk7XG4gICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGVhc2UpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSk7XG4gICAgY29uc3QgeFByb3AgPSAvKiogQHR5cGUge1N0cmluZ30gKi8oaXNPYmoocGFyYW1YKSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtPYmplY3R9ICovKHBhcmFtWCkubWFwVG8pID8gLyoqIEB0eXBlIHtPYmplY3R9ICovKHBhcmFtWCkubWFwVG8gOiAndHJhbnNsYXRlWCcpO1xuICAgIGNvbnN0IHlQcm9wID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGlzT2JqKHBhcmFtWSkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVkpLm1hcFRvKSA/IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVkpLm1hcFRvIDogJ3RyYW5zbGF0ZVknKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtZXRlcnMuY29udGFpbmVyLCB0aGlzKTtcbiAgICB0aGlzLmNvbnRhaW5lckFycmF5ID0gaXNBcnIoY29udGFpbmVyKSA/IGNvbnRhaW5lciA6IG51bGw7XG4gICAgdGhpcy4kY29udGFpbmVyID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY29udGFpbmVyICYmICF0aGlzLmNvbnRhaW5lckFycmF5ID8gcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhjb250YWluZXIpKVswXSA6IGRvYy5ib2R5KTtcbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuJGNvbnRhaW5lciA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtXaW5kb3cgfCBIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSB0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuJGNvbnRhaW5lcjtcbiAgICB0aGlzLiR0YXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhpc09iaih0YXJnZXQpID8gbmV3IERPTVByb3h5KHRhcmdldCkgOiBwYXJzZVRhcmdldHModGFyZ2V0KVswXSk7XG4gICAgdGhpcy4kdHJpZ2dlciA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHBhcnNlVGFyZ2V0cyh0cmlnZ2VyID8gdHJpZ2dlciA6IHRhcmdldClbMF0pO1xuICAgIHRoaXMuZml4ZWQgPSBnZXRUYXJnZXRWYWx1ZSh0aGlzLiR0YXJnZXQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnO1xuICAgIC8vIFJlZnJlc2hhYmxlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmlzRmluZVBvaW50ZXIgPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb250YWluZXJQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuY29udGFpbmVyRnJpY3Rpb24gPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcnxBcnJheTxOdW1iZXI+fSAqL1xuICAgIHRoaXMuc25hcFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfEFycmF5PE51bWJlcj59ICovXG4gICAgdGhpcy5zbmFwWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhZ1NwZWVkID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm1heFZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm1pblZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IDA7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufERyYWdnYWJsZUN1cnNvclBhcmFtc30gKi9cbiAgICB0aGlzLmN1cnNvciA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7U3ByaW5nfSAqL1xuICAgIHRoaXMucmVsZWFzZVhTcHJpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkgOiBjcmVhdGVTcHJpbmcoe1xuICAgICAgbWFzczogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlTWFzcywgMSksXG4gICAgICBzdGlmZm5lc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZVN0aWZmbmVzcywgODApLFxuICAgICAgZGFtcGluZzogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlRGFtcGluZywgMjApLFxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7U3ByaW5nfSAqL1xuICAgIHRoaXMucmVsZWFzZVlTcHJpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkgOiBjcmVhdGVTcHJpbmcoe1xuICAgICAgbWFzczogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlTWFzcywgMSksXG4gICAgICBzdGlmZm5lc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZVN0aWZmbmVzcywgODApLFxuICAgICAgZGFtcGluZzogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlRGFtcGluZywgMjApLFxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZWxlYXNlRWFzZSA9IGN1c3RvbUVhc2UgfHwgZWFzZXMub3V0UXVpbnQ7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaGFzUmVsZWFzZVNwcmluZyA9IGhhc1NwcmluZztcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25HcmFiID0gcGFyYW1ldGVycy5vbkdyYWIgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25EcmFnID0gcGFyYW1ldGVycy5vbkRyYWcgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZWxlYXNlID0gcGFyYW1ldGVycy5vblJlbGVhc2UgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBwYXJhbWV0ZXJzLm9uVXBkYXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uU2V0dGxlID0gcGFyYW1ldGVycy5vblNldHRsZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblNuYXAgPSBwYXJhbWV0ZXJzLm9uU25hcCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlc2l6ZSA9IHBhcmFtZXRlcnMub25SZXNpemUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25BZnRlclJlc2l6ZSA9IHBhcmFtZXRlcnMub25BZnRlclJlc2l6ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gWzAsIDBdO1xuICAgIC8qKiBAdHlwZSB7QW5pbWF0YWJsZVBhcmFtc30gKi9cbiAgICBjb25zdCBhbmltYXRhYmxlUGFyYW1zID0ge307XG4gICAgaWYgKG1vZGlmaWVyKSBhbmltYXRhYmxlUGFyYW1zLm1vZGlmaWVyID0gbW9kaWZpZXI7XG4gICAgaWYgKGlzVW5kKHBhcmFtWCkgfHwgcGFyYW1YID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3hQcm9wXSA9IDA7XG4gICAgfSBlbHNlIGlmIChpc09iaihwYXJhbVgpKSB7XG4gICAgICBjb25zdCBwYXJhbVhPYmplY3QgPSAvKiogQHR5cGUge0RyYWdnYWJsZUF4aXNQYXJhbX0gKi8ocGFyYW1YKTtcbiAgICAgIGNvbnN0IGFuaW1hdGFibGVYUGFyYW1zID0ge307XG4gICAgICBpZiAocGFyYW1YT2JqZWN0Lm1vZGlmaWVyKSBhbmltYXRhYmxlWFBhcmFtcy5tb2RpZmllciA9IHBhcmFtWE9iamVjdC5tb2RpZmllcjtcbiAgICAgIGlmIChwYXJhbVhPYmplY3QuY29tcG9zaXRpb24pIGFuaW1hdGFibGVYUGFyYW1zLmNvbXBvc2l0aW9uID0gcGFyYW1YT2JqZWN0LmNvbXBvc2l0aW9uO1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t4UHJvcF0gPSBhbmltYXRhYmxlWFBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBhcmFtWCA9PT0gZmFsc2UpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeFByb3BdID0gMDtcbiAgICAgIHRoaXMuZGlzYWJsZWRbMF0gPSAxO1xuICAgIH1cbiAgICBpZiAoaXNVbmQocGFyYW1ZKSB8fCBwYXJhbVkgPT09IHRydWUpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeVByb3BdID0gMDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKHBhcmFtWSkpIHtcbiAgICAgIGNvbnN0IHBhcmFtWU9iamVjdCA9IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQXhpc1BhcmFtfSAqLyhwYXJhbVkpO1xuICAgICAgY29uc3QgYW5pbWF0YWJsZVlQYXJhbXMgPSB7fTtcbiAgICAgIGlmIChwYXJhbVlPYmplY3QubW9kaWZpZXIpIGFuaW1hdGFibGVZUGFyYW1zLm1vZGlmaWVyID0gcGFyYW1ZT2JqZWN0Lm1vZGlmaWVyO1xuICAgICAgaWYgKHBhcmFtWU9iamVjdC5jb21wb3NpdGlvbikgYW5pbWF0YWJsZVlQYXJhbXMuY29tcG9zaXRpb24gPSBwYXJhbVlPYmplY3QuY29tcG9zaXRpb247XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3lQcm9wXSA9IGFuaW1hdGFibGVZUGFyYW1zO1xuICAgIH0gZWxzZSBpZiAocGFyYW1ZID09PSBmYWxzZSkge1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t5UHJvcF0gPSAwO1xuICAgICAgdGhpcy5kaXNhYmxlZFsxXSA9IDE7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7QW5pbWF0YWJsZU9iamVjdH0gKi9cbiAgICB0aGlzLmFuaW1hdGUgPSAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovKG5ldyBBbmltYXRhYmxlKHRoaXMuJHRhcmdldCwgYW5pbWF0YWJsZVBhcmFtcykpO1xuICAgIC8vIEludGVybmFsIHByb3BzXG4gICAgdGhpcy54UHJvcCA9IHhQcm9wO1xuICAgIHRoaXMueVByb3AgPSB5UHJvcDtcbiAgICB0aGlzLmRlc3RYID0gMDtcbiAgICB0aGlzLmRlc3RZID0gMDtcbiAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgIHRoaXMuc2Nyb2xsID0ge3g6IDAsIHk6IDB9O1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb29yZHMgPSBbdGhpcy54LCB0aGlzLnksIDAsIDBdOyAvLyB4LCB5LCB0ZW1wIHgsIHRlbXAgeVxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLnNuYXBwZWQgPSBbMCwgMF07IC8vIHgsIHlcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5wb2ludGVyID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOyAvLyB4MSwgeTEsIHgyLCB5MiwgdGVtcCB4MSwgdGVtcCB5MSwgdGVtcCB4MiwgdGVtcCB5MlxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLnNjcm9sbFZpZXcgPSBbMCwgMF07IC8vIHcsIGhcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuZHJhZ0FyZWEgPSBbMCwgMCwgMCwgMF07IC8vIHgsIHksIHcsIGhcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29udGFpbmVyQm91bmRzID0gWy0xZTEyLCBtYXhWYWx1ZSwgbWF4VmFsdWUsIC0xZTEyXTsgLy8gdCwgciwgYiwgbFxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxCb3VuZHMgPSBbMCwgMCwgMCwgMF07IC8vIHQsIHIsIGIsIGxcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMudGFyZ2V0Qm91bmRzID0gWzAsIDAsIDAsIDBdOyAvLyB0LCByLCBiLCBsXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMud2luZG93ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrID0gWzAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG5vdygpO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgVHJhbnNmb3Jtcyh0aGlzLiR0YXJnZXQpO1xuICAgIHRoaXMub3ZlcnNob290Q29vcmRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5vdmVyc2hvb3RYVGlja2VyID0gbmV3IFRpbWVyKHsgYXV0b3BsYXk6IGZhbHNlIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIgPSBuZXcgVGltZXIoeyBhdXRvcGxheTogZmFsc2UgfSwgbnVsbCwgMCkuaW5pdCgpO1xuICAgIHRoaXMudXBkYXRlVGlja2VyID0gbmV3IFRpbWVyKHsgYXV0b3BsYXk6IGZhbHNlIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFhUaWNrZXIub25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZFswXSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAwKTtcbiAgICB9O1xuICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWRbMF0pIHJldHVybjtcbiAgICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueCwgMCk7XG4gICAgfTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIub25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZFsxXSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy55LCAwKTtcbiAgICB9O1xuICAgIHRoaXMub3ZlcnNob290WVRpY2tlci5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWRbMV0pIHJldHVybjtcbiAgICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgICB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5vblVwZGF0ZSA9ICgpID0+IHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy5jb250YWluZWQgPSAhaXNVbmQoY29udGFpbmVyKTtcbiAgICB0aGlzLm1hbnVhbCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFjdGl2ZVByb3AgPSB0aGlzLmRpc2FibGVkWzFdID8geFByb3AgOiB5UHJvcDtcbiAgICB0aGlzLmFuaW1hdGUuYW5pbWF0aW9uc1t0aGlzLmFjdGl2ZVByb3BdLm9uUmVuZGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgaGFzVXBkYXRlZCA9IHRoaXMudXBkYXRlZDtcbiAgICAgIGNvbnN0IGhhc01vdmVkID0gdGhpcy5ncmFiYmVkICYmIGhhc1VwZGF0ZWQ7XG4gICAgICBjb25zdCBoYXNSZWxlYXNlZCA9ICFoYXNNb3ZlZCAmJiB0aGlzLnJlbGVhc2VkO1xuICAgICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgICBjb25zdCBkeCA9IHggLSB0aGlzLmNvb3Jkc1syXTtcbiAgICAgIGNvbnN0IGR5ID0geSAtIHRoaXMuY29vcmRzWzNdO1xuICAgICAgdGhpcy5kZWx0YVggPSBkeDtcbiAgICAgIHRoaXMuZGVsdGFZID0gZHk7XG4gICAgICB0aGlzLmNvb3Jkc1syXSA9IHg7XG4gICAgICB0aGlzLmNvb3Jkc1szXSA9IHk7XG4gICAgICBpZiAoaGFzVXBkYXRlZCkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSZWxlYXNlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhdGFuMihkeSwgZHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlLmFuaW1hdGlvbnNbdGhpcy5hY3RpdmVQcm9wXS5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCghdGhpcy5ncmFiYmVkICYmIHRoaXMucmVsZWFzZWQpKSB7XG4gICAgICAgIC8vIFNldCBlbGVhc2VkIHRvIGZhbHNlIGJlZm9yZSBjYWxsaW5nIG9uU2V0dGxlIHRvIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWFudWFsKSB7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzFdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzJdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm9uU2V0dGxlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemVUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDE1MCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm9uUmVzaXplKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyUmVzaXplKHRoaXMpO1xuICAgICAgfSxcbiAgICB9KS5pbml0KCk7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplVGlja2VyLnJlc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgaWYgKCFpc09iaih0YXJnZXQpKSB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy4kdGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGR4XG4gICAqIEBwYXJhbSAge051bWJlcn0gZHlcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSkge1xuICAgIGNvbnN0IHByZXZUaW1lID0gdGhpcy52ZWxvY2l0eVRpbWU7XG4gICAgY29uc3QgY3VyVGltZSA9IG5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJUaW1lIC0gcHJldlRpbWU7XG4gICAgaWYgKGVsYXBzZWQgPCAxNykgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG4gICAgdGhpcy52ZWxvY2l0eVRpbWUgPSBjdXJUaW1lO1xuICAgIGNvbnN0IHZlbG9jaXR5U3RhY2sgPSB0aGlzLnZlbG9jaXR5U3RhY2s7XG4gICAgY29uc3Qgdk11bCA9IHRoaXMudmVsb2NpdHlNdWx0aXBsaWVyO1xuICAgIGNvbnN0IG1pblYgPSB0aGlzLm1pblZlbG9jaXR5O1xuICAgIGNvbnN0IG1heFYgPSB0aGlzLm1heFZlbG9jaXR5O1xuICAgIGNvbnN0IHZpID0gdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXg7XG4gICAgdmVsb2NpdHlTdGFja1t2aV0gPSByb3VuZChjbGFtcCgoc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLyBlbGFwc2VkKSAqIHZNdWwsIG1pblYsIG1heFYpLCA1KTtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IG1heCh2ZWxvY2l0eVN0YWNrWzBdLCB2ZWxvY2l0eVN0YWNrWzFdLCB2ZWxvY2l0eVN0YWNrWzJdKTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAodmkgKyAxKSAlIDM7XG4gICAgcmV0dXJuIHZlbG9jaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgeFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttdXRlVXBkYXRlQ2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzZXRYKHgsIG11dGVVcGRhdGVDYWxsYmFjayA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRbMF0pIHJldHVybjtcbiAgICBjb25zdCB2ID0gcm91bmQoeCwgNSk7XG4gICAgdGhpcy5vdmVyc2hvb3RYVGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WCA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzBdID0gc25hcCh2LCB0aGlzLnNuYXBYKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WSh5LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzFdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHksIDUpO1xuICAgIHRoaXMub3ZlcnNob290WVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSAhbXV0ZVVwZGF0ZUNhbGxiYWNrO1xuICAgIHRoaXMuZGVzdFkgPSB2O1xuICAgIHRoaXMuc25hcHBlZFsxXSA9IHNuYXAodiwgdGhpcy5zbmFwWSk7XG4gICAgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKHYsIDApO1xuICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gcm91bmQoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSgpKSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuc2V0WCh4LCBmYWxzZSk7XG4gIH1cblxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gcm91bmQoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXSgpKSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgc2V0IHkoeSkge1xuICAgIHRoaXMuc2V0WSh5LCBmYWxzZSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NYKCkge1xuICAgIHJldHVybiBtYXBSYW5nZSh0aGlzLngsIHRoaXMuY29udGFpbmVyQm91bmRzWzNdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1sxXSwgMCwgMSk7XG4gIH1cblxuICBzZXQgcHJvZ3Jlc3NYKHgpIHtcbiAgICB0aGlzLnNldFgobWFwUmFuZ2UoeCwgMCwgMSwgdGhpcy5jb250YWluZXJCb3VuZHNbM10sIHRoaXMuY29udGFpbmVyQm91bmRzWzFdKSwgZmFsc2UpO1xuICB9XG5cbiAgZ2V0IHByb2dyZXNzWSgpIHtcbiAgICByZXR1cm4gbWFwUmFuZ2UodGhpcy55LCB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSwgdGhpcy5jb250YWluZXJCb3VuZHNbMl0sIDAsIDEpO1xuICB9XG5cbiAgc2V0IHByb2dyZXNzWSh5KSB7XG4gICAgdGhpcy5zZXRZKG1hcFJhbmdlKHksIDAsIDEsIHRoaXMuY29udGFpbmVyQm91bmRzWzBdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSksIGZhbHNlKTtcbiAgfVxuXG4gIHVwZGF0ZVNjcm9sbENvb3JkcygpIHtcbiAgICBjb25zdCBzeCA9IHJvdW5kKHRoaXMudXNlV2luID8gd2luLnNjcm9sbFggOiB0aGlzLiRjb250YWluZXIuc2Nyb2xsTGVmdCwgMCk7XG4gICAgY29uc3Qgc3kgPSByb3VuZCh0aGlzLnVzZVdpbiA/IHdpbi5zY3JvbGxZIDogdGhpcy4kY29udGFpbmVyLnNjcm9sbFRvcCwgMCk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLnNjcm9sbFRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbC54ID0gc3g7XG4gICAgdGhpcy5zY3JvbGwueSA9IHN5O1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzBdID0gc3kgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCAtIHRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbEJvdW5kc1sxXSA9IHN4IC0gdGhpcy50YXJnZXRCb3VuZHNbMV0gLSBjcHIgKyB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbMl0gPSBzeSAtIHRoaXMudGFyZ2V0Qm91bmRzWzJdIC0gY3BiICsgdGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzNdID0gc3ggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCAtIHRocmVzaG9sZDtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kaW5nVmFsdWVzKCkge1xuICAgIGNvbnN0ICRjb250YWluZXIgPSB0aGlzLiRjb250YWluZXI7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgY3gyID0gdGhpcy5jb29yZHNbMl07XG4gICAgY29uc3QgY3kyID0gIHRoaXMuY29vcmRzWzNdO1xuICAgIC8vIFByZXZlbnRzIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbCBhcmVhIGluIGNhc2VzIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0ZW1wIGNvb3JkcyBhcmUgYWxzbyBhZGp1c2V0IHRvIHByZXZlbnRzIHdyb25nIGRlbHRhIGNhbGN1bGF0aW9uIG9uIHVwZGF0ZXNcbiAgICB0aGlzLmNvb3Jkc1syXSA9IDA7XG4gICAgdGhpcy5jb29yZHNbM10gPSAwO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1zLnJlbW92ZSgpO1xuICAgIGNvbnN0IGl3ID0gdGhpcy53aW5kb3dbMF0gPSB3aW4uaW5uZXJXaWR0aDtcbiAgICBjb25zdCBpaCA9IHRoaXMud2luZG93WzFdID0gd2luLmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHV3ID0gdGhpcy51c2VXaW47XG4gICAgY29uc3Qgc3cgPSAkY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuICAgIGNvbnN0IHNoID0gJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgZnggPSB0aGlzLmZpeGVkO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QgPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgdGhpcy5kcmFnQXJlYVswXSA9IHV3ID8gMCA6IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QubGVmdDtcbiAgICB0aGlzLmRyYWdBcmVhWzFdID0gdXcgPyAwIDogdHJhbnNmb3JtQ29udGFpbmVyUmVjdC50b3A7XG4gICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gdXcgPyBjbGFtcChzdywgaXcsIHN3KSA6IHN3O1xuICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IHV3ID8gY2xhbXAoc2gsIGloLCBzaCkgOiBzaDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH0gPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuZHJhZ0FyZWFbMl0gPSByb3VuZCh1dyA/IGNsYW1wKHdpZHRoLCBpdywgaXcpIDogd2lkdGgsIDApO1xuICAgIHRoaXMuZHJhZ0FyZWFbM10gPSByb3VuZCh1dyA/IGNsYW1wKGhlaWdodCwgaWgsIGloKSA6IGhlaWdodCwgMCk7XG4gICAgY29uc3QgY29udGFpbmVyT3ZlcmZsb3cgPSBnZXRUYXJnZXRWYWx1ZSgkY29udGFpbmVyLCAnb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB2aXNpYmxlT3ZlcmZsb3cgPSBjb250YWluZXJPdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgIGNvbnN0IGhpZGRlbk92ZXJmbG93ID0gY29udGFpbmVyT3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuICAgIHRoaXMuY2FuU2Nyb2xsID0gZnggPyBmYWxzZSA6XG4gICAgICB0aGlzLmNvbnRhaW5lZCAmJlxuICAgICAgKCgkY29udGFpbmVyID09PSBkb2MuYm9keSAmJiB2aXNpYmxlT3ZlcmZsb3cpIHx8ICghaGlkZGVuT3ZlcmZsb3cgJiYgIXZpc2libGVPdmVyZmxvdykpICYmXG4gICAgICAoc3cgPiB0aGlzLmRyYWdBcmVhWzJdICsgY3BsIC0gY3ByIHx8IHNoID4gdGhpcy5kcmFnQXJlYVszXSArIGNwdCAtIGNwYikgJiZcbiAgICAgICghdGhpcy5jb250YWluZXJBcnJheSB8fCAodGhpcy5jb250YWluZXJBcnJheSAmJiAhaXNBcnIodGhpcy5jb250YWluZXJBcnJheSkpKTtcbiAgICBpZiAodGhpcy5jb250YWluZWQpIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMuJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGhpZGRlbkxlZnQgPSBjYW5TY3JvbGwgPyB1dyA/IDAgOiAkY29udGFpbmVyLnNjcm9sbExlZnQgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuVG9wID0gY2FuU2Nyb2xsID8gdXcgPyAwIDogJGNvbnRhaW5lci5zY3JvbGxUb3AgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuUmlnaHQgPSBjYW5TY3JvbGwgPyB0aGlzLnNjcm9sbFZpZXdbMF0gLSBoaWRkZW5MZWZ0IC0gd2lkdGggOiAwO1xuICAgICAgY29uc3QgaGlkZGVuQm90dG9tID0gY2FuU2Nyb2xsID8gdGhpcy5zY3JvbGxWaWV3WzFdIC0gaGlkZGVuVG9wIC0gaGVpZ2h0IDogMDtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzBdID0gcm91bmQoKHRhcmdldFJlY3QudG9wICsgc3kpIC0gKHV3ID8gMCA6IHRvcCksIDApO1xuICAgICAgdGhpcy50YXJnZXRCb3VuZHNbMV0gPSByb3VuZCgodGFyZ2V0UmVjdC5yaWdodCArIHN4KSAtICh1dyA/IGl3IDogcmlnaHQpLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzJdID0gcm91bmQoKHRhcmdldFJlY3QuYm90dG9tICsgc3kpIC0gKHV3ID8gaWggOiBib3R0b20pLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzNdID0gcm91bmQoKHRhcmdldFJlY3QubGVmdCArIHN4KSAtICh1dyA/IDAgOiBsZWZ0KSwgMCk7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJBcnJheSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbMF0gKyBjcHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gdGhpcy5jb250YWluZXJBcnJheVsxXSAtIGNwcjtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZHNbMl0gPSB0aGlzLmNvbnRhaW5lckFycmF5WzJdIC0gY3BiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbM10gKyBjcGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IC1yb3VuZCh0YXJnZXRSZWN0LnRvcCAtIChmeCA/IGNsYW1wKHRvcCwgMCwgaWgpIDogdG9wKSArIGhpZGRlblRvcCAtIGNwdCwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gLXJvdW5kKHRhcmdldFJlY3QucmlnaHQgLSAoZnggPyBjbGFtcChyaWdodCwgMCwgaXcpIDogcmlnaHQpIC0gaGlkZGVuUmlnaHQgKyBjcHIsIDApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSA9IC1yb3VuZCh0YXJnZXRSZWN0LmJvdHRvbSAtIChmeCA/IGNsYW1wKGJvdHRvbSwgMCwgaWgpIDogYm90dG9tKSAtIGhpZGRlbkJvdHRvbSArIGNwYiwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzNdID0gLXJvdW5kKHRhcmdldFJlY3QubGVmdCAtIChmeCA/IGNsYW1wKGxlZnQsIDAsIGl3KSA6IGxlZnQpICsgaGlkZGVuTGVmdCAtIGNwbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3Jtcy5yZXZlcnQoKTtcbiAgICAvLyBSZXN0b3JlIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5jb29yZHNbMl0gPSBjeDI7XG4gICAgdGhpcy5jb29yZHNbM10gPSBjeTI7XG4gICAgdGhpcy5zZXRYKGN4LCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY3ksIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgMCBpZiBub3QgT0IsIDEgaWYgeCBpcyBPQiwgMiBpZiB5IGlzIE9CLCAzIGlmIGJvdGggeCBhbmQgeSBhcmUgT0JcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGJvdW5kc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGlzT3V0T2ZCb3VuZHMoYm91bmRzLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lZCkgcmV0dXJuIDA7XG4gICAgY29uc3QgWyBidCwgYnIsIGJiLCBibCBdID0gYm91bmRzO1xuICAgIGNvbnN0IFsgZHgsIGR5IF0gPSB0aGlzLmRpc2FibGVkO1xuICAgIGNvbnN0IG9ieCA9ICFkeCAmJiB4IDwgYmwgfHwgIWR4ICYmIHggPiBicjtcbiAgICBjb25zdCBvYnkgPSAhZHkgJiYgeSA8IGJ0IHx8ICFkeSAmJiB5ID4gYmI7XG4gICAgcmV0dXJuIG9ieCAmJiAhb2J5ID8gMSA6ICFvYnggJiYgb2J5ID8gMiA6IG9ieCAmJiBvYnkgPyAzIDogMDtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHBhcmFtWCA9IHBhcmFtcy54O1xuICAgIGNvbnN0IHBhcmFtWSA9IHBhcmFtcy55O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgY29uc3QgY3AgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5jb250YWluZXJQYWRkaW5nLCB0aGlzKSB8fCAwO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqLyhpc0FycihjcCkgPyBjcCA6IFtjcCwgY3AsIGNwLCBjcF0pO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIGNvbnN0IHBhcnNlZEN1cnNvclN0eWxlcyA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmN1cnNvciwgdGhpcyk7XG4gICAgY29uc3QgY3Vyc29yU3R5bGVzID0geyBvbkhvdmVyOiAnZ3JhYicsIG9uR3JhYjogJ2dyYWJiaW5nJyB9O1xuICAgIGlmIChwYXJzZWRDdXJzb3JTdHlsZXMpIHtcbiAgICAgIGNvbnN0IHsgb25Ib3Zlciwgb25HcmFiIH0gPSAvKiogQHR5cGUge0RyYWdnYWJsZUN1cnNvclBhcmFtc30gKi8ocGFyc2VkQ3Vyc29yU3R5bGVzKTtcbiAgICAgIGlmIChvbkhvdmVyKSBjdXJzb3JTdHlsZXMub25Ib3ZlciA9IG9uSG92ZXI7XG4gICAgICBpZiAob25HcmFiKSBjdXJzb3JTdHlsZXMub25HcmFiID0gb25HcmFiO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lckFycmF5ID0gaXNBcnIoY29udGFpbmVyKSA/IGNvbnRhaW5lciA6IG51bGw7XG4gICAgdGhpcy4kY29udGFpbmVyID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY29udGFpbmVyICYmICF0aGlzLmNvbnRhaW5lckFycmF5ID8gcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhjb250YWluZXIpKVswXSA6IGRvYy5ib2R5KTtcbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuJGNvbnRhaW5lciA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtXaW5kb3cgfCBIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSB0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuJGNvbnRhaW5lcjtcbiAgICB0aGlzLmlzRmluZVBvaW50ZXIgPSBtYXRjaE1lZGlhKCcocG9pbnRlcjpmaW5lKScpLm1hdGNoZXM7XG4gICAgdGhpcy5jb250YWluZXJQYWRkaW5nID0gc2V0VmFsdWUoY29udGFpbmVyUGFkZGluZywgWzAsIDAsIDAsIDBdKTtcbiAgICB0aGlzLmNvbnRhaW5lckZyaWN0aW9uID0gY2xhbXAoc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY29udGFpbmVyRnJpY3Rpb24sIHRoaXMpLCAuOCksIDAsIDEpO1xuICAgIHRoaXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uID0gY2xhbXAoc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uLCB0aGlzKSwgdGhpcy5jb250YWluZXJGcmljdGlvbiksIDAsIDEpO1xuICAgIHRoaXMuc25hcFggPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKGlzT2JqKHBhcmFtWCkgJiYgIWlzVW5kKHBhcmFtWC5zbmFwKSA/IHBhcmFtWC5zbmFwIDogcGFyYW1zLnNuYXAsIHRoaXMpO1xuICAgIHRoaXMuc25hcFkgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKGlzT2JqKHBhcmFtWSkgJiYgIWlzVW5kKHBhcmFtWS5zbmFwKSA/IHBhcmFtWS5zbmFwIDogcGFyYW1zLnNuYXAsIHRoaXMpO1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5zY3JvbGxTcGVlZCwgdGhpcyksIDEuNSk7XG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQsIHRoaXMpLCAyMCk7XG4gICAgdGhpcy5kcmFnU3BlZWQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5kcmFnU3BlZWQsIHRoaXMpLCAxKTtcbiAgICB0aGlzLm1pblZlbG9jaXR5ID0gc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMubWluVmVsb2NpdHksIHRoaXMpLCAwKTtcbiAgICB0aGlzLm1heFZlbG9jaXR5ID0gc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMubWF4VmVsb2NpdHksIHRoaXMpLCA1MCk7XG4gICAgdGhpcy52ZWxvY2l0eU11bHRpcGxpZXIgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy52ZWxvY2l0eU11bHRpcGxpZXIsIHRoaXMpLCAxKTtcbiAgICB0aGlzLmN1cnNvciA9IHBhcnNlZEN1cnNvclN0eWxlcyA9PT0gZmFsc2UgPyBmYWxzZSA6IGN1cnNvclN0eWxlcztcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nVmFsdWVzKCk7XG5cbiAgICAvLyBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyh0aGlzLmNvbnRhaW5lckJvdW5kcywgdGhpcy54LCB0aGlzLnkpO1xuICAgIC8vIGlmIChvYiA9PT0gMSB8fCBvYiA9PT0gMykgdGhpcy5wcm9ncmVzc1ggPSBweDtcbiAgICAvLyBpZiAob2IgPT09IDIgfHwgb2IgPT09IDMpIHRoaXMucHJvZ3Jlc3NZID0gcHk7XG5cbiAgICAvLyBpZiAodGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLmNvbnRhaW5lZCkge1xuICAgIC8vICAgaWYgKHRoaXMucHJvZ3Jlc3NYICE9PSBweCkgdGhpcy5wcm9ncmVzc1ggPSBweDtcbiAgICAvLyAgIGlmICh0aGlzLnByb2dyZXNzWSAhPT0gcHkpIHRoaXMucHJvZ3Jlc3NZID0gcHk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgWyBidCwgYnIsIGJiLCBibCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgdGhpcy5zZXRYKGNsYW1wKGN4LCBibCwgYnIpLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY2xhbXAoY3ksIGJ0LCBiYiksIHRydWUpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29vcmRzKCk7XG4gICAgaWYgKHRoaXMuY2FuU2Nyb2xsKSB7XG4gICAgICBjb25zdCBbIGNwdCwgY3ByLCBjcGIsIGNwbCBdID0gdGhpcy5jb250YWluZXJQYWRkaW5nO1xuICAgICAgY29uc3QgWyBzdywgc2ggXSA9IHRoaXMuc2Nyb2xsVmlldztcbiAgICAgIGNvbnN0IGRhdyA9IHRoaXMuZHJhZ0FyZWFbMl07XG4gICAgICBjb25zdCBkYWggPSB0aGlzLmRyYWdBcmVhWzNdO1xuICAgICAgY29uc3QgY3N4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IGNzeSA9IHRoaXMuc2Nyb2xsLnk7XG4gICAgICBjb25zdCBuc3cgPSB0aGlzLiRjb250YWluZXIuc2Nyb2xsV2lkdGg7XG4gICAgICBjb25zdCBuc2ggPSB0aGlzLiRjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY29uc3QgY3N3ID0gdGhpcy51c2VXaW4gPyBjbGFtcChuc3csIHRoaXMud2luZG93WzBdLCBuc3cpIDogbnN3O1xuICAgICAgY29uc3QgY3NoID0gdGhpcy51c2VXaW4gPyBjbGFtcChuc2gsIHRoaXMud2luZG93WzFdLCBuc2gpIDogbnNoO1xuICAgICAgY29uc3Qgc3dkID0gc3cgLSBjc3c7XG4gICAgICBjb25zdCBzaGQgPSBzaCAtIGNzaDtcbiAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgc2Nyb2xsYXJlYSBkaW1lbnNpb25zIGNoYW5nZXMgZHVyaW5nIGRyYWdcbiAgICAgIGlmICh0aGlzLmRyYWdnZWQgJiYgc3dkID4gMCkge1xuICAgICAgICB0aGlzLmNvb3Jkc1swXSAtPSBzd2Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsVmlld1swXSA9IGNzdztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRyYWdnZWQgJiYgc2hkID4gMCkge1xuICAgICAgICB0aGlzLmNvb3Jkc1sxXSAtPSBzaGQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IGNzaDtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBhdXRvc2Nyb2xsIHdoZW4gdGFyZ2V0IGlzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGJvdW5kc1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2Nyb2xsU3BlZWQgKiAxMDtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgICAgY29uc3QgWyB4LCB5IF0gPSB0aGlzLmNvb3JkcztcbiAgICAgIGNvbnN0IFsgc3QsIHNyLCBzYiwgc2wgXSA9IHRoaXMuc2Nyb2xsQm91bmRzO1xuICAgICAgY29uc3QgdCA9IHJvdW5kKGNsYW1wKCh5IC0gc3QgKyBjcHQpIC8gdGhyZXNob2xkLCAtMSwgMCkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgoeCAtIHNyIC0gY3ByKSAvIHRocmVzaG9sZCwgMCwgMSkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IGIgPSByb3VuZChjbGFtcCgoeSAtIHNiIC0gY3BiKSAvIHRocmVzaG9sZCwgMCwgMSkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IGwgPSByb3VuZChjbGFtcCgoeCAtIHNsICsgY3BsKSAvIHRocmVzaG9sZCwgLTEsIDApICogcywgMCk7XG4gICAgICBpZiAodCB8fCBiIHx8IGwgfHwgcikge1xuICAgICAgICBjb25zdCBbbngsIG55XSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIGxldCBzY3JvbGxYID0gY3N4O1xuICAgICAgICBsZXQgc2Nyb2xsWSA9IGNzeTtcbiAgICAgICAgaWYgKCFueCkge1xuICAgICAgICAgIHNjcm9sbFggPSByb3VuZChjbGFtcChjc3ggKyAobCB8fCByKSwgMCwgc3cgLSBkYXcpLCAwKTtcbiAgICAgICAgICB0aGlzLmNvb3Jkc1swXSAtPSBjc3ggLSBzY3JvbGxYO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbnkpIHtcbiAgICAgICAgICBzY3JvbGxZID0gcm91bmQoY2xhbXAoY3N5ICsgKHQgfHwgYiksIDAsIHNoIC0gZGFoKSwgMCk7XG4gICAgICAgICAgdGhpcy5jb29yZHNbMV0gLT0gY3N5IC0gc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTYWZhcmkgbW9iaWxlIHJlcXVpcmVzIHRvIHVzZSBkaWZmZXJlbnQgc2Nyb2xsIG1ldGhvZHMgZGVwZW5kaW5nIGlmIHVzaW5nIHRoZSB3aW5kb3cgb3Igbm90XG4gICAgICAgIGlmICh0aGlzLnVzZVdpbikge1xuICAgICAgICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSgtKGNzeCAtIHNjcm9sbFgpLCAtKGNzeSAtIHNjcm9sbFkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgWyBweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzIF0gPSB0aGlzLnBvaW50ZXI7XG4gICAgdGhpcy5jb29yZHNbMF0gKz0gKHB4MSAtIHB4MykgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICB0aGlzLmNvb3Jkc1sxXSArPSAocHkxIC0gcHkzKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIHRoaXMucG9pbnRlcls0XSA9IHB4MTtcbiAgICB0aGlzLnBvaW50ZXJbNV0gPSBweTE7XG4gICAgY29uc3QgWyBjeCwgY3kgXSA9IHRoaXMuY29vcmRzO1xuICAgIGNvbnN0IFsgc3gsIHN5IF0gPSB0aGlzLnNuYXBwZWQ7XG4gICAgY29uc3QgY2YgPSAoMSAtIHRoaXMuY29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgdGhpcy5zZXRYKGN4ID4gY3IgPyBjciArIChjeCAtIGNyKSAqIGNmIDogY3ggPCBjbCA/IGNsICsgKGN4IC0gY2wpICogY2YgOiBjeCwgZmFsc2UpO1xuICAgIHRoaXMuc2V0WShjeSA+IGNiID8gY2IgKyAoY3kgLSBjYikgKiBjZiA6IGN5IDwgY3QgPyBjdCArIChjeSAtIGN0KSAqIGNmIDogY3ksIGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVWZWxvY2l0eShweDEgLSBweDMsIHB5MSAtIHB5Myk7XG4gICAgdGhpcy5hbmdsZSA9IGF0YW4yKHB5MSAtIHB5MiwgcHgxIC0gcHgyKTtcbiAgICBjb25zdCBbIG5zeCwgbnN5IF0gPSB0aGlzLnNuYXBwZWQ7XG4gICAgaWYgKG5zeCAhPT0gc3ggJiYgdGhpcy5zbmFwWCB8fCBuc3kgIT09IHN5ICYmIHRoaXMuc25hcFkpIHtcbiAgICAgIHRoaXMub25TbmFwKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy51cGRhdGVUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFhUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIucGF1c2UoKTtcbiAgICAvLyBQYXVzZXMgdGhlIGluIGJvdW5kcyBvblJlbGVhc2UgYW5pbWF0aW9uc1xuICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5hbmltYXRlLmFuaW1hdGlvbnMpIHRoaXMuYW5pbWF0ZS5hbmltYXRpb25zW3Byb3BdLnBhdXNlKCk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICd4Jyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICd5Jyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICdwcm9ncmVzc1gnKTtcbiAgICByZW1vdmUodGhpcywgbnVsbCwgJ3Byb2dyZXNzWScpO1xuICAgIHJlbW92ZSh0aGlzLnNjcm9sbCk7IC8vIFJlbW92ZXMgYW55IGFjdGl2ZSBhbmltYXRpb25zIG9uIHRoZSBjb250YWluZXIgc2Nyb2xsXG4gICAgcmVtb3ZlKHRoaXMub3ZlcnNob290Q29vcmRzKTsgLy8gUmVtb3ZlcyBhY3RpdmUgb3ZlcnNob290IGFuaW1hdGlvbnNcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtIHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzY3JvbGxJblZpZXcoZHVyYXRpb24sIGdhcCA9IDAsIGVhc2UgPSBlYXNlcy5pbk91dFF1YWQpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHggPSB0aGlzLmRlc3RYO1xuICAgIGNvbnN0IHkgPSB0aGlzLmRlc3RZO1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuc2Nyb2xsO1xuICAgIGNvbnN0IHNjcm9sbEJvdW5kcyA9IHRoaXMuc2Nyb2xsQm91bmRzO1xuICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgIGlmICghdGhpcy5jb250YWluZXJBcnJheSAmJiB0aGlzLmlzT3V0T2ZCb3VuZHMoc2Nyb2xsQm91bmRzLCB4LCB5KSkge1xuICAgICAgY29uc3QgWyBzdCwgc3IsIHNiLCBzbCBdID0gc2Nyb2xsQm91bmRzO1xuICAgICAgY29uc3QgdCA9IHJvdW5kKGNsYW1wKHkgLSBzdCwgLTFlMTIsIDApLCAwKTtcbiAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCh4IC0gc3IsIDAsIG1heFZhbHVlKSwgMCk7XG4gICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoeSAtIHNiLCAwLCBtYXhWYWx1ZSksIDApO1xuICAgICAgY29uc3QgbCA9IHJvdW5kKGNsYW1wKHggLSBzbCwgLTFlMTIsIDApLCAwKTtcbiAgICAgIG5ldyBKU0FuaW1hdGlvbihzY3JvbGwsIHtcbiAgICAgICAgeDogcm91bmQoc2Nyb2xsLnggKyAobCA/IGwgLSBnYXAgOiByID8gciArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgeTogcm91bmQoc2Nyb2xsLnkgKyAodCA/IHQgLSBnYXAgOiBiID8gYiArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgZHVyYXRpb246IGlzVW5kKGR1cmF0aW9uKSA/IDM1MCAqIGdsb2JhbHMudGltZVNjYWxlIDogZHVyYXRpb24sXG4gICAgICAgIGVhc2UsXG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgICAgICAgfVxuICAgICAgfSkuaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmNhblNjcm9sbCA9IGNhblNjcm9sbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhbmRsZUhvdmVyKCkge1xuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IgJiYgIXRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkhvdmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbZHVyYXRpb25dXG4gICAqIEBwYXJhbSAge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgYW5pbWF0ZUluVmlldyhkdXJhdGlvbiwgZ2FwID0gMCwgZWFzZSA9IGVhc2VzLmluT3V0UXVhZCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCBidCA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCArIGdhcDtcbiAgICBjb25zdCBiciA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciAtIGdhcDtcbiAgICBjb25zdCBiYiA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1syXSAtIGNwYiAtIGdhcDtcbiAgICBjb25zdCBibCA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCArIGdhcDtcbiAgICBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyhbYnQsIGJyLCBiYiwgYmxdLCB4LCB5KTtcbiAgICBpZiAob2IpIHtcbiAgICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICBjb25zdCBkZXN0WCA9IGNsYW1wKHNuYXAoeCwgdGhpcy5zbmFwWCksIGJsLCBicik7XG4gICAgICBjb25zdCBkZXN0WSA9IGNsYW1wKHNuYXAoeSwgdGhpcy5zbmFwWSksIGJ0LCBiYik7XG4gICAgICBjb25zdCBkdXIgPSBpc1VuZChkdXJhdGlvbikgPyAzNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSA6IGR1cmF0aW9uO1xuICAgICAgaWYgKCFkaXNhYmxlZFggJiYgKG9iID09PSAxIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGRlc3RYLCBkdXIsIGVhc2UpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkgJiYgKG9iID09PSAyIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKGRlc3RZLCBkdXIsIGVhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRG93bihlKSB7XG4gICAgY29uc3QgJGVUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgaWYgKHRoaXMuZ3JhYmJlZCB8fCAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICAqLygkZVRhcmdldCkudHlwZSA9PT0gJ3JhbmdlJykgcmV0dXJuO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuZ3JhYmJlZCA9IHRydWU7XG4gICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB0b3VjaGVzID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhlKS5jaGFuZ2VkVG91Y2hlcztcbiAgICBjb25zdCBldmVudFggPSB0b3VjaGVzID8gdG91Y2hlc1swXS5jbGllbnRYIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKS5jbGllbnRYO1xuICAgIGNvbnN0IGV2ZW50WSA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFkgOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRyYW5zZm9ybXMubm9ybWFsaXplUG9pbnQoZXZlbnRYLCBldmVudFkpO1xuICAgIGNvbnN0IFsgY3QsIGNyLCBjYiwgY2wgXSA9IHRoaXMuY29udGFpbmVyQm91bmRzO1xuICAgIGNvbnN0IGNmID0gKDEgLSB0aGlzLmNvbnRhaW5lckZyaWN0aW9uKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIHRoaXMuY29vcmRzWzBdID0gdGhpcy5jb29yZHNbMl0gPSAhY2YgPyBjeCA6IGN4ID4gY3IgPyBjciArIChjeCAtIGNyKSAvIGNmIDogY3ggPCBjbCA/IGNsICsgKGN4IC0gY2wpIC8gY2YgOiBjeDtcbiAgICB0aGlzLmNvb3Jkc1sxXSA9IHRoaXMuY29vcmRzWzNdID0gIWNmID8gY3kgOiBjeSA+IGNiID8gY2IgKyAoY3kgLSBjYikgLyBjZiA6IGN5IDwgY3QgPyBjdCArIChjeSAtIGN0KSAvIGNmIDogY3k7XG4gICAgdGhpcy5wb2ludGVyWzBdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgIHRoaXMucG9pbnRlclsyXSA9IHg7XG4gICAgdGhpcy5wb2ludGVyWzNdID0geTtcbiAgICB0aGlzLnBvaW50ZXJbNF0gPSB4O1xuICAgIHRoaXMucG9pbnRlcls1XSA9IHk7XG4gICAgdGhpcy5wb2ludGVyWzZdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbN10gPSB5O1xuICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICB0aGlzLmRlbHRhWSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMV0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIGlmICh0aGlzLnRhcmdldFN0eWxlcykge1xuICAgICAgdGhpcy50YXJnZXRTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHogPSAvKiogQHR5cGUge051bWJlcn0gKi8oZ2V0VGFyZ2V0VmFsdWUodGhpcy4kdGFyZ2V0LCAnekluZGV4JywgZmFsc2UpKTtcbiAgICB6SW5kZXggPSAoeiA+IHpJbmRleCA/IHogOiB6SW5kZXgpICsgMTtcbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0YXJnZXQsIHsgekluZGV4IH0pO1xuICAgIGlmICh0aGlzLnRyaWdnZXJTdHlsZXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnNvclN0eWxlcykge1xuICAgICAgdGhpcy5jdXJzb3JTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyhkb2MuYm9keSwge1xuICAgICAgICBjdXJzb3I6IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfSAqLyh0aGlzLmN1cnNvcikub25HcmFiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxJblZpZXcoMTAwLCAwLCBlYXNlcy5vdXQoMykpO1xuICAgIHRoaXMub25HcmFiKHRoaXMpO1xuXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBlXG4gICAqL1xuICBoYW5kbGVNb3ZlKGUpIHtcbiAgICBpZiAoIXRoaXMuZ3JhYmJlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGNvbnN0IGV2ZW50WCA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFggOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFg7XG4gICAgY29uc3QgZXZlbnRZID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WSA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudHJhbnNmb3Jtcy5ub3JtYWxpemVQb2ludChldmVudFgsIGV2ZW50WSk7XG4gICAgY29uc3QgbW92ZWRYID0geCAtIHRoaXMucG9pbnRlcls2XTtcbiAgICBjb25zdCBtb3ZlZFkgPSB5IC0gdGhpcy5wb2ludGVyWzddO1xuXG4gICAgbGV0ICRwYXJlbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgbGV0IGlzQXRUb3AgPSBmYWxzZTtcbiAgICBsZXQgaXNBdEJvdHRvbSA9IGZhbHNlO1xuICAgIGxldCBjYW5Ub3VjaFNjcm9sbCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRvdWNoZXMgJiYgJHBhcmVudCAmJiAkcGFyZW50ICE9PSB0aGlzLiR0cmlnZ2VyKSB7XG4gICAgICBjb25zdCBvdmVyZmxvd1kgPSBnZXRUYXJnZXRWYWx1ZSgkcGFyZW50LCAnb3ZlcmZsb3cteScpO1xuICAgICAgaWYgKG92ZXJmbG93WSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3dZICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0IH0gPSAkcGFyZW50O1xuICAgICAgICBpZiAoc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgY2FuVG91Y2hTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgIGlzQXRUb3AgPSBzY3JvbGxUb3AgPD0gMztcbiAgICAgICAgICBpc0F0Qm90dG9tID0gc2Nyb2xsVG9wID49IChzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpIC0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhblRvdWNoU2Nyb2xsICYmICgoIWlzQXRUb3AgJiYgIWlzQXRCb3R0b20pIHx8IChpc0F0VG9wICYmIG1vdmVkWSA8IDApIHx8IChpc0F0Qm90dG9tICYmIG1vdmVkWSA+IDApKSkge1xuXG4gICAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzFdID0geTtcbiAgICAgIHRoaXMucG9pbnRlclsyXSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbM10gPSB5O1xuICAgICAgdGhpcy5wb2ludGVyWzRdID0geDtcbiAgICAgIHRoaXMucG9pbnRlcls1XSA9IHk7XG4gICAgICB0aGlzLnBvaW50ZXJbNl0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzddID0geTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAvLyBOZWVkZWQgdG8gcHJldmVudHMgY2xpY2sgb24gaGFuZGxlVXBcbiAgICAgIGlmICghdGhpcy50cmlnZ2VyU3R5bGVzKSB0aGlzLnRyaWdnZXJTdHlsZXMgPSBzZXRUYXJnZXRWYWx1ZXModGhpcy4kdHJpZ2dlciwgeyBwb2ludGVyRXZlbnRzOiAnbm9uZScgfSk7XG4gICAgICAvLyBOZWVkZWQgdG8gcHJldmVudCBwYWdlIHNjcm9sbCB3aGlsZSBkcmFnZ2luZyBvbiB0b3VjaCBkZXZ2aWNlXG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuXG5cbiAgICAgIGlmICgoIXRoaXMuZGlzYWJsZWRbMF0gJiYgYWJzKG1vdmVkWCkgPiAzKSB8fCAoIXRoaXMuZGlzYWJsZWRbMV0gJiYgYWJzKG1vdmVkWSkgPiAzKSkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlVGlja2VyLnJlc3VtZSgpO1xuICAgICAgICB0aGlzLnBvaW50ZXJbMl0gPSB0aGlzLnBvaW50ZXJbMF07XG4gICAgICAgIHRoaXMucG9pbnRlclszXSA9IHRoaXMucG9pbnRlclsxXTtcbiAgICAgICAgdGhpcy5wb2ludGVyWzBdID0geDtcbiAgICAgICAgdGhpcy5wb2ludGVyWzFdID0geTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uRHJhZyh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVVcCgpIHtcblxuICAgIGlmICghdGhpcy5ncmFiYmVkKSByZXR1cm47XG5cbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5wYXVzZSgpO1xuXG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5U3R5bGVzKSB7XG4gICAgICB0aGlzLmJvZHlTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmJvZHlTdHlsZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgY29uc3QgWyBweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzIF0gPSB0aGlzLnBvaW50ZXI7XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgWyBzeCwgc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBjb25zdCBzcHJpbmdYID0gdGhpcy5yZWxlYXNlWFNwcmluZztcbiAgICBjb25zdCBzcHJpbmdZID0gdGhpcy5yZWxlYXNlWVNwcmluZztcbiAgICBjb25zdCByZWxlYXNlRWFzZSA9IHRoaXMucmVsZWFzZUVhc2U7XG4gICAgY29uc3QgaGFzUmVsZWFzZVNwcmluZyA9IHRoaXMuaGFzUmVsZWFzZVNwcmluZztcbiAgICBjb25zdCBvdmVyc2hvb3RDb29yZHMgPSB0aGlzLm92ZXJzaG9vdENvb3JkcztcbiAgICBjb25zdCBjeCA9IHRoaXMueDtcbiAgICBjb25zdCBjeSA9IHRoaXMueTtcbiAgICBjb25zdCBwdiA9IHRoaXMuY29tcHV0ZVZlbG9jaXR5KHB4MSAtIHB4MywgcHkxIC0gcHkzKTtcbiAgICBjb25zdCBwYSA9IHRoaXMuYW5nbGUgPSBhdGFuMihweTEgLSBweTIsIHB4MSAtIHB4Mik7XG4gICAgY29uc3QgZHMgPSBwdiAqIDE1MDtcbiAgICBjb25zdCBjZiA9ICgxIC0gdGhpcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgY29uc3QgbnggPSBjeCArIChjb3MocGEpICogZHMpO1xuICAgIGNvbnN0IG55ID0gY3kgKyAoc2luKHBhKSAqIGRzKTtcbiAgICBjb25zdCBieCA9IG54ID4gY3IgPyBjciArIChueCAtIGNyKSAqIGNmIDogbnggPCBjbCA/IGNsICsgKG54IC0gY2wpICogY2YgOiBueDtcbiAgICBjb25zdCBieSA9IG55ID4gY2IgPyBjYiArIChueSAtIGNiKSAqIGNmIDogbnkgPCBjdCA/IGN0ICsgKG55IC0gY3QpICogY2YgOiBueTtcbiAgICBjb25zdCBkeCA9IHRoaXMuZGVzdFggPSBjbGFtcChyb3VuZChzbmFwKGJ4LCB0aGlzLnNuYXBYKSwgNSksIGNsLCBjcik7XG4gICAgY29uc3QgZHkgPSB0aGlzLmRlc3RZID0gY2xhbXAocm91bmQoc25hcChieSwgdGhpcy5zbmFwWSksIDUpLCBjdCwgY2IpO1xuICAgIGNvbnN0IG9iID0gdGhpcy5pc091dE9mQm91bmRzKHRoaXMuY29udGFpbmVyQm91bmRzLCBueCwgbnkpO1xuXG4gICAgbGV0IGR1cmF0aW9uWCA9IDA7XG4gICAgbGV0IGR1cmF0aW9uWSA9IDA7XG4gICAgbGV0IGVhc2VYID0gcmVsZWFzZUVhc2U7XG4gICAgbGV0IGVhc2VZID0gcmVsZWFzZUVhc2U7XG4gICAgbGV0IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSAwO1xuXG4gICAgb3ZlcnNob290Q29vcmRzLnggPSBjeDtcbiAgICBvdmVyc2hvb3RDb29yZHMueSA9IGN5O1xuXG4gICAgaWYgKCFkaXNhYmxlZFgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvblggPSBkeCA9PT0gY3IgPyBjeCA+IGNyID8gLTEgOiAxIDogY3ggPCBjbCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IHJvdW5kKGN4IC0gZHgsIDApO1xuICAgICAgc3ByaW5nWC52ZWxvY2l0eSA9IGRpc2FibGVkWSAmJiBoYXNSZWxlYXNlU3ByaW5nID8gZGlzdGFuY2VYID8gKGRzICogZGlyZWN0aW9uWCkgLyBhYnMoZGlzdGFuY2VYKSA6IDAgOiBwdjtcbiAgICAgIGNvbnN0IHsgZWFzZSwgZHVyYXRpb24sIHJlc3REdXJhdGlvbiB9ID0gc3ByaW5nWDtcbiAgICAgIGR1cmF0aW9uWCA9IGN4ID09PSBkeCA/IDAgOiBoYXNSZWxlYXNlU3ByaW5nID8gZHVyYXRpb24gOiBkdXJhdGlvbiAtIChyZXN0RHVyYXRpb24gKiBnbG9iYWxzLnRpbWVTY2FsZSk7XG4gICAgICBpZiAoaGFzUmVsZWFzZVNwcmluZykgZWFzZVggPSBlYXNlO1xuICAgICAgaWYgKGR1cmF0aW9uWCA+IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24pIGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSBkdXJhdGlvblg7XG4gICAgfVxuXG4gICAgaWYgKCFkaXNhYmxlZFkpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvblkgPSBkeSA9PT0gY2IgPyBjeSA+IGNiID8gLTEgOiAxIDogY3kgPCBjdCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IHJvdW5kKGN5IC0gZHksIDApO1xuICAgICAgc3ByaW5nWS52ZWxvY2l0eSA9IGRpc2FibGVkWCAmJiBoYXNSZWxlYXNlU3ByaW5nID8gZGlzdGFuY2VZID8gKGRzICogZGlyZWN0aW9uWSkgLyBhYnMoZGlzdGFuY2VZKSA6IDAgOiBwdjtcbiAgICAgIGNvbnN0IHsgZWFzZSwgZHVyYXRpb24sIHJlc3REdXJhdGlvbiB9ID0gc3ByaW5nWTtcbiAgICAgIGR1cmF0aW9uWSA9IGN5ID09PSBkeSA/IDAgOiBoYXNSZWxlYXNlU3ByaW5nID8gZHVyYXRpb24gOiBkdXJhdGlvbiAtIChyZXN0RHVyYXRpb24gKiBnbG9iYWxzLnRpbWVTY2FsZSk7XG4gICAgICBpZiAoaGFzUmVsZWFzZVNwcmluZykgZWFzZVkgPSBlYXNlO1xuICAgICAgaWYgKGR1cmF0aW9uWSA+IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24pIGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSBkdXJhdGlvblk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNSZWxlYXNlU3ByaW5nICYmIG9iICYmIGNmICYmIChkdXJhdGlvblggfHwgZHVyYXRpb25ZKSkge1xuXG4gICAgICAgIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5ibGVuZDtcblxuICAgICAgICBuZXcgSlNBbmltYXRpb24ob3ZlcnNob290Q29vcmRzLCB7XG4gICAgICAgICAgeDogeyB0bzogYngsIGR1cmF0aW9uOiBkdXJhdGlvblggKiAuNjUgfSxcbiAgICAgICAgICB5OiB7IHRvOiBieSwgZHVyYXRpb246IGR1cmF0aW9uWSAqIC42NSB9LFxuICAgICAgICAgIGVhc2U6IHJlbGVhc2VFYXNlLFxuICAgICAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgICB9KS5pbml0KCk7XG5cbiAgICAgICAgbmV3IEpTQW5pbWF0aW9uKG92ZXJzaG9vdENvb3Jkcywge1xuICAgICAgICAgIHg6IHsgdG86IGR4LCBkdXJhdGlvbjogZHVyYXRpb25YIH0sXG4gICAgICAgICAgeTogeyB0bzogZHksIGR1cmF0aW9uOiBkdXJhdGlvblkgfSxcbiAgICAgICAgICBlYXNlOiByZWxlYXNlRWFzZSxcbiAgICAgICAgICBjb21wb3NpdGlvbixcbiAgICAgICAgfSkuaW5pdCgpO1xuXG4gICAgICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5zdHJldGNoKGR1cmF0aW9uWCkucmVzdGFydCgpO1xuICAgICAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIuc3RyZXRjaChkdXJhdGlvblkpLnJlc3RhcnQoKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICghZGlzYWJsZWRYKSB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0oZHgsIGR1cmF0aW9uWCwgZWFzZVgpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkpIHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXShkeSwgZHVyYXRpb25ZLCBlYXNlWSk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbEluVmlldyhsb25nZXN0UmVsZWFzZUR1cmF0aW9uLCB0aGlzLnNjcm9sbFRocmVzaG9sZCwgcmVsZWFzZUVhc2UpO1xuXG4gICAgbGV0IGhhc1NuYXBwZWQgPSBmYWxzZTtcblxuICAgIGlmIChkeCAhPT0gc3gpIHtcbiAgICAgIHRoaXMuc25hcHBlZFswXSA9IGR4O1xuICAgICAgaWYgKHRoaXMuc25hcFgpIGhhc1NuYXBwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkeSAhPT0gc3kgJiYgdGhpcy5zbmFwWSkge1xuICAgICAgdGhpcy5zbmFwcGVkWzFdID0gZHk7XG4gICAgICBpZiAodGhpcy5zbmFwWSkgaGFzU25hcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc1NuYXBwZWQpIHRoaXMub25TbmFwKHRoaXMpO1xuXG4gICAgdGhpcy5ncmFiYmVkID0gZmFsc2U7XG4gICAgdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gdHJ1ZTtcblxuICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSByZWxlYXNlIGFuaW1hdGlvbnMgdG8gYmUgYWJsZSB0byBjYW5jZWwgdGhlbVxuICAgIHRoaXMub25SZWxlYXNlKHRoaXMpO1xuXG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy5jb29yZHNbMF0gPSAwO1xuICAgIHRoaXMuY29vcmRzWzFdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbMF0gPSAwO1xuICAgIHRoaXMucG9pbnRlclsxXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzJdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbM10gPSAwO1xuICAgIHRoaXMucG9pbnRlcls0XSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzVdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbNl0gPSAwO1xuICAgIHRoaXMucG9pbnRlcls3XSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMV0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKHRoaXMuJHRyaWdnZXIsIHtcbiAgICAgICAgdG91Y2hBY3Rpb246IHRoaXMuZGlzYWJsZWRbMF0gPyAncGFuLXgnIDogdGhpcy5kaXNhYmxlZFsxXSA/ICdwYW4teScgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hBY3Rpb25TdHlsZXMucmV2ZXJ0KCk7XG4gICAgaWYgKHRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuY3Vyc29yU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYm9keVN0eWxlcykge1xuICAgICAgdGhpcy5ib2R5U3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy5ib2R5U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0U3R5bGVzKSB7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy4kdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2lzLWRpc2FibGVkJyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMudXBkYXRlVGlja2VyLnJldmVydCgpO1xuICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIucmV2ZXJ0KCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIucmV2ZXJ0KCk7XG4gICAgdGhpcy5hbmltYXRlLnJldmVydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duKC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICB0aGlzLmhhbmRsZURvd24oLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZSgvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICB0aGlzLmhhbmRsZUhvdmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldFxuICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICovXG5jb25zdCBjcmVhdGVEcmFnZ2FibGUgPSAodGFyZ2V0LCBwYXJhbWV0ZXJzKSA9PiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgcGFyYW1ldGVycyk7XG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhY3RSZWZcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudHxudWxsfSBbY3VycmVudF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuZ3VsYXJSZWZcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudH0gW25hdGl2ZUVsZW1lbnRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY29wZVBhcmFtc1xuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3RvcnxSZWFjdFJlZnxBbmd1bGFyUmVmfSBbcm9vdF1cbiAqIEBwcm9wZXJ0eSB7RGVmYXVsdHNQYXJhbXN9IFtkZWZhdWx0c11cbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPFN0cmluZywgU3RyaW5nPn0gW21lZGlhUXVlcmllc11cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNsZWFudXBcbiAqIEBwYXJhbSB7U2NvcGV9IFtzY29wZV1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Njb3BlfSBbc2NvcGVdXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXB8dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZU1ldGhvZFxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXB8dm9pZH1cbiAqL1xuXG5jbGFzcyBTY29wZSB7XG4gIC8qKiBAcGFyYW0ge1Njb3BlUGFyYW1zfSBbcGFyYW1ldGVyc10gKi9cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgaWYgKGdsb2JhbHMuc2NvcGUpIGdsb2JhbHMuc2NvcGUucmV2ZXJ0aWJsZXMucHVzaCh0aGlzKTtcbiAgICBjb25zdCByb290UGFyYW0gPSBwYXJhbWV0ZXJzLnJvb3Q7XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudHxET01UYXJnZXR9ICovXG4gICAgbGV0IHJvb3QgPSBkb2M7XG4gICAgaWYgKHJvb3RQYXJhbSkge1xuICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7UmVhY3RSZWZ9ICovKHJvb3RQYXJhbSkuY3VycmVudCB8fFxuICAgICAgICAgICAgIC8qKiBAdHlwZSB7QW5ndWxhclJlZn0gKi8ocm9vdFBhcmFtKS5uYXRpdmVFbGVtZW50IHx8XG4gICAgICAgICAgICAgcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0U2VsZWN0b3J9ICovKHJvb3RQYXJhbSkpWzBdIHx8XG4gICAgICAgICAgICAgZG9jO1xuICAgIH1cbiAgICBjb25zdCBzY29wZURlZmF1bHRzID0gcGFyYW1ldGVycy5kZWZhdWx0cztcbiAgICBjb25zdCBnbG9iYWxEZWZhdWx0ID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICBjb25zdCBtZWRpYVF1ZXJpZXMgPSBwYXJhbWV0ZXJzLm1lZGlhUXVlcmllcztcbiAgICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICAgIHRoaXMuZGVmYXVsdHMgPSBzY29wZURlZmF1bHRzID8gbWVyZ2VPYmplY3RzKHNjb3BlRGVmYXVsdHMsIGdsb2JhbERlZmF1bHQpIDogZ2xvYmFsRGVmYXVsdDtcbiAgICAvKiogQHR5cGUge0RvY3VtZW50fERPTVRhcmdldH0gKi9cbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8U2NvcGVDb25zdHJ1Y3Rvcj59ICovXG4gICAgdGhpcy5jb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn0gKi9cbiAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8UmV2ZXJ0aWJsZT59ICovXG4gICAgdGhpcy5yZXZlcnRpYmxlcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgRnVuY3Rpb24+fSAqL1xuICAgIHRoaXMubWV0aG9kcyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgQm9vbGVhbj59ICovXG4gICAgdGhpcy5tYXRjaGVzID0ge307XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBNZWRpYVF1ZXJ5TGlzdD59ICovXG4gICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdHMgPSB7fTtcbiAgICAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIGFueT59ICovXG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgaWYgKG1lZGlhUXVlcmllcykge1xuICAgICAgZm9yIChsZXQgbXEgaW4gbWVkaWFRdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IF9tcSA9IHdpbi5tYXRjaE1lZGlhKG1lZGlhUXVlcmllc1ttcV0pO1xuICAgICAgICB0aGlzLm1lZGlhUXVlcnlMaXN0c1ttcV0gPSBfbXE7XG4gICAgICAgIF9tcS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIFNjb3BwZWRDYWxsYmFja1xuICAgKiBAcGFyYW0ge3RoaXN9IHNjb3BlXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICpcbiAgICogQHBhcmFtIHtTY29wcGVkQ2FsbGJhY2t9IGNiXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBleGVjdXRlKGNiKSB7XG4gICAgbGV0IGFjdGl2ZVNjb3BlID0gZ2xvYmFscy5zY29wZTtcbiAgICBsZXQgYWN0aXZlUm9vdCA9IGdsb2JhbHMucm9vdDtcbiAgICBsZXQgYWN0aXZlRGVmYXVsdHMgPSBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGdsb2JhbHMuc2NvcGUgPSB0aGlzO1xuICAgIGdsb2JhbHMucm9vdCA9IHRoaXMucm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gdGhpcy5kZWZhdWx0cztcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBmb3IgKGxldCBtcSBpbiBtcXMpIHRoaXMubWF0Y2hlc1ttcV0gPSBtcXNbbXFdLm1hdGNoZXM7XG4gICAgY29uc3QgcmV0dXJuZWQgPSBjYih0aGlzKTtcbiAgICBnbG9iYWxzLnNjb3BlID0gYWN0aXZlU2NvcGU7XG4gICAgZ2xvYmFscy5yb290ID0gYWN0aXZlUm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gYWN0aXZlRGVmYXVsdHM7XG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuZXhlY3V0ZSgoKSA9PiB7XG4gICAgICBsZXQgaSA9IHRoaXMucmV2ZXJ0aWJsZXMubGVuZ3RoO1xuICAgICAgbGV0IHkgPSB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0aGlzLnJldmVydGlibGVzW2ldLnJldmVydCgpO1xuICAgICAgd2hpbGUgKHktLSkgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnNbeV0odGhpcyk7XG4gICAgICB0aGlzLnJldmVydGlibGVzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvcnMuZm9yRWFjaCggY29uc3RydWN0b3IgPT4ge1xuICAgICAgICBjb25zdCByZXZlcnRDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICBpZiAocmV2ZXJ0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGNvbnRydWN0b3JDYWxsYmFja1xuICAgKiBAcGFyYW0ge3RoaXN9IHNlbGZcbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhMVxuICAgKiBAcGFyYW0ge1Njb3BlTWV0aG9kfSBhMlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtjb250cnVjdG9yQ2FsbGJhY2t9IGExXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfGNvbnRydWN0b3JDYWxsYmFja30gYTFcbiAgICogQHBhcmFtIHtTY29wZU1ldGhvZH0gW2EyXVxuICAgKi9cbiAgYWRkKGExLCBhMikge1xuICAgIGlmIChpc0ZuYyhhMSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtjb250cnVjdG9yQ2FsbGJhY2t9ICovKGExKTtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKHJldmVydENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMucHVzaChyZXZlcnRDb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGhvZHNbLyoqIEB0eXBlIHtTdHJpbmd9ICovKGExKV0gPSAoLyoqIEB0eXBlIHthbnl9ICovLi4uYXJncykgPT4gdGhpcy5leGVjdXRlKCgpID0+IGEyKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdjaGFuZ2UnOlxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIGNvbnN0IHJldmVydGlibGVzID0gdGhpcy5yZXZlcnRpYmxlcztcbiAgICBjb25zdCByZXZlcnRDb25zdHJ1Y3RvcnMgPSB0aGlzLnJldmVydENvbnN0cnVjdG9ycztcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBsZXQgaSA9IHJldmVydGlibGVzLmxlbmd0aDtcbiAgICBsZXQgeSA9IHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgcmV2ZXJ0aWJsZXNbaV0ucmV2ZXJ0KCk7XG4gICAgd2hpbGUgKHktLSkgcmV2ZXJ0Q29uc3RydWN0b3JzW3ldKHRoaXMpO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgbXFzW21xXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICByZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgIHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXRjaGVzID0ge307XG4gICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NvcGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTY29wZX1cbiAqL1xuY29uc3QgY3JlYXRlU2NvcGUgPSBwYXJhbXMgPT4gbmV3IFNjb3BlKHBhcmFtcyk7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ9IFNjcm9sbFRocmVzaG9sZFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE1heFZpZXdIZWlnaHQgPSAoKSA9PiB7XG4gIGNvbnN0ICRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZCgkZWwpO1xuICAkZWwuc3R5bGUuaGVpZ2h0ID0gJzEwMGx2aCc7XG4gIGNvbnN0IGhlaWdodCA9ICRlbC5vZmZzZXRIZWlnaHQ7XG4gIGRvYy5ib2R5LnJlbW92ZUNoaWxkKCRlbCk7XG4gIHJldHVybiBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV8U3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufE9iamVjdH0gVFxuICogQHBhcmFtIHtUIHwgKChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtTY3JvbGxPYnNlcnZlcn0gc2Nyb2xsZXJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgc2Nyb2xsZXIpID0+IHZhbHVlICYmIGlzRm5jKHZhbHVlKSA/IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovKHZhbHVlKShzY3JvbGxlcikgOiB2YWx1ZTtcblxuY29uc3Qgc2Nyb2xsQ29udGFpbmVycyA9IG5ldyBNYXAoKTtcblxuY2xhc3MgU2Nyb2xsQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRlbFxuICAgKi9cbiAgY29uc3RydWN0b3IoJGVsKSB7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLmVsZW1lbnQgPSAkZWw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMudXNlV2luID0gdGhpcy5lbGVtZW50ID09PSBkb2MuYm9keTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLndpbldpZHRoID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLndpbkhlaWdodCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnNjcm9sbFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5wcmV2U2Nyb2xsWCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5wcmV2U2Nyb2xsWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxXaWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkWCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkWSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgb25CZWdpbjogKCkgPT4gdGhpcy5kYXRhVGltZXIucmVzdW1lKCksXG4gICAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSB0aGlzLmJhY2t3YXJkWCB8fCB0aGlzLmJhY2t3YXJkWTtcbiAgICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL2NoaWxkKSA9PiBjaGlsZC5oYW5kbGVTY3JvbGwoKSwgYmFja3dhcmRzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB0aGlzLmRhdGFUaW1lci5wYXVzZSgpXG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5kYXRhVGltZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZnJhbWVSYXRlOiAzMCxcbiAgICAgIG9uVXBkYXRlOiBzZWxmID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSBzZWxmLmRlbHRhVGltZTtcbiAgICAgICAgY29uc3QgcHggPSB0aGlzLnByZXZTY3JvbGxYO1xuICAgICAgICBjb25zdCBweSA9IHRoaXMucHJldlNjcm9sbFk7XG4gICAgICAgIGNvbnN0IG54ID0gdGhpcy5zY3JvbGxYO1xuICAgICAgICBjb25zdCBueSA9IHRoaXMuc2Nyb2xsWTtcbiAgICAgICAgY29uc3QgZHggPSBweCAtIG54O1xuICAgICAgICBjb25zdCBkeSA9IHB5IC0gbnk7XG4gICAgICAgIHRoaXMucHJldlNjcm9sbFggPSBueDtcbiAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWSA9IG55O1xuICAgICAgICBpZiAoZHgpIHRoaXMuYmFja3dhcmRYID0gcHggPiBueDtcbiAgICAgICAgaWYgKGR5KSB0aGlzLmJhY2t3YXJkWSA9IHB5ID4gbnk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSByb3VuZChkdCA+IDAgPyBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZHQgOiAwLCA1KTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtUaW1lcn0gKi9cbiAgICB0aGlzLnJlc2l6ZVRpY2tlciA9IG5ldyBUaW1lcih7XG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogMjUwICogZ2xvYmFscy50aW1lU2NhbGUsXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0pLmluaXQoKTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMud2FrZVRpY2tlciA9IG5ldyBUaW1lcih7XG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogNTAwICogZ2xvYmFscy50aW1lU2NhbGUsXG4gICAgICBvbkJlZ2luOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGlja2VyLnJlc3VtZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zY3JvbGxUaWNrZXIucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29vcmRzKCk7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLnJlc2l6ZVRpY2tlci5yZXN0YXJ0KCkpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuZWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgZmFsc2UpO1xuICB9XG5cbiAgdXBkYXRlU2Nyb2xsQ29vcmRzKCkge1xuICAgIGNvbnN0IHVzZVdpbiA9IHRoaXMudXNlV2luO1xuICAgIGNvbnN0ICRlbCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLnNjcm9sbFggPSByb3VuZCh1c2VXaW4gPyB3aW4uc2Nyb2xsWCA6ICRlbC5zY3JvbGxMZWZ0LCAwKTtcbiAgICB0aGlzLnNjcm9sbFkgPSByb3VuZCh1c2VXaW4gPyB3aW4uc2Nyb2xsWSA6ICRlbC5zY3JvbGxUb3AsIDApO1xuICB9XG5cbiAgdXBkYXRlV2luZG93Qm91bmRzKCkge1xuICAgIHRoaXMud2luV2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgICB0aGlzLndpbkhlaWdodCA9IGdldE1heFZpZXdIZWlnaHQoKTtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KTtcbiAgICBjb25zdCAkZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxXaWR0aCA9ICRlbC5zY3JvbGxXaWR0aCArIHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9ICRlbC5zY3JvbGxIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkJvdHRvbSk7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAodGhpcy51c2VXaW4pIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aW5XaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMud2luSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbFJlY3QgPSAkZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IGVsUmVjdC50b3A7XG4gICAgICB0aGlzLmxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgcmVmcmVzaFNjcm9sbE9ic2VydmVycygpIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5fZGVidWcpIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlRGVidWcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY2hpbGQucmVmcmVzaCgpO1xuICAgICAgaWYgKGNoaWxkLl9kZWJ1Zykge1xuICAgICAgICBjaGlsZC5kZWJ1ZygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnVwZGF0ZVdpbmRvd0JvdW5kcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgdGhpcy5yZWZyZXNoU2Nyb2xsT2JzZXJ2ZXJzKCk7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCgpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIHRoaXMud2FrZVRpY2tlci5yZXN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5zY3JvbGxUaWNrZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5kYXRhVGltZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIuY2FuY2VsKCk7XG4gICAgdGhpcy53YWtlVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgKHRoaXMudXNlV2luID8gd2luIDogdGhpcy5lbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzKTtcbiAgICBzY3JvbGxDb250YWluZXJzLmRlbGV0ZSh0aGlzLmVsZW1lbnQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldFxuICogQHJldHVybiB7U2Nyb2xsQ29udGFpbmVyfVxuICovXG5jb25zdCByZWdpc3RlckFuZEdldFNjcm9sbENvbnRhaW5lciA9IHRhcmdldCA9PiB7XG4gIGNvbnN0ICRlbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHRhcmdldCA/IHBhcnNlVGFyZ2V0cyh0YXJnZXQpWzBdIHx8IGRvYy5ib2R5IDogZG9jLmJvZHkpO1xuICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVycy5nZXQoJGVsKTtcbiAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICBzY3JvbGxDb250YWluZXIgPSBuZXcgU2Nyb2xsQ29udGFpbmVyKCRlbCk7XG4gICAgc2Nyb2xsQ29udGFpbmVycy5zZXQoJGVsLCBzY3JvbGxDb250YWluZXIpO1xuICB9XG4gIHJldHVybiBzY3JvbGxDb250YWluZXI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRlbFxuICogQHBhcmFtIHtOdW1iZXJ8c3RyaW5nfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFt1bmRlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3Zlcl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgY29udmVydFZhbHVlVG9QeCA9ICgkZWwsIHYsIHNpemUsIHVuZGVyLCBvdmVyKSA9PiB7XG4gIGNvbnN0IGNsYW1wTWluID0gdiA9PT0gJ21pbic7XG4gIGNvbnN0IGNsYW1wTWF4ID0gdiA9PT0gJ21heCc7XG4gIGNvbnN0IHZhbHVlID0gdiA9PT0gJ3RvcCcgfHwgdiA9PT0gJ2xlZnQnIHx8IHYgPT09ICdzdGFydCcgfHwgY2xhbXBNaW4gPyAwIDpcbiAgICAgICAgICAgICAgICB2ID09PSAnYm90dG9tJyB8fCB2ID09PSAncmlnaHQnIHx8IHYgPT09ICdlbmQnIHx8IGNsYW1wTWF4ID8gJzEwMCUnIDpcbiAgICAgICAgICAgICAgICB2ID09PSAnY2VudGVyJyA/ICc1MCUnIDpcbiAgICAgICAgICAgICAgICB2O1xuICBjb25zdCB7IG4sIHUgfSA9IGRlY29tcG9zZVJhd1ZhbHVlKHZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gIGxldCBweCA9IG47XG4gIGlmICh1ID09PSAnJScpIHtcbiAgICBweCA9IChuIC8gMTAwKSAqIHNpemU7XG4gIH0gZWxzZSBpZiAodSkge1xuICAgIHB4ID0gY29udmVydFZhbHVlVW5pdCgkZWwsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLCAncHgnLCB0cnVlKS5uO1xuICB9XG4gIGlmIChjbGFtcE1heCAmJiB1bmRlciA8IDApIHB4ICs9IHVuZGVyO1xuICBpZiAoY2xhbXBNaW4gJiYgb3ZlciA+IDApIHB4ICs9IG92ZXI7XG4gIHJldHVybiBweDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge1Njcm9sbFRocmVzaG9sZFZhbHVlfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFt1bmRlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3Zlcl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcGFyc2VCb3VuZFZhbHVlID0gKCRlbCwgdiwgc2l6ZSwgdW5kZXIsIG92ZXIpID0+IHtcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gIGxldCB2YWx1ZTtcbiAgaWYgKGlzU3RyKHYpKSB7XG4gICAgY29uc3QgbWF0Y2hlZE9wZXJhdG9yID0gcmVsYXRpdmVWYWx1ZXNFeGVjUmd4LmV4ZWMoLyoqIEB0eXBlIHtTdHJpbmd9ICovKHYpKTtcbiAgICBpZiAobWF0Y2hlZE9wZXJhdG9yKSB7XG4gICAgICBjb25zdCBzcGxpdHRlciA9IG1hdGNoZWRPcGVyYXRvclswXTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gc3BsaXR0ZXJbMF07XG4gICAgICBjb25zdCBzcGxpdHRlZCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2KS5zcGxpdChzcGxpdHRlcik7XG4gICAgICBjb25zdCBjbGFtcE1pbiA9IHNwbGl0dGVkWzBdID09PSAnbWluJztcbiAgICAgIGNvbnN0IGNsYW1wTWF4ID0gc3BsaXR0ZWRbMF0gPT09ICdtYXgnO1xuICAgICAgY29uc3QgdmFsdWVBUHggPSBjb252ZXJ0VmFsdWVUb1B4KCRlbCwgc3BsaXR0ZWRbMF0sIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICAgIGNvbnN0IHZhbHVlQlB4ID0gY29udmVydFZhbHVlVG9QeCgkZWwsIHNwbGl0dGVkWzFdLCBzaXplLCB1bmRlciwgb3Zlcik7XG4gICAgICBpZiAoY2xhbXBNaW4pIHtcbiAgICAgICAgY29uc3QgbWluID0gZ2V0UmVsYXRpdmVWYWx1ZShjb252ZXJ0VmFsdWVUb1B4KCRlbCwgJ21pbicsIHNpemUpLCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgICB2YWx1ZSA9IG1pbiA8IHZhbHVlQVB4ID8gdmFsdWVBUHggOiBtaW47XG4gICAgICB9IGVsc2UgaWYgKGNsYW1wTWF4KSB7XG4gICAgICAgIGNvbnN0IG1heCA9IGdldFJlbGF0aXZlVmFsdWUoY29udmVydFZhbHVlVG9QeCgkZWwsICdtYXgnLCBzaXplKSwgdmFsdWVCUHgsIG9wZXJhdG9yKTtcbiAgICAgICAgdmFsdWUgPSBtYXggPiB2YWx1ZUFQeCA/IHZhbHVlQVB4IDogbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbHVlQVB4LCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCB2LCBzaXplLCB1bmRlciwgb3Zlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHYpO1xuICB9XG4gIHJldHVybiByb3VuZCh2YWx1ZSwgMCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SlNBbmltYXRpb259IGxpbmtlZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmNvbnN0IGdldEFuaW1hdGlvbkRvbVRhcmdldCA9IGxpbmtlZCA9PiB7XG4gIGxldCAkbGlua2VkVGFyZ2V0O1xuICBjb25zdCBsaW5rZWRUYXJnZXRzID0gbGlua2VkLnRhcmdldHM7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlua2VkVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSBsaW5rZWRUYXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXRbaXNEb21TeW1ib2xdKSB7XG4gICAgICAkbGlua2VkVGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGFyZ2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJGxpbmtlZFRhcmdldDtcbn07XG5cbmxldCBzY3JvbGxlckluZGV4ID0gMDtcblxuY29uc3QgZGVidWdDb2xvcnMgPSBbJyNGRjRCNEInLCcjRkY5NzFCJywnI0ZGQzczMCcsJyNGOUY2NDAnLCcjN0FGRjVBJywnIzE4RkY3NCcsJyMxN0UwOUInLCcjM0NGRkVDJywnIzA1REJFOScsJyMzM0IzRjEnLCcjNjM4Q0Y5JywnI0M1NjNGRScsJyNGRjRGQ0YnLCcjRjkzRjhBJ107XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2Nyb2xsVGhyZXNob2xkUGFyYW1cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkge1Njcm9sbFRocmVzaG9sZFZhbHVlfSBbY29udGFpbmVyXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjcm9sbE9ic2VydmVyQXhpc0NhbGxiYWNrXG4gKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyfSBzZWxmXG4gKiBAcmV0dXJuIHsneCd8J3knfVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjcm9sbFRocmVzaG9sZENhbGxiYWNrXG4gKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyfSBzZWxmXG4gKiBAcmV0dXJuIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbX1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjcm9sbE9ic2VydmVyUGFyYW1zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ8U3RyaW5nfEVhc2luZ1BhcmFtfSBbc3luY11cbiAqIEBwcm9wZXJ0eSB7VGFyZ2V0c1BhcmFtfSBbY29udGFpbmVyXVxuICogQHByb3BlcnR5IHtUYXJnZXRzUGFyYW19IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkgeyd4J3wneSd8U2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2t8KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+ICd4J3wneSd8U2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2spfSBbYXhpc11cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t8KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IFNjcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrKX0gW2VudGVyXVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gU2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2spfSBbbGVhdmVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IEJvb2xlYW4pfSBbcmVwZWF0XVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZGVidWddXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uRW50ZXJdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uRW50ZXJGb3J3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkxlYXZlRm9yd2FyZF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlckJhY2t3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkxlYXZlQmFja3dhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvblN5bmNDb21wbGV0ZV1cbiAqL1xuXG5jbGFzcyBTY3JvbGxPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuICAgIGNvbnN0IHN5bmNNb2RlID0gc2V0VmFsdWUocGFyYW1ldGVycy5zeW5jLCAncGxheSBwYXVzZScpO1xuICAgIGNvbnN0IGVhc2UgPSBzeW5jTW9kZSA/IHBhcnNlRWFzaW5ncygvKiogQHR5cGUge0Vhc2luZ1BhcmFtfSAqLyhzeW5jTW9kZSkpIDogbnVsbDtcbiAgICBjb25zdCBpc0xpbmVhciA9IHN5bmNNb2RlICYmIChzeW5jTW9kZSA9PT0gJ2xpbmVhcicgfHwgc3luY01vZGUgPT09IG5vbmUpO1xuICAgIGNvbnN0IGlzRWFzZSA9IHN5bmNNb2RlICYmICEoZWFzZSA9PT0gbm9uZSAmJiAhaXNMaW5lYXIpO1xuICAgIGNvbnN0IGlzU21vb3RoID0gc3luY01vZGUgJiYgKGlzTnVtKHN5bmNNb2RlKSB8fCBzeW5jTW9kZSA9PT0gdHJ1ZSB8fCBpc0xpbmVhcik7XG4gICAgY29uc3QgaXNNZXRob2RzID0gc3luY01vZGUgJiYgKGlzU3RyKHN5bmNNb2RlKSAmJiAhaXNFYXNlICYmICFpc1Ntb290aCk7XG4gICAgY29uc3Qgc3luY01ldGhvZHMgPSBpc01ldGhvZHMgPyAvKiogQHR5cGUge1N0cmluZ30gKi8oc3luY01vZGUpLnNwbGl0KCcgJykubWFwKFxuICAgICAgKC8qKiBAdHlwZSB7U3RyaW5nfSAqL20pID0+ICgpID0+IHtcbiAgICAgICAgY29uc3QgbGlua2VkID0gdGhpcy5saW5rZWQ7XG4gICAgICAgIHJldHVybiBsaW5rZWQgJiYgbGlua2VkW21dID8gbGlua2VkW21dKCkgOiBudWxsO1xuICAgICAgfVxuICAgICkgOiBudWxsO1xuICAgIGNvbnN0IGJpRGlyU3luYyA9IGlzTWV0aG9kcyAmJiBzeW5jTWV0aG9kcy5sZW5ndGggPiAyO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaW5kZXggPSBzY3JvbGxlckluZGV4Kys7XG4gICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgIHRoaXMuaWQgPSAhaXNVbmQocGFyYW1ldGVycy5pZCkgPyBwYXJhbWV0ZXJzLmlkIDogdGhpcy5pbmRleDtcbiAgICAvKiogQHR5cGUge1Njcm9sbENvbnRhaW5lcn0gKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IHJlZ2lzdGVyQW5kR2V0U2Nyb2xsQ29udGFpbmVyKHBhcmFtZXRlcnMuY29udGFpbmVyKTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMubGlua2VkID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXBlYXQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhvcml6b250YWwgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t9ICovXG4gICAgdGhpcy5lbnRlciA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja30gKi9cbiAgICB0aGlzLmxlYXZlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5zeW5jID0gaXNFYXNlIHx8IGlzU21vb3RoIHx8ICEhc3luY01ldGhvZHM7XG4gICAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnN5bmNFYXNlID0gaXNFYXNlID8gZWFzZSA6IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zeW5jU21vb3RoID0gaXNTbW9vdGggPyBzeW5jTW9kZSA9PT0gdHJ1ZSB8fCBpc0xpbmVhciA/IDEgOiAvKiogQHR5cGUge051bWJlcn0gKi8oc3luY01vZGUpIDogbnVsbDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyID0gc3luY01ldGhvZHMgJiYgIWJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1swXSA/IHN5bmNNZXRob2RzWzBdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0xlYXZlID0gc3luY01ldGhvZHMgJiYgIWJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1sxXSA/IHN5bmNNZXRob2RzWzFdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyRm9yd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1swXSA/IHN5bmNNZXRob2RzWzBdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0xlYXZlRm9yd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1sxXSA/IHN5bmNNZXRob2RzWzFdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyQmFja3dhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMl0gPyBzeW5jTWV0aG9kc1syXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZUJhY2t3YXJkID0gc3luY01ldGhvZHMgJiYgYmlEaXJTeW5jICYmIHN5bmNNZXRob2RzWzNdID8gc3luY01ldGhvZHNbM10gOiBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25FbnRlciA9IHBhcmFtZXRlcnMub25FbnRlciB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZSA9IHBhcmFtZXRlcnMub25MZWF2ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25FbnRlckZvcndhcmQgPSBwYXJhbWV0ZXJzLm9uRW50ZXJGb3J3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkxlYXZlRm9yd2FyZCA9IHBhcmFtZXRlcnMub25MZWF2ZUZvcndhcmQgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXJCYWNrd2FyZCA9IHBhcmFtZXRlcnMub25FbnRlckJhY2t3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkxlYXZlQmFja3dhcmQgPSBwYXJhbWV0ZXJzLm9uTGVhdmVCYWNrd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBwYXJhbWV0ZXJzLm9uVXBkYXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNDb21wbGV0ZSA9IHBhcmFtZXRlcnMub25TeW5jQ29tcGxldGUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXZlcnRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJlZ2FuID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5mb3JjZUVudGVyID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaGFzRW50ZXJlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59ICovXG4gICAgdGhpcy5vZmZzZXRzID0gW107XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMub2Zmc2V0U3RhcnQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMub2Zmc2V0RW5kID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnByZXZQcm9ncmVzcyA9IDA7XG4gICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICB0aGlzLnRocmVzaG9sZHMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdlbmQnLCAnc3RhcnQnXTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29vcmRzID0gWzAsIDAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5kZWJ1Z1N0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRkZWJ1ZyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlclBhcmFtc30gKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbWV0ZXJzO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLl9kZWJ1ZyA9IHNldFZhbHVlKHBhcmFtZXRlcnMuZGVidWcsIGZhbHNlKTtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgYWRkQ2hpbGQodGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lIHRvIGFkZCB0byB0aGUgY29udGFpbmVyIGluIG9yZGVyIHRvIGhhbmRsZSBjYWxscyB0byBsaW5rKClcbiAgICBzeW5jKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJldmVydGVkKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHBhcnNlVGFyZ2V0cyhwYXJhbWV0ZXJzLnRhcmdldClbMF0pO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBkb2MuYm9keTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGVidWcpIHRoaXMuZGVidWcoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufSBsaW5rZWRcbiAgICovXG4gIGxpbmsobGlua2VkKSB7XG4gICAgaWYgKGxpbmtlZCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHBhdXNlIHRoZSBsaW5rZWQgb2JqZWN0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgbGlua2VkLnBhdXNlKCk7XG4gICAgICB0aGlzLmxpbmtlZCA9IGxpbmtlZDtcbiAgICAgIC8vIFRyeSB0byB1c2UgYSB0YXJnZXQgb2YgdGhlIGxpbmtlZCBvYmplY3QgaWYgbm8gdGFyZ2V0IHBhcmFtZXRlcnMgc3BlY2lmaWVkXG4gICAgICBpZiAoIXRoaXMuX3BhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgbGV0ICRsaW5rZWRUYXJnZXQ7XG4gICAgICAgIGlmICghaXNVbmQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8obGlua2VkKS50YXJnZXRzKSkge1xuICAgICAgICAgICRsaW5rZWRUYXJnZXQgPSBnZXRBbmltYXRpb25Eb21UYXJnZXQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8obGlua2VkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yRWFjaENoaWxkcmVuKC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKGxpbmtlZCksICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudGFyZ2V0cyAmJiAhJGxpbmtlZFRhcmdldCkge1xuICAgICAgICAgICAgICAkbGlua2VkVGFyZ2V0ID0gZ2V0QW5pbWF0aW9uRG9tVGFyZ2V0KC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gYm9keSBpZiBubyB0YXJnZXQgZm91bmRcbiAgICAgICAgdGhpcy50YXJnZXQgPSAkbGlua2VkVGFyZ2V0IHx8IGRvYy5ib2R5O1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnZlbG9jaXR5O1xuICB9XG5cbiAgZ2V0IGJhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyB0aGlzLmNvbnRhaW5lci5iYWNrd2FyZFggOiB0aGlzLmNvbnRhaW5lci5iYWNrd2FyZFk7XG4gIH1cblxuICBnZXQgc2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyB0aGlzLmNvbnRhaW5lci5zY3JvbGxYIDogdGhpcy5jb250YWluZXIuc2Nyb2xsWTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICBjb25zdCBwID0gKHRoaXMuc2Nyb2xsIC0gdGhpcy5vZmZzZXRTdGFydCkgLyB0aGlzLmRpc3RhbmNlO1xuICAgIHJldHVybiBwID09PSBJbmZpbml0eSB8fCBpc05hTihwKSA/IDAgOiByb3VuZChjbGFtcChwLCAwLCAxKSwgNik7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgdGhpcy5yZXBlYXQgPSBzZXRWYWx1ZShwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnJlcGVhdCwgdGhpcyksIHRydWUpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHNldFZhbHVlKHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuYXhpcywgdGhpcyksICd5JykgPT09ICd4JztcbiAgICB0aGlzLmVudGVyID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5lbnRlciwgdGhpcyksICdlbmQgc3RhcnQnKTtcbiAgICB0aGlzLmxlYXZlID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5sZWF2ZSwgdGhpcyksICdzdGFydCBlbmQnKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVEZWJ1ZygpIHtcbiAgICBpZiAodGhpcy4kZGVidWcpIHtcbiAgICAgIHRoaXMuJGRlYnVnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZGVidWcpO1xuICAgICAgdGhpcy4kZGVidWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Z1N0eWxlcykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1ZygpIHtcbiAgICB0aGlzLnJlbW92ZURlYnVnKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0ICRleGlzdGluZ0RlYnVnID0gY29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gLmFuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICBjb25zdCAkZGVidWcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRocmVzaG9sZHMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRyaWdnZXJzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gZGVidWdDb2xvcnNbdGhpcy5pbmRleCAlIGRlYnVnQ29sb3JzLmxlbmd0aF07XG4gICAgY29uc3QgdXNlV2luID0gY29udGFpbmVyLnVzZVdpbjtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IHVzZVdpbiA/IGNvbnRhaW5lci53aW5XaWR0aCA6IGNvbnRhaW5lci53aWR0aDtcbiAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSB1c2VXaW4gPyBjb250YWluZXIud2luSGVpZ2h0IDogY29udGFpbmVyLmhlaWdodDtcbiAgICBjb25zdCBzY3JvbGxXaWR0aCA9IGNvbnRhaW5lci5zY3JvbGxXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbnRhaW5lci53aWR0aCA+IDM2MCA/IDMyMCA6IDI2MDtcbiAgICBjb25zdCBvZmZMZWZ0ID0gaXNIb3JpID8gMCA6IDEwO1xuICAgIGNvbnN0IG9mZlRvcCA9IGlzSG9yaSA/IDEwIDogMDtcbiAgICBjb25zdCBoYWxmID0gaXNIb3JpID8gMjQgOiBzaXplIC8gMjtcbiAgICBjb25zdCBsYWJlbEhlaWdodCA9IGlzSG9yaSA/IGhhbGYgOiAxNTtcbiAgICBjb25zdCBsYWJlbFdpZHRoID0gaXNIb3JpID8gNjAgOiBoYWxmO1xuICAgIGNvbnN0IGxhYmVsU2l6ZSA9IGlzSG9yaSA/IGxhYmVsV2lkdGggOiBsYWJlbEhlaWdodDtcbiAgICBjb25zdCByZXBlYXQgPSBpc0hvcmkgPyAncmVwZWF0LXgnIDogJ3JlcGVhdC15JztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBncmFkaWVudE9mZnNldCA9IHYgPT4gaXNIb3JpID8gJzBweCAnKyh2KSsncHgnIDogKHYpKydweCcrJyAycHgnO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnN0IGxpbmVDU1MgPSAoYykgPT4gYGxpbmVhci1ncmFkaWVudCgke2lzSG9yaSA/IDkwIDogMH1kZWcsICR7Y30gMnB4LCB0cmFuc3BhcmVudCAxcHgpYDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2VDU1MgPSAocCwgbCwgdCwgdywgaCkgPT4gYHBvc2l0aW9uOiR7cH07bGVmdDoke2x9cHg7dG9wOiR7dH1weDt3aWR0aDoke3d9cHg7aGVpZ2h0OiR7aH1weDtgO1xuICAgICRkZWJ1Zy5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygnYWJzb2x1dGUnLCBvZmZMZWZ0LCBvZmZUb3AsIGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogc2l6ZSwgaXNIb3JpID8gc2l6ZSA6IHNjcm9sbEhlaWdodCl9XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIHotaW5kZXg6ICR7dGhpcy5jb250YWluZXIuekluZGV4Kyt9O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiAke2lzSG9yaSA/ICdjb2x1bW4nIDogJ3Jvdyd9O1xuICAgICAgZmlsdGVyOiBkcm9wLXNoYWRvdygwcHggMXB4IDBweCByZ2JhKDAsMCwwLC43NSkpO1xuICAgIGA7XG4gICAgJHRocmVzaG9sZHMuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ3N0aWNreScsIDAsIDAsIGlzSG9yaSA/IGNvbnRhaW5lcldpZHRoIDogaGFsZiwgaXNIb3JpID8gaGFsZiA6IGNvbnRhaW5lckhlaWdodCl9YDtcbiAgICBpZiAoISRleGlzdGluZ0RlYnVnKSB7XG4gICAgICAkdGhyZXNob2xkcy5zdHlsZS5jc3NUZXh0ICs9IGBiYWNrZ3JvdW5kOlxuICAgICAgICAke2xpbmVDU1MoJyNGRkZGJyl9JHtncmFkaWVudE9mZnNldChoYWxmLTEwKX0gLyAke2lzSG9yaSA/ICcxMDBweCAxMDBweCcgOiAnMTAwcHggMTAwcHgnfSAke3JlcGVhdH0sXG4gICAgICAgICR7bGluZUNTUygnI0ZGRjgnKX0ke2dyYWRpZW50T2Zmc2V0KGhhbGYtMTApfSAvICR7aXNIb3JpID8gJzEwcHggMTBweCcgOiAnMTBweCAxMHB4J30gJHtyZXBlYXR9O1xuICAgICAgYDtcbiAgICB9XG4gICAgJHRyaWdnZXJzLnN0eWxlLmNzc1RleHQgPSBgJHtiYXNlQ1NTKCdyZWxhdGl2ZScsIDAsIDAsIGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogaGFsZiwgaXNIb3JpID8gaGFsZiA6IHNjcm9sbEhlaWdodCl9YDtcbiAgICBpZiAoISRleGlzdGluZ0RlYnVnKSB7XG4gICAgICAkdHJpZ2dlcnMuc3R5bGUuY3NzVGV4dCArPSBgYmFja2dyb3VuZDpcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGRicpfSR7Z3JhZGllbnRPZmZzZXQoMCl9IC8gJHtpc0hvcmkgPyAnMTAwcHggMTBweCcgOiAnMTBweCAxMDBweCd9ICR7cmVwZWF0fSxcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGOCcpfSR7Z3JhZGllbnRPZmZzZXQoMCl9IC8gJHtpc0hvcmkgPyAnMTBweCAwcHgnIDogJzBweCAxMHB4J30gJHtyZXBlYXR9O1xuICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gWycgZW50ZXI6ICcsICcgbGVhdmU6ICddO1xuICAgIHRoaXMuY29vcmRzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIGNvbnN0IGlzVmlldyA9IGkgPiAxO1xuICAgICAgY29uc3QgdmFsdWUgPSAoaXNWaWV3ID8gMCA6IHRoaXMub2Zmc2V0KSArIHY7XG4gICAgICBjb25zdCBpc1RhaWwgPSBpICUgMjtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB2YWx1ZSA8IGxhYmVsU2l6ZTtcbiAgICAgIGNvbnN0IGlzT3ZlciA9IHZhbHVlID4gKGlzVmlldyA/IGlzSG9yaSA/IGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVySGVpZ2h0IDogaXNIb3JpID8gc2Nyb2xsV2lkdGggOiBzY3JvbGxIZWlnaHQpIC0gbGFiZWxTaXplO1xuICAgICAgY29uc3QgaXNGbGlwID0gKGlzVmlldyA/IGlzVGFpbCAmJiAhaXNGaXJzdCA6ICFpc1RhaWwgJiYgIWlzRmlyc3QpIHx8IGlzT3ZlcjtcbiAgICAgIGNvbnN0ICRsYWJlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0ICR0ZXh0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgZGlyUHJvcCA9IGlzSG9yaSA/IGlzRmxpcCA/ICdyaWdodCcgOiAnbGVmdCcgOiBpc0ZsaXAgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgY29uc3QgZmxpcE9mZnNldCA9IGlzRmxpcCA/IChpc0hvcmkgPyBsYWJlbFdpZHRoIDogbGFiZWxIZWlnaHQpICsgKCFpc1ZpZXcgPyBpc0hvcmkgPyAtMSA6IC0yIDogaXNIb3JpID8gLTEgOiBpc092ZXIgPyAwIDogLTIpIDogIWlzVmlldyA/IGlzSG9yaSA/IDEgOiAwIDogaXNIb3JpID8gMSA6IDA7XG4gICAgICAvLyAkdGV4dC5pbm5lckhUTUwgPSBgJHshaXNWaWV3ID8gJycgOiBsYWJlbHNbaXNUYWlsXSArICcgJ30ke3RoaXMuaWR9OiAke3RoaXMudGhyZXNob2xkc1tpXX0gJHtpc1ZpZXcgPyAnJyA6IGxhYmVsc1tpc1RhaWxdfWA7XG4gICAgICAkdGV4dC5pbm5lckhUTUwgPSBgJHt0aGlzLmlkfSR7bGFiZWxzW2lzVGFpbF19JHt0aGlzLnRocmVzaG9sZHNbaV19YDtcbiAgICAgICRsYWJlbC5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygnYWJzb2x1dGUnLCAwLCAwLCBsYWJlbFdpZHRoLCBsYWJlbEhlaWdodCl9XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiAke2lzSG9yaSA/ICdjb2x1bW4nIDogJ3Jvdyd9O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtJHtpc1ZpZXcgPyAnc3RhcnQnIDogJ2VuZCd9O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC0ke2lzRmxpcCA/ICdlbmQnIDogJ3N0YXJ0J307XG4gICAgICAgIGJvcmRlci0ke2RpclByb3B9OiAycHggJHtpc1RhaWwgPyAnc29saWQnIDogJ3NvbGlkJ30gJHtjb2xvcn07XG4gICAgICBgO1xuICAgICAgJHRleHQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbWF4LXdpZHRoOiAkeyhzaXplIC8gMikgLSAxMH1weDtcbiAgICAgICAgaGVpZ2h0OiAke2xhYmVsSGVpZ2h0fTtcbiAgICAgICAgbWFyZ2luLSR7aXNIb3JpID8gaXNGbGlwID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGlzRmxpcCA/ICdib3R0b20nIDogJ3RvcCd9OiAtMnB4O1xuICAgICAgICBwYWRkaW5nOiAxcHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIG1vbm9zcGFjZTtcbiAgICAgICAgZm9udC1zaXplOiAxMHB4O1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMjVlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDlweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgdGV4dC1hbGlnbjogJHtpc0hvcmkgJiYgaXNGbGlwIHx8ICFpc0hvcmkgJiYgIWlzVmlldyA/ICdyaWdodCcgOiAnbGVmdCd9O1xuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgY29sb3I6ICR7aXNUYWlsID8gY29sb3IgOiAncmdiYSgwLDAsMCwuNzUpJ307XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7aXNUYWlsID8gJ3JnYmEoMCwwLDAsLjY1KScgOiBjb2xvcn07XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICR7aXNUYWlsID8gY29sb3IgOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgICAgYm9yZGVyLSR7aXNIb3JpID8gaXNGbGlwID8gJ3RvcC1sZWZ0JyA6ICd0b3AtcmlnaHQnIDogaXNGbGlwID8gJ3RvcC1sZWZ0JyA6ICdib3R0b20tbGVmdCd9LXJhZGl1czogNXB4O1xuICAgICAgICBib3JkZXItJHtpc0hvcmkgPyBpc0ZsaXAgPyAnYm90dG9tLWxlZnQnIDogJ2JvdHRvbS1yaWdodCcgOiBpc0ZsaXAgPyAndG9wLXJpZ2h0JyA6ICdib3R0b20tcmlnaHQnfS1yYWRpdXM6IDVweDtcbiAgICAgIGA7XG4gICAgICAkbGFiZWwuYXBwZW5kQ2hpbGQoJHRleHQpO1xuICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUgLSBmbGlwT2Zmc2V0ICsgKGlzSG9yaSA/IDEgOiAwKTtcbiAgICAgICRsYWJlbC5zdHlsZVtpc0hvcmkgPyAnbGVmdCcgOiAndG9wJ10gPSBgJHtwb3NpdGlvbn1weGA7XG4gICAgICAvLyAkbGFiZWwuc3R5bGVbaXNIb3JpID8gJ2xlZnQnIDogJ3RvcCddID0gdmFsdWUgLSBmbGlwT2Zmc2V0ICsgKCFpc0ZsaXAgJiYgaXNGaXJzdCAmJiAhaXNWaWV3ID8gMSA6IGlzRmxpcCA/IDAgOiAtMikgKyAncHgnO1xuICAgICAgKGlzVmlldyA/ICR0aHJlc2hvbGRzIDogJHRyaWdnZXJzKS5hcHBlbmRDaGlsZCgkbGFiZWwpO1xuICAgIH0pO1xuXG4gICAgJGRlYnVnLmFwcGVuZENoaWxkKCR0aHJlc2hvbGRzKTtcbiAgICAkZGVidWcuYXBwZW5kQ2hpbGQoJHRyaWdnZXJzKTtcbiAgICBjb250YWluZXIuZWxlbWVudC5hcHBlbmRDaGlsZCgkZGVidWcpO1xuXG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1ZykgJGRlYnVnLmNsYXNzTGlzdC5hZGQoJ2FuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICB0aGlzLiRkZWJ1ZyA9ICRkZWJ1ZztcbiAgICBjb25zdCBjb250YWluZXJQb3NpdGlvbiA9IGdldFRhcmdldFZhbHVlKGNvbnRhaW5lci5lbGVtZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAoY29udGFpbmVyUG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB0aGlzLmRlYnVnU3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKGNvbnRhaW5lci5lbGVtZW50LCB7IHBvc2l0aW9uOiAncmVsYXRpdmUgJ30pO1xuICAgIH1cblxuICB9XG5cbiAgdXBkYXRlQm91bmRzKCkge1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5yZW1vdmVEZWJ1ZygpO1xuICAgIH1cbiAgICBsZXQgc3RpY2t5cztcbiAgICBjb25zdCAkdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgIGxldCBsaW5rZWRUaW1lO1xuICAgIGxldCAkZWwgPSAkdGFyZ2V0O1xuICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIGxldCAkb2Zmc2V0UGFyZW50ID0gJGVsO1xuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgIGxpbmtlZFRpbWUgPSBsaW5rZWQuY3VycmVudFRpbWU7XG4gICAgICBsaW5rZWQuc2VlaygwLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgaXNDb250YWluZXJTdGF0aWMgPSBnZXRUYXJnZXRWYWx1ZShjb250YWluZXIuZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnID8gc2V0VGFyZ2V0VmFsdWVzKGNvbnRhaW5lci5lbGVtZW50LCB7IHBvc2l0aW9uOiAncmVsYXRpdmUgJ30pIDogZmFsc2U7XG4gICAgd2hpbGUgKCRlbCAmJiAkZWwgIT09IGNvbnRhaW5lci5lbGVtZW50ICYmICRlbCAhPT0gZG9jLmJvZHkpIHtcbiAgICAgIGNvbnN0IGlzU3RpY2t5ID0gZ2V0VGFyZ2V0VmFsdWUoJGVsLCAncG9zaXRpb24nKSA9PT0gJ3N0aWNreScgP1xuICAgICAgICAgICAgICAgICAgICAgICBzZXRUYXJnZXRWYWx1ZXMoJGVsLCB7IHBvc2l0aW9uOiAnc3RhdGljJyB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgaWYgKCRlbCA9PT0gJG9mZnNldFBhcmVudCkge1xuICAgICAgICBvZmZzZXRYICs9ICRlbC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgIG9mZnNldFkgKz0gJGVsLm9mZnNldFRvcCB8fCAwO1xuICAgICAgICAkb2Zmc2V0UGFyZW50ID0gJGVsLm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgICRlbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRlbC5wYXJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChpc1N0aWNreSkge1xuICAgICAgICBpZiAoIXN0aWNreXMpIHN0aWNreXMgPSBbXTtcbiAgICAgICAgc3RpY2t5cy5wdXNoKGlzU3RpY2t5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ29udGFpbmVyU3RhdGljKSBpc0NvbnRhaW5lclN0YXRpYy5yZXZlcnQoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBpc0hvcmkgPyBvZmZzZXRYIDogb2Zmc2V0WTtcbiAgICBjb25zdCB0YXJnZXRTaXplID0gaXNIb3JpID8gJHRhcmdldC5vZmZzZXRXaWR0aCA6ICR0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBpc0hvcmkgPyBjb250YWluZXIud2lkdGggOiBjb250YWluZXIuaGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbFNpemUgPSBpc0hvcmkgPyBjb250YWluZXIuc2Nyb2xsV2lkdGggOiBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbFNpemUgLSBjb250YWluZXJTaXplO1xuICAgIGNvbnN0IGVudGVyID0gdGhpcy5lbnRlcjtcbiAgICBjb25zdCBsZWF2ZSA9IHRoaXMubGVhdmU7XG5cbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBlbnRlclRhcmdldCA9ICdzdGFydCc7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gKi9cbiAgICBsZXQgbGVhdmVUYXJnZXQgPSAnZW5kJztcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBlbnRlckNvbnRhaW5lciA9ICdlbmQnO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGxlYXZlQ29udGFpbmVyID0gJ3N0YXJ0JztcblxuICAgIGlmIChpc1N0cihlbnRlcikpIHtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGVudGVyKS5zcGxpdCgnICcpO1xuICAgICAgZW50ZXJDb250YWluZXIgPSBzcGxpdHRlZFswXTtcbiAgICAgIGVudGVyVGFyZ2V0ID0gc3BsaXR0ZWQubGVuZ3RoID4gMSA/IHNwbGl0dGVkWzFdIDogZW50ZXJUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc09iaihlbnRlcikpIHtcbiAgICAgIGNvbnN0IGUgPSAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFBhcmFtfSAqLyhlbnRlcik7XG4gICAgICBpZiAoIWlzVW5kKGUuY29udGFpbmVyKSkgZW50ZXJDb250YWluZXIgPSBlLmNvbnRhaW5lcjtcbiAgICAgIGlmICghaXNVbmQoZS50YXJnZXQpKSBlbnRlclRhcmdldCA9IGUudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoaXNOdW0oZW50ZXIpKSB7XG4gICAgICBlbnRlckNvbnRhaW5lciA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhlbnRlcik7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyKGxlYXZlKSkge1xuICAgICAgY29uc3Qgc3BsaXR0ZWQgPSAvKiogQHR5cGUge1N0cmluZ30gKi8obGVhdmUpLnNwbGl0KCcgJyk7XG4gICAgICBsZWF2ZUNvbnRhaW5lciA9IHNwbGl0dGVkWzBdO1xuICAgICAgbGVhdmVUYXJnZXQgPSBzcGxpdHRlZC5sZW5ndGggPiAxID8gc3BsaXR0ZWRbMV0gOiBsZWF2ZVRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKGxlYXZlKSkge1xuICAgICAgY29uc3QgdCA9IC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW19ICovKGxlYXZlKTtcbiAgICAgIGlmICghaXNVbmQodC5jb250YWluZXIpKSBsZWF2ZUNvbnRhaW5lciA9IHQuY29udGFpbmVyO1xuICAgICAgaWYgKCFpc1VuZCh0LnRhcmdldCkpIGxlYXZlVGFyZ2V0ID0gdC50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc051bShsZWF2ZSkpIHtcbiAgICAgIGxlYXZlQ29udGFpbmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKGxlYXZlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRFbnRlclRhcmdldCA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBlbnRlclRhcmdldCwgdGFyZ2V0U2l6ZSk7XG4gICAgY29uc3QgcGFyc2VkTGVhdmVUYXJnZXQgPSBwYXJzZUJvdW5kVmFsdWUoJHRhcmdldCwgbGVhdmVUYXJnZXQsIHRhcmdldFNpemUpO1xuICAgIGNvbnN0IHVuZGVyID0gKHBhcnNlZEVudGVyVGFyZ2V0ICsgb2Zmc2V0KSAtIGNvbnRhaW5lclNpemU7XG4gICAgY29uc3Qgb3ZlciA9IChwYXJzZWRMZWF2ZVRhcmdldCArIG9mZnNldCkgLSBtYXhTY3JvbGw7XG4gICAgY29uc3QgcGFyc2VkRW50ZXJDb250YWluZXIgPSBwYXJzZUJvdW5kVmFsdWUoJHRhcmdldCwgZW50ZXJDb250YWluZXIsIGNvbnRhaW5lclNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICBjb25zdCBwYXJzZWRMZWF2ZUNvbnRhaW5lciA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBsZWF2ZUNvbnRhaW5lciwgY29udGFpbmVyU2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gcGFyc2VkRW50ZXJUYXJnZXQgKyBvZmZzZXQgLSBwYXJzZWRFbnRlckNvbnRhaW5lcjtcbiAgICBjb25zdCBvZmZzZXRFbmQgPSBwYXJzZWRMZWF2ZVRhcmdldCArIG9mZnNldCAtIHBhcnNlZExlYXZlQ29udGFpbmVyO1xuICAgIGNvbnN0IHNjcm9sbERlbHRhID0gb2Zmc2V0RW5kIC0gb2Zmc2V0U3RhcnQ7XG4gICAgdGhpcy5vZmZzZXRzWzBdID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldHNbMV0gPSBvZmZzZXRZO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMub2Zmc2V0U3RhcnQgPSBvZmZzZXRTdGFydDtcbiAgICB0aGlzLm9mZnNldEVuZCA9IG9mZnNldEVuZDtcbiAgICB0aGlzLmRpc3RhbmNlID0gc2Nyb2xsRGVsdGEgPD0gMCA/IDAgOiBzY3JvbGxEZWx0YTtcbiAgICB0aGlzLnRocmVzaG9sZHMgPSBbZW50ZXJUYXJnZXQsIGxlYXZlVGFyZ2V0LCBlbnRlckNvbnRhaW5lciwgbGVhdmVDb250YWluZXJdO1xuICAgIHRoaXMuY29vcmRzID0gW3BhcnNlZEVudGVyVGFyZ2V0LCBwYXJzZWRMZWF2ZVRhcmdldCwgcGFyc2VkRW50ZXJDb250YWluZXIsIHBhcnNlZExlYXZlQ29udGFpbmVyXTtcbiAgICBpZiAoc3RpY2t5cykge1xuICAgICAgc3RpY2t5cy5mb3JFYWNoKHN0aWNreSA9PiBzdGlja3kucmV2ZXJ0KCkpO1xuICAgIH1cbiAgICBpZiAobGlua2VkKSB7XG4gICAgICBsaW5rZWQuc2VlayhsaW5rZWRUaW1lLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICB0aGlzLmRlYnVnKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsKCkge1xuICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgIGNvbnN0IHN5bmMgPSB0aGlzLnN5bmM7XG4gICAgY29uc3Qgc3luY0Vhc2UgPSB0aGlzLnN5bmNFYXNlO1xuICAgIGNvbnN0IHN5bmNTbW9vdGggPSB0aGlzLnN5bmNTbW9vdGg7XG4gICAgY29uc3Qgc2hvdWxkU2VlayA9IGxpbmtlZCAmJiAoc3luY0Vhc2UgfHwgc3luY1Ntb290aCk7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuc2Nyb2xsO1xuICAgIGNvbnN0IGlzQmVmb3JlID0gc2Nyb2xsIDw9IHRoaXMub2Zmc2V0U3RhcnQ7XG4gICAgY29uc3QgaXNBZnRlciA9IHNjcm9sbCA+PSB0aGlzLm9mZnNldEVuZDtcbiAgICBjb25zdCBpc0luVmlldyA9ICFpc0JlZm9yZSAmJiAhaXNBZnRlcjtcbiAgICBjb25zdCBpc09uVGhlRWRnZSA9IHNjcm9sbCA9PT0gdGhpcy5vZmZzZXRTdGFydCB8fCBzY3JvbGwgPT09IHRoaXMub2Zmc2V0RW5kO1xuICAgIGNvbnN0IGZvcmNlRW50ZXIgPSAhdGhpcy5oYXNFbnRlcmVkICYmIGlzT25UaGVFZGdlO1xuICAgIGNvbnN0ICRkZWJ1ZyA9IHRoaXMuX2RlYnVnICYmIHRoaXMuJGRlYnVnO1xuICAgIGxldCBoYXNVcGRhdGVkID0gZmFsc2U7XG4gICAgbGV0IHN5bmNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcCA9IHRoaXMucHJvZ3Jlc3M7XG5cbiAgICBpZiAoaXNCZWZvcmUgJiYgdGhpcy5iZWdhbikge1xuICAgICAgdGhpcy5iZWdhbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwID4gMCAmJiAhdGhpcy5iZWdhbikge1xuICAgICAgdGhpcy5iZWdhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNlZWspIHtcbiAgICAgIGNvbnN0IGxwID0gbGlua2VkLnByb2dyZXNzO1xuICAgICAgaWYgKHN5bmNTbW9vdGggJiYgaXNOdW0oc3luY1Ntb290aCkpIHtcbiAgICAgICAgaWYgKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzeW5jU21vb3RoKSA8IDEpIHtcbiAgICAgICAgICBjb25zdCBzdGVwID0gMC4wMDAxO1xuICAgICAgICAgIGNvbnN0IHNuYXAgPSBscCA8IHAgJiYgcCA9PT0gMSA/IHN0ZXAgOiBscCA+IHAgJiYgIXAgPyAtMWUtNCA6IDA7XG4gICAgICAgICAgcCA9IHJvdW5kKGxlcnAobHAsIHAsIGludGVycG9sYXRlKC4wMSwgLjIsIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzeW5jU21vb3RoKSksIGZhbHNlKSArIHNuYXAsIDYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN5bmNFYXNlKSB7XG4gICAgICAgIHAgPSBzeW5jRWFzZShwKTtcbiAgICAgIH1cbiAgICAgIGhhc1VwZGF0ZWQgPSBwICE9PSB0aGlzLnByZXZQcm9ncmVzcztcbiAgICAgIHN5bmNDb21wbGV0ZWQgPSBscCA9PT0gMTtcbiAgICAgIGlmIChoYXNVcGRhdGVkICYmICFzeW5jQ29tcGxldGVkICYmIChzeW5jU21vb3RoICYmIGxwKSkge1xuICAgICAgICBjb250YWluZXIud2FrZVRpY2tlci5yZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRkZWJ1Zykge1xuICAgICAgY29uc3Qgc3RpY2t5ID0gaXNIb3JpID8gY29udGFpbmVyLnNjcm9sbFkgOiBjb250YWluZXIuc2Nyb2xsWDtcbiAgICAgICRkZWJ1Zy5zdHlsZVtpc0hvcmkgPyAndG9wJyA6ICdsZWZ0J10gPSBzdGlja3kgKyAxMCArICdweCc7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBlbnRlciBjYWxsYmFja3MgaWYgYWxyZWFkeSBpbiB2aWV3IG9yIHdoZW4gZW50ZXJpbmcgdGhlIHZpZXdcbiAgICBpZiAoKGlzSW5WaWV3ICYmICF0aGlzLmlzSW5WaWV3KSB8fCAoZm9yY2VFbnRlciAmJiAhdGhpcy5mb3JjZUVudGVyICYmICF0aGlzLmhhc0VudGVyZWQpKSB7XG4gICAgICBpZiAoaXNJblZpZXcpIHRoaXMuaXNJblZpZXcgPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLmZvcmNlRW50ZXIgfHwgIXRoaXMuaGFzRW50ZXJlZCkge1xuICAgICAgICBpZiAoJGRlYnVnICYmIGlzSW5WaWV3KSAkZGVidWcuc3R5bGUuekluZGV4ID0gYCR7dGhpcy5jb250YWluZXIuekluZGV4Kyt9YDtcbiAgICAgICAgdGhpcy5vblN5bmNFbnRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVudGVyKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5iYWNrd2FyZCkge1xuICAgICAgICAgIHRoaXMub25TeW5jRW50ZXJCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9uRW50ZXJCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uU3luY0VudGVyRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9uRW50ZXJGb3J3YXJkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRW50ZXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChmb3JjZUVudGVyKSB0aGlzLmZvcmNlRW50ZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0luVmlldykge1xuICAgICAgICB0aGlzLmZvcmNlRW50ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNJblZpZXcgfHwgIWlzSW5WaWV3ICYmIHRoaXMuaXNJblZpZXcpIHtcbiAgICAgIGhhc1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNVcGRhdGVkKSB7XG4gICAgICBpZiAoc2hvdWxkU2VlaykgbGlua2VkLnNlZWsobGlua2VkLmR1cmF0aW9uICogcCk7XG4gICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIGlmICghaXNJblZpZXcgJiYgdGhpcy5pc0luVmlldykge1xuICAgICAgdGhpcy5pc0luVmlldyA9IGZhbHNlO1xuICAgICAgdGhpcy5vblN5bmNMZWF2ZSh0aGlzKTtcbiAgICAgIHRoaXMub25MZWF2ZSh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmJhY2t3YXJkKSB7XG4gICAgICAgIHRoaXMub25TeW5jTGVhdmVCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxlYXZlQmFja3dhcmQodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uU3luY0xlYXZlRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxlYXZlRm9yd2FyZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW5jICYmICFzeW5jU21vb3RoKSB7XG4gICAgICAgIHN5bmNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwID49IDEgJiYgdGhpcy5iZWdhbiAmJiAhdGhpcy5jb21wbGV0ZWQgJiYgKHN5bmMgJiYgc3luY0NvbXBsZXRlZCB8fCAhc3luYykpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHRoaXMub25TeW5jQ29tcGxldGUodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICBpZiAoKCF0aGlzLnJlcGVhdCAmJiAhbGlua2VkKSB8fCAoIXRoaXMucmVwZWF0ICYmIGxpbmtlZCAmJiBsaW5rZWQuY29tcGxldGVkKSkge1xuICAgICAgICB0aGlzLnJldmVydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwIDwgMSAmJiB0aGlzLmNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZQcm9ncmVzcyA9IHA7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgaWYgKHRoaXMucmV2ZXJ0ZWQpIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICByZW1vdmVDaGlsZChjb250YWluZXIsIHRoaXMpO1xuICAgIGlmICghY29udGFpbmVyLl9oZWFkKSB7XG4gICAgICBjb250YWluZXIucmV2ZXJ0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5yZW1vdmVEZWJ1ZygpO1xuICAgIH1cbiAgICB0aGlzLnJldmVydGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtTY3JvbGxPYnNlcnZlclBhcmFtc30gW3BhcmFtZXRlcnM9e31dXG4gKiBAcmV0dXJuIHtTY3JvbGxPYnNlcnZlcn1cbiAqL1xuY29uc3Qgb25TY3JvbGwgPSAocGFyYW1ldGVycyA9IHt9KSA9PiBuZXcgU2Nyb2xsT2JzZXJ2ZXIocGFyYW1ldGVycyk7XG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYgIHtPYmplY3R9IFN0YWdnZXJQYXJhbWV0ZXJzXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtzdGFydF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCdmaXJzdCd8J2NlbnRlcid8J2xhc3QnfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JldmVyc2VkXVxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gW2dyaWRdXG4gKiBAcHJvcGVydHkgeygneCd8J3knKX0gW2F4aXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN0YWdnZXJGdW5jdGlvblxuICogQHBhcmFtIHtUYXJnZXR9IFt0YXJnZXRdXG4gKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGhdXG4gKiBAcGFyYW0ge1RpbWVsaW5lfSBbdGxdXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICovXG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ3xbTnVtYmVyfFN0cmluZyxOdW1iZXJ8U3RyaW5nXX0gdmFsXG4gKiBAcGFyYW0gIHtTdGFnZ2VyUGFyYW1ldGVyc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb259XG4gKi9cbmNvbnN0IHN0YWdnZXIgPSAodmFsLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGxldCBtYXhWYWx1ZSA9IDA7XG4gIGNvbnN0IGZyb20gPSBwYXJhbXMuZnJvbTtcbiAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQ7XG4gIGNvbnN0IGVhc2UgPSBwYXJhbXMuZWFzZTtcbiAgY29uc3QgaGFzRWFzaW5nID0gIWlzVW5kKGVhc2UpO1xuICBjb25zdCBoYXNTcHJpbmcgPSBoYXNFYXNpbmcgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgY29uc3Qgc3RhZ2dlckVhc2UgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSA6IGhhc0Vhc2luZyA/IHBhcnNlRWFzaW5ncyhlYXNlKSA6IG51bGw7XG4gIGNvbnN0IGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgY29uc3QgYXhpcyA9IHBhcmFtcy5heGlzO1xuICBjb25zdCBmcm9tRmlyc3QgPSBpc1VuZChmcm9tKSB8fCBmcm9tID09PSAwIHx8IGZyb20gPT09ICdmaXJzdCc7XG4gIGNvbnN0IGZyb21DZW50ZXIgPSBmcm9tID09PSAnY2VudGVyJztcbiAgY29uc3QgZnJvbUxhc3QgPSBmcm9tID09PSAnbGFzdCc7XG4gIGNvbnN0IGlzUmFuZ2UgPSBpc0Fycih2YWwpO1xuICBjb25zdCB2YWwxID0gaXNSYW5nZSA/IHBhcnNlTnVtYmVyKHZhbFswXSkgOiBwYXJzZU51bWJlcih2YWwpO1xuICBjb25zdCB2YWwyID0gaXNSYW5nZSA/IHBhcnNlTnVtYmVyKHZhbFsxXSkgOiAwO1xuICBjb25zdCB1bml0TWF0Y2ggPSB1bml0c0V4ZWNSZ3guZXhlYygoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgKyBlbXB0eVN0cmluZyk7XG4gIGNvbnN0IHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgbGV0IGZyb21JbmRleCA9IGZyb21GaXJzdCA/IDAgOiBpc051bShmcm9tKSA/IGZyb20gOiAwO1xuICByZXR1cm4gKF8sIGksIHQsIHRsKSA9PiB7XG4gICAgaWYgKGZyb21DZW50ZXIpIGZyb21JbmRleCA9ICh0IC0gMSkgLyAyO1xuICAgIGlmIChmcm9tTGFzdCkgZnJvbUluZGV4ID0gdCAtIDE7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChhYnMoZnJvbUluZGV4IC0gaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4ICUgZ3JpZFswXSA6IChncmlkWzBdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IGZyb21ZID0gIWZyb21DZW50ZXIgPyBmbG9vcihmcm9tSW5kZXggLyBncmlkWzBdKSA6IChncmlkWzFdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IHRvWCA9IGluZGV4ICUgZ3JpZFswXTtcbiAgICAgICAgICBjb25zdCB0b1kgPSBmbG9vcihpbmRleCAvIGdyaWRbMF0pO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IGZyb21ZIC0gdG9ZO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB2YWx1ZSA9IC1kaXN0YW5jZVg7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd5JykgdmFsdWUgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IG1heCguLi52YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWdnZXJFYXNlKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiBzdGFnZ2VyRWFzZSh2YWwgLyBtYXhWYWx1ZSkgKiBtYXhWYWx1ZSk7XG4gICAgICBpZiAocmV2ZXJzZWQpIHZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+IGF4aXMgPyAodmFsIDwgMCkgPyB2YWwgKiAtMSA6IC12YWwgOiBhYnMobWF4VmFsdWUgLSB2YWwpKTtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIGNvbnN0IG9mZnNldCA9IHRsID8gcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRsLCBpc1VuZChwYXJhbXMuc3RhcnQpID8gdGwuaXRlcmF0aW9uRHVyYXRpb24gOiBzdGFydCkgOiAvKiogQHR5cGUge051bWJlcn0gKi8oc3RhcnQpO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfE51bWJlcn0gKi9cbiAgICBsZXQgb3V0cHV0ID0gb2Zmc2V0ICsgKChzcGFjaW5nICogcm91bmQodmFsdWVzW2ldLCAyKSkgfHwgMCk7XG4gICAgaWYgKHBhcmFtcy5tb2RpZmllcikgb3V0cHV0ID0gcGFyYW1zLm1vZGlmaWVyKG91dHB1dCk7XG4gICAgaWYgKHVuaXRNYXRjaCkgb3V0cHV0ID0gYCR7b3V0cHV0fSR7dW5pdE1hdGNoWzJdfWA7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgQW5pbWF0YWJsZSwgRHJhZ2dhYmxlLCBKU0FuaW1hdGlvbiwgU2NvcGUsIFNjcm9sbE9ic2VydmVyLCBTcHJpbmcsIFRpbWVsaW5lLCBUaW1lciwgV0FBUElBbmltYXRpb24sIGFuaW1hdGUsIGNyZWF0ZUFuaW1hdGFibGUsIGNyZWF0ZURyYWdnYWJsZSwgY3JlYXRlU2NvcGUsIGNyZWF0ZVNwcmluZywgY3JlYXRlVGltZWxpbmUsIGNyZWF0ZVRpbWVyLCBlYXNlcywgZW5naW5lLCBvblNjcm9sbCwgc2Nyb2xsQ29udGFpbmVycywgc3RhZ2dlciwgc3ZnLCB1dGlscywgd2FhcGkgfTtcbiJdLCJuYW1lcyI6WyJpc0Jyb3dzZXIiLCJ3aW4iLCJ3aW5kb3ciLCJkb2MiLCJkb2N1bWVudCIsInR3ZWVuVHlwZXMiLCJPQkpFQ1QiLCJBVFRSSUJVVEUiLCJDU1MiLCJUUkFOU0ZPUk0iLCJDU1NfVkFSIiwidmFsdWVUeXBlcyIsIk5VTUJFUiIsIlVOSVQiLCJDT0xPUiIsIkNPTVBMRVgiLCJ0aWNrTW9kZXMiLCJOT05FIiwiQVVUTyIsIkZPUkNFIiwiY29tcG9zaXRpb25UeXBlcyIsInJlcGxhY2UiLCJub25lIiwiYmxlbmQiLCJpc1JlZ2lzdGVyZWRUYXJnZXRTeW1ib2wiLCJTeW1ib2wiLCJpc0RvbVN5bWJvbCIsImlzU3ZnU3ltYm9sIiwidHJhbnNmb3Jtc1N5bWJvbCIsIm1vcnBoUG9pbnRzU3ltYm9sIiwicHJveHlUYXJnZXRTeW1ib2wiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiSyIsIm1heEZwcyIsImVtcHR5U3RyaW5nIiwic2hvcnRUcmFuc2Zvcm1zIiwiTWFwIiwic2V0IiwidmFsaWRUcmFuc2Zvcm1zIiwidHJhbnNmb3Jtc0ZyYWdtZW50U3RyaW5ncyIsInJlZHVjZSIsImEiLCJ2Iiwibm9vcCIsImhleFRlc3RSZ3giLCJyZ2JFeGVjUmd4IiwicmdiYUV4ZWNSZ3giLCJoc2xFeGVjUmd4IiwiaHNsYUV4ZWNSZ3giLCJkaWdpdFdpdGhFeHBvbmVudFJneCIsInVuaXRzRXhlY1JneCIsImxvd2VyQ2FzZVJneCIsInRyYW5zZm9ybXNFeGVjUmd4IiwicmVsYXRpdmVWYWx1ZXNFeGVjUmd4IiwiZGVmYXVsdHMiLCJpZCIsImtleWZyYW1lcyIsInBsYXliYWNrRWFzZSIsInBsYXliYWNrUmF0ZSIsImZyYW1lUmF0ZSIsImxvb3AiLCJyZXZlcnNlZCIsImFsdGVybmF0ZSIsImF1dG9wbGF5IiwiZHVyYXRpb24iLCJkZWxheSIsImxvb3BEZWxheSIsImVhc2UiLCJjb21wb3NpdGlvbiIsIm1vZGlmaWVyIiwib25CZWdpbiIsIm9uQmVmb3JlVXBkYXRlIiwib25VcGRhdGUiLCJvbkxvb3AiLCJvblBhdXNlIiwib25Db21wbGV0ZSIsIm9uUmVuZGVyIiwiZ2xvYmFscyIsInJvb3QiLCJzY29wZSIsInByZWNpc2lvbiIsInRpbWVTY2FsZSIsInRpY2tUaHJlc2hvbGQiLCJnbG9iYWxWZXJzaW9ucyIsInZlcnNpb24iLCJlbmdpbmUiLCJBbmltZUpTIiwicHVzaCIsInRvTG93ZXJDYXNlIiwic3RyIiwic3RyaW5nU3RhcnRzV2l0aCIsInN1YiIsImluZGV4T2YiLCJub3ciLCJEYXRlIiwiaXNBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJpc09iaiIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNOdW0iLCJpc05hTiIsImlzU3RyIiwiaXNGbmMiLCJpc1VuZCIsImlzTmlsIiwiaXNTdmciLCJTVkdFbGVtZW50IiwiaXNIZXgiLCJ0ZXN0IiwiaXNSZ2IiLCJpc0hzbCIsImlzQ29sIiwiaXNLZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnNlTnVtYmVyIiwicGFyc2VGbG9hdCIsInBvdyIsIk1hdGgiLCJzcXJ0Iiwic2luIiwiY29zIiwiYWJzIiwiZXhwIiwiY2VpbCIsImZsb29yIiwiYXNpbiIsIm1heCIsImF0YW4yIiwiUEkiLCJfcm91bmQiLCJyb3VuZCIsImNsYW1wIiwibWluIiwicG93Q2FjaGUiLCJkZWNpbWFsTGVuZ3RoIiwicCIsInNuYXAiLCJpbmNyZW1lbnQiLCJjbG9zZXN0IiwiY3YiLCJpbnRlcnBvbGF0ZSIsInN0YXJ0IiwiZW5kIiwicHJvZ3Jlc3MiLCJjbGFtcEluZmluaXR5IiwiSW5maW5pdHkiLCJub3JtYWxpemVUaW1lIiwiY2xvbmVBcnJheSIsIm1lcmdlT2JqZWN0cyIsIm8xIiwibzIiLCJtZXJnZWQiLCJvMXAiLCJmb3JFYWNoQ2hpbGRyZW4iLCJwYXJlbnQiLCJjYWxsYmFjayIsInJldmVyc2UiLCJwcmV2UHJvcCIsIm5leHRQcm9wIiwibmV4dCIsIl9oZWFkIiwiYWRqdXN0ZWROZXh0UHJvcCIsIl90YWlsIiwiY3VycmVudE5leHQiLCJyZW1vdmVDaGlsZCIsImNoaWxkIiwicHJldiIsImFkZENoaWxkIiwic29ydE1ldGhvZCIsIkNsb2NrIiwiaW5pdFRpbWUiLCJkZWx0YVRpbWUiLCJfY3VycmVudFRpbWUiLCJfZWxhcHNlZFRpbWUiLCJfc3RhcnRUaW1lIiwiX2xhc3RUaW1lIiwiX3NjaGVkdWxlZFRpbWUiLCJfZnJhbWVEdXJhdGlvbiIsIl9mcHMiLCJfc3BlZWQiLCJfaGFzQ2hpbGRyZW4iLCJmcHMiLCJwcmV2aW91c0ZyYW1lRHVyYXRpb24iLCJmciIsImZyYW1lRHVyYXRpb24iLCJzcGVlZCIsInBiciIsInJlcXVlc3RUaWNrIiwidGltZSIsInNjaGVkdWxlZFRpbWUiLCJlbGFwc2VkVGltZSIsImZyYW1lRGVsdGEiLCJjb21wdXRlRGVsdGFUaW1lIiwiZGVsdGEiLCJyZW5kZXIiLCJ0aWNrYWJsZSIsIm11dGVDYWxsYmFja3MiLCJpbnRlcm5hbFJlbmRlciIsInRpY2tNb2RlIiwiY29tcGxldGVkIiwiaXRlcmF0aW9uRHVyYXRpb24iLCJpdGVyYXRpb25Db3VudCIsIl9jdXJyZW50SXRlcmF0aW9uIiwiX2xvb3BEZWxheSIsIl9yZXZlcnNlZCIsIl9hbHRlcm5hdGUiLCJ0aWNrYWJsZURlbGF5IiwiX2RlbGF5IiwidGlja2FibGVQcmV2QWJzb2x1dGVUaW1lIiwidGlja2FibGVFbmRUaW1lIiwidGlja2FibGVBYnNvbHV0ZVRpbWUiLCJ0aWNrYWJsZVByZXZUaW1lIiwidGlja2FibGVDdXJyZW50VGltZSIsImlzQ3VycmVudFRpbWVBYm92ZVplcm8iLCJpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24iLCJpc1NldHRlciIsImZvcmNlZFRpY2siLCJpc09kZCIsIml0ZXJhdGlvbkVsYXBzZWRUaW1lIiwiaGFzUmVuZGVyZWQiLCJjdXJyZW50SXRlcmF0aW9uIiwiaXNSZXZlcnNlZCIsIl9lYXNlIiwiaXRlcmF0aW9uVGltZSIsImlzUnVubmluZ0JhY2t3YXJkcyIsImJhY2t3YXJkcyIsIl9pdGVyYXRpb25UaW1lIiwiYmVnYW4iLCJmb3JjZWRSZW5kZXIiLCJhYnNvbHV0ZVRpbWUiLCJfb2Zmc2V0IiwidHdlZW4iLCJ0d2VlblRhcmdldCIsInR3ZWVuU3R5bGUiLCJ0d2VlblRhcmdldFRyYW5zZm9ybXMiLCJ0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzIiwidHdlZW5UcmFuc2Zvcm1zTmVlZFVwZGF0ZSIsInR3ZWVuQ29tcG9zaXRpb24iLCJfY29tcG9zaXRpb24iLCJ0d2VlbkN1cnJlbnRUaW1lIiwidHdlZW5DaGFuZ2VEdXJhdGlvbiIsIl9jaGFuZ2VEdXJhdGlvbiIsInR3ZWVuQWJzRW5kVGltZSIsIl9hYnNvbHV0ZVN0YXJ0VGltZSIsInR3ZWVuTmV4dFJlcCIsIl9uZXh0UmVwIiwidHdlZW5QcmV2UmVwIiwiX3ByZXZSZXAiLCJ0d2Vlbkhhc0NvbXBvc2l0aW9uIiwiX2lzT3ZlcnJpZGRlbiIsIl9pc092ZXJsYXBwZWQiLCJ0d2Vlbk5ld1RpbWUiLCJ0d2VlblByb2dyZXNzIiwiX3VwZGF0ZUR1cmF0aW9uIiwidHdlZW5Nb2RpZmllciIsIl9tb2RpZmllciIsInR3ZWVuVmFsdWVUeXBlIiwiX3ZhbHVlVHlwZSIsInR3ZWVuVHlwZSIsIl90d2VlblR5cGUiLCJ0d2VlbklzT2JqZWN0IiwidHdlZW5Jc051bWJlciIsInR3ZWVuUHJlY2lzaW9uIiwidmFsdWUiLCJudW1iZXIiLCJfZnJvbU51bWJlciIsIl90b051bWJlciIsIl91bml0IiwiZm4iLCJfZnJvbU51bWJlcnMiLCJ0biIsIl90b051bWJlcnMiLCJyIiwiZyIsImIiLCJucyIsIl9udW1iZXJzIiwiX3N0cmluZ3MiLCJqIiwibCIsImxlbmd0aCIsIm4iLCJzIiwiX251bWJlciIsInR3ZWVuUHJvcGVydHkiLCJwcm9wZXJ0eSIsInRhcmdldCIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJfdmFsdWUiLCJfcmVuZGVyVHJhbnNmb3JtcyIsImtleSIsInRyYW5zZm9ybSIsIl9uZXh0IiwicGF1c2VkIiwiX3Jlc29sdmUiLCJ0aWNrIiwidGwiLCJ0bElzUnVubmluZ0JhY2t3YXJkcyIsInRsQ2hpbGRyZW5UaW1lIiwidGxDaWxkcmVuVGlja1RpbWUiLCJ0bENoaWxkcmVuSGFzUmVuZGVyZWQiLCJ0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCIsInRsSXRlcmF0aW9uRHVyYXRpb24iLCJjaGlsZER1cmF0aW9uIiwiY2hpbGRTdGFydFRpbWUiLCJjaGlsZEVuZFRpbWUiLCJjaGlsZFRpbWUiLCJjaGlsZFRpY2tNb2RlIiwiYWRkaXRpdmUiLCJhbmltYXRpb24iLCJ1cGRhdGUiLCJhZGRBZGRpdGl2ZUFuaW1hdGlvbiIsImxvb2t1cHMiLCJmb3JFYWNoIiwicHJvcGVydHlBbmltYXRpb24iLCJwcm9wZXJ0eU5hbWUiLCJ0d2VlbnMiLCJsb29rdXBUd2VlbiIsInZhbHVlVHlwZSIsImFkZGl0aXZlVmFsdWVzIiwiYWRkaXRpdmVWYWx1ZSIsImkiLCJfcHJldkFkZCIsImVuZ2luZVRpY2tNZXRob2QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRJbW1lZGlhdGUiLCJlbmdpbmVDYW5jZWxNZXRob2QiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFySW1tZWRpYXRlIiwiRW5naW5lIiwidXNlRGVmYXVsdE1haW5Mb29wIiwicGF1c2VPbkRvY3VtZW50SGlkZGVuIiwiaGlkZGVuIiwicmVxSWQiLCJlbmdpbmVTcGVlZCIsImVuZ2luZUZwcyIsImFjdGl2ZVRpY2thYmxlIiwibmV4dFRpY2thYmxlIiwiX3J1bm5pbmciLCJfY2FuY2VsbGVkIiwiY2FuY2VsIiwid2FrZSIsInRpY2tFbmdpbmUiLCJwYXVzZSIsImtpbGxFbmdpbmUiLCJyZXN1bWUiLCJyZXNldFRpbWUiLCJ0aW1lVW5pdCIsInVuaXQiLCJzZWNvbmRzU2NhbGUiLCJpc1NlY29uZCIsIm5ld1NjYWxlIiwic2NhbGVGYWN0b3IiLCJhZGRFdmVudExpc3RlbmVyIiwicGFyc2VJbmxpbmVUcmFuc2Zvcm1zIiwicHJvcE5hbWUiLCJhbmltYXRpb25JbmxpbmVTdHlsZXMiLCJpbmxpbmVUcmFuc2Zvcm1zIiwiaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUiLCJjYWNoZWRUcmFuc2Zvcm1zIiwidCIsImV4ZWMiLCJpbmxpbmVQcm9wZXJ0eU5hbWUiLCJpbmxpbmVQcm9wZXJ0eVZhbHVlIiwic2xpY2UiLCJnZXROb2RlTGlzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJOb2RlTGlzdCIsIkhUTUxDb2xsZWN0aW9uIiwicGFyc2VUYXJnZXRzIiwidGFyZ2V0cyIsImZsYXR0ZW5lZCIsImZsYXQiLCJwYXJzZWQiLCJpdGVtIiwibm9kZUxpc3QiLCJqbCIsInN1Ykl0ZW0iLCJpc0R1cGxpY2F0ZSIsImsiLCJrbCIsImZyb20iLCJyZWdpc3RlclRhcmdldHMiLCJwYXJzZWRUYXJnZXRzQXJyYXkiLCJwYXJzZWRUYXJnZXRzTGVuZ3RoIiwiaXNTdmdUeXBlIiwiaXNEb20iLCJub2RlVHlwZSIsImdldFBhdGgiLCJwYXRoIiwicGFyc2VkVGFyZ2V0cyIsIiRwYXJzZWRTdmciLCJtb3JwaFRvIiwicGF0aDIiLCIkcGF0aDEiLCIkcGF0aDIiLCJpc1BhdGgiLCJ0YWdOYW1lIiwic2VwYXJhdG9yIiwicHJldmlvdXNQb2ludHMiLCJ2MSIsInYyIiwiZ2V0QXR0cmlidXRlIiwibGVuZ3RoMSIsImdldFRvdGFsTGVuZ3RoIiwibGVuZ3RoMiIsIm1heFBvaW50cyIsInBvaW50T25QYXRoMSIsImdldFBvaW50QXRMZW5ndGgiLCJwb2ludE9uUGF0aDIiLCJwcmVmaXgiLCJ4IiwieSIsImdldFNjYWxlRmFjdG9yIiwiJGVsIiwiZ2V0Q1RNIiwiY3RtIiwic2NhbGVYIiwic2NhbGVZIiwiYyIsImQiLCJjcmVhdGVEcmF3YWJsZVByb3h5IiwicGF0aExlbmd0aCIsImNvbXB1dGVkU3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN0cm9rZUxpbmVDYXAiLCJzdHJva2VMaW5lY2FwIiwiJHNjYWxsZWQiLCJ2ZWN0b3JFZmZlY3QiLCJjdXJyZW50Q2FwIiwicHJveHkiLCJQcm94eSIsImdldCIsImFyZ3MiLCJ2YWx1ZXMiLCJzcGxpdCIsIm9zIiwiZDEiLCJkMiIsIm5ld0NhcCIsIlJlZmxlY3QiLCJhcHBseSIsImNyZWF0ZURyYXdhYmxlIiwic2VsZWN0b3IiLCJlbHMiLCJtYXAiLCJnZXRQYXRoUG9pbnQiLCIkcGF0aCIsImxvb2t1cCIsImdldFBhdGhQcm9nZXNzIiwicGF0aFByb3BlcnR5IiwidG90YWxMZW5ndGgiLCJpblN2ZyIsInRvIiwicDAiLCJwMSIsImUiLCJmIiwiY3JlYXRlTW90aW9uUGF0aCIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwicm90YXRlIiwiY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzIiwiaXNWYWxpZFNWR0F0dHJpYnV0ZSIsImVsIiwiaW5jbHVkZXMiLCJlbFBhcmVudE5vZGUiLCJwYXJlbnROb2RlIiwic3ZnIiwicmdiVG9SZ2JhIiwicmdiVmFsdWUiLCJyZ2JhIiwiaGV4VG9SZ2JhIiwiaGV4VmFsdWUiLCJoZXhMZW5ndGgiLCJpc1Nob3J0IiwidG9GaXhlZCIsImh1ZTJyZ2IiLCJxIiwiaHNsVG9SZ2JhIiwiaHNsVmFsdWUiLCJoc2xhIiwiaCIsImNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5IiwiY29sb3JTdHJpbmciLCJzZXRWYWx1ZSIsInRhcmdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0RnVuY3Rpb25WYWx1ZSIsImluZGV4IiwidG90YWwiLCJzdG9yZSIsImZ1bmMiLCJjb21wdXRlZCIsImdldFR3ZWVuVHlwZSIsInByb3AiLCJnZXRDU1NWYWx1ZSIsImlubGluZVN0eWxlcyIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSIsInR5cGUiLCJ0cmltU3RhcnQiLCJnZXRSZWxhdGl2ZVZhbHVlIiwib3BlcmF0b3IiLCJjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QiLCJ1IiwibyIsImRlY29tcG9zZVJhd1ZhbHVlIiwicmF3VmFsdWUiLCJ0YXJnZXRPYmplY3QiLCJudW0iLCJ1bml0TWF0Y2giLCJtYXRjaGVkTnVtYmVycyIsIm1hdGNoIiwiTnVtYmVyIiwiZGVjb21wb3NlVHdlZW5WYWx1ZSIsImRlY29tcG9zZWRPcmlnaW5hbFZhbHVlIiwiX3JlcCIsIldlYWtNYXAiLCJfYWRkIiwiZ2V0VHdlZW5TaWJsaW5ncyIsImxvb2t1cE1hcCIsInRhcmdldExvb2t1cCIsImFkZFR3ZWVuU29ydE1ldGhvZCIsIm92ZXJyaWRlVHdlZW4iLCJjb21wb3NlVHdlZW4iLCJzaWJsaW5ncyIsInR3ZWVuQ29tcG9zaXRpb25UeXBlIiwidHdlZW5BYnNTdGFydFRpbWUiLCJwcmV2U2libGluZyIsInByZXZQYXJlbnQiLCJwcmV2QWJzRW5kVGltZSIsInByZXZQcmV2U2libGluZyIsImFic29sdXRlVXBkYXRlU3RhcnRUaW1lIiwicHJldkNoYW5nZVN0YXJ0VGltZSIsInByZXZUTE9mZnNldCIsInBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiIsInByZXZQYXJlbnRUTCIsInBhdXNlUHJldlBhcmVudFRMIiwiYWRkaXRpdmVUd2VlblNpYmxpbmdzIiwiYWRkaXRpdmVBbmltYXRpb24iLCJfcHJldiIsInRvTnVtYmVyIiwidG9OdW1iZXJzIiwicmVtb3ZlVHdlZW5TbGlibGluZ3MiLCJyZXBsYWNlVHdlZW5zTG9va3VwIiwicmVwbGFjZVRhcmdldFByb3BzIiwidHdlZW5SZXBsYWNlU2libGluZ3MiLCJhZGRUd2VlbnNMb29rdXAiLCJhZGRUYXJnZXRQcm9wcyIsInNob3VsZENsZWFuIiwiZGVsZXRlIiwicmVzZXRUaW1lclByb3BlcnRpZXMiLCJ0aW1lciIsInJldml2ZVRpbWVyIiwidGltZXJJZCIsIlRpbWVyIiwicGFyYW1ldGVycyIsInBhcmVudFBvc2l0aW9uIiwicmV2ZXJ0aWJsZXMiLCJ0aW1lckluaXRUaW1lIiwidGltZXJEZWZhdWx0cyIsInRpbWVyRGVsYXkiLCJ0aW1lckR1cmF0aW9uIiwidGltZXJMb29wIiwidGltZXJMb29wRGVsYXkiLCJ0aW1lckl0ZXJhdGlvbkNvdW50Iiwib2Zmc2V0UG9zaXRpb24iLCJzdGFydFRpbWUiLCJfYXV0b3BsYXkiLCJfcmV2ZXJzZSIsImNhbmNlbGxlZCIsInJlc2V0IiwicGxheSIsImN1cnJlbnRUaW1lIiwic2VlayIsIml0ZXJhdGlvbkN1cnJlbnRUaW1lIiwiaXRlcmF0aW9uUHJvZ3Jlc3MiLCJpbml0IiwibGlua2VkIiwibGluayIsInJlc3RhcnQiLCJpc1BhdXNlZCIsImNvdW50IiwiaXRlcmF0aW9ucyIsInN0cmV0Y2giLCJuZXdEdXJhdGlvbiIsImN1cnJlbnREdXJhdGlvbiIsIm5vcm1saXplZER1cmF0aW9uIiwicmV2ZXJ0IiwiYXAiLCJjb21wbGV0ZSIsInRoZW4iLCJvblJlc29sdmUiLCJQcm9taXNlIiwiY3JlYXRlVGltZXIiLCJjYWxjQmV6aWVyIiwiYVQiLCJhQTEiLCJhQTIiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsIm1YMSIsIm1YMiIsImFBIiwiYUIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiY3ViaWNCZXppZXIiLCJtWTEiLCJtWTIiLCJzdGVwcyIsImZyb21TdGFydCIsInJvdW5kTWV0aG9kIiwibGluZWFyIiwiYXJnc0xlbmd0aCIsInRvdGFsUG9pbnRzIiwiZmlyc3RBcmciLCJsYXN0QXJnIiwieFBvaW50cyIsInlQb2ludHMiLCJhcmciLCJzcGxpdFZhbHVlIiwidHJpbSIsInBlcmNlbnQiLCJlYXNlTGluZWFyIiwicHJldlgiLCJwcmV2WSIsImlycmVndWxhciIsInJhbmRvbW5lc3MiLCJwcmV2aW91c1ZhbHVlIiwic3BhY2luZyIsInNlZ21lbnRFbmQiLCJyYW5kb21WYXJpYXRpb24iLCJyYW5kb20iLCJyYW5kb21WYWx1ZSIsImhhbGZQSSIsImRvdWJsZVBJIiwiZWFzZUluUG93ZXIiLCJlYXNlSW5GdW5jdGlvbnMiLCJRdWFkIiwiQ3ViaWMiLCJRdWFydCIsIlF1aW50IiwiU2luZSIsIkNpcmMiLCJFeHBvIiwiQm91bmNlIiwicG93MiIsIkJhY2siLCJvdmVyc2hvb3QiLCJFbGFzdGljIiwiYW1wbGl0dWRlIiwicGVyaW9kIiwiZWFzZVR5cGVzIiwiaW4iLCJlYXNlSW4iLCJvdXQiLCJpbk91dCIsIm91dEluIiwicGFyc2VFYXNlU3RyaW5nIiwic3RyaW5nIiwiZWFzZXNGdW5jdGlvbnMiLCJlYXNlc0xvb2t1cHMiLCJoYXNQYXJhbXMiLCJwYXJzZWRGbiIsImVhc2VzIiwibGlzdCIsIm5hbWUiLCJlYXNlVHlwZSIsIkpTRWFzZXNMb29rdXBzIiwicGFyc2VFYXNpbmdzIiwicHJvcGVydHlOYW1lc0NhY2hlIiwic2FuaXRpemVQcm9wZXJ0eU5hbWUiLCJjYWNoZWRQcm9wZXJ0eU5hbWUiLCJsb3dlckNhc2VOYW1lIiwiYW5nbGVVbml0c01hcCIsImNvbnZlcnRlZFZhbHVlc0NhY2hlIiwiY29udmVydFZhbHVlVW5pdCIsImRlY29tcG9zZWRWYWx1ZSIsImZvcmNlIiwiY3VycmVudFVuaXQiLCJjdXJyZW50TnVtYmVyIiwiY2FjaGVkS2V5IiwiY2FjaGVkIiwiY29udmVydGVkVmFsdWUiLCJiYXNlbGluZSIsInRlbXBFbCIsImNsb25lTm9kZSIsInBhcmVudEVsIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZWxTdHlsZSIsIndpZHRoIiwiY3VycmVudFVuaXRXaWR0aCIsIm9mZnNldFdpZHRoIiwibmV3VW5pdFdpZHRoIiwiZmFjdG9yIiwiY2xlYW5JbmxpbmVTdHlsZXMiLCJyZW5kZXJhYmxlIiwidGFyZ2V0U3R5bGUiLCJvcmlnaW5hbElubGluZWRWYWx1ZSIsIl9pbmxpbmVTdHlsZXMiLCJrZXlzIiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJmcm9tVGFyZ2V0T2JqZWN0IiwidG9UYXJnZXRPYmplY3QiLCJ0b0Z1bmN0aW9uU3RvcmUiLCJrZXlmcmFtZXNUYXJnZXRBcnJheSIsImZhc3RTZXRWYWx1ZXNBcnJheSIsImtleU9iamVjdFRhcmdldCIsInR3ZWVuSWQiLCJnZW5lcmF0ZUtleWZyYW1lcyIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eU5hbWVzIiwiY29uY2F0IiwiZmlsdGVyIiwicHJvcEFycmF5IiwibmV3S2V5Iiwia2V5VmFsdWUiLCJ0b3RhbER1cmF0aW9uIiwic29ydCIsIm9mZnNldCIsInByZXZLZXkiLCJrZXlPYmoiLCJkdXJQcm9ncmVzcyIsInByZXZFYXNlIiwiY3VycmVudEVhc2UiLCJ1bmRlZmluZWQiLCJzaGlmdCIsIkpTQW5pbWF0aW9uIiwiZmFzdFNldCIsInRhcmdldHNMZW5ndGgiLCJrZlBhcmFtcyIsInBhcmFtcyIsImFuaW1EZWZhdWx0cyIsImFuaW1hUGxheWJhY2tFYXNlIiwiYW5pbUVhc2UiLCJoYXNTcHJpbmciLCJ0RWFzaW5nIiwidER1cmF0aW9uIiwidERlbGF5IiwidE1vZGlmaWVyIiwidENvbXBvc2l0aW9uIiwiYW5pbUlubGluZVN0eWxlcyIsImFic29sdXRlT2Zmc2V0VGltZSIsIk5hTiIsIml0ZXJhdGlvbkRlbGF5IiwiYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoIiwic2hvdWxkVHJpZ2dlclJlbmRlciIsInRhcmdldEluZGV4IiwidGkiLCJsYXN0VHJhbnNmb3JtR3JvdXBJbmRleCIsImxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCIsInByb3BWYWx1ZSIsImlzUHJvcFZhbHVlQXJyYXkiLCJhcnJheUxlbmd0aCIsImlzTm90T2JqZWN0VmFsdWUiLCJwcmV2VHdlZW4iLCJmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lIiwibGFzdFR3ZWVuQ2hhbmdlRW5kVGltZSIsInR3ZWVuSW5kZXgiLCJrZXlmcmFtZSIsImNvbXB1dGVkVG9WYWx1ZSIsInR3ZWVuVG9WYWx1ZSIsInR3ZWVuRnJvbVZhbHVlIiwia2V5RWFzaW5nIiwidHdlZW5FYXNpbmciLCJ0d2VlbkR1cmF0aW9uIiwidHdlZW5EZWxheSIsImNvbXB1dGVkQ29tcG9zaXRpb24iLCJoYXNGcm9tdmFsdWUiLCJoYXNUb1ZhbHVlIiwiaXNGcm9tVG9BcnJheSIsImlzRnJvbVRvVmFsdWUiLCJ0d2VlblN0YXJ0VGltZSIsImFic29sdXRlU3RhcnRUaW1lIiwibmV4dFNpYmxpbmciLCJjb21wbGV4VmFsdWUiLCJub3RDb21wbGV4VmFsdWUiLCJ1bml0VmFsdWUiLCJub3RVbml0VmFsdWUiLCJjb2xvclZhbHVlIiwibm90Q29sb3JWYWx1ZSIsInZhbHVlVG9Db252ZXJ0IiwibG9uZ2VzdFZhbHVlIiwic2hvcnRlc3RWYWx1ZSIsIl8iLCJ0d2VlblVwZGF0ZUR1cmF0aW9uIiwiX2Z1bmMiLCJfbmV4dEFkZCIsImFkZGl0aXZlVHdlZW4iLCJjb25zb2xlIiwid2FybiIsInJlZnJlc2giLCJvZ1ZhbHVlIiwiYW5pbWF0ZSIsImVhc2luZ1RvTGluZWFyIiwic2FtcGxlcyIsInBvaW50cyIsImpvaW4iLCJXQUFQSUVhc2VzTG9va3VwcyIsIldBQVBJZWFzZXMiLCJwYXJzZVdBQVBJRWFzaW5nIiwicGFyc2VkRWFzZSIsImVhc2luZyIsInRyYW5zZm9ybXNTaG9ydGhhbmRzIiwiY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyIsInZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMiLCJzb21lIiwiYXhpcyIsImVuZHNXaXRoIiwidHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkIiwiY2FsbCIsInJlZ2lzdGVyVHJhbnNmb3Jtc1Byb3BlcnRpZXMiLCJpc1NrZXciLCJpc1NjYWxlIiwiaXNSb3RhdGUiLCJpc1RyYW5zbGF0ZSIsImlzQW5nbGUiLCJzeW50YXgiLCJyZWdpc3RlclByb3BlcnR5IiwiaW5oZXJpdHMiLCJpbml0aWFsVmFsdWUiLCJXQUFQSUFuaW1hdGlvbnNMb29rdXBzIiwicmVtb3ZlV0FBUElBbmltYXRpb24iLCJuZXh0TG9va3VwIiwibWF0Y2hUYXJnZXQiLCJtYXRjaFByb3BlcnR5IiwibWF0Y2hQYXJlbnQiLCJhbmltIiwiY29tbWl0U3R5bGVzIiwibG9va3VwUGFyZW50IiwiX2NvbXBsZXRlZCIsImFuaW1hdGlvbnMiLCJhZGRXQUFQSUFuaW1hdGlvbiIsImFuaW1Ub3RhbER1cmF0aW9uIiwiY29udHJvbEFuaW1hdGlvbiIsImhhbmRsZVJlbW92ZSIsIm9ucmVtb3ZlIiwib25maW5pc2giLCJub3JtYWxpemVUd2VlblZhbHVlIiwicGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSIsInR3ZWVuVmFsdWUiLCJjb21wdXRlZFRvIiwiY29tcHV0ZWRGcm9tIiwiV0FBUElBbmltYXRpb24iLCJzcHJpbmciLCJzY3JvbGwiLCJkaXJlY3Rpb24iLCJmaWxsIiwiaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMiLCJjb21wb3NpdGUiLCJ0d2VlblBhcmFtcyIsInByb3BlcnR5VmFsdWUiLCJpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkiLCJwYXJzZWRQcm9wZXJ0eVZhbHVlIiwidHdlZW5PcHRpb25zIiwidHdlZW5PcHRpb25zRWFzZSIsInR3ZWVuT3B0aW9uc1NwcmluZyIsInRyYW5zZm9ybXMiLCJjYiIsIndhYXBpIiwiY29udmVydEVhc2UiLCJzeW5jIiwiZ2V0VGFyZ2V0VmFsdWUiLCJ0YXJnZXRTZWxlY3RvciIsIm5vcm1hbGl6ZVByb3BOYW1lIiwib3JpZ2luYWxWYWx1ZSIsInNldFRhcmdldFZhbHVlcyIsInJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uIiwidGFyZ2V0c0FycmF5IiwidHdlZW5zTWF0Y2hlc1RhcmdldHMiLCJ0d2Vlbk5hbWUiLCJyZW1vdmUiLCJ3YWFwaUFuaW1hdGlvbiIsInJlbW92ZU1hdGNoZXMiLCJjaGlsZFRMT2Zmc2V0IiwiY2hpbGREdXIiLCJtIiwicmFuZG9tUGljayIsIml0ZW1zIiwic2h1ZmZsZSIsInJvdW5kUGFkIiwicGFkU3RhcnQiLCJwYWRTdHJpbmciLCJwYWRFbmQiLCJ3cmFwIiwibWFwUmFuZ2UiLCJpbkxvdyIsImluSGlnaCIsIm91dExvdyIsIm91dEhpZ2giLCJkZWdUb1JhZCIsImRlZ3JlZXMiLCJyYWRUb0RlZyIsInJhZGlhbnMiLCJsZXJwIiwiYW1vdW50IiwiZHQiLCJ0aWNrZXIiLCJjdXJyeSIsImxhc3QiLCJjaGFpbiIsInJlc3VsdCIsIl9fIiwibmV4dEFyZ3MiLCJuZXh0UmVzdWx0IiwidXRpbHMiLCJtYWtlQ2hhaW5hYmxlIiwicmlnaHQiLCIkIiwiZ2V0UHJldkNoaWxkT2Zmc2V0IiwidGltZWxpbmUiLCJ0aW1lUG9zaXRpb24iLCJnb1RvUHJldkFuaW1hdGlvbk9mZnNldCIsInByZXZBbmltYXRpb24iLCJwcmV2T2Zmc2V0IiwicGFyc2VUaW1lbGluZVBvc2l0aW9uIiwidGxEdXJhdGlvbiIsInRpbWVQb3NTdHIiLCJ0bExhYmVscyIsImxhYmVscyIsImhhc0xhYmVscyIsImhhc1NpYmxpbmciLCJtYXRjaGVkUmVsYXRpdmVPcGVyYXRvciIsImZ1bGxPcGVyYXRvciIsImxhYmVsT2Zmc2V0IiwicGFyc2VkT2Zmc2V0IiwicGFyc2VkTnVtZXJpY2FsT2Zmc2V0IiwiZ2V0VGltZWxpbmVUb3RhbER1cmF0aW9uIiwiYWRkVGxDaGlsZCIsImNoaWxkUGFyYW1zIiwiYWRqdXN0ZWRQb3NpdGlvbiIsInRsQ2hpbGQiLCJUaW1lbGluZSIsImRlZmF1bHRzUGFyYW1zIiwiZ2xvYmFsRGVmYXVsdHMiLCJ0bFBsYXliYWNrRWFzZSIsImFkZCIsImExIiwiYTIiLCJhMyIsImlzQW5pbSIsImlzVGltZXIiLCJzdGFnZ2VyZWRQb3NpdGlvbiIsInBhcnNlZExlbmd0aCIsInN0YWdnZXJlZENoaWxkUGFyYW1zIiwic3luY2VkIiwicG9zaXRpb24iLCJlZmZlY3QiLCJnZXRUaW1pbmciLCJsYWJlbCIsImxhYmVsTmFtZSIsImNyZWF0ZVRpbWVsaW5lIiwiQW5pbWF0YWJsZSIsImdsb2JhbFBhcmFtcyIsInBhcmFtVmFsdWUiLCJpc09ialZhbHVlIiwicHJvcFBhcmFtcyIsImFuaW1QYXJhbXMiLCJudW1iZXJzIiwiY3JlYXRlQW5pbWF0YWJsZSIsIlNwcmluZyIsInRpbWVTdGVwIiwicmVzdFRocmVzaG9sZCIsInJlc3REdXJhdGlvbiIsIm1heER1cmF0aW9uIiwibWF4UmVzdFN0ZXBzIiwibWF4SXRlcmF0aW9ucyIsIm1hc3MiLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwidmVsb2NpdHkiLCJ3MCIsInpldGEiLCJ3ZCIsInNvbHZlckR1cmF0aW9uIiwiY29tcHV0ZSIsInNvbHZlIiwic29sdmVyVGltZSIsInJlc3RTdGVwcyIsImNyZWF0ZVNwcmluZyIsInByZXZlbnREZWZhdWx0IiwiY2FuY2VsYWJsZSIsIkRPTVByb3h5IiwiekluZGV4IiwicGFyZW50RWxlbWVudCIsImNsYXNzTGlzdCIsImhlaWdodCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJUcmFuc2Zvcm1zIiwicG9pbnQiLCJET01Qb2ludCIsImludmVyc2VkTWF0cml4IiwiZ2V0TWF0cml4IiwiaW52ZXJzZSIsIm5vcm1hbGl6ZVBvaW50IiwibWF0cml4VHJhbnNmb3JtIiwidHJhdmVyc2VVcCIsIm1hdHJpeCIsIkRPTU1hdHJpeCIsInRyYW5zZm9ybVZhbHVlIiwiZWxNYXRyaXgiLCJwcmVNdWx0aXBseVNlbGYiLCJjdCIsInBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIiLCJkcmFnZ2FibGUiLCJEcmFnZ2FibGUiLCJwYXJhbVgiLCJwYXJhbVkiLCJ0cmlnZ2VyIiwicmVsZWFzZUVhc2UiLCJjdXN0b21FYXNlIiwieFByb3AiLCJtYXBUbyIsInlQcm9wIiwiY29udGFpbmVyIiwiY29udGFpbmVyQXJyYXkiLCIkY29udGFpbmVyIiwidXNlV2luIiwiJHNjcm9sbENvbnRhaW5lciIsIiR0YXJnZXQiLCIkdHJpZ2dlciIsImZpeGVkIiwiaXNGaW5lUG9pbnRlciIsImNvbnRhaW5lclBhZGRpbmciLCJjb250YWluZXJGcmljdGlvbiIsInJlbGVhc2VDb250YWluZXJGcmljdGlvbiIsInNuYXBYIiwic25hcFkiLCJzY3JvbGxTcGVlZCIsInNjcm9sbFRocmVzaG9sZCIsImRyYWdTcGVlZCIsIm1heFZlbG9jaXR5IiwibWluVmVsb2NpdHkiLCJ2ZWxvY2l0eU11bHRpcGxpZXIiLCJjdXJzb3IiLCJyZWxlYXNlWFNwcmluZyIsInJlbGVhc2VNYXNzIiwicmVsZWFzZVN0aWZmbmVzcyIsInJlbGVhc2VEYW1waW5nIiwicmVsZWFzZVlTcHJpbmciLCJvdXRRdWludCIsImhhc1JlbGVhc2VTcHJpbmciLCJvbkdyYWIiLCJvbkRyYWciLCJvblJlbGVhc2UiLCJvblNldHRsZSIsIm9uU25hcCIsIm9uUmVzaXplIiwib25BZnRlclJlc2l6ZSIsImRpc2FibGVkIiwiYW5pbWF0YWJsZVBhcmFtcyIsInBhcmFtWE9iamVjdCIsImFuaW1hdGFibGVYUGFyYW1zIiwicGFyYW1ZT2JqZWN0IiwiYW5pbWF0YWJsZVlQYXJhbXMiLCJkZXN0WCIsImRlc3RZIiwiZGVsdGFYIiwiZGVsdGFZIiwiY29vcmRzIiwic25hcHBlZCIsInBvaW50ZXIiLCJzY3JvbGxWaWV3IiwiZHJhZ0FyZWEiLCJjb250YWluZXJCb3VuZHMiLCJzY3JvbGxCb3VuZHMiLCJ0YXJnZXRCb3VuZHMiLCJ2ZWxvY2l0eVN0YWNrIiwidmVsb2NpdHlTdGFja0luZGV4IiwidmVsb2NpdHlUaW1lIiwiYW5nbGUiLCJjdXJzb3JTdHlsZXMiLCJ0cmlnZ2VyU3R5bGVzIiwiYm9keVN0eWxlcyIsInRhcmdldFN0eWxlcyIsInRvdWNoQWN0aW9uU3R5bGVzIiwib3ZlcnNob290Q29vcmRzIiwib3ZlcnNob290WFRpY2tlciIsIm92ZXJzaG9vdFlUaWNrZXIiLCJ1cGRhdGVUaWNrZXIiLCJ1cGRhdGVkIiwibWFudWFsIiwiY29udGFpbmVkIiwiZ3JhYmJlZCIsImRyYWdnZWQiLCJyZWxlYXNlZCIsImNhblNjcm9sbCIsImVuYWJsZWQiLCJpbml0aWFsaXplZCIsImFjdGl2ZVByb3AiLCJoYXNVcGRhdGVkIiwiaGFzTW92ZWQiLCJoYXNSZWxlYXNlZCIsImR4IiwiZHkiLCJjb21wdXRlVmVsb2NpdHkiLCJyZXNpemVUaWNrZXIiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZW5hYmxlIiwib2JzZXJ2ZSIsInByZXZUaW1lIiwiY3VyVGltZSIsImVsYXBzZWQiLCJ2TXVsIiwibWluViIsIm1heFYiLCJ2aSIsInNldFgiLCJtdXRlVXBkYXRlQ2FsbGJhY2siLCJzZXRZIiwicHJvZ3Jlc3NYIiwicHJvZ3Jlc3NZIiwidXBkYXRlU2Nyb2xsQ29vcmRzIiwic3giLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsInN5Iiwic2Nyb2xsWSIsInNjcm9sbFRvcCIsImNwdCIsImNwciIsImNwYiIsImNwbCIsInRocmVzaG9sZCIsInVwZGF0ZUJvdW5kaW5nVmFsdWVzIiwiY3giLCJjeSIsImN4MiIsImN5MiIsIml3IiwiaW5uZXJXaWR0aCIsImloIiwiaW5uZXJIZWlnaHQiLCJ1dyIsInN3Iiwic2Nyb2xsV2lkdGgiLCJzaCIsInNjcm9sbEhlaWdodCIsImZ4IiwidHJhbnNmb3JtQ29udGFpbmVyUmVjdCIsImNvbnRhaW5lck92ZXJmbG93IiwidmlzaWJsZU92ZXJmbG93IiwiaGlkZGVuT3ZlcmZsb3ciLCJ0YXJnZXRSZWN0IiwiaGlkZGVuTGVmdCIsImhpZGRlblRvcCIsImhpZGRlblJpZ2h0IiwiaGlkZGVuQm90dG9tIiwiaXNPdXRPZkJvdW5kcyIsImJvdW5kcyIsImJ0IiwiYnIiLCJiYiIsImJsIiwib2J4Iiwib2J5IiwiY3AiLCJwYXJzZWRDdXJzb3JTdHlsZXMiLCJvbkhvdmVyIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJkYXciLCJkYWgiLCJjc3giLCJjc3kiLCJuc3ciLCJuc2giLCJjc3ciLCJjc2giLCJzd2QiLCJzaGQiLCJzdCIsInNyIiwic2IiLCJzbCIsIm54IiwibnkiLCJzY3JvbGxCeSIsInNjcm9sbFRvIiwiY3IiLCJjbCIsInB4MSIsInB5MSIsInB4MiIsInB5MiIsInB4MyIsInB5MyIsImNmIiwibnN4IiwibnN5Iiwic3RvcCIsInNjcm9sbEluVmlldyIsImdhcCIsImluT3V0UXVhZCIsImhhbmRsZUhvdmVyIiwiYW5pbWF0ZUluVmlldyIsIm9iIiwiZGlzYWJsZWRYIiwiZGlzYWJsZWRZIiwiZHVyIiwiaGFuZGxlRG93biIsIiRlVGFyZ2V0Iiwic3RvcFByb3BhZ2F0aW9uIiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiZXZlbnRYIiwiY2xpZW50WCIsImV2ZW50WSIsImNsaWVudFkiLCJ6IiwiaGFuZGxlTW92ZSIsIm1vdmVkWCIsIm1vdmVkWSIsIiRwYXJlbnQiLCJpc0F0VG9wIiwiaXNBdEJvdHRvbSIsImNhblRvdWNoU2Nyb2xsIiwib3ZlcmZsb3dZIiwiY2xpZW50SGVpZ2h0IiwicG9pbnRlckV2ZW50cyIsInBhc3NpdmUiLCJoYW5kbGVVcCIsInNwcmluZ1giLCJzcHJpbmdZIiwicHYiLCJwYSIsImRzIiwiYngiLCJieSIsImR1cmF0aW9uWCIsImR1cmF0aW9uWSIsImVhc2VYIiwiZWFzZVkiLCJsb25nZXN0UmVsZWFzZUR1cmF0aW9uIiwiZGlyZWN0aW9uWCIsImRpc3RhbmNlWCIsImRpcmVjdGlvblkiLCJkaXN0YW5jZVkiLCJoYXNTbmFwcGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvdWNoQWN0aW9uIiwiZGlzYWJsZSIsImhhbmRsZUV2ZW50IiwiY3JlYXRlRHJhZ2dhYmxlIiwiU2NvcGUiLCJyb290UGFyYW0iLCJjdXJyZW50IiwibmF0aXZlRWxlbWVudCIsInNjb3BlRGVmYXVsdHMiLCJnbG9iYWxEZWZhdWx0IiwibWVkaWFRdWVyaWVzIiwiY29uc3RydWN0b3JzIiwicmV2ZXJ0Q29uc3RydWN0b3JzIiwibWV0aG9kcyIsIm1lZGlhUXVlcnlMaXN0cyIsImRhdGEiLCJtcSIsIl9tcSIsImV4ZWN1dGUiLCJhY3RpdmVTY29wZSIsImFjdGl2ZVJvb3QiLCJhY3RpdmVEZWZhdWx0cyIsIm1xcyIsInJldHVybmVkIiwicmV2ZXJ0Q29uc3RydWN0b3IiLCJjcmVhdGVTY29wZSIsImdldE1heFZpZXdIZWlnaHQiLCJjcmVhdGVFbGVtZW50Iiwib2Zmc2V0SGVpZ2h0IiwicGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyIiwic2Nyb2xsZXIiLCJzY3JvbGxDb250YWluZXJzIiwiU2Nyb2xsQ29udGFpbmVyIiwiZWxlbWVudCIsIndpbldpZHRoIiwid2luSGVpZ2h0IiwicHJldlNjcm9sbFgiLCJwcmV2U2Nyb2xsWSIsImJhY2t3YXJkWCIsImJhY2t3YXJkWSIsInNjcm9sbFRpY2tlciIsImRhdGFUaW1lciIsImhhbmRsZVNjcm9sbCIsInNlbGYiLCJweCIsInB5IiwidXBkYXRlV2luZG93Qm91bmRzIiwicmVmcmVzaFNjcm9sbE9ic2VydmVycyIsIndha2VUaWNrZXIiLCJ1cGRhdGVCb3VuZHMiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJlbFJlY3QiLCJfZGVidWciLCJyZW1vdmVEZWJ1ZyIsImRlYnVnIiwidW5vYnNlcnZlIiwicmVnaXN0ZXJBbmRHZXRTY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXIiLCJjb252ZXJ0VmFsdWVUb1B4Iiwic2l6ZSIsInVuZGVyIiwib3ZlciIsImNsYW1wTWluIiwiY2xhbXBNYXgiLCJwYXJzZUJvdW5kVmFsdWUiLCJtYXRjaGVkT3BlcmF0b3IiLCJzcGxpdHRlciIsInNwbGl0dGVkIiwidmFsdWVBUHgiLCJ2YWx1ZUJQeCIsImdldEFuaW1hdGlvbkRvbVRhcmdldCIsIiRsaW5rZWRUYXJnZXQiLCJsaW5rZWRUYXJnZXRzIiwic2Nyb2xsZXJJbmRleCIsImRlYnVnQ29sb3JzIiwiU2Nyb2xsT2JzZXJ2ZXIiLCJzeW5jTW9kZSIsImlzTGluZWFyIiwiaXNFYXNlIiwiaXNTbW9vdGgiLCJpc01ldGhvZHMiLCJzeW5jTWV0aG9kcyIsImJpRGlyU3luYyIsInJlcGVhdCIsImhvcml6b250YWwiLCJlbnRlciIsImxlYXZlIiwic3luY0Vhc2UiLCJzeW5jU21vb3RoIiwib25TeW5jRW50ZXIiLCJvblN5bmNMZWF2ZSIsIm9uU3luY0VudGVyRm9yd2FyZCIsIm9uU3luY0xlYXZlRm9yd2FyZCIsIm9uU3luY0VudGVyQmFja3dhcmQiLCJvblN5bmNMZWF2ZUJhY2t3YXJkIiwib25FbnRlciIsIm9uTGVhdmUiLCJvbkVudGVyRm9yd2FyZCIsIm9uTGVhdmVGb3J3YXJkIiwib25FbnRlckJhY2t3YXJkIiwib25MZWF2ZUJhY2t3YXJkIiwib25TeW5jQ29tcGxldGUiLCJyZXZlcnRlZCIsImlzSW5WaWV3IiwiZm9yY2VFbnRlciIsImhhc0VudGVyZWQiLCJvZmZzZXRzIiwib2Zmc2V0U3RhcnQiLCJvZmZzZXRFbmQiLCJkaXN0YW5jZSIsInByZXZQcm9ncmVzcyIsInRocmVzaG9sZHMiLCJkZWJ1Z1N0eWxlcyIsIiRkZWJ1ZyIsIl9wYXJhbXMiLCJiYWNrd2FyZCIsImlzSG9yaSIsIiRleGlzdGluZ0RlYnVnIiwicXVlcnlTZWxlY3RvciIsIiR0aHJlc2hvbGRzIiwiJHRyaWdnZXJzIiwiY29sb3IiLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsIm9mZkxlZnQiLCJvZmZUb3AiLCJoYWxmIiwibGFiZWxIZWlnaHQiLCJsYWJlbFdpZHRoIiwibGFiZWxTaXplIiwiZ3JhZGllbnRPZmZzZXQiLCJsaW5lQ1NTIiwiYmFzZUNTUyIsInciLCJjc3NUZXh0IiwiaXNWaWV3IiwiaXNUYWlsIiwiaXNGaXJzdCIsImlzT3ZlciIsImlzRmxpcCIsIiRsYWJlbCIsIiR0ZXh0IiwiZGlyUHJvcCIsImZsaXBPZmZzZXQiLCJpbm5lckhUTUwiLCJjb250YWluZXJQb3NpdGlvbiIsInN0aWNreXMiLCJsaW5rZWRUaW1lIiwib2Zmc2V0WCIsIm9mZnNldFkiLCIkb2Zmc2V0UGFyZW50IiwiaXNDb250YWluZXJTdGF0aWMiLCJpc1N0aWNreSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJ0YXJnZXRTaXplIiwiY29udGFpbmVyU2l6ZSIsInNjcm9sbFNpemUiLCJtYXhTY3JvbGwiLCJlbnRlclRhcmdldCIsImxlYXZlVGFyZ2V0IiwiZW50ZXJDb250YWluZXIiLCJsZWF2ZUNvbnRhaW5lciIsInBhcnNlZEVudGVyVGFyZ2V0IiwicGFyc2VkTGVhdmVUYXJnZXQiLCJwYXJzZWRFbnRlckNvbnRhaW5lciIsInBhcnNlZExlYXZlQ29udGFpbmVyIiwic2Nyb2xsRGVsdGEiLCJzdGlja3kiLCJzaG91bGRTZWVrIiwiaXNCZWZvcmUiLCJpc0FmdGVyIiwiaXNPblRoZUVkZ2UiLCJzeW5jQ29tcGxldGVkIiwibHAiLCJzdGVwIiwib25TY3JvbGwiLCJzdGFnZ2VyIiwidmFsIiwiaGFzRWFzaW5nIiwic3RhZ2dlckVhc2UiLCJncmlkIiwiZnJvbUZpcnN0IiwiZnJvbUNlbnRlciIsImZyb21MYXN0IiwiaXNSYW5nZSIsInZhbDEiLCJ2YWwyIiwiZnJvbUluZGV4IiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/animejs/lib/anime.esm.js\n");

/***/ })

};
;