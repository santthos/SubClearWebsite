"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_ArrowRightIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowRightIcon!=!@heroicons/react/24/outline */ \"(app-pages-browser)/./node_modules/@heroicons/react/24/outline/esm/ArrowRightIcon.js\");\n/* harmony import */ var _components_Navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Navigation */ \"(app-pages-browser)/./app/components/Navigation.tsx\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! animejs */ \"(app-pages-browser)/./node_modules/animejs/lib/anime.esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction Home() {\n    _s();\n    const [showMain, setShowMain] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [transitioning, setTransitioning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [visibleSection, setVisibleSection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const observerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Prevent scrolling when splash is visible\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!showMain) {\n            document.body.style.overflow = \"hidden\";\n        } else {\n            document.body.style.overflow = \"\";\n        }\n        return ()=>{\n            document.body.style.overflow = \"\";\n        };\n    }, [\n        showMain\n    ]);\n    // Set up intersection observer for section animations\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (showMain) {\n            observerRef.current = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    if (entry.isIntersecting) {\n                        setVisibleSection(entry.target.id);\n                        const content = entry.target.querySelector(\".section-content\");\n                        const bg = entry.target.querySelector(\".section-bg\");\n                        if (content) content.classList.add(\"visible\");\n                        if (bg) bg.classList.add(\"visible\");\n                    } else {\n                        const content = entry.target.querySelector(\".section-content\");\n                        const bg = entry.target.querySelector(\".section-bg\");\n                        if (content) content.classList.remove(\"visible\");\n                        if (bg) bg.classList.remove(\"visible\");\n                    }\n                });\n            }, {\n                threshold: 0.3\n            });\n            document.querySelectorAll(\"section\").forEach((section)=>{\n                var _observerRef_current;\n                (_observerRef_current = observerRef.current) === null || _observerRef_current === void 0 ? void 0 : _observerRef_current.observe(section);\n            });\n        }\n        return ()=>{\n            var _observerRef_current;\n            (_observerRef_current = observerRef.current) === null || _observerRef_current === void 0 ? void 0 : _observerRef_current.disconnect();\n        };\n    }, [\n        showMain\n    ]);\n    // Handles the splash-to-main transition\n    const handleFindOutMore = ()=>{\n        setTransitioning(true);\n        // Animate splash screen elements out\n        (0,animejs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n            targets: \".splash-content h1, .splash-content p, .splash-content button\",\n            opacity: [\n                1,\n                0\n            ],\n            translateY: [\n                0,\n                20\n            ],\n            duration: 500,\n            easing: \"easeOutExpo\",\n            delay: animejs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].stagger(100),\n            complete: ()=>{\n                (0,animejs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\n                    targets: \".splash-screen\",\n                    opacity: [\n                        1,\n                        0\n                    ],\n                    duration: 700,\n                    easing: \"easeOutExpo\",\n                    complete: ()=>setShowMain(true)\n                });\n            }\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-neutral-900\",\n        children: [\n            !showMain && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed inset-0 z-50 flex flex-col items-center justify-center bg-neutral-900 transition-opacity duration-700 \".concat(transitioning ? \"opacity-0 pointer-events-none\" : \"opacity-100\"),\n                style: {\n                    transform: \"scale(1)\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"splash-content flex flex-col items-center justify-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-center justify-center mb-10 w-[180px] h-[28px] sm:w-[320px] sm:h-[48px] md:w-[480px] md:h-[72px]\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                src: \"/SubclearLogo.svg\",\n                                alt: \"SubClear Logo\",\n                                width: 480,\n                                height: 72,\n                                priority: true,\n                                className: \"w-full h-auto\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 93,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                            lineNumber: 92,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"text-lg sm:text-2xl md:text-3xl mb-12 text-neutral-300 font-light font-sans text-center px-4\",\n                            children: \"Clearing the air beneath our cities.\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                            lineNumber: 95,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"btn-primary text-base sm:text-lg px-6 sm:px-10 py-4 sm:py-5 shadow-md w-full max-w-xs sm:max-w-md\",\n                            onClick: handleFindOutMore,\n                            style: {\n                                minWidth: 120\n                            },\n                            children: [\n                                \"Find out more\",\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightIcon_heroicons_react_24_outline__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    className: \"w-6 h-6 sm:w-7 sm:h-7 inline-block ml-3\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                    lineNumber: 104,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                            lineNumber: 98,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                    lineNumber: 91,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                lineNumber: 87,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"transition-opacity duration-700 \".concat(showMain ? \"opacity-100\" : \"opacity-0 pointer-events-none\", \" scroll-snap-container\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Navigation__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 112,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"concept\",\n                        className: \"full-page-section bg-neutral-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"section-bg bg-white\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 115,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-custom section-content\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-10 sm:mb-16 md:mb-20 font-sans\",\n                                        children: \"The Concept\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 117,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"max-w-4xl mx-auto\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-base sm:text-xl md:text-2xl mb-8 leading-relaxed font-sans px-2 sm:px-0\",\n                                            children: \"SubClear is a clean-tech startup developing a track-mounted air filtration system designed specifically for underground railway systems, starting with the London Underground. The system attaches to existing engineering trains and is passively towed through the tunnels, cleaning polluted air directly at track level — where air pollution is densest and most toxic.\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                            lineNumber: 119,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 118,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 116,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 114,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"problem\",\n                        className: \"full-page-section bg-neutral-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"section-bg bg-white\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 127,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-custom section-content\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-10 sm:mb-16 md:mb-20 font-sans\",\n                                        children: \"The Problem\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 129,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"max-w-4xl mx-auto\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-base sm:text-xl md:text-2xl mb-8 leading-relaxed font-sans px-2 sm:px-0\",\n                                                children: \"Air pollution in subway systems is dangerously high — in some areas, particulate matter (especially PM2.5 and metallic dust) exceeds above-ground limits by 10x or more. These pollutants come primarily from:\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                lineNumber: 131,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                className: \"list-disc list-inside text-base sm:text-xl md:text-2xl space-y-4 mb-12 font-sans px-2 sm:px-0\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Brake and wheel wear\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                        lineNumber: 135,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Track friction\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                        lineNumber: 136,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Poor tunnel ventilation\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                        lineNumber: 137,\n                                                        columnNumber: 17\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                        children: \"Accumulated historic dust\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                        lineNumber: 138,\n                                                        columnNumber: 17\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                lineNumber: 134,\n                                                columnNumber: 15\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-base sm:text-xl md:text-2xl leading-relaxed font-sans px-2 sm:px-0\",\n                                                children: \"Prolonged exposure poses serious health risks to commuters, staff, and maintenance crews.\"\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                lineNumber: 140,\n                                                columnNumber: 15\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 130,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 128,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 126,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"solution\",\n                        className: \"full-page-section bg-neutral-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"section-bg bg-white\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 148,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-custom section-content\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-10 sm:mb-16 md:mb-20 font-sans\",\n                                        children: \"The Solution\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 150,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"max-w-4xl mx-auto\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"text-base sm:text-xl md:text-2xl mb-8 leading-relaxed font-sans px-2 sm:px-0\",\n                                            children: \"SubClear introduces a modular, retrofittable filtration system that's mounted on the chassis of engineering trains or dedicated rolling stock. As the train moves through the tunnels during non-passenger hours, the system sucks in contaminated air, filters it, and discharges cleaned air back into the tunnel environment.\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                            lineNumber: 152,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 151,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 149,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 147,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"components\",\n                        className: \"full-page-section bg-neutral-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"section-bg bg-white\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 160,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-custom section-content\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-10 sm:mb-16 md:mb-20 font-sans\",\n                                        children: \"Core System Components\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 162,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"max-w-6xl mx-auto\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 sm:gap-8 lg:gap-10\",\n                                            children: components.map((component, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"card group p-4 sm:p-6 md:p-8\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                            className: \"text-lg sm:text-xl md:text-2xl font-bold mb-4 text-neutral-100 group-hover:text-secondary-700 transition-colors duration-200 font-sans\",\n                                                            children: component.module\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                            lineNumber: 167,\n                                                            columnNumber: 21\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                            className: \"text-base sm:text-lg text-neutral-300 font-sans\",\n                                                            children: component.function\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                            lineNumber: 170,\n                                                            columnNumber: 21\n                                                        }, this)\n                                                    ]\n                                                }, index, true, {\n                                                    fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                                    lineNumber: 166,\n                                                    columnNumber: 19\n                                                }, this))\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                            lineNumber: 164,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 163,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 161,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 159,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"contact\",\n                        className: \"full-page-section bg-neutral-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"section-bg bg-white\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 179,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"container-custom section-content\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-8 sm:mb-10 font-sans\",\n                                        children: \"Contact Us\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 181,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-base sm:text-xl md:text-2xl mb-8 sm:mb-12 text-neutral-300 font-sans text-center px-2 sm:px-0\",\n                                        children: \"Ready to discuss your underground transit project?\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 182,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex justify-center\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"mailto:Team@SubClear.co.uk\",\n                                            className: \"btn-primary inline-block text-base sm:text-xl md:text-2xl px-6 sm:px-10 md:px-12 py-4 sm:py-5 md:py-6 shadow-xl\",\n                                            children: \"Team@SubClear.co.uk\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                            lineNumber: 186,\n                                            columnNumber: 15\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                        lineNumber: 185,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                                lineNumber: 180,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                        lineNumber: 178,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n                lineNumber: 111,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\SantthosSiwasubraman\\\\source\\\\repos\\\\SubClear Website\\\\app\\\\page.tsx\",\n        lineNumber: 84,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"ZrMPtczuA655QB17lTXPXclbvSI=\");\n_c = Home;\nconst components = [\n    {\n        module: \"Air Intake & Suction System\",\n        function: \"Captures tunnel air at high flow rate\"\n    },\n    {\n        module: \"Electrostatic Precipitator (ESP)\",\n        function: \"Ionises and traps ultrafine dust\"\n    },\n    {\n        module: \"Magnetic Particle Collection\",\n        function: \"Extracts metallic particles using embedded magnets\"\n    },\n    {\n        module: \"HEPA Filtration Unit\",\n        function: \"Removes residual PM2.5 and PM10 particles\"\n    },\n    {\n        module: \"Power Supply Unit\",\n        function: \"Battery, onboard generator, or regenerative power\"\n    },\n    {\n        module: \"Control System\",\n        function: \"Embedded PLC to monitor flow rates, filter condition, and diagnostics\"\n    },\n    {\n        module: \"Modular Chassis\",\n        function: \"Designed to integrate with existing TfL rolling stock and loading gauges\"\n    }\n];\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVQLFdBQVU7a0RBQXFHOzs7Ozs7a0RBR2xILDhEQUFDRDt3Q0FBSUMsV0FBVTtrREFDYiw0RUFBQ3FCOzRDQUNDQyxNQUFLOzRDQUNMdEIsV0FBVTtzREFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTZjtHQTdMd0J6QztLQUFBQTtBQStMeEIsTUFBTXVELGFBQWE7SUFDakI7UUFDRUssUUFBUTtRQUNSQyxVQUFVO0lBQ1o7SUFDQTtRQUNFRCxRQUFRO1FBQ1JDLFVBQVU7SUFDWjtJQUNBO1FBQ0VELFFBQVE7UUFDUkMsVUFBVTtJQUNaO0lBQ0E7UUFDRUQsUUFBUTtRQUNSQyxVQUFVO0lBQ1o7SUFDQTtRQUNFRCxRQUFRO1FBQ1JDLFVBQVU7SUFDWjtJQUNBO1FBQ0VELFFBQVE7UUFDUkMsVUFBVTtJQUNaO0lBQ0E7UUFDRUQsUUFBUTtRQUNSQyxVQUFVO0lBQ1o7Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBBcnJvd1JpZ2h0SWNvbiB9IGZyb20gJ0BoZXJvaWNvbnMvcmVhY3QvMjQvb3V0bGluZSdcclxuaW1wb3J0IE5hdmlnYXRpb24gZnJvbSAnLi9jb21wb25lbnRzL05hdmlnYXRpb24nXHJcbmltcG9ydCBJbWFnZSBmcm9tICduZXh0L2ltYWdlJ1xyXG5pbXBvcnQgYW5pbWUgZnJvbSAnYW5pbWVqcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XHJcbiAgY29uc3QgW3Nob3dNYWluLCBzZXRTaG93TWFpbl0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbdHJhbnNpdGlvbmluZywgc2V0VHJhbnNpdGlvbmluZ10gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbdmlzaWJsZVNlY3Rpb24sIHNldFZpc2libGVTZWN0aW9uXSA9IHVzZVN0YXRlKCcnKVxyXG4gIGNvbnN0IG9ic2VydmVyUmVmID0gdXNlUmVmPEludGVyc2VjdGlvbk9ic2VydmVyIHwgbnVsbD4obnVsbClcclxuXHJcbiAgLy8gUHJldmVudCBzY3JvbGxpbmcgd2hlbiBzcGxhc2ggaXMgdmlzaWJsZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXNob3dNYWluKSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcclxuICAgIH07XHJcbiAgfSwgW3Nob3dNYWluXSk7XHJcblxyXG4gIC8vIFNldCB1cCBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgZm9yIHNlY3Rpb24gYW5pbWF0aW9uc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc2hvd01haW4pIHtcclxuICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcclxuICAgICAgICAoZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcclxuICAgICAgICAgICAgICBzZXRWaXNpYmxlU2VjdGlvbihlbnRyeS50YXJnZXQuaWQpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbnRyeS50YXJnZXQucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tY29udGVudCcpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJnID0gZW50cnkudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy5zZWN0aW9uLWJnJyk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgIGlmIChiZykgYmcuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbnRyeS50YXJnZXQucXVlcnlTZWxlY3RvcignLnNlY3Rpb24tY29udGVudCcpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGJnID0gZW50cnkudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy5zZWN0aW9uLWJnJyk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIGNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgIGlmIChiZykgYmcuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgdGhyZXNob2xkOiAwLjMgfVxyXG4gICAgICApO1xyXG5cclxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2VjdGlvbicpLmZvckVhY2goKHNlY3Rpb24pID0+IHtcclxuICAgICAgICBvYnNlcnZlclJlZi5jdXJyZW50Py5vYnNlcnZlKHNlY3Rpb24pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBvYnNlcnZlclJlZi5jdXJyZW50Py5kaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gIH0sIFtzaG93TWFpbl0pO1xyXG5cclxuICAvLyBIYW5kbGVzIHRoZSBzcGxhc2gtdG8tbWFpbiB0cmFuc2l0aW9uXHJcbiAgY29uc3QgaGFuZGxlRmluZE91dE1vcmUgPSAoKSA9PiB7XHJcbiAgICBzZXRUcmFuc2l0aW9uaW5nKHRydWUpXHJcbiAgICAvLyBBbmltYXRlIHNwbGFzaCBzY3JlZW4gZWxlbWVudHMgb3V0XHJcbiAgICBhbmltZSh7XHJcbiAgICAgIHRhcmdldHM6ICcuc3BsYXNoLWNvbnRlbnQgaDEsIC5zcGxhc2gtY29udGVudCBwLCAuc3BsYXNoLWNvbnRlbnQgYnV0dG9uJyxcclxuICAgICAgb3BhY2l0eTogWzEsIDBdLFxyXG4gICAgICB0cmFuc2xhdGVZOiBbMCwgMjBdLFxyXG4gICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0RXhwbycsXHJcbiAgICAgIGRlbGF5OiBhbmltZS5zdGFnZ2VyKDEwMCksXHJcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgYW5pbWUoe1xyXG4gICAgICAgICAgdGFyZ2V0czogJy5zcGxhc2gtc2NyZWVuJyxcclxuICAgICAgICAgIG9wYWNpdHk6IFsxLCAwXSxcclxuICAgICAgICAgIGR1cmF0aW9uOiA3MDAsXHJcbiAgICAgICAgICBlYXNpbmc6ICdlYXNlT3V0RXhwbycsXHJcbiAgICAgICAgICBjb21wbGV0ZTogKCkgPT4gc2V0U2hvd01haW4odHJ1ZSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1zY3JlZW4gYmctbmV1dHJhbC05MDBcIj5cclxuICAgICAgey8qIFNwbGFzaCBTY3JlZW4gKi99XHJcbiAgICAgIHshc2hvd01haW4gJiYgKFxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIGNsYXNzTmFtZT17YGZpeGVkIGluc2V0LTAgei01MCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1uZXV0cmFsLTkwMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tNzAwICR7dHJhbnNpdGlvbmluZyA/ICdvcGFjaXR5LTAgcG9pbnRlci1ldmVudHMtbm9uZScgOiAnb3BhY2l0eS0xMDAnfWB9XHJcbiAgICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06ICdzY2FsZSgxKScgfX1cclxuICAgICAgICA+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwbGFzaC1jb250ZW50IGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgbWItMTAgdy1bMTgwcHhdIGgtWzI4cHhdIHNtOnctWzMyMHB4XSBzbTpoLVs0OHB4XSBtZDp3LVs0ODBweF0gbWQ6aC1bNzJweF1cIj5cclxuICAgICAgICAgICAgICA8SW1hZ2Ugc3JjPVwiL1N1YmNsZWFyTG9nby5zdmdcIiBhbHQ9XCJTdWJDbGVhciBMb2dvXCIgd2lkdGg9ezQ4MH0gaGVpZ2h0PXs3Mn0gcHJpb3JpdHkgY2xhc3NOYW1lPVwidy1mdWxsIGgtYXV0b1wiIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWxnIHNtOnRleHQtMnhsIG1kOnRleHQtM3hsIG1iLTEyIHRleHQtbmV1dHJhbC0zMDAgZm9udC1saWdodCBmb250LXNhbnMgdGV4dC1jZW50ZXIgcHgtNFwiPlxyXG4gICAgICAgICAgICAgIENsZWFyaW5nIHRoZSBhaXIgYmVuZWF0aCBvdXIgY2l0aWVzLlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4tcHJpbWFyeSB0ZXh0LWJhc2Ugc206dGV4dC1sZyBweC02IHNtOnB4LTEwIHB5LTQgc206cHktNSBzaGFkb3ctbWQgdy1mdWxsIG1heC13LXhzIHNtOm1heC13LW1kXCJcclxuICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVGaW5kT3V0TW9yZX1cclxuICAgICAgICAgICAgICBzdHlsZT17eyBtaW5XaWR0aDogMTIwIH19XHJcbiAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICBGaW5kIG91dCBtb3JlXHJcbiAgICAgICAgICAgICAgPEFycm93UmlnaHRJY29uIGNsYXNzTmFtZT1cInctNiBoLTYgc206dy03IHNtOmgtNyBpbmxpbmUtYmxvY2sgbWwtM1wiIC8+XHJcbiAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcblxyXG4gICAgICB7LyogTWFpbiBDb250ZW50ICovfVxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi03MDAgJHtzaG93TWFpbiA/ICdvcGFjaXR5LTEwMCcgOiAnb3BhY2l0eS0wIHBvaW50ZXItZXZlbnRzLW5vbmUnfSBzY3JvbGwtc25hcC1jb250YWluZXJgfT5cclxuICAgICAgICA8TmF2aWdhdGlvbiAvPlxyXG4gICAgICAgIHsvKiBDb25jZXB0IFNlY3Rpb24gKi99XHJcbiAgICAgICAgPHNlY3Rpb24gaWQ9XCJjb25jZXB0XCIgY2xhc3NOYW1lPVwiZnVsbC1wYWdlLXNlY3Rpb24gYmctbmV1dHJhbC05MDBcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2VjdGlvbi1iZyBiZy13aGl0ZVwiPjwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXItY3VzdG9tIHNlY3Rpb24tY29udGVudFwiPlxyXG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0zeGwgc206dGV4dC00eGwgbWQ6dGV4dC01eGwgZm9udC1ib2xkIHRleHQtY2VudGVyIG1iLTEwIHNtOm1iLTE2IG1kOm1iLTIwIGZvbnQtc2Fuc1wiPlRoZSBDb25jZXB0PC9oMj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy00eGwgbXgtYXV0b1wiPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmFzZSBzbTp0ZXh0LXhsIG1kOnRleHQtMnhsIG1iLTggbGVhZGluZy1yZWxheGVkIGZvbnQtc2FucyBweC0yIHNtOnB4LTBcIj5cclxuICAgICAgICAgICAgICAgIFN1YkNsZWFyIGlzIGEgY2xlYW4tdGVjaCBzdGFydHVwIGRldmVsb3BpbmcgYSB0cmFjay1tb3VudGVkIGFpciBmaWx0cmF0aW9uIHN5c3RlbSBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIHVuZGVyZ3JvdW5kIHJhaWx3YXkgc3lzdGVtcywgc3RhcnRpbmcgd2l0aCB0aGUgTG9uZG9uIFVuZGVyZ3JvdW5kLiBUaGUgc3lzdGVtIGF0dGFjaGVzIHRvIGV4aXN0aW5nIGVuZ2luZWVyaW5nIHRyYWlucyBhbmQgaXMgcGFzc2l2ZWx5IHRvd2VkIHRocm91Z2ggdGhlIHR1bm5lbHMsIGNsZWFuaW5nIHBvbGx1dGVkIGFpciBkaXJlY3RseSBhdCB0cmFjayBsZXZlbCDigJQgd2hlcmUgYWlyIHBvbGx1dGlvbiBpcyBkZW5zZXN0IGFuZCBtb3N0IHRveGljLlxyXG4gICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgey8qIFByb2JsZW0gU2VjdGlvbiAqL31cclxuICAgICAgICA8c2VjdGlvbiBpZD1cInByb2JsZW1cIiBjbGFzc05hbWU9XCJmdWxsLXBhZ2Utc2VjdGlvbiBiZy1uZXV0cmFsLTkwMFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWN0aW9uLWJnIGJnLXdoaXRlXCI+PC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lci1jdXN0b20gc2VjdGlvbi1jb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBzbTp0ZXh0LTR4bCBtZDp0ZXh0LTV4bCBmb250LWJvbGQgdGV4dC1jZW50ZXIgbWItMTAgc206bWItMTYgbWQ6bWItMjAgZm9udC1zYW5zXCI+VGhlIFByb2JsZW08L2gyPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTR4bCBteC1hdXRvXCI+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIHNtOnRleHQteGwgbWQ6dGV4dC0yeGwgbWItOCBsZWFkaW5nLXJlbGF4ZWQgZm9udC1zYW5zIHB4LTIgc206cHgtMFwiPlxyXG4gICAgICAgICAgICAgICAgQWlyIHBvbGx1dGlvbiBpbiBzdWJ3YXkgc3lzdGVtcyBpcyBkYW5nZXJvdXNseSBoaWdoIOKAlCBpbiBzb21lIGFyZWFzLCBwYXJ0aWN1bGF0ZSBtYXR0ZXIgKGVzcGVjaWFsbHkgUE0yLjUgYW5kIG1ldGFsbGljIGR1c3QpIGV4Y2VlZHMgYWJvdmUtZ3JvdW5kIGxpbWl0cyBieSAxMHggb3IgbW9yZS4gVGhlc2UgcG9sbHV0YW50cyBjb21lIHByaW1hcmlseSBmcm9tOlxyXG4gICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibGlzdC1kaXNjIGxpc3QtaW5zaWRlIHRleHQtYmFzZSBzbTp0ZXh0LXhsIG1kOnRleHQtMnhsIHNwYWNlLXktNCBtYi0xMiBmb250LXNhbnMgcHgtMiBzbTpweC0wXCI+XHJcbiAgICAgICAgICAgICAgICA8bGk+QnJha2UgYW5kIHdoZWVsIHdlYXI8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRyYWNrIGZyaWN0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Qb29yIHR1bm5lbCB2ZW50aWxhdGlvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+QWNjdW11bGF0ZWQgaGlzdG9yaWMgZHVzdDwvbGk+XHJcbiAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWJhc2Ugc206dGV4dC14bCBtZDp0ZXh0LTJ4bCBsZWFkaW5nLXJlbGF4ZWQgZm9udC1zYW5zIHB4LTIgc206cHgtMFwiPlxyXG4gICAgICAgICAgICAgICAgUHJvbG9uZ2VkIGV4cG9zdXJlIHBvc2VzIHNlcmlvdXMgaGVhbHRoIHJpc2tzIHRvIGNvbW11dGVycywgc3RhZmYsIGFuZCBtYWludGVuYW5jZSBjcmV3cy5cclxuICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICAgIHsvKiBTb2x1dGlvbiBTZWN0aW9uICovfVxyXG4gICAgICAgIDxzZWN0aW9uIGlkPVwic29sdXRpb25cIiBjbGFzc05hbWU9XCJmdWxsLXBhZ2Utc2VjdGlvbiBiZy1uZXV0cmFsLTkwMFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWN0aW9uLWJnIGJnLXdoaXRlXCI+PC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lci1jdXN0b20gc2VjdGlvbi1jb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBzbTp0ZXh0LTR4bCBtZDp0ZXh0LTV4bCBmb250LWJvbGQgdGV4dC1jZW50ZXIgbWItMTAgc206bWItMTYgbWQ6bWItMjAgZm9udC1zYW5zXCI+VGhlIFNvbHV0aW9uPC9oMj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy00eGwgbXgtYXV0b1wiPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtYmFzZSBzbTp0ZXh0LXhsIG1kOnRleHQtMnhsIG1iLTggbGVhZGluZy1yZWxheGVkIGZvbnQtc2FucyBweC0yIHNtOnB4LTBcIj5cclxuICAgICAgICAgICAgICAgIFN1YkNsZWFyIGludHJvZHVjZXMgYSBtb2R1bGFyLCByZXRyb2ZpdHRhYmxlIGZpbHRyYXRpb24gc3lzdGVtIHRoYXQncyBtb3VudGVkIG9uIHRoZSBjaGFzc2lzIG9mIGVuZ2luZWVyaW5nIHRyYWlucyBvciBkZWRpY2F0ZWQgcm9sbGluZyBzdG9jay4gQXMgdGhlIHRyYWluIG1vdmVzIHRocm91Z2ggdGhlIHR1bm5lbHMgZHVyaW5nIG5vbi1wYXNzZW5nZXIgaG91cnMsIHRoZSBzeXN0ZW0gc3Vja3MgaW4gY29udGFtaW5hdGVkIGFpciwgZmlsdGVycyBpdCwgYW5kIGRpc2NoYXJnZXMgY2xlYW5lZCBhaXIgYmFjayBpbnRvIHRoZSB0dW5uZWwgZW52aXJvbm1lbnQuXHJcbiAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgICB7LyogQ29tcG9uZW50cyBTZWN0aW9uICovfVxyXG4gICAgICAgIDxzZWN0aW9uIGlkPVwiY29tcG9uZW50c1wiIGNsYXNzTmFtZT1cImZ1bGwtcGFnZS1zZWN0aW9uIGJnLW5ldXRyYWwtOTAwXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNlY3Rpb24tYmcgYmctd2hpdGVcIj48L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyLWN1c3RvbSBzZWN0aW9uLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtM3hsIHNtOnRleHQtNHhsIG1kOnRleHQtNXhsIGZvbnQtYm9sZCB0ZXh0LWNlbnRlciBtYi0xMCBzbTptYi0xNiBtZDptYi0yMCBmb250LXNhbnNcIj5Db3JlIFN5c3RlbSBDb21wb25lbnRzPC9oMj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy02eGwgbXgtYXV0b1wiPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBzbTpncmlkLWNvbHMtMiBsZzpncmlkLWNvbHMtMyBnYXAtNiBzbTpnYXAtOCBsZzpnYXAtMTBcIj5cclxuICAgICAgICAgICAgICAgIHtjb21wb25lbnRzLm1hcCgoY29tcG9uZW50LCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5kZXh9IGNsYXNzTmFtZT1cImNhcmQgZ3JvdXAgcC00IHNtOnAtNiBtZDpwLThcIj5cclxuICAgICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBzbTp0ZXh0LXhsIG1kOnRleHQtMnhsIGZvbnQtYm9sZCBtYi00IHRleHQtbmV1dHJhbC0xMDAgZ3JvdXAtaG92ZXI6dGV4dC1zZWNvbmRhcnktNzAwIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBmb250LXNhbnNcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIHtjb21wb25lbnQubW9kdWxlfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvaDM+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIHNtOnRleHQtbGcgdGV4dC1uZXV0cmFsLTMwMCBmb250LXNhbnNcIj57Y29tcG9uZW50LmZ1bmN0aW9ufTwvcD5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L3NlY3Rpb24+XHJcbiAgICAgICAgey8qIENvbnRhY3QgU2VjdGlvbiAqL31cclxuICAgICAgICA8c2VjdGlvbiBpZD1cImNvbnRhY3RcIiBjbGFzc05hbWU9XCJmdWxsLXBhZ2Utc2VjdGlvbiBiZy1uZXV0cmFsLTkwMFwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzZWN0aW9uLWJnIGJnLXdoaXRlXCI+PC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lci1jdXN0b20gc2VjdGlvbi1jb250ZW50XCI+XHJcbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBzbTp0ZXh0LTR4bCBtZDp0ZXh0LTV4bCBmb250LWJvbGQgdGV4dC1jZW50ZXIgbWItOCBzbTptYi0xMCBmb250LXNhbnNcIj5Db250YWN0IFVzPC9oMj5cclxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIHNtOnRleHQteGwgbWQ6dGV4dC0yeGwgbWItOCBzbTptYi0xMiB0ZXh0LW5ldXRyYWwtMzAwIGZvbnQtc2FucyB0ZXh0LWNlbnRlciBweC0yIHNtOnB4LTBcIj5cclxuICAgICAgICAgICAgICBSZWFkeSB0byBkaXNjdXNzIHlvdXIgdW5kZXJncm91bmQgdHJhbnNpdCBwcm9qZWN0P1xyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgIDxhXHJcbiAgICAgICAgICAgICAgICBocmVmPVwibWFpbHRvOlRlYW1AU3ViQ2xlYXIuY28udWtcIlxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgaW5saW5lLWJsb2NrIHRleHQtYmFzZSBzbTp0ZXh0LXhsIG1kOnRleHQtMnhsIHB4LTYgc206cHgtMTAgbWQ6cHgtMTIgcHktNCBzbTpweS01IG1kOnB5LTYgc2hhZG93LXhsXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICBUZWFtQFN1YkNsZWFyLmNvLnVrXHJcbiAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn1cclxuXHJcbmNvbnN0IGNvbXBvbmVudHMgPSBbXHJcbiAge1xyXG4gICAgbW9kdWxlOiBcIkFpciBJbnRha2UgJiBTdWN0aW9uIFN5c3RlbVwiLFxyXG4gICAgZnVuY3Rpb246IFwiQ2FwdHVyZXMgdHVubmVsIGFpciBhdCBoaWdoIGZsb3cgcmF0ZVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBtb2R1bGU6IFwiRWxlY3Ryb3N0YXRpYyBQcmVjaXBpdGF0b3IgKEVTUClcIixcclxuICAgIGZ1bmN0aW9uOiBcIklvbmlzZXMgYW5kIHRyYXBzIHVsdHJhZmluZSBkdXN0XCJcclxuICB9LFxyXG4gIHtcclxuICAgIG1vZHVsZTogXCJNYWduZXRpYyBQYXJ0aWNsZSBDb2xsZWN0aW9uXCIsXHJcbiAgICBmdW5jdGlvbjogXCJFeHRyYWN0cyBtZXRhbGxpYyBwYXJ0aWNsZXMgdXNpbmcgZW1iZWRkZWQgbWFnbmV0c1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBtb2R1bGU6IFwiSEVQQSBGaWx0cmF0aW9uIFVuaXRcIixcclxuICAgIGZ1bmN0aW9uOiBcIlJlbW92ZXMgcmVzaWR1YWwgUE0yLjUgYW5kIFBNMTAgcGFydGljbGVzXCJcclxuICB9LFxyXG4gIHtcclxuICAgIG1vZHVsZTogXCJQb3dlciBTdXBwbHkgVW5pdFwiLFxyXG4gICAgZnVuY3Rpb246IFwiQmF0dGVyeSwgb25ib2FyZCBnZW5lcmF0b3IsIG9yIHJlZ2VuZXJhdGl2ZSBwb3dlclwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBtb2R1bGU6IFwiQ29udHJvbCBTeXN0ZW1cIixcclxuICAgIGZ1bmN0aW9uOiBcIkVtYmVkZGVkIFBMQyB0byBtb25pdG9yIGZsb3cgcmF0ZXMsIGZpbHRlciBjb25kaXRpb24sIGFuZCBkaWFnbm9zdGljc1wiXHJcbiAgfSxcclxuICB7XHJcbiAgICBtb2R1bGU6IFwiTW9kdWxhciBDaGFzc2lzXCIsXHJcbiAgICBmdW5jdGlvbjogXCJEZXNpZ25lZCB0byBpbnRlZ3JhdGUgd2l0aCBleGlzdGluZyBUZkwgcm9sbGluZyBzdG9jayBhbmQgbG9hZGluZyBnYXVnZXNcIlxyXG4gIH1cclxuXSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJBcnJvd1JpZ2h0SWNvbiIsIk5hdmlnYXRpb24iLCJJbWFnZSIsImFuaW1lIiwiSG9tZSIsInNob3dNYWluIiwic2V0U2hvd01haW4iLCJ0cmFuc2l0aW9uaW5nIiwic2V0VHJhbnNpdGlvbmluZyIsInZpc2libGVTZWN0aW9uIiwic2V0VmlzaWJsZVNlY3Rpb24iLCJvYnNlcnZlclJlZiIsImRvY3VtZW50IiwiYm9keSIsInN0eWxlIiwib3ZlcmZsb3ciLCJjdXJyZW50IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJ0YXJnZXQiLCJpZCIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwiYmciLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJ0aHJlc2hvbGQiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2VjdGlvbiIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiaGFuZGxlRmluZE91dE1vcmUiLCJ0YXJnZXRzIiwib3BhY2l0eSIsInRyYW5zbGF0ZVkiLCJkdXJhdGlvbiIsImVhc2luZyIsImRlbGF5Iiwic3RhZ2dlciIsImNvbXBsZXRlIiwiZGl2IiwiY2xhc3NOYW1lIiwidHJhbnNmb3JtIiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJwcmlvcml0eSIsInAiLCJidXR0b24iLCJvbkNsaWNrIiwibWluV2lkdGgiLCJoMiIsInVsIiwibGkiLCJjb21wb25lbnRzIiwibWFwIiwiY29tcG9uZW50IiwiaW5kZXgiLCJoMyIsIm1vZHVsZSIsImZ1bmN0aW9uIiwiYSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/animejs/lib/anime.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/animejs/lib/anime.esm.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animatable: function() { return /* binding */ Animatable; },\n/* harmony export */   Draggable: function() { return /* binding */ Draggable; },\n/* harmony export */   JSAnimation: function() { return /* binding */ JSAnimation; },\n/* harmony export */   Scope: function() { return /* binding */ Scope; },\n/* harmony export */   ScrollObserver: function() { return /* binding */ ScrollObserver; },\n/* harmony export */   Spring: function() { return /* binding */ Spring; },\n/* harmony export */   Timeline: function() { return /* binding */ Timeline; },\n/* harmony export */   Timer: function() { return /* binding */ Timer; },\n/* harmony export */   WAAPIAnimation: function() { return /* binding */ WAAPIAnimation; },\n/* harmony export */   animate: function() { return /* binding */ animate; },\n/* harmony export */   createAnimatable: function() { return /* binding */ createAnimatable; },\n/* harmony export */   createDraggable: function() { return /* binding */ createDraggable; },\n/* harmony export */   createScope: function() { return /* binding */ createScope; },\n/* harmony export */   createSpring: function() { return /* binding */ createSpring; },\n/* harmony export */   createTimeline: function() { return /* binding */ createTimeline; },\n/* harmony export */   createTimer: function() { return /* binding */ createTimer; },\n/* harmony export */   eases: function() { return /* binding */ eases; },\n/* harmony export */   engine: function() { return /* binding */ engine; },\n/* harmony export */   onScroll: function() { return /* binding */ onScroll; },\n/* harmony export */   scrollContainers: function() { return /* binding */ scrollContainers; },\n/* harmony export */   stagger: function() { return /* binding */ stagger; },\n/* harmony export */   svg: function() { return /* binding */ svg; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   waapi: function() { return /* binding */ waapi; }\n/* harmony export */ });\n/**\n * anime.js - ESM\n * @version v4.0.2\n * @author Julian Garnier\n * @license MIT\n * @copyright (c) 2025 Julian Garnier\n * @see https://animejs.com\n */ /**\n * @typedef {Object} DefaultsParams\n * @property {Number|String} [id]\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n * @property {Number} [playbackRate]\n * @property {Number} [frameRate]\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number|FunctionValue} [duration]\n * @property {Number|FunctionValue} [delay]\n * @property {Number} [loopDelay]\n * @property {EasingParam} [ease]\n * @property {'none'|'replace'|'blend'|compositionTypes} [composition]\n * @property {(v: any) => any} [modifier]\n * @property {(tickable: Tickable) => void} [onBegin]\n * @property {(tickable: Tickable) => void} [onBeforeUpdate]\n * @property {(tickable: Tickable) => void} [onUpdate]\n * @property {(tickable: Tickable) => void} [onLoop]\n * @property {(tickable: Tickable) => void} [onPause]\n * @property {(tickable: Tickable) => void} [onComplete]\n * @property {(renderable: Renderable) => void} [onRender]\n */ /** @typedef {JSAnimation|Timeline} Renderable */ /** @typedef {Timer|Renderable} Tickable */ /** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */ /** @typedef {Animatable|Tickable|Draggable|ScrollObserver|Scope} Revertible */ /**\n * @typedef {Object} DraggableAxisParam\n * @property {String} [mapTo]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n */ /**\n * @typedef {Object} DraggableCursorParams\n * @property {String} [onHover]\n * @property {String} [onGrab]\n */ /**\n * @typedef {Object} DraggableParams\n * @property {DOMTargetSelector} [trigger]\n * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]\n * @property {Boolean|DraggableAxisParam} [x]\n * @property {Boolean|DraggableAxisParam} [y]\n * @property {TweenModifier} [modifier]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]\n * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]\n * @property {Number|((draggable: Draggable) => Number)} [containerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]\n * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]\n * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]\n * @property {Number|((draggable: Draggable) => Number)} [minVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]\n * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]\n * @property {Number} [releaseMass]\n * @property {Number} [releaseStiffness]\n * @property {Number} [releaseDamping]\n * @property {Boolean} [releaseDamping]\n * @property {EasingParam} [releaseEase]\n * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]\n * @property {Callback<Draggable>} [onGrab]\n * @property {Callback<Draggable>} [onDrag]\n * @property {Callback<Draggable>} [onRelease]\n * @property {Callback<Draggable>} [onUpdate]\n * @property {Callback<Draggable>} [onSettle]\n * @property {Callback<Draggable>} [onSnap]\n * @property {Callback<Draggable>} [onResize]\n * @property {Callback<Draggable>} [onAfterResize]\n */ /**\n * @typedef {SVGGeometryElement & {\n *   setAttribute(name: 'draw', value: `${number} ${number}`): void;\n *   draw: `${number} ${number}`;\n * }} DrawableSVGGeometry\n */ /**\n * @callback EasingFunction\n * @param {Number} time\n * @return {Number}\n */ /**\n * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames\n */ // A hack to get both ease names suggestions AND allow any strings\n// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421\n/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */ /** @typedef {HTMLElement|SVGElement} DOMTarget */ /** @typedef {Record<String, any>} JSTarget */ /** @typedef {DOMTarget|JSTarget} Target */ /** @typedef {Target|NodeList|String} TargetSelector */ /** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */ /** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */ /** @typedef {Array.<DOMTarget>} DOMTargetsArray */ /** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */ /** @typedef {Array.<JSTarget>} JSTargetsArray */ /** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */ /** @typedef {Array.<Target>} TargetsArray */ /**\n * @callback FunctionValue\n * @param {Target} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}\n */ /**\n * @callback TweenModifier\n * @param {Number} value - The animated value\n * @return {Number|String}\n */ /** @typedef {[Number, Number, Number, Number]} ColorArray */ /**\n * @template T\n * @callback Callback\n * @param {T} self - Returns itself\n * @param {PointerEvent} [e]\n * @return {*}\n */ /**\n * @template {object} T\n * @typedef {Object} TickableCallbacks\n * @property {Callback<T>} [onBegin]\n * @property {Callback<T>} [onBeforeUpdate]\n * @property {Callback<T>} [onUpdate]\n * @property {Callback<T>} [onLoop]\n * @property {Callback<T>} [onPause]\n * @property {Callback<T>} [onComplete]\n */ /**\n * @template {object} T\n * @typedef {Object} RenderableCallbacks\n * @property {Callback<T>} [onRender]\n */ /**\n * @typedef {Object} Tween\n * @property {Number} id\n * @property {JSAnimation} parent\n * @property {String} property\n * @property {Target} target\n * @property {String|Number} _value\n * @property {Function|null} _func\n * @property {EasingFunction} _ease\n * @property {Array.<Number>} _fromNumbers\n * @property {Array.<Number>} _toNumbers\n * @property {Array.<String>} _strings\n * @property {Number} _fromNumber\n * @property {Number} _toNumber\n * @property {Array.<Number>} _numbers\n * @property {Number} _number\n * @property {String} _unit\n * @property {TweenModifier} _modifier\n * @property {Number} _currentTime\n * @property {Number} _delay\n * @property {Number} _updateDuration\n * @property {Number} _startTime\n * @property {Number} _changeDuration\n * @property {Number} _absoluteStartTime\n * @property {tweenTypes} _tweenType\n * @property {valueTypes} _valueType\n * @property {Number} _composition\n * @property {Number} _isOverlapped\n * @property {Number} _isOverridden\n * @property {Number} _renderTransforms\n * @property {Tween} _prevRep\n * @property {Tween} _nextRep\n * @property {Tween} _prevAdd\n * @property {Tween} _nextAdd\n * @property {Tween} _prev\n * @property {Tween} _next\n */ /**\n * @typedef TweenDecomposedValue\n * @property {Number} t - Type\n * @property {Number} n - Single number value\n * @property {String} u - Value unit\n * @property {String} o - Value operator\n * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)\n * @property {Array.<String>} s - Strings (in case of complex value type)\n */ /** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */ /** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */ /** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */ /** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */ /**\n * @typedef {Object} TimerOptions\n * @property {Number|String} [id]\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {Number} [loopDelay]\n * @property {Boolean} [reversed]\n * @property {Boolean} [alternate]\n * @property {Boolean|Number} [loop]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [frameRate]\n * @property {Number} [playbackRate]\n */ /**\n\n/**\n * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams\n */ /**\n * @typedef {Number|String|FunctionValue} TweenParamValue\n */ /**\n * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue\n */ /**\n * @typedef {(String & {})|'none'|'replace'|'blend'|compositionTypes} TweenComposition\n */ /**\n * @typedef {Object} TweenParamsOptions\n * @property {TweenParamValue} [duration]\n * @property {TweenParamValue} [delay]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */ /**\n * @typedef {Object} TweenValues\n * @property {TweenParamValue} [from]\n * @property {TweenPropValue} [to]\n * @property {TweenPropValue} [fromTo]\n */ /**\n * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue\n */ /**\n * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue\n */ /**\n * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions\n */ /**\n * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue\n */ /**\n * @typedef {Object} PercentageKeyframeOptions\n * @property {EasingParam} [ease]\n */ /**\n * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams\n */ /**\n * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes\n */ /**\n * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes\n */ /**\n * @typedef {Object} AnimationOptions\n * @property {PercentageKeyframes|DurationKeyframes} [keyframes]\n * @property {EasingParam} [playbackEase]\n */ // TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set\n/**\n * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams\n */ /**\n * @typedef {Object} TimelineOptions\n * @property {DefaultsParams} [defaults]\n * @property {EasingParam} [playbackEase]\n */ /**\n * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams\n */ /**\n * @callback AnimatablePropertySetter\n * @param  {Number|Array.<Number>} to\n * @param  {Number} [duration]\n * @param  {EasingParam} [ease]\n * @return {AnimatableObject}\n */ /**\n * @callback AnimatablePropertyGetter\n * @return {Number|Array.<Number>}\n */ /**\n * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty\n */ /**\n * @typedef {Animatable & Record<String, AnimatableProperty>} AnimatableObject\n */ /**\n * @typedef {Object} AnimatablePropertyParamsOptions\n * @property {String} [unit]\n * @property {TweenParamValue} [duration]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n * @property {TweenComposition} [composition]\n */ /**\n * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams\n */ // Environments\n// TODO: Do we need to check if we're running inside a worker ?\nconst isBrowser = \"object\" !== \"undefined\";\n/** @type {Object|Null} */ const win = isBrowser ? window : null;\n/** @type {Document} */ const doc = isBrowser ? document : null;\n// Enums\n/** @enum {Number} */ const tweenTypes = {\n    OBJECT: 0,\n    ATTRIBUTE: 1,\n    CSS: 2,\n    TRANSFORM: 3,\n    CSS_VAR: 4\n};\n/** @enum {Number} */ const valueTypes = {\n    NUMBER: 0,\n    UNIT: 1,\n    COLOR: 2,\n    COMPLEX: 3\n};\n/** @enum {Number} */ const tickModes = {\n    NONE: 0,\n    AUTO: 1,\n    FORCE: 2\n};\n/** @enum {Number} */ const compositionTypes = {\n    replace: 0,\n    none: 1,\n    blend: 2\n};\n// Cache symbols\nconst isRegisteredTargetSymbol = Symbol();\nconst isDomSymbol = Symbol();\nconst isSvgSymbol = Symbol();\nconst transformsSymbol = Symbol();\nconst morphPointsSymbol = Symbol();\nconst proxyTargetSymbol = Symbol();\n// Numbers\nconst minValue = 1e-11;\nconst maxValue = 1e12;\nconst K = 1e3;\nconst maxFps = 120;\n// Strings\nconst emptyString = \"\";\nconst shortTransforms = new Map();\nshortTransforms.set(\"x\", \"translateX\");\nshortTransforms.set(\"y\", \"translateY\");\nshortTransforms.set(\"z\", \"translateZ\");\nconst validTransforms = [\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"scaleZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n    \"perspective\",\n    \"matrix\",\n    \"matrix3d\"\n];\nconst transformsFragmentStrings = validTransforms.reduce((a, v)=>({\n        ...a,\n        [v]: v + \"(\"\n    }), {});\n// Functions\n/** @return {void} */ const noop = ()=>{};\n// Regex\nconst hexTestRgx = /(^#([\\da-f]{3}){1,2}$)|(^#([\\da-f]{4}){1,2}$)/i;\nconst rgbExecRgx = /rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i;\nconst rgbaExecRgx = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\nconst hslExecRgx = /hsl\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*\\)/i;\nconst hslaExecRgx = /hsla\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)\\s*\\)/i;\n// export const digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?/g;\nconst digitWithExponentRgx = /[-+]?\\d*\\.?\\d+(?:e[-+]?\\d)?/gi;\n// export const unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)+([a-z]+|%)$/i;\nconst unitsExecRgx = /^([-+]?\\d*\\.?\\d+(?:e[-+]?\\d+)?)([a-z]+|%)$/i;\nconst lowerCaseRgx = /([a-z])([A-Z])/g;\nconst transformsExecRgx = /(\\w+)(\\([^)]+\\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()\nconst relativeValuesExecRgx = /(\\*=|\\+=|-=)/;\n/** @type {DefaultsParams} */ const defaults = {\n    id: null,\n    keyframes: null,\n    playbackEase: null,\n    playbackRate: 1,\n    frameRate: maxFps,\n    loop: 0,\n    reversed: false,\n    alternate: false,\n    autoplay: true,\n    duration: K,\n    delay: 0,\n    loopDelay: 0,\n    ease: \"out(2)\",\n    composition: compositionTypes.replace,\n    modifier: (v)=>v,\n    onBegin: noop,\n    onBeforeUpdate: noop,\n    onUpdate: noop,\n    onLoop: noop,\n    onPause: noop,\n    onComplete: noop,\n    onRender: noop\n};\nconst globals = {\n    /** @type {DefaultsParams} */ defaults,\n    /** @type {Document|DOMTarget} */ root: doc,\n    /** @type {Scope} */ scope: null,\n    /** @type {Number} */ precision: 4,\n    /** @type {Number} */ timeScale: 1,\n    /** @type {Number} */ tickThreshold: 200\n};\nconst globalVersions = {\n    version: \"4.0.2\",\n    engine: null\n};\nif (isBrowser) {\n    if (!win.AnimeJS) win.AnimeJS = [];\n    win.AnimeJS.push(globalVersions);\n}\n// Strings\n/**\n * @param  {String} str\n * @return {String}\n */ const toLowerCase = (str)=>str.replace(lowerCaseRgx, \"$1-$2\").toLowerCase();\n/**\n * Prioritize this method instead of regex when possible\n * @param  {String} str\n * @param  {String} sub\n * @return {Boolean}\n */ const stringStartsWith = (str, sub)=>str.indexOf(sub) === 0;\n// Time\n// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.\nconst now = Date.now;\n// Types checkers\nconst isArr = Array.isArray;\n/**@param {any} a @return {a is Record<String, any>} */ const isObj = (a)=>a && a.constructor === Object;\n/**@param {any} a @return {a is Number} */ const isNum = (a)=>typeof a === \"number\" && !isNaN(a);\n/**@param {any} a @return {a is String} */ const isStr = (a)=>typeof a === \"string\";\n/**@param {any} a @return {a is Function} */ const isFnc = (a)=>typeof a === \"function\";\n/**@param {any} a @return {a is undefined} */ const isUnd = (a)=>typeof a === \"undefined\";\n/**@param {any} a @return {a is null | undefined} */ const isNil = (a)=>isUnd(a) || a === null;\n/**@param {any} a @return {a is SVGElement} */ const isSvg = (a)=>isBrowser && a instanceof SVGElement;\n/**@param {any} a @return {Boolean} */ const isHex = (a)=>hexTestRgx.test(a);\n/**@param {any} a @return {Boolean} */ const isRgb = (a)=>stringStartsWith(a, \"rgb\");\n/**@param {any} a @return {Boolean} */ const isHsl = (a)=>stringStartsWith(a, \"hsl\");\n/**@param {any} a @return {Boolean} */ const isCol = (a)=>isHex(a) || isRgb(a) || isHsl(a);\n/**@param {any} a @return {Boolean} */ const isKey = (a)=>!globals.defaults.hasOwnProperty(a);\n// Number\n/**\n * @param  {Number|String} str\n * @return {Number}\n */ const parseNumber = (str)=>isStr(str) ? parseFloat(/** @type {String} */ str) : /** @type {Number} */ str;\n// Math\nconst pow = Math.pow;\nconst sqrt = Math.sqrt;\nconst sin = Math.sin;\nconst cos = Math.cos;\nconst abs = Math.abs;\nconst exp = Math.exp;\nconst ceil = Math.ceil;\nconst floor = Math.floor;\nconst asin = Math.asin;\nconst max = Math.max;\nconst atan2 = Math.atan2;\nconst PI = Math.PI;\nconst _round = Math.round;\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */ const clamp = (v, min, max)=>v < min ? min : v > max ? max : v;\nconst powCache = {};\n/**\n * @param  {Number} v\n * @param  {Number} decimalLength\n * @return {Number}\n */ const round = (v, decimalLength)=>{\n    if (decimalLength < 0) return v;\n    if (!decimalLength) return _round(v);\n    let p = powCache[decimalLength];\n    if (!p) p = powCache[decimalLength] = 10 ** decimalLength;\n    return _round(v * p) / p;\n};\n/**\n * @param  {Number} v\n * @param  {Number|Array<Number>} increment\n * @return {Number}\n */ const snap = (v, increment)=>isArr(increment) ? increment.reduce((closest, cv)=>abs(cv - v) < abs(closest - v) ? cv : closest) : increment ? _round(v / increment) * increment : v;\n/**\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} progress\n * @return {Number}\n */ const interpolate = (start, end, progress)=>start + (end - start) * progress;\n/**\n * @param  {Number} v\n * @return {Number}\n */ const clampInfinity = (v)=>v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;\n/**\n * @param  {Number} v\n * @return {Number}\n */ const normalizeTime = (v)=>v <= minValue ? minValue : clampInfinity(round(v, 11));\n// Arrays\n/**\n * @template T\n * @param {T[]} a\n * @return {T[]}\n */ const cloneArray = (a)=>isArr(a) ? [\n        ...a\n    ] : a;\n// Objects\n/**\n * @template T\n * @template U\n * @param {T} o1\n * @param {U} o2\n * @return {T & U}\n */ const mergeObjects = (o1, o2)=>{\n    const merged = /** @type {T & U} */ {\n        ...o1\n    };\n    for(let p in o2){\n        const o1p = /** @type {T & U} */ o1[p];\n        merged[p] = isUnd(o1p) ? /** @type {T & U} */ o2[p] : o1p;\n    }\n    return merged;\n};\n// Linked lists\n/**\n * @param {Object} parent\n * @param {Function} callback\n * @param {Boolean} [reverse]\n * @param {String} [prevProp]\n * @param {String} [nextProp]\n * @return {void}\n */ const forEachChildren = function(parent, callback, reverse) {\n    let prevProp = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"_prev\", nextProp = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"_next\";\n    let next = parent._head;\n    let adjustedNextProp = nextProp;\n    if (reverse) {\n        next = parent._tail;\n        adjustedNextProp = prevProp;\n    }\n    while(next){\n        const currentNext = next[adjustedNextProp];\n        callback(next);\n        next = currentNext;\n    }\n};\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {String} [prevProp]\n * @param  {String} [nextProp]\n * @return {void}\n */ const removeChild = function(parent, child) {\n    let prevProp = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"_prev\", nextProp = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"_next\";\n    const prev = child[prevProp];\n    const next = child[nextProp];\n    prev ? prev[nextProp] = next : parent._head = next;\n    next ? next[prevProp] = prev : parent._tail = prev;\n    child[prevProp] = null;\n    child[nextProp] = null;\n};\n/**\n * @param  {Object} parent\n * @param  {Object} child\n * @param  {Function} [sortMethod]\n * @param  {String} prevProp\n * @param  {String} nextProp\n * @return {void}\n */ const addChild = function(parent, child, sortMethod) {\n    let prevProp = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"_prev\", nextProp = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"_next\";\n    let prev = parent._tail;\n    while(prev && sortMethod && sortMethod(prev, child))prev = prev[prevProp];\n    const next = prev ? prev[nextProp] : parent._head;\n    prev ? prev[nextProp] = child : parent._head = child;\n    next ? next[prevProp] = child : parent._tail = child;\n    child[prevProp] = prev;\n    child[nextProp] = next;\n};\n/*\n * Base class to control framerate and playback rate.\n * Inherited by Engine, Timer, Animation and Timeline.\n */ class Clock {\n    get fps() {\n        return this._fps;\n    }\n    set fps(frameRate) {\n        const previousFrameDuration = this._frameDuration;\n        const fr = +frameRate;\n        const fps = fr < minValue ? minValue : fr;\n        const frameDuration = round(K / fps, 0);\n        this._fps = fps;\n        this._frameDuration = frameDuration;\n        this._scheduledTime += frameDuration - previousFrameDuration;\n    }\n    get speed() {\n        return this._speed;\n    }\n    set speed(playbackRate) {\n        const pbr = +playbackRate;\n        this._speed = pbr < minValue ? minValue : pbr;\n    }\n    /**\n   * @param  {Number} time\n   * @return {tickModes}\n   */ requestTick(time) {\n        const scheduledTime = this._scheduledTime;\n        const elapsedTime = this._elapsedTime;\n        this._elapsedTime += time - elapsedTime;\n        // If the elapsed time is lower than the scheduled time\n        // this means not enough time has passed to hit one frameDuration\n        // so skip that frame\n        if (elapsedTime < scheduledTime) return tickModes.NONE;\n        const frameDuration = this._frameDuration;\n        const frameDelta = elapsedTime - scheduledTime;\n        // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.\n        // Skips ahead if the actual elapsed time is higher.\n        this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;\n        return tickModes.AUTO;\n    }\n    /**\n   * @param  {Number} time\n   * @return {Number}\n   */ computeDeltaTime(time) {\n        const delta = time - this._lastTime;\n        this.deltaTime = delta;\n        this._lastTime = time;\n        return delta;\n    }\n    /** @param {Number} [initTime] */ constructor(initTime = 0){\n        /** @type {Number} */ this.deltaTime = 0;\n        /** @type {Number} */ this._currentTime = initTime;\n        /** @type {Number} */ this._elapsedTime = initTime;\n        /** @type {Number} */ this._startTime = initTime;\n        /** @type {Number} */ this._lastTime = initTime;\n        /** @type {Number} */ this._scheduledTime = 0;\n        /** @type {Number} */ this._frameDuration = round(K / maxFps, 0);\n        /** @type {Number} */ this._fps = maxFps;\n        /** @type {Number} */ this._speed = 1;\n        /** @type {Boolean} */ this._hasChildren = false;\n        /** @type {Tickable|Tween} */ this._head = null;\n        /** @type {Tickable|Tween} */ this._tail = null;\n    }\n}\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {tickModes} tickMode\n * @return {Number}\n */ const render = (tickable, time, muteCallbacks, internalRender, tickMode)=>{\n    const parent = tickable.parent;\n    const duration = tickable.duration;\n    const completed = tickable.completed;\n    const iterationDuration = tickable.iterationDuration;\n    const iterationCount = tickable.iterationCount;\n    const _currentIteration = tickable._currentIteration;\n    const _loopDelay = tickable._loopDelay;\n    const _reversed = tickable._reversed;\n    const _alternate = tickable._alternate;\n    const _hasChildren = tickable._hasChildren;\n    const tickableDelay = tickable._delay;\n    const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime\n    const tickableEndTime = tickableDelay + iterationDuration;\n    const tickableAbsoluteTime = time - tickableDelay;\n    const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);\n    const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);\n    const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;\n    const isCurrentTimeAboveZero = tickableCurrentTime > 0;\n    const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;\n    const isSetter = duration <= minValue;\n    const forcedTick = tickMode === tickModes.FORCE;\n    let isOdd = 0;\n    let iterationElapsedTime = tickableAbsoluteTime;\n    // Render checks\n    // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer\n    let hasRendered = 0;\n    // Execute the \"expensive\" iterations calculations only when necessary\n    if (iterationCount > 1) {\n        // bitwise NOT operator seems to be generally faster than Math.floor() across browsers\n        const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));\n        tickable._currentIteration = clamp(currentIteration, 0, iterationCount);\n        // Prevent the iteration count to go above the max iterations when reaching the end of the animation\n        if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;\n        isOdd = tickable._currentIteration % 2;\n        iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;\n    }\n    // Checks if exactly one of _reversed and (_alternate && isOdd) is true\n    const isReversed = _reversed ^ (_alternate && isOdd);\n    const _ease = /** @type {Renderable} */ tickable._ease;\n    let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;\n    if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;\n    const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;\n    tickable._currentTime = tickableAbsoluteTime;\n    tickable._iterationTime = iterationTime;\n    tickable.backwards = isRunningBackwards;\n    if (isCurrentTimeAboveZero && !tickable.began) {\n        tickable.began = true;\n        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n            tickable.onBegin(/** @type {CallbackArgument} */ tickable);\n        }\n    } else if (tickableAbsoluteTime <= 0) {\n        tickable.began = false;\n    }\n    // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function\n    // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values\n    if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {\n        tickable.onLoop(/** @type {CallbackArgument} */ tickable);\n    }\n    if (forcedTick || tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime || // Normal render\n    time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state\n    time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state\n    ) || iterationTime >= tickableEndTime && tickablePrevTime !== duration || iterationTime <= tickableDelay && tickablePrevTime > 0 || time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation\n    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped\n    ) {\n        if (isCurrentTimeAboveZero) {\n            // Trigger onUpdate callback before rendering\n            tickable.computeDeltaTime(tickablePrevTime);\n            if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */ tickable);\n        }\n        // Start tweens rendering\n        if (!_hasChildren) {\n            // Time has jumped more than globals.tickThreshold so consider this tick manual\n            const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;\n            const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;\n            // Only Animation can have tweens, Timer returns undefined\n            let tween = /** @type {Tween} */ /** @type {JSAnimation} */ tickable._head;\n            let tweenTarget;\n            let tweenStyle;\n            let tweenTargetTransforms;\n            let tweenTargetTransformsProperties;\n            let tweenTransformsNeedUpdate = 0;\n            while(tween){\n                const tweenComposition = tween._composition;\n                const tweenCurrentTime = tween._currentTime;\n                const tweenChangeDuration = tween._changeDuration;\n                const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;\n                const tweenNextRep = tween._nextRep;\n                const tweenPrevRep = tween._prevRep;\n                const tweenHasComposition = tweenComposition !== compositionTypes.none;\n                if ((forcedRender || (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) && (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)) && (!tweenHasComposition || !tween._isOverridden && (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) && (!tweenNextRep || tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime) && (!tweenPrevRep || tweenPrevRep._isOverridden || absoluteTime >= tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration + tween._delay))) {\n                    const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);\n                    const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);\n                    const tweenModifier = tween._modifier;\n                    const tweenValueType = tween._valueType;\n                    const tweenType = tween._tweenType;\n                    const tweenIsObject = tweenType === tweenTypes.OBJECT;\n                    const tweenIsNumber = tweenValueType === valueTypes.NUMBER;\n                    // Only round the in-between frames values if the final value is a string\n                    const tweenPrecision = tweenIsNumber && tweenIsObject || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;\n                    // Recompose tween value\n                    /** @type {String|Number} */ let value;\n                    /** @type {Number} */ let number;\n                    if (tweenIsNumber) {\n                        value = number = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n                    } else if (tweenValueType === valueTypes.UNIT) {\n                        // Rounding the values speed up string composition\n                        number = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision));\n                        value = \"\".concat(number).concat(tween._unit);\n                    } else if (tweenValueType === valueTypes.COLOR) {\n                        const fn = tween._fromNumbers;\n                        const tn = tween._toNumbers;\n                        const r = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[0], tn[0], tweenProgress)), 0, 255), 0);\n                        const g = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[1], tn[1], tweenProgress)), 0, 255), 0);\n                        const b = round(clamp(/** @type {Number} */ tweenModifier(interpolate(fn[2], tn[2], tweenProgress)), 0, 255), 0);\n                        const a = clamp(/** @type {Number} */ tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision)), 0, 1);\n                        value = \"rgba(\".concat(r, \",\").concat(g, \",\").concat(b, \",\").concat(a, \")\");\n                        if (tweenHasComposition) {\n                            const ns = tween._numbers;\n                            ns[0] = r;\n                            ns[1] = g;\n                            ns[2] = b;\n                            ns[3] = a;\n                        }\n                    } else if (tweenValueType === valueTypes.COMPLEX) {\n                        value = tween._strings[0];\n                        for(let j = 0, l = tween._toNumbers.length; j < l; j++){\n                            const n = /** @type {Number} */ tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision));\n                            const s = tween._strings[j + 1];\n                            value += \"\".concat(s ? n + s : n);\n                            if (tweenHasComposition) {\n                                tween._numbers[j] = n;\n                            }\n                        }\n                    }\n                    // For additive tweens and Animatables\n                    if (tweenHasComposition) {\n                        tween._number = number;\n                    }\n                    if (!internalRender && tweenComposition !== compositionTypes.blend) {\n                        const tweenProperty = tween.property;\n                        tweenTarget = tween.target;\n                        if (tweenIsObject) {\n                            tweenTarget[tweenProperty] = value;\n                        } else if (tweenType === tweenTypes.ATTRIBUTE) {\n                            /** @type {DOMTarget} */ tweenTarget.setAttribute(tweenProperty, /** @type {String} */ value);\n                        } else {\n                            tweenStyle = /** @type {DOMTarget} */ tweenTarget.style;\n                            if (tweenType === tweenTypes.TRANSFORM) {\n                                if (tweenTarget !== tweenTargetTransforms) {\n                                    tweenTargetTransforms = tweenTarget;\n                                    // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.\n                                    tweenTargetTransformsProperties = tweenTarget[transformsSymbol];\n                                }\n                                tweenTargetTransformsProperties[tweenProperty] = value;\n                                tweenTransformsNeedUpdate = 1;\n                            } else if (tweenType === tweenTypes.CSS) {\n                                tweenStyle[tweenProperty] = value;\n                            } else if (tweenType === tweenTypes.CSS_VAR) {\n                                tweenStyle.setProperty(tweenProperty, /** @type {String} */ value);\n                            }\n                        }\n                        if (isCurrentTimeAboveZero) hasRendered = 1;\n                    } else {\n                        // Used for composing timeline tweens without having to do a real render\n                        tween._value = value;\n                    }\n                }\n                // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax\n                // to reduce memory usage on string composition\n                if (tweenTransformsNeedUpdate && tween._renderTransforms) {\n                    let str = emptyString;\n                    for(let key in tweenTargetTransformsProperties){\n                        str += \"\".concat(transformsFragmentStrings[key]).concat(tweenTargetTransformsProperties[key], \") \");\n                    }\n                    tweenStyle.transform = str;\n                    tweenTransformsNeedUpdate = 0;\n                }\n                tween = tween._next;\n            }\n            if (!muteCallbacks && hasRendered) {\n                /** @type {JSAnimation} */ tickable.onRender(/** @type {JSAnimation} */ tickable);\n            }\n        }\n        if (!muteCallbacks && isCurrentTimeAboveZero) {\n            tickable.onUpdate(/** @type {CallbackArgument} */ tickable);\n        }\n    }\n    // End tweens rendering\n    // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards\n    if (parent && isSetter) {\n        if (!muteCallbacks && (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed || isRunningBackwards && tickableAbsoluteTime <= minValue && completed)) {\n            tickable.onComplete(/** @type {CallbackArgument} */ tickable);\n            tickable.completed = !isRunningBackwards;\n        }\n    // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops\n    } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {\n        if (iterationCount === Infinity) {\n            // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer\n            tickable._startTime += tickable.duration;\n        } else if (tickable._currentIteration >= iterationCount - 1) {\n            // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick\n            tickable.paused = true;\n            if (!completed && !_hasChildren) {\n                // If the tickable has children, triggers onComplete() only when all children have completed in the tick function\n                tickable.completed = true;\n                if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {\n                    tickable.onComplete(/** @type {CallbackArgument} */ tickable);\n                    tickable._resolve(/** @type {CallbackArgument} */ tickable);\n                }\n            }\n        }\n    // Otherwise set the completed flag to false\n    } else {\n        tickable.completed = false;\n    }\n    // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?\n    return hasRendered;\n};\n/**\n * @param  {Tickable} tickable\n * @param  {Number} time\n * @param  {Number} muteCallbacks\n * @param  {Number} internalRender\n * @param  {Number} tickMode\n * @return {void}\n */ const tick = (tickable, time, muteCallbacks, internalRender, tickMode)=>{\n    const _currentIteration = tickable._currentIteration;\n    render(tickable, time, muteCallbacks, internalRender, tickMode);\n    if (tickable._hasChildren) {\n        const tl = /** @type {Timeline} */ tickable;\n        const tlIsRunningBackwards = tl.backwards;\n        const tlChildrenTime = internalRender ? time : tl._iterationTime;\n        const tlCildrenTickTime = now();\n        let tlChildrenHasRendered = 0;\n        let tlChildrenHaveCompleted = true;\n        // If the timeline has looped forward, we need to manually triggers children skipped callbacks\n        if (!internalRender && tl._currentIteration !== _currentIteration) {\n            const tlIterationDuration = tl.iterationDuration;\n            forEachChildren(tl, (/** @type {JSAnimation} */ child)=>{\n                if (!tlIsRunningBackwards) {\n                    // Force an internal render to trigger the callbacks if the child has not completed on loop\n                    if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {\n                        render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);\n                    }\n                    // Reset their began and completed flags to allow retrigering callbacks on the next iteration\n                    child.began = false;\n                    child.completed = false;\n                } else {\n                    const childDuration = child.duration;\n                    const childStartTime = child._offset + child._delay;\n                    const childEndTime = childStartTime + childDuration;\n                    // Triggers the onComplete callback on reverse for children on the edges of the timeline\n                    if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {\n                        child.onComplete(child);\n                    }\n                }\n            });\n            if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */ tl);\n        }\n        forEachChildren(tl, (/** @type {JSAnimation} */ child)=>{\n            const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds\n            const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;\n            tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);\n            if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;\n        }, tlIsRunningBackwards);\n        // Renders on timeline are triggered by its children so it needs to be set after rendering the children\n        if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */ tl);\n        // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end\n        if (tlChildrenHaveCompleted && tl._currentTime >= tl.duration) {\n            // Make sure the paused flag is false in case it has been skipped in the render function\n            tl.paused = true;\n            if (!tl.completed) {\n                tl.completed = true;\n                if (!muteCallbacks) {\n                    tl.onComplete(/** @type {CallbackArgument} */ tl);\n                    tl._resolve(/** @type {CallbackArgument} */ tl);\n                }\n            }\n        }\n    }\n};\nconst additive = {\n    animation: null,\n    update: noop\n};\n/**\n * @typedef AdditiveAnimation\n * @property {Number} duration\n * @property {Number} _offset\n * @property {Number} _delay\n * @property {Tween} _head\n * @property {Tween} _tail\n */ /**\n * @param  {TweenAdditiveLookups} lookups\n * @return {AdditiveAnimation}\n */ const addAdditiveAnimation = (lookups)=>{\n    let animation = additive.animation;\n    if (!animation) {\n        animation = {\n            duration: minValue,\n            computeDeltaTime: noop,\n            _offset: 0,\n            _delay: 0,\n            _head: null,\n            _tail: null\n        };\n        additive.animation = animation;\n        additive.update = ()=>{\n            lookups.forEach((propertyAnimation)=>{\n                for(let propertyName in propertyAnimation){\n                    const tweens = propertyAnimation[propertyName];\n                    const lookupTween = tweens._head;\n                    if (lookupTween) {\n                        const valueType = lookupTween._valueType;\n                        const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;\n                        let additiveValue = lookupTween._fromNumber;\n                        let tween = tweens._tail;\n                        while(tween && tween !== lookupTween){\n                            if (additiveValues) {\n                                for(let i = 0, l = tween._numbers.length; i < l; i++)additiveValues[i] += tween._numbers[i];\n                            } else {\n                                additiveValue += tween._number;\n                            }\n                            tween = tween._prevAdd;\n                        }\n                        lookupTween._toNumber = additiveValue;\n                        lookupTween._toNumbers = additiveValues;\n                    }\n                }\n            });\n            // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop\n            render(animation, 1, 1, 0, tickModes.FORCE);\n        };\n    }\n    return animation;\n};\nconst engineTickMethod = isBrowser ? requestAnimationFrame : setImmediate;\nconst engineCancelMethod = isBrowser ? cancelAnimationFrame : clearImmediate;\nclass Engine extends Clock {\n    update() {\n        const time = this._currentTime = now();\n        if (this.requestTick(time)) {\n            this.computeDeltaTime(time);\n            const engineSpeed = this._speed;\n            const engineFps = this._fps;\n            let activeTickable = /** @type {Tickable} */ this._head;\n            while(activeTickable){\n                const nextTickable = activeTickable._next;\n                if (!activeTickable.paused) {\n                    tick(activeTickable, (time - activeTickable._startTime) * activeTickable._speed * engineSpeed, 0, 0, activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO);\n                } else {\n                    removeChild(this, activeTickable);\n                    this._hasChildren = !!this._tail;\n                    activeTickable._running = false;\n                    if (activeTickable.completed && !activeTickable._cancelled) {\n                        activeTickable.cancel();\n                    }\n                }\n                activeTickable = nextTickable;\n            }\n            additive.update();\n        }\n    }\n    wake() {\n        if (this.useDefaultMainLoop && !this.reqId && !this.paused) {\n            this.reqId = engineTickMethod(tickEngine);\n        }\n        return this;\n    }\n    pause() {\n        this.paused = true;\n        return killEngine();\n    }\n    resume() {\n        if (!this.paused) return;\n        this.paused = false;\n        forEachChildren(this, (/** @type {Tickable} */ child)=>child.resetTime());\n        return this.wake();\n    }\n    // Getter and setter for speed\n    get speed() {\n        return this._speed * (globals.timeScale === 1 ? 1 : K);\n    }\n    set speed(playbackRate) {\n        this._speed = playbackRate * globals.timeScale;\n        forEachChildren(this, (/** @type {Tickable} */ child)=>child.speed = child._speed);\n    }\n    // Getter and setter for timeUnit\n    get timeUnit() {\n        return globals.timeScale === 1 ? \"ms\" : \"s\";\n    }\n    set timeUnit(unit) {\n        const secondsScale = 0.001;\n        const isSecond = unit === \"s\";\n        const newScale = isSecond ? secondsScale : 1;\n        if (globals.timeScale !== newScale) {\n            globals.timeScale = newScale;\n            globals.tickThreshold = 200 * newScale;\n            const scaleFactor = isSecond ? secondsScale : K;\n            /** @type {Number} */ this.defaults.duration *= scaleFactor;\n            this._speed *= scaleFactor;\n        }\n    }\n    // Getter and setter for precision\n    get precision() {\n        return globals.precision;\n    }\n    set precision(precision) {\n        globals.precision = precision;\n    }\n    /** @param {Number} [initTime] */ constructor(initTime){\n        super(initTime);\n        this.useDefaultMainLoop = true;\n        this.pauseOnDocumentHidden = true;\n        /** @type {DefaultsParams} */ this.defaults = defaults;\n        this.paused = isBrowser && doc.hidden ? true : false;\n        /** @type {Number|NodeJS.Immediate} */ this.reqId = null;\n    }\n}\nconst engine = /*#__PURE__*/ (()=>{\n    const engine = new Engine(now());\n    if (isBrowser) {\n        globalVersions.engine = engine;\n        doc.addEventListener(\"visibilitychange\", ()=>{\n            if (!engine.pauseOnDocumentHidden) return;\n            doc.hidden ? engine.pause() : engine.resume();\n        });\n    }\n    return engine;\n})();\nconst tickEngine = ()=>{\n    if (engine._head) {\n        engine.reqId = engineTickMethod(tickEngine);\n        engine.update();\n    } else {\n        engine.reqId = 0;\n    }\n};\nconst killEngine = ()=>{\n    engineCancelMethod(/** @type {NodeJS.Immediate & Number} */ engine.reqId);\n    engine.reqId = 0;\n    return engine;\n};\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */ const parseInlineTransforms = (target, propName, animationInlineStyles)=>{\n    const inlineTransforms = target.style.transform;\n    let inlinedStylesPropertyValue;\n    if (inlineTransforms) {\n        const cachedTransforms = target[transformsSymbol];\n        let t;\n        while(t = transformsExecRgx.exec(inlineTransforms)){\n            const inlinePropertyName = t[1];\n            // const inlinePropertyValue = t[2];\n            const inlinePropertyValue = t[2].slice(1, -1);\n            cachedTransforms[inlinePropertyName] = inlinePropertyValue;\n            if (inlinePropertyName === propName) {\n                inlinedStylesPropertyValue = inlinePropertyValue;\n                // Store the new parsed inline styles if animationInlineStyles is provided\n                if (animationInlineStyles) {\n                    animationInlineStyles[propName] = inlinePropertyValue;\n                }\n            }\n        }\n    }\n    return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue : stringStartsWith(propName, \"scale\") ? \"1\" : stringStartsWith(propName, \"rotate\") || stringStartsWith(propName, \"skew\") ? \"0deg\" : \"0px\";\n};\n/**\n * @param  {DOMTargetsParam|TargetsParam} v\n * @return {NodeList|HTMLCollection}\n */ function getNodeList(v) {\n    const n = isStr(v) ? globals.root.querySelectorAll(v) : v;\n    if (n instanceof NodeList || n instanceof HTMLCollection) return n;\n}\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */ function parseTargets(targets) {\n    if (isNil(targets)) return /** @type {TargetsArray} */ [];\n    if (isArr(targets)) {\n        const flattened = targets.flat(Infinity);\n        /** @type {TargetsArray} */ const parsed = [];\n        for(let i = 0, l = flattened.length; i < l; i++){\n            const item = flattened[i];\n            if (!isNil(item)) {\n                const nodeList = getNodeList(item);\n                if (nodeList) {\n                    for(let j = 0, jl = nodeList.length; j < jl; j++){\n                        const subItem = nodeList[j];\n                        if (!isNil(subItem)) {\n                            let isDuplicate = false;\n                            for(let k = 0, kl = parsed.length; k < kl; k++){\n                                if (parsed[k] === subItem) {\n                                    isDuplicate = true;\n                                    break;\n                                }\n                            }\n                            if (!isDuplicate) {\n                                parsed.push(subItem);\n                            }\n                        }\n                    }\n                } else {\n                    let isDuplicate = false;\n                    for(let j = 0, jl = parsed.length; j < jl; j++){\n                        if (parsed[j] === item) {\n                            isDuplicate = true;\n                            break;\n                        }\n                    }\n                    if (!isDuplicate) {\n                        parsed.push(item);\n                    }\n                }\n            }\n        }\n        return parsed;\n    }\n    if (!isBrowser) return /** @type {JSTargetsArray} */ [\n        targets\n    ];\n    const nodeList = getNodeList(targets);\n    if (nodeList) return /** @type {DOMTargetsArray} */ Array.from(nodeList);\n    return /** @type {TargetsArray} */ [\n        targets\n    ];\n}\n/**\n * @overload\n * @param  {DOMTargetsParam} targets\n * @return {DOMTargetsArray}\n *\n * @overload\n * @param  {JSTargetsParam} targets\n * @return {JSTargetsArray}\n *\n * @overload\n * @param  {TargetsParam} targets\n * @return {TargetsArray}\n *\n * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets\n */ function registerTargets(targets) {\n    const parsedTargetsArray = parseTargets(targets);\n    const parsedTargetsLength = parsedTargetsArray.length;\n    if (parsedTargetsLength) {\n        for(let i = 0; i < parsedTargetsLength; i++){\n            const target = parsedTargetsArray[i];\n            if (!target[isRegisteredTargetSymbol]) {\n                target[isRegisteredTargetSymbol] = true;\n                const isSvgType = isSvg(target);\n                const isDom = /** @type {DOMTarget} */ target.nodeType || isSvgType;\n                if (isDom) {\n                    target[isDomSymbol] = true;\n                    target[isSvgSymbol] = isSvgType;\n                    target[transformsSymbol] = {};\n                }\n            }\n        }\n    }\n    return parsedTargetsArray;\n}\n/**\n * @param  {TargetsParam} path\n * @return {SVGGeometryElement|undefined}\n */ const getPath = (path)=>{\n    const parsedTargets = parseTargets(path);\n    const $parsedSvg = /** @type {SVGGeometryElement} */ parsedTargets[0];\n    if (!$parsedSvg || !isSvg($parsedSvg)) return;\n    return $parsedSvg;\n};\n/**\n * @param  {TargetsParam} path2\n * @param  {Number} [precision]\n * @return {FunctionValue}\n */ const morphTo = function(path2) {\n    let precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .33;\n    return ($path1)=>{\n        const $path2 = /** @type {SVGGeometryElement} */ getPath(path2);\n        if (!$path2) return;\n        const isPath = $path1.tagName === \"path\";\n        const separator = isPath ? \" \" : \",\";\n        const previousPoints = $path1[morphPointsSymbol];\n        if (previousPoints) $path1.setAttribute(isPath ? \"d\" : \"points\", previousPoints);\n        let v1 = \"\", v2 = \"\";\n        if (!precision) {\n            v1 = $path1.getAttribute(isPath ? \"d\" : \"points\");\n            v2 = $path2.getAttribute(isPath ? \"d\" : \"points\");\n        } else {\n            const length1 = /** @type {SVGGeometryElement} */ $path1.getTotalLength();\n            const length2 = $path2.getTotalLength();\n            const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));\n            for(let i = 0; i < maxPoints; i++){\n                const t = i / (maxPoints - 1);\n                const pointOnPath1 = /** @type {SVGGeometryElement} */ $path1.getPointAtLength(length1 * t);\n                const pointOnPath2 = $path2.getPointAtLength(length2 * t);\n                const prefix = isPath ? i === 0 ? \"M\" : \"L\" : \"\";\n                v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + \" \";\n                v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + \" \";\n            }\n        }\n        $path1[morphPointsSymbol] = v2;\n        return [\n            v1,\n            v2\n        ];\n    };\n};\n/**\n * @param {SVGGeometryElement} [$el]\n * @return {Number}\n */ const getScaleFactor = ($el)=>{\n    let scaleFactor = 1;\n    if ($el && $el.getCTM) {\n        const ctm = $el.getCTM();\n        if (ctm) {\n            const scaleX = sqrt(ctm.a * ctm.a + ctm.b * ctm.b);\n            const scaleY = sqrt(ctm.c * ctm.c + ctm.d * ctm.d);\n            scaleFactor = (scaleX + scaleY) / 2;\n        }\n    }\n    return scaleFactor;\n};\n/**\n * Creates a proxy that wraps an SVGGeometryElement and adds drawing functionality.\n * @param {SVGGeometryElement} $el - The SVG element to transform into a drawable\n * @param {number} start - Starting position (0-1)\n * @param {number} end - Ending position (0-1)\n * @return {DrawableSVGGeometry} - Returns a proxy that preserves the original element's type with additional 'draw' attribute functionality\n */ const createDrawableProxy = ($el, start, end)=>{\n    const pathLength = K;\n    const computedStyles = getComputedStyle($el);\n    const strokeLineCap = computedStyles.strokeLinecap;\n    // @ts-ignore\n    const $scalled = computedStyles.vectorEffect === \"non-scaling-stroke\" ? $el : null;\n    let currentCap = strokeLineCap;\n    const proxy = new Proxy($el, {\n        get (target, property) {\n            const value = target[property];\n            if (property === proxyTargetSymbol) return target;\n            if (property === \"setAttribute\") {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (args[0] === \"draw\") {\n                        const value = args[1];\n                        const values = value.split(\" \");\n                        const v1 = +values[0];\n                        const v2 = +values[1];\n                        // TOTO: Benchmark if performing two slices is more performant than one split\n                        // const spaceIndex = value.indexOf(' ');\n                        // const v1 = round(+value.slice(0, spaceIndex), precision);\n                        // const v2 = round(+value.slice(spaceIndex + 1), precision);\n                        const scaleFactor = getScaleFactor($scalled);\n                        const os = v1 * -1e3 * scaleFactor;\n                        const d1 = v2 * pathLength * scaleFactor + os;\n                        const d2 = pathLength * scaleFactor + (v1 === 0 && v2 === 1 || v1 === 1 && v2 === 0 ? 0 : 10 * scaleFactor) - d1;\n                        if (strokeLineCap !== \"butt\") {\n                            const newCap = v1 === v2 ? \"butt\" : strokeLineCap;\n                            if (currentCap !== newCap) {\n                                target.style.strokeLinecap = \"\".concat(newCap);\n                                currentCap = newCap;\n                            }\n                        }\n                        target.setAttribute(\"stroke-dashoffset\", \"\".concat(os));\n                        target.setAttribute(\"stroke-dasharray\", \"\".concat(d1, \" \").concat(d2));\n                    }\n                    return Reflect.apply(value, target, args);\n                };\n            }\n            if (isFnc(value)) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    return Reflect.apply(value, target, args);\n                };\n            } else {\n                return value;\n            }\n        }\n    });\n    if ($el.getAttribute(\"pathLength\") !== \"\".concat(pathLength)) {\n        $el.setAttribute(\"pathLength\", \"\".concat(pathLength));\n        proxy.setAttribute(\"draw\", \"\".concat(start, \" \").concat(end));\n    }\n    return /** @type {DrawableSVGGeometry} */ proxy;\n};\n/**\n * Creates drawable proxies for multiple SVG elements.\n * @param {TargetsParam} selector - CSS selector, SVG element, or array of elements and selectors\n * @param {number} [start=0] - Starting position (0-1)\n * @param {number} [end=0] - Ending position (0-1)\n * @return {Array<DrawableSVGGeometry>} - Array of proxied elements with drawing functionality\n */ const createDrawable = function(selector) {\n    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    const els = parseTargets(selector);\n    return els.map(($el)=>createDrawableProxy(/** @type {SVGGeometryElement} */ $el, start, end));\n};\n// Motion path animation\n/**\n * @param {SVGGeometryElement} $path\n * @param {Number} progress\n * @param {Number}lookup\n * @return {DOMPoint}\n */ const getPathPoint = function($path, progress) {\n    let lookup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n    return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);\n};\n/**\n * @param {SVGGeometryElement} $path\n * @param {String} pathProperty\n * @return {FunctionValue}\n */ const getPathProgess = ($path, pathProperty)=>{\n    return ($el)=>{\n        const totalLength = +$path.getTotalLength();\n        const inSvg = $el[isSvgSymbol];\n        const ctm = $path.getCTM();\n        /** @type {TweenObjectValue} */ return {\n            from: 0,\n            to: totalLength,\n            /** @type {TweenModifier} */ modifier: (progress)=>{\n                if (pathProperty === \"a\") {\n                    const p0 = getPathPoint($path, progress, -1);\n                    const p1 = getPathPoint($path, progress, 1);\n                    return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;\n                } else {\n                    const p = getPathPoint($path, progress, 0);\n                    return pathProperty === \"x\" ? inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e : inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;\n                }\n            }\n        };\n    };\n};\n/**\n * @param {TargetsParam} path\n */ const createMotionPath = (path)=>{\n    const $path = getPath(path);\n    if (!$path) return;\n    return {\n        translateX: getPathProgess($path, \"x\"),\n        translateY: getPathProgess($path, \"y\"),\n        rotate: getPathProgess($path, \"a\")\n    };\n};\n// Check for valid SVG attribute\nconst cssReservedProperties = [\n    \"opacity\",\n    \"rotate\",\n    \"overflow\",\n    \"color\"\n];\n/**\n * @param  {Target} el\n * @param  {String} propertyName\n * @return {Boolean}\n */ const isValidSVGAttribute = (el, propertyName)=>{\n    // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform\n    if (cssReservedProperties.includes(propertyName)) return false;\n    if (el.getAttribute(propertyName) || propertyName in el) {\n        if (propertyName === \"scale\") {\n            const elParentNode = /** @type {SVGGeometryElement} */ /** @type {DOMTarget} */ el.parentNode;\n            // Only consider scale as a valid SVG attribute on filter element\n            return elParentNode && elParentNode.tagName === \"filter\";\n        }\n        return true;\n    }\n};\nconst svg = {\n    morphTo,\n    createMotionPath,\n    createDrawable\n};\n/**\n * RGB / RGBA Color value string -> RGBA values array\n * @param  {String} rgbValue\n * @return {ColorArray}\n */ const rgbToRgba = (rgbValue)=>{\n    const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);\n    const a = !isUnd(rgba[4]) ? +rgba[4] : 1;\n    return [\n        +rgba[1],\n        +rgba[2],\n        +rgba[3],\n        a\n    ];\n};\n/**\n * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array\n * @param  {String} hexValue\n * @return {ColorArray}\n */ const hexToRgba = (hexValue)=>{\n    const hexLength = hexValue.length;\n    const isShort = hexLength === 4 || hexLength === 5;\n    return [\n        +(\"0x\" + hexValue[1] + hexValue[isShort ? 1 : 2]),\n        +(\"0x\" + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),\n        +(\"0x\" + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),\n        hexLength === 5 || hexLength === 9 ? +(+(\"0x\" + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1\n    ];\n};\n/**\n * @param  {Number} p\n * @param  {Number} q\n * @param  {Number} t\n * @return {Number}\n */ const hue2rgb = (p, q, t)=>{\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    return t < 1 / 6 ? p + (q - p) * 6 * t : t < 1 / 2 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;\n};\n/**\n * HSL / HSLA Color value string -> RGBA values array\n * @param  {String} hslValue\n * @return {ColorArray}\n */ const hslToRgba = (hslValue)=>{\n    const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);\n    const h = +hsla[1] / 360;\n    const s = +hsla[2] / 100;\n    const l = +hsla[3] / 100;\n    const a = !isUnd(hsla[4]) ? +hsla[4] : 1;\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const q = l < .5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);\n        g = round(hue2rgb(p, q, h) * 255, 0);\n        b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);\n    }\n    return [\n        r,\n        g,\n        b,\n        a\n    ];\n};\n/**\n * All in one color converter that converts a color string value into an array of RGBA values\n * @param  {String} colorString\n * @return {ColorArray}\n */ const convertColorStringValuesToRgbaArray = (colorString)=>{\n    return isRgb(colorString) ? rgbToRgba(colorString) : isHex(colorString) ? hexToRgba(colorString) : isHsl(colorString) ? hslToRgba(colorString) : [\n        0,\n        0,\n        0,\n        1\n    ];\n};\n/**\n * @template T, D\n * @param {T|undefined} targetValue\n * @param {D} defaultValue\n * @return {T|D}\n */ const setValue = (targetValue, defaultValue)=>{\n    return isUnd(targetValue) ? defaultValue : targetValue;\n};\n/**\n * @param  {TweenPropValue} value\n * @param  {Target} target\n * @param  {Number} index\n * @param  {Number} total\n * @param  {Object} [store]\n * @return {any}\n */ const getFunctionValue = (value, target, index, total, store)=>{\n    if (isFnc(value)) {\n        const func = ()=>{\n            const computed = /** @type {Function} */ value(target, index, total);\n            // Fallback to 0 if the function returns undefined / NaN / null / false / 0\n            return !isNaN(+computed) ? +computed : computed || 0;\n        };\n        if (store) {\n            store.func = func;\n        }\n        return func();\n    } else {\n        return value;\n    }\n};\n/**\n * @param  {Target} target\n * @param  {String} prop\n * @return {tweenTypes}\n */ const getTweenType = (target, prop)=>{\n    return !target[isDomSymbol] ? tweenTypes.OBJECT : // Handle SVG attributes\n    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE : // Handle CSS Transform properties differently than CSS to allow individual animations\n    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM : // CSS variables\n    stringStartsWith(prop, \"--\") ? tweenTypes.CSS_VAR : // All other CSS properties\n    prop in /** @type {DOMTarget} */ target.style ? tweenTypes.CSS : // Handle other DOM Attributes\n    prop in target ? tweenTypes.OBJECT : tweenTypes.ATTRIBUTE;\n};\n/**\n * @param  {DOMTarget} target\n * @param  {String} propName\n * @param  {Object} animationInlineStyles\n * @return {String}\n */ const getCSSValue = (target, propName, animationInlineStyles)=>{\n    const inlineStyles = target.style[propName];\n    if (inlineStyles && animationInlineStyles) {\n        animationInlineStyles[propName] = inlineStyles;\n    }\n    const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);\n    return value === \"auto\" ? \"0\" : value;\n};\n/**\n * @param {Target} target\n * @param {String} propName\n * @param {tweenTypes} [tweenType]\n * @param {Object|void} [animationInlineStyles]\n * @return {String|Number}\n */ const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles)=>{\n    const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);\n    return type === tweenTypes.OBJECT ? target[propName] || 0 : type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */ target.getAttribute(propName) : type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */ target, propName, animationInlineStyles) : type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */ target, propName, animationInlineStyles).trimStart() : getCSSValue(/** @type {DOMTarget} */ target, propName, animationInlineStyles);\n};\n/**\n * @param  {Number} x\n * @param  {Number} y\n * @param  {String} operator\n * @return {Number}\n */ const getRelativeValue = (x, y, operator)=>{\n    return operator === \"-\" ? x - y : operator === \"+\" ? x + y : x * y;\n};\n/** @return {TweenDecomposedValue} */ const createDecomposedValueTargetObject = ()=>{\n    return {\n        /** @type {valueTypes} */ t: valueTypes.NUMBER,\n        n: 0,\n        u: null,\n        o: null,\n        d: null,\n        s: null\n    };\n};\n/**\n * @param  {String|Number} rawValue\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */ const decomposeRawValue = (rawValue, targetObject)=>{\n    /** @type {valueTypes} */ targetObject.t = valueTypes.NUMBER;\n    targetObject.n = 0;\n    targetObject.u = null;\n    targetObject.o = null;\n    targetObject.d = null;\n    targetObject.s = null;\n    if (!rawValue) return targetObject;\n    const num = +rawValue;\n    if (!isNaN(num)) {\n        // It's a number\n        targetObject.n = num;\n        return targetObject;\n    } else {\n        // let str = /** @type {String} */(rawValue).trim();\n        let str = /** @type {String} */ rawValue;\n        // Parsing operators (+=, -=, *=) manually is much faster than using regex here\n        if (str[1] === \"=\") {\n            targetObject.o = str[0];\n            str = str.slice(2);\n        }\n        // Skip exec regex if the value type is complex or color to avoid long regex backtracking\n        const unitMatch = str.includes(\" \") ? false : unitsExecRgx.exec(str);\n        if (unitMatch) {\n            // Has a number and a unit\n            targetObject.t = valueTypes.UNIT;\n            targetObject.n = +unitMatch[1];\n            targetObject.u = unitMatch[2];\n            return targetObject;\n        } else if (targetObject.o) {\n            // Has an operator (+=, -=, *=)\n            targetObject.n = +str;\n            return targetObject;\n        } else if (isCol(str)) {\n            // Is a color\n            targetObject.t = valueTypes.COLOR;\n            targetObject.d = convertColorStringValuesToRgbaArray(str);\n            return targetObject;\n        } else {\n            // Is a more complex string (generally svg coords, calc() or filters CSS values)\n            const matchedNumbers = str.match(digitWithExponentRgx);\n            targetObject.t = valueTypes.COMPLEX;\n            targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];\n            targetObject.s = str.split(digitWithExponentRgx) || [];\n            return targetObject;\n        }\n    }\n};\n/**\n * @param  {Tween} tween\n * @param  {TweenDecomposedValue} targetObject\n * @return {TweenDecomposedValue}\n */ const decomposeTweenValue = (tween, targetObject)=>{\n    targetObject.t = tween._valueType;\n    targetObject.n = tween._toNumber;\n    targetObject.u = tween._unit;\n    targetObject.o = null;\n    targetObject.d = cloneArray(tween._toNumbers);\n    targetObject.s = cloneArray(tween._strings);\n    return targetObject;\n};\nconst decomposedOriginalValue = createDecomposedValueTargetObject();\nconst lookups = {\n    /** @type {TweenReplaceLookups} */ _rep: new WeakMap(),\n    /** @type {TweenAdditiveLookups} */ _add: new Map()\n};\n/**\n * @param  {Target} target\n * @param  {String} property\n * @param  {String} lookup\n * @return {TweenPropertySiblings}\n */ const getTweenSiblings = function(target, property) {\n    let lookup = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"_rep\";\n    const lookupMap = lookups[lookup];\n    let targetLookup = lookupMap.get(target);\n    if (!targetLookup) {\n        targetLookup = {};\n        lookupMap.set(target, targetLookup);\n    }\n    return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {\n        _head: null,\n        _tail: null\n    };\n};\n/**\n * @param  {Tween} p\n * @param  {Tween} c\n * @return {Number|Boolean}\n */ const addTweenSortMethod = (p, c)=>{\n    return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;\n};\n/**\n * @param {Tween} tween\n */ const overrideTween = (tween)=>{\n    tween._isOverlapped = 1;\n    tween._isOverridden = 1;\n    tween._changeDuration = minValue;\n    tween._currentTime = minValue;\n};\n/**\n * @param  {Tween} tween\n * @param  {TweenPropertySiblings} siblings\n * @return {Tween}\n */ const composeTween = (tween, siblings)=>{\n    const tweenCompositionType = tween._composition;\n    // Handle replaced tweens\n    if (tweenCompositionType === compositionTypes.replace) {\n        const tweenAbsStartTime = tween._absoluteStartTime;\n        addChild(siblings, tween, addTweenSortMethod, \"_prevRep\", \"_nextRep\");\n        const prevSibling = tween._prevRep;\n        // Update the previous siblings for composition replace tweens\n        if (prevSibling) {\n            const prevParent = prevSibling.parent;\n            const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;\n            // Handle looped animations tween\n            if (// Check if the previous tween is from a different animation\n            tween.parent.id !== prevParent.id && // Check if the animation has loops\n            prevParent.iterationCount > 1 && // Check if _absoluteChangeEndTime of last loop overlaps the current tween\n            prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {\n                // TODO: Find a way to only override the iterations overlapping with the tween\n                overrideTween(prevSibling);\n                let prevPrevSibling = prevSibling._prevRep;\n                // If the tween was part of a set of keyframes, override its siblings\n                while(prevPrevSibling && prevPrevSibling.parent.id === prevParent.id){\n                    overrideTween(prevPrevSibling);\n                    prevPrevSibling = prevPrevSibling._prevRep;\n                }\n            }\n            const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;\n            if (prevAbsEndTime > absoluteUpdateStartTime) {\n                const prevChangeStartTime = prevSibling._startTime;\n                const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);\n                prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;\n                prevSibling._currentTime = prevSibling._changeDuration;\n                prevSibling._isOverlapped = 1;\n                if (prevSibling._changeDuration < minValue) {\n                    overrideTween(prevSibling);\n                }\n            }\n            // Pause (and cancel) the parent if it only contains overlapped tweens\n            let pausePrevParentAnimation = true;\n            forEachChildren(prevParent, (/** @type Tween */ t)=>{\n                if (!t._isOverlapped) pausePrevParentAnimation = false;\n            });\n            if (pausePrevParentAnimation) {\n                const prevParentTL = prevParent.parent;\n                if (prevParentTL) {\n                    let pausePrevParentTL = true;\n                    forEachChildren(prevParentTL, (/** @type JSAnimation */ a)=>{\n                        if (a !== prevParent) {\n                            forEachChildren(a, (/** @type Tween */ t)=>{\n                                if (!t._isOverlapped) pausePrevParentTL = false;\n                            });\n                        }\n                    });\n                    if (pausePrevParentTL) {\n                        prevParentTL.cancel();\n                    }\n                } else {\n                    prevParent.cancel();\n                // Previously, calling .cancel() on a timeline child would affect the render order of other children\n                // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop\n                // This is no longer needed since timeline tween composition is now handled separatly\n                // Keeping this here for reference\n                // prevParent.completed = true;\n                // prevParent.pause();\n                }\n            }\n        }\n    // let nextSibling = tween._nextRep;\n    // // All the next siblings are automatically overridden\n    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {\n    //   while (nextSibling) {\n    //     overrideTween(nextSibling);\n    //     console.log(tween.id, nextSibling.id);\n    //     nextSibling = nextSibling._nextRep;\n    //   }\n    // }\n    // Handle additive tweens composition\n    } else if (tweenCompositionType === compositionTypes.blend) {\n        const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, \"_add\");\n        const additiveAnimation = addAdditiveAnimation(lookups._add);\n        let lookupTween = additiveTweenSiblings._head;\n        if (!lookupTween) {\n            lookupTween = {\n                ...tween\n            };\n            lookupTween._composition = compositionTypes.replace;\n            lookupTween._updateDuration = minValue;\n            lookupTween._startTime = 0;\n            lookupTween._numbers = cloneArray(tween._fromNumbers);\n            lookupTween._number = 0;\n            lookupTween._next = null;\n            lookupTween._prev = null;\n            addChild(additiveTweenSiblings, lookupTween);\n            addChild(additiveAnimation, lookupTween);\n        }\n        // Convert the values of TO to FROM and set TO to 0\n        const toNumber = tween._toNumber;\n        tween._fromNumber = lookupTween._fromNumber - toNumber;\n        tween._toNumber = 0;\n        tween._numbers = cloneArray(tween._fromNumbers);\n        tween._number = 0;\n        lookupTween._fromNumber = toNumber;\n        if (tween._toNumbers) {\n            const toNumbers = cloneArray(tween._toNumbers);\n            if (toNumbers) {\n                toNumbers.forEach((value, i)=>{\n                    tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;\n                    tween._toNumbers[i] = 0;\n                });\n            }\n            lookupTween._fromNumbers = toNumbers;\n        }\n        addChild(additiveTweenSiblings, tween, null, \"_prevAdd\", \"_nextAdd\");\n    }\n    return tween;\n};\n/**\n * @param  {Tween} tween\n * @return {Tween}\n */ const removeTweenSliblings = (tween)=>{\n    const tweenComposition = tween._composition;\n    if (tweenComposition !== compositionTypes.none) {\n        const tweenTarget = tween.target;\n        const tweenProperty = tween.property;\n        const replaceTweensLookup = lookups._rep;\n        const replaceTargetProps = replaceTweensLookup.get(tweenTarget);\n        const tweenReplaceSiblings = replaceTargetProps[tweenProperty];\n        removeChild(tweenReplaceSiblings, tween, \"_prevRep\", \"_nextRep\");\n        if (tweenComposition === compositionTypes.blend) {\n            const addTweensLookup = lookups._add;\n            const addTargetProps = addTweensLookup.get(tweenTarget);\n            if (!addTargetProps) return;\n            const additiveTweenSiblings = addTargetProps[tweenProperty];\n            const additiveAnimation = additive.animation;\n            removeChild(additiveTweenSiblings, tween, \"_prevAdd\", \"_nextAdd\");\n            // If only one tween is left in the additive lookup, it's the tween lookup\n            const lookupTween = additiveTweenSiblings._head;\n            if (lookupTween && lookupTween === additiveTweenSiblings._tail) {\n                removeChild(additiveTweenSiblings, lookupTween, \"_prevAdd\", \"_nextAdd\");\n                removeChild(additiveAnimation, lookupTween);\n                let shouldClean = true;\n                for(let prop in addTargetProps){\n                    if (addTargetProps[prop]._head) {\n                        shouldClean = false;\n                        break;\n                    }\n                }\n                if (shouldClean) {\n                    addTweensLookup.delete(tweenTarget);\n                }\n            }\n        }\n    }\n    return tween;\n};\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */ const resetTimerProperties = (timer)=>{\n    timer.paused = true;\n    timer.began = false;\n    timer.completed = false;\n    return timer;\n};\n/**\n * @param  {Timer} timer\n * @return {Timer}\n */ const reviveTimer = (timer)=>{\n    if (!timer._cancelled) return timer;\n    if (timer._hasChildren) {\n        forEachChildren(timer, reviveTimer);\n    } else {\n        forEachChildren(timer, (/** @type {Tween} tween*/ tween)=>{\n            if (tween._composition !== compositionTypes.none) {\n                composeTween(tween, getTweenSiblings(tween.target, tween.property));\n            }\n        });\n    }\n    timer._cancelled = 0;\n    return timer;\n};\nlet timerId = 0;\n/**\n * Base class used to create Timers, Animations and Timelines\n */ class Timer extends Clock {\n    get cancelled() {\n        return !!this._cancelled;\n    }\n    /** @param {Boolean} cancelled  */ set cancelled(cancelled) {\n        cancelled ? this.cancel() : this.reset(1).play();\n    }\n    get currentTime() {\n        return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);\n    }\n    /** @param {Number} time  */ set currentTime(time) {\n        const paused = this.paused;\n        // Pausing the timer is necessary to avoid time jumps on a running instance\n        this.pause().seek(+time);\n        if (!paused) this.resume();\n    }\n    get iterationCurrentTime() {\n        return round(this._iterationTime, globals.precision);\n    }\n    /** @param {Number} time  */ set iterationCurrentTime(time) {\n        this.currentTime = this.iterationDuration * this._currentIteration + time;\n    }\n    get progress() {\n        return clamp(round(this._currentTime / this.duration, 5), 0, 1);\n    }\n    /** @param {Number} progress  */ set progress(progress) {\n        this.currentTime = this.duration * progress;\n    }\n    get iterationProgress() {\n        return clamp(round(this._iterationTime / this.iterationDuration, 5), 0, 1);\n    }\n    /** @param {Number} progress  */ set iterationProgress(progress) {\n        const iterationDuration = this.iterationDuration;\n        this.currentTime = iterationDuration * this._currentIteration + iterationDuration * progress;\n    }\n    get currentIteration() {\n        return this._currentIteration;\n    }\n    /** @param {Number} iterationCount  */ set currentIteration(iterationCount) {\n        this.currentTime = this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1);\n    }\n    get reversed() {\n        return !!this._reversed;\n    }\n    /** @param {Boolean} reverse  */ set reversed(reverse) {\n        reverse ? this.reverse() : this.play();\n    }\n    get speed() {\n        return super.speed;\n    }\n    /** @param {Number} playbackRate  */ set speed(playbackRate) {\n        super.speed = playbackRate;\n        this.resetTime();\n    }\n    /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */ reset() {\n        let internalRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings\n        reviveTimer(this);\n        if (this._reversed && !this._reverse) this.reversed = false;\n        // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden\n        // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order\n        // NOTE: This is only required for Timelines and might be better to move to the Timeline class?\n        this._iterationTime = this.iterationDuration;\n        // Set tickMode to tickModes.FORCE to force rendering\n        tick(this, 0, 1, internalRender, tickModes.FORCE);\n        // Reset timer properties after revive / render to make sure the props are not updated again\n        resetTimerProperties(this);\n        // Also reset children properties\n        if (this._hasChildren) {\n            forEachChildren(this, resetTimerProperties);\n        }\n        return this;\n    }\n    /**\n   * @param  {Number} internalRender\n   * @return {this}\n   */ init() {\n        let internalRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        this.fps = this._fps;\n        this.speed = this._speed;\n        // Manually calling .init() on timelines should render all children intial state\n        // Forces all children to render once then render to 0 when reseted\n        if (!internalRender && this._hasChildren) {\n            tick(this, this.duration, 1, internalRender, tickModes.FORCE);\n        }\n        this.reset(internalRender);\n        // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link\n        const autoplay = this._autoplay;\n        if (autoplay === true) {\n            this.resume();\n        } else if (autoplay && !isUnd(/** @type {ScrollObserver} */ autoplay.linked)) {\n            /** @type {ScrollObserver} */ autoplay.link(this);\n        }\n        return this;\n    }\n    /** @return {this} */ resetTime() {\n        const timeScale = 1 / (this._speed * engine._speed);\n        this._startTime = now() - (this._currentTime + this._delay) * timeScale;\n        return this;\n    }\n    /** @return {this} */ pause() {\n        if (this.paused) return this;\n        this.paused = true;\n        this.onPause(this);\n        return this;\n    }\n    /** @return {this} */ resume() {\n        if (!this.paused) return this;\n        this.paused = false;\n        // We can safely imediatly render a timer that has no duration and no children\n        if (this.duration <= minValue && !this._hasChildren) {\n            tick(this, minValue, 0, 0, tickModes.FORCE);\n        } else {\n            if (!this._running) {\n                addChild(engine, this);\n                engine._hasChildren = true;\n                this._running = true;\n            }\n            this.resetTime();\n            // Forces the timer to advance by at least one frame when the next tick occurs\n            this._startTime -= 12;\n            engine.wake();\n        }\n        return this;\n    }\n    /** @return {this} */ restart() {\n        return this.reset(0).resume();\n    }\n    /**\n   * @param  {Number} time\n   * @param  {Boolean|Number} [muteCallbacks]\n   * @param  {Boolean|Number} [internalRender]\n   * @return {this}\n   */ seek(time) {\n        let muteCallbacks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, internalRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        // Recompose the tween siblings in case the timer has been cancelled\n        reviveTimer(this);\n        // If you seek a completed animation, otherwise the next play will starts at 0\n        this.completed = false;\n        const isPaused = this.paused;\n        this.paused = true;\n        // timer, time, muteCallbacks, internalRender, tickMode\n        tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);\n        return isPaused ? this : this.resume();\n    }\n    /** @return {this} */ alternate() {\n        const reversed = this._reversed;\n        const count = this.iterationCount;\n        const duration = this.iterationDuration;\n        // Calculate the maximum iterations possible given the iteration duration\n        const iterations = count === Infinity ? floor(maxValue / duration) : count;\n        this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);\n        if (count === Infinity) {\n            // Handle infinite loops to loop on themself\n            this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;\n        } else {\n            this.seek(duration * iterations - this._currentTime);\n        }\n        this.resetTime();\n        return this;\n    }\n    /** @return {this} */ play() {\n        if (this._reversed) this.alternate();\n        return this.resume();\n    }\n    /** @return {this} */ reverse() {\n        if (!this._reversed) this.alternate();\n        return this.resume();\n    }\n    // TODO: Move all the animation / tweens / children related code to Animation / Timeline\n    /** @return {this} */ cancel() {\n        if (this._hasChildren) {\n            forEachChildren(this, (/** @type {Renderable} */ child)=>child.cancel(), true);\n        } else {\n            forEachChildren(this, removeTweenSliblings);\n        }\n        this._cancelled = 1;\n        // Pausing the timer removes it from the engine\n        return this.pause();\n    }\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        const normlizedDuration = normalizeTime(newDuration);\n        if (currentDuration === normlizedDuration) return this;\n        const timeScale = newDuration / currentDuration;\n        const isSetter = newDuration <= minValue;\n        this.duration = isSetter ? minValue : normlizedDuration;\n        this.iterationDuration = isSetter ? minValue : normalizeTime(this.iterationDuration * timeScale);\n        this._offset *= timeScale;\n        this._delay *= timeScale;\n        this._loopDelay *= timeScale;\n        return this;\n    }\n    /**\n   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary\n   * @return {this}\n   */ revert() {\n        tick(this, 0, 1, 0, tickModes.AUTO);\n        const ap = /** @type {ScrollObserver} */ this._autoplay;\n        if (ap && ap.linked && ap.linked === this) ap.revert();\n        return this.cancel();\n    }\n    /**\n   * Imediatly completes the timer, cancels it and triggers the onComplete callback\n   * @return {this}\n   */ complete() {\n        return this.seek(this.duration).cancel();\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then() {\n        let callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : noop;\n        const then = this.then;\n        const onResolve = ()=>{\n            // this.then = null prevents infinite recursion if returned by an async function\n            // https://github.com/juliangarnierorg/anime-beta/issues/26\n            this.then = null;\n            callback(this);\n            this.then = then;\n            this._resolve = noop;\n        };\n        return new Promise((r)=>{\n            this._resolve = ()=>r(onResolve());\n            // Make sure to resolve imediatly if the timer has already completed\n            if (this.completed) this._resolve();\n            return this;\n        });\n    }\n    /**\n   * @param {TimerParams} [parameters]\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   */ constructor(parameters = {}, parent = null, parentPosition = 0){\n        super(0);\n        const { id, delay, duration, reversed, alternate, loop, loopDelay, autoplay, frameRate, playbackRate, onComplete, onLoop, onPause, onBegin, onBeforeUpdate, onUpdate } = parameters;\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const timerInitTime = parent ? 0 : engine._elapsedTime;\n        const timerDefaults = parent ? parent.defaults : globals.defaults;\n        const timerDelay = /** @type {Number} */ isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay;\n        const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;\n        const timerLoop = setValue(loop, timerDefaults.loop);\n        const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);\n        const timerIterationCount = timerLoop === true || timerLoop === Infinity || /** @type {Number} */ timerLoop < 0 ? Infinity : /** @type {Number} */ timerLoop + 1;\n        let offsetPosition = 0;\n        if (parent) {\n            offsetPosition = parentPosition;\n        } else {\n            let startTime = now();\n            // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation\n            if (engine.paused) {\n                engine.requestTick(startTime);\n                startTime = engine._elapsedTime;\n            }\n            offsetPosition = startTime - engine._startTime;\n        }\n        // Timer's parameters\n        this.id = !isUnd(id) ? id : ++timerId;\n        /** @type {Timeline} */ this.parent = parent;\n        // Total duration of the timer\n        this.duration = clampInfinity((timerDuration + timerLoopDelay) * timerIterationCount - timerLoopDelay) || minValue;\n        /** @type {Boolean} */ this.backwards = false;\n        /** @type {Boolean} */ this.paused = true;\n        /** @type {Boolean} */ this.began = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Callback<this>} */ this.onBegin = onBegin || timerDefaults.onBegin;\n        /** @type {Callback<this>} */ this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;\n        /** @type {Callback<this>} */ this.onUpdate = onUpdate || timerDefaults.onUpdate;\n        /** @type {Callback<this>} */ this.onLoop = onLoop || timerDefaults.onLoop;\n        /** @type {Callback<this>} */ this.onPause = onPause || timerDefaults.onPause;\n        /** @type {Callback<this>} */ this.onComplete = onComplete || timerDefaults.onComplete;\n        /** @type {Number} */ this.iterationDuration = timerDuration; // Duration of one loop\n        /** @type {Number} */ this.iterationCount = timerIterationCount; // Number of loops\n        /** @type {Boolean|ScrollObserver} */ this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);\n        /** @type {Number} */ this._offset = offsetPosition;\n        /** @type {Number} */ this._delay = timerDelay;\n        /** @type {Number} */ this._loopDelay = timerLoopDelay;\n        /** @type {Number} */ this._iterationTime = 0;\n        /** @type {Number} */ this._currentIteration = 0; // Current loop index\n        /** @type {Function} */ this._resolve = noop; // Used by .then()\n        /** @type {Boolean} */ this._running = false;\n        /** @type {Number} */ this._reversed = +setValue(reversed, timerDefaults.reversed);\n        /** @type {Number} */ this._reverse = this._reversed;\n        /** @type {Number} */ this._cancelled = 0;\n        /** @type {Boolean} */ this._alternate = setValue(alternate, timerDefaults.alternate);\n        /** @type {Renderable} */ this._prev = null;\n        /** @type {Renderable} */ this._next = null;\n        // Clock's parameters\n        /** @type {Number} */ this._elapsedTime = timerInitTime;\n        /** @type {Number} */ this._startTime = timerInitTime;\n        /** @type {Number} */ this._lastTime = timerInitTime;\n        /** @type {Number} */ this._fps = setValue(frameRate, timerDefaults.frameRate);\n        /** @type {Number} */ this._speed = setValue(playbackRate, timerDefaults.playbackRate);\n    }\n}\n/**\n * @param {TimerParams} [parameters]\n * @return {Timer}\n */ const createTimer = (parameters)=>new Timer(parameters, null, 0).init();\n/** @type {EasingFunction} */ const none = (t)=>t;\n// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease © Gaëtan Renaudeau\n/**\n * @param  {Number} aT\n * @param  {Number} aA1\n * @param  {Number} aA2\n * @return {Number}\n */ const calcBezier = (aT, aA1, aA2)=>(((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + 3 * aA1) * aT;\n/**\n * @param  {Number} aX\n * @param  {Number} mX1\n * @param  {Number} mX2\n * @return {Number}\n */ const binarySubdivide = (aX, mX1, mX2)=>{\n    let aA = 0, aB = 1, currentX, currentT, i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (abs(currentX) > .0000001 && ++i < 100);\n    return currentT;\n};\n/**\n * @param  {Number} [mX1]\n * @param  {Number} [mY1]\n * @param  {Number} [mX2]\n * @param  {Number} [mY2]\n * @return {EasingFunction}\n */ const cubicBezier = function() {\n    let mX1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.5, mY1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.0, mX2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5, mY2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1.0;\n    return mX1 === mY1 && mX2 === mY2 ? none : (t)=>t === 0 || t === 1 ? t : calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);\n};\n/**\n * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function\n * Only covers 'end' and 'start' jumpterms\n * @param  {Number} steps\n * @param  {Boolean} [fromStart]\n * @return {EasingFunction}\n */ const steps = function() {\n    let steps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, fromStart = arguments.length > 1 ? arguments[1] : void 0;\n    const roundMethod = fromStart ? ceil : floor;\n    return (t)=>roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);\n};\n/**\n * Without parameters, the linear function creates a non-eased transition.\n * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.\n * @param  {...String|Number} [args] - Points\n * @return {EasingFunction}\n */ const linear = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    const argsLength = args.length;\n    if (!argsLength) return none;\n    const totalPoints = argsLength - 1;\n    const firstArg = args[0];\n    const lastArg = args[totalPoints];\n    const xPoints = [\n        0\n    ];\n    const yPoints = [\n        parseNumber(firstArg)\n    ];\n    for(let i = 1; i < totalPoints; i++){\n        const arg = args[i];\n        const splitValue = isStr(arg) ? /** @type {String} */ arg.trim().split(\" \") : [\n            arg\n        ];\n        const value = splitValue[0];\n        const percent = splitValue[1];\n        xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);\n        yPoints.push(parseNumber(value));\n    }\n    yPoints.push(parseNumber(lastArg));\n    xPoints.push(1);\n    return function easeLinear(t) {\n        for(let i = 1, l = xPoints.length; i < l; i++){\n            const currentX = xPoints[i];\n            if (t <= currentX) {\n                const prevX = xPoints[i - 1];\n                const prevY = yPoints[i - 1];\n                return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);\n            }\n        }\n        return yPoints[yPoints.length - 1];\n    };\n};\n/**\n * Generate random steps\n * @param  {Number} [length] - The number of steps\n * @param  {Number} [randomness] - How strong the randomness is\n * @return {EasingFunction}\n */ const irregular = function() {\n    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, randomness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n    const values = [\n        0\n    ];\n    const total = length - 1;\n    for(let i = 1; i < total; i++){\n        const previousValue = values[i - 1];\n        const spacing = i / total;\n        const segmentEnd = (i + 1) / total;\n        const randomVariation = spacing + (segmentEnd - spacing) * Math.random();\n        // Mix the even spacing and random variation based on the randomness parameter\n        const randomValue = spacing * (1 - randomness) + randomVariation * randomness;\n        values.push(clamp(randomValue, previousValue, 1));\n    }\n    values.push(1);\n    return linear(...values);\n};\n// Easing functions adapted from http://www.robertpenner.com/ease © Robert Penner\n/**\n * @callback PowerEasing\n * @param {Number|String} [power=1.675]\n * @return {EasingFunction}\n */ /**\n * @callback BackEasing\n * @param {Number|String} [overshoot=1.70158]\n * @return {EasingFunction}\n */ /**\n * @callback ElasticEasing\n * @param {Number|String} [amplitude=1]\n * @param {Number|String} [period=.3]\n * @return {EasingFunction}\n */ /**\n * @callback EaseFactory\n * @param {Number|String} [paramA]\n * @param {Number|String} [paramB]\n * @return {EasingFunction|Number}\n */ /** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */ const halfPI = PI / 2;\nconst doublePI = PI * 2;\n/** @type {PowerEasing} */ const easeInPower = function() {\n    let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1.68;\n    return (t)=>pow(t, +p);\n};\n/** @type {Record<String, EasesFactory|EasingFunction>} */ const easeInFunctions = {\n    [emptyString]: easeInPower,\n    Quad: easeInPower(2),\n    Cubic: easeInPower(3),\n    Quart: easeInPower(4),\n    Quint: easeInPower(5),\n    /** @type {EasingFunction} */ Sine: (t)=>1 - cos(t * halfPI),\n    /** @type {EasingFunction} */ Circ: (t)=>1 - sqrt(1 - t * t),\n    /** @type {EasingFunction} */ Expo: (t)=>t ? pow(2, 10 * t - 10) : 0,\n    /** @type {EasingFunction} */ Bounce: (t)=>{\n        let pow2, b = 4;\n        while(t < ((pow2 = pow(2, --b)) - 1) / 11);\n        return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);\n    },\n    /** @type {BackEasing} */ Back: function() {\n        let overshoot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1.70158;\n        return (t)=>(+overshoot + 1) * t * t * t - +overshoot * t * t;\n    },\n    /** @type {ElasticEasing} */ Elastic: function() {\n        let amplitude = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, period = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .3;\n        const a = clamp(+amplitude, 1, 10);\n        const p = clamp(+period, minValue, 2);\n        const s = p / doublePI * asin(1 / a);\n        const e = doublePI / p;\n        return (t)=>t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin((1 - t - s) * e);\n    }\n};\n/**\n * @callback EaseType\n * @param {EasingFunction} Ease\n * @return {EasingFunction}\n */ /** @type {Record<String, EaseType>} */ const easeTypes = {\n    in: (easeIn)=>(t)=>easeIn(t),\n    out: (easeIn)=>(t)=>1 - easeIn(1 - t),\n    inOut: (easeIn)=>(t)=>t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,\n    outIn: (easeIn)=>(t)=>t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2\n};\n/**\n * @param  {String} string\n * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions\n * @param  {Object} easesLookups\n * @return {EasingFunction}\n */ const parseEaseString = (string, easesFunctions, easesLookups)=>{\n    if (easesLookups[string]) return easesLookups[string];\n    if (string.indexOf(\"(\") <= -1) {\n        const hasParams = easeTypes[string] || string.includes(\"Back\") || string.includes(\"Elastic\");\n        const parsedFn = /** @type {EasingFunction} */ hasParams ? /** @type {EasesFactory} */ easesFunctions[string]() : easesFunctions[string];\n        return parsedFn ? easesLookups[string] = parsedFn : none;\n    } else {\n        const split = string.slice(0, -1).split(\"(\");\n        const parsedFn = /** @type {EasesFactory} */ easesFunctions[split[0]];\n        return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(\",\")) : none;\n    }\n};\n/**\n * @typedef  {Object} EasesFunctions\n * @property {typeof linear} linear\n * @property {typeof irregular} irregular\n * @property {typeof steps} steps\n * @property {typeof cubicBezier} cubicBezier\n * @property {PowerEasing} in\n * @property {PowerEasing} out\n * @property {PowerEasing} inOut\n * @property {PowerEasing} outIn\n * @property {EasingFunction} inQuad\n * @property {EasingFunction} outQuad\n * @property {EasingFunction} inOutQuad\n * @property {EasingFunction} outInQuad\n * @property {EasingFunction} inCubic\n * @property {EasingFunction} outCubic\n * @property {EasingFunction} inOutCubic\n * @property {EasingFunction} outInCubic\n * @property {EasingFunction} inQuart\n * @property {EasingFunction} outQuart\n * @property {EasingFunction} inOutQuart\n * @property {EasingFunction} outInQuart\n * @property {EasingFunction} inQuint\n * @property {EasingFunction} outQuint\n * @property {EasingFunction} inOutQuint\n * @property {EasingFunction} outInQuint\n * @property {EasingFunction} inSine\n * @property {EasingFunction} outSine\n * @property {EasingFunction} inOutSine\n * @property {EasingFunction} outInSine\n * @property {EasingFunction} inCirc\n * @property {EasingFunction} outCirc\n * @property {EasingFunction} inOutCirc\n * @property {EasingFunction} outInCirc\n * @property {EasingFunction} inExpo\n * @property {EasingFunction} outExpo\n * @property {EasingFunction} inOutExpo\n * @property {EasingFunction} outInExpo\n * @property {EasingFunction} inBounce\n * @property {EasingFunction} outBounce\n * @property {EasingFunction} inOutBounce\n * @property {EasingFunction} outInBounce\n * @property {BackEasing} inBack\n * @property {BackEasing} outBack\n * @property {BackEasing} inOutBack\n * @property {BackEasing} outInBack\n * @property {ElasticEasing} inElastic\n * @property {ElasticEasing} outElastic\n * @property {ElasticEasing} inOutElastic\n * @property {ElasticEasing} outInElastic\n */ const eases = /*#__PURE__*/ (()=>{\n    const list = {\n        linear,\n        irregular,\n        steps,\n        cubicBezier\n    };\n    for(let type in easeTypes){\n        for(let name in easeInFunctions){\n            const easeIn = easeInFunctions[name];\n            const easeType = easeTypes[type];\n            list[type + name] = /** @type {EasesFactory|EasingFunction} */ name === emptyString || name === \"Back\" || name === \"Elastic\" ? (a, b)=>easeType(/** @type {EasesFactory} */ easeIn(a, b)) : easeType(/** @type {EasingFunction} */ easeIn);\n        }\n    }\n    return /** @type {EasesFunctions} */ list;\n})();\n/** @type {Record<String, EasingFunction>} */ const JSEasesLookups = {\n    linear: none\n};\n/**\n * @param  {EasingParam} ease\n * @return {EasingFunction}\n */ const parseEasings = (ease)=>isFnc(ease) ? ease : isStr(ease) ? parseEaseString(/** @type {String} */ ease, eases, JSEasesLookups) : none;\nconst propertyNamesCache = {};\n/**\n * @param  {String} propertyName\n * @param  {Target} target\n * @param  {tweenTypes} tweenType\n * @return {String}\n */ const sanitizePropertyName = (propertyName, target, tweenType)=>{\n    if (tweenType === tweenTypes.TRANSFORM) {\n        const t = shortTransforms.get(propertyName);\n        return t ? t : propertyName;\n    } else if (tweenType === tweenTypes.CSS || // Handle special cases where properties like \"strokeDashoffset\" needs to be set as \"stroke-dashoffset\"\n    // but properties like \"baseFrequency\" should stay in lowerCamelCase\n    tweenType === tweenTypes.ATTRIBUTE && isSvg(target) && propertyName in /** @type {DOMTarget} */ target.style) {\n        const cachedPropertyName = propertyNamesCache[propertyName];\n        if (cachedPropertyName) {\n            return cachedPropertyName;\n        } else {\n            const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;\n            propertyNamesCache[propertyName] = lowerCaseName;\n            return lowerCaseName;\n        }\n    } else {\n        return propertyName;\n    }\n};\nconst angleUnitsMap = {\n    \"deg\": 1,\n    \"rad\": 180 / PI,\n    \"turn\": 360\n};\nconst convertedValuesCache = {};\n/**\n * @param  {DOMTarget} el\n * @param  {TweenDecomposedValue} decomposedValue\n * @param  {String} unit\n * @param  {Boolean} [force]\n * @return {TweenDecomposedValue}\n */ const convertValueUnit = function(el, decomposedValue, unit) {\n    let force = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const currentUnit = decomposedValue.u;\n    const currentNumber = decomposedValue.n;\n    if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) {\n        return decomposedValue;\n    }\n    const cachedKey = currentNumber + currentUnit + unit;\n    const cached = convertedValuesCache[cachedKey];\n    if (!isUnd(cached) && !force) {\n        decomposedValue.n = cached;\n    } else {\n        let convertedValue;\n        if (currentUnit in angleUnitsMap) {\n            convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];\n        } else {\n            const baseline = 100;\n            const tempEl = /** @type {DOMTarget} */ el.cloneNode();\n            const parentNode = el.parentNode;\n            const parentEl = parentNode && parentNode !== doc ? parentNode : doc.body;\n            parentEl.appendChild(tempEl);\n            const elStyle = tempEl.style;\n            elStyle.width = baseline + currentUnit;\n            const currentUnitWidth = /** @type {HTMLElement} */ tempEl.offsetWidth || baseline;\n            elStyle.width = baseline + unit;\n            const newUnitWidth = /** @type {HTMLElement} */ tempEl.offsetWidth || baseline;\n            const factor = currentUnitWidth / newUnitWidth;\n            parentEl.removeChild(tempEl);\n            convertedValue = factor * currentNumber;\n        }\n        decomposedValue.n = convertedValue;\n        convertedValuesCache[cachedKey] = convertedValue;\n    }\n    decomposedValue.t === valueTypes.UNIT;\n    decomposedValue.u = unit;\n    return decomposedValue;\n};\n/**\n * @template {Renderable} T\n * @param {T} renderable\n * @return {T}\n */ const cleanInlineStyles = (renderable)=>{\n    // Allow cleanInlineStyles() to be called on timelines\n    if (renderable._hasChildren) {\n        forEachChildren(renderable, cleanInlineStyles, true);\n    } else {\n        const animation = /** @type {JSAnimation} */ renderable;\n        animation.pause();\n        forEachChildren(animation, (/** @type {Tween} */ tween)=>{\n            const tweenProperty = tween.property;\n            const tweenTarget = tween.target;\n            if (tweenTarget[isDomSymbol]) {\n                const targetStyle = /** @type {DOMTarget} */ tweenTarget.style;\n                const originalInlinedValue = animation._inlineStyles[tweenProperty];\n                if (tween._tweenType === tweenTypes.TRANSFORM) {\n                    const cachedTransforms = tweenTarget[transformsSymbol];\n                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n                        delete cachedTransforms[tweenProperty];\n                    } else {\n                        cachedTransforms[tweenProperty] = originalInlinedValue;\n                    }\n                    if (tween._renderTransforms) {\n                        if (!Object.keys(cachedTransforms).length) {\n                            targetStyle.removeProperty(\"transform\");\n                        } else {\n                            let str = emptyString;\n                            for(let key in cachedTransforms){\n                                str += transformsFragmentStrings[key] + cachedTransforms[key] + \") \";\n                            }\n                            targetStyle.transform = str;\n                        }\n                    }\n                } else {\n                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {\n                        targetStyle.removeProperty(tweenProperty);\n                    } else {\n                        targetStyle[tweenProperty] = originalInlinedValue;\n                    }\n                }\n                if (animation._tail === tween) {\n                    animation.targets.forEach((t)=>{\n                        if (t.getAttribute && t.getAttribute(\"style\") === emptyString) {\n                            t.removeAttribute(\"style\");\n                        }\n                    });\n                }\n            }\n        });\n    }\n    return renderable;\n};\n// Defines decomposed values target objects only once and mutate their properties later to avoid GC\n// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object\nconst fromTargetObject = createDecomposedValueTargetObject();\nconst toTargetObject = createDecomposedValueTargetObject();\nconst toFunctionStore = {\n    func: null\n};\nconst keyframesTargetArray = [\n    null\n];\nconst fastSetValuesArray = [\n    null,\n    null\n];\n/** @type {TweenKeyValue} */ const keyObjectTarget = {\n    to: null\n};\nlet tweenId = 0;\nlet keyframes;\n/** @type {TweenParamsOptions & TweenValues} */ let key;\n/**\n * @param {DurationKeyframes | PercentageKeyframes} keyframes\n * @param {AnimationParams} parameters\n * @return {AnimationParams}\n */ const generateKeyframes = (keyframes, parameters)=>{\n    /** @type {AnimationParams} */ const properties = {};\n    if (isArr(keyframes)) {\n        const propertyNames = [].concat(.../** @type {DurationKeyframes} */ keyframes.map((key)=>Object.keys(key))).filter(isKey);\n        for(let i = 0, l = propertyNames.length; i < l; i++){\n            const propName = propertyNames[i];\n            const propArray = /** @type {DurationKeyframes} */ keyframes.map((key)=>{\n                /** @type {TweenKeyValue} */ const newKey = {};\n                for(let p in key){\n                    const keyValue = /** @type {TweenPropValue} */ key[p];\n                    if (isKey(p)) {\n                        if (p === propName) {\n                            newKey.to = keyValue;\n                        }\n                    } else {\n                        newKey[p] = keyValue;\n                    }\n                }\n                return newKey;\n            });\n            properties[propName] = /** @type {ArraySyntaxValue} */ propArray;\n        }\n    } else {\n        const totalDuration = /** @type {Number} */ setValue(parameters.duration, globals.defaults.duration);\n        const keys = Object.keys(keyframes).map((key)=>{\n            return {\n                o: parseFloat(key) / 100,\n                p: keyframes[key]\n            };\n        }).sort((a, b)=>a.o - b.o);\n        keys.forEach((key)=>{\n            const offset = key.o;\n            const prop = key.p;\n            for(let name in prop){\n                if (isKey(name)) {\n                    let propArray = /** @type {Array} */ properties[name];\n                    if (!propArray) propArray = properties[name] = [];\n                    const duration = offset * totalDuration;\n                    let length = propArray.length;\n                    let prevKey = propArray[length - 1];\n                    const keyObj = {\n                        to: prop[name]\n                    };\n                    let durProgress = 0;\n                    for(let i = 0; i < length; i++){\n                        durProgress += propArray[i].duration;\n                    }\n                    if (length === 1) {\n                        keyObj.from = prevKey.to;\n                    }\n                    if (prop.ease) {\n                        keyObj.ease = prop.ease;\n                    }\n                    keyObj.duration = duration - (length ? durProgress : 0);\n                    propArray.push(keyObj);\n                }\n            }\n            return key;\n        });\n        for(let name in properties){\n            const propArray = /** @type {Array} */ properties[name];\n            let prevEase;\n            // let durProgress = 0\n            for(let i = 0, l = propArray.length; i < l; i++){\n                const prop = propArray[i];\n                // Emulate WAPPI easing parameter position\n                const currentEase = prop.ease;\n                prop.ease = prevEase ? prevEase : undefined;\n                prevEase = currentEase;\n            // durProgress += prop.duration;\n            // if (i === l - 1 && durProgress !== totalDuration) {\n            //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })\n            // }\n            }\n            if (!propArray[0].duration) {\n                propArray.shift();\n            }\n        }\n    }\n    return properties;\n};\nclass JSAnimation extends Timer {\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        if (currentDuration === normalizeTime(newDuration)) return this;\n        const timeScale = newDuration / currentDuration;\n        // NOTE: Find a better way to handle the stretch of an animation after stretch = 0\n        forEachChildren(this, (/** @type {Tween} */ tween)=>{\n            // Rounding is necessary here to minimize floating point errors\n            tween._updateDuration = normalizeTime(tween._updateDuration * timeScale);\n            tween._changeDuration = normalizeTime(tween._changeDuration * timeScale);\n            tween._currentTime *= timeScale;\n            tween._startTime *= timeScale;\n            tween._absoluteStartTime *= timeScale;\n        });\n        return super.stretch(newDuration);\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        forEachChildren(this, (/** @type {Tween} */ tween)=>{\n            const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);\n            decomposeRawValue(ogValue, decomposedOriginalValue);\n            tween._fromNumbers = cloneArray(decomposedOriginalValue.d);\n            tween._fromNumber = decomposedOriginalValue.n;\n            if (tween._func) {\n                decomposeRawValue(tween._func(), toTargetObject);\n                tween._toNumbers = cloneArray(toTargetObject.d);\n                tween._strings = cloneArray(toTargetObject.s);\n                tween._toNumber = toTargetObject.n;\n            }\n        });\n        return this;\n    }\n    /**\n   * Cancel the animation and revert all the values affected by this animation to their original state\n   * @return {this}\n   */ revert() {\n        super.revert();\n        return cleanInlineStyles(this);\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then(callback) {\n        return super.then(callback);\n    }\n    /**\n   * @param {TargetsParam} targets\n   * @param {AnimationParams} parameters\n   * @param {Timeline} [parent]\n   * @param {Number} [parentPosition]\n   * @param {Boolean} [fastSet=false]\n   * @param {Number} [index=0]\n   * @param {Number} [length=0]\n   */ constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0){\n        super(/** @type {TimerParams&AnimationParams} */ parameters, parent, parentPosition);\n        const parsedTargets = registerTargets(targets);\n        const targetsLength = parsedTargets.length;\n        // If the parameters object contains a \"keyframes\" property, convert all the keyframes values to regular properties\n        const kfParams = /** @type {AnimationParams} */ parameters.keyframes;\n        const params = /** @type {AnimationParams} */ kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */ kfParams, parameters), parameters) : parameters;\n        const { delay, duration, ease, playbackEase, modifier, composition, onRender } = params;\n        const animDefaults = parent ? parent.defaults : globals.defaults;\n        const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);\n        const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;\n        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ ease.ease);\n        const tEasing = hasSpring ? /** @type {Spring} */ ease.ease : setValue(ease, animEase ? \"linear\" : animDefaults.ease);\n        const tDuration = hasSpring ? /** @type {Spring} */ ease.duration : setValue(duration, animDefaults.duration);\n        const tDelay = setValue(delay, animDefaults.delay);\n        const tModifier = modifier || animDefaults.modifier;\n        // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation\n        const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;\n        // TODO: Do not create an empty object until we know the animation will generate inline styles\n        const animInlineStyles = {};\n        // const absoluteOffsetTime = this._offset;\n        const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);\n        let iterationDuration = NaN;\n        let iterationDelay = NaN;\n        let animationAnimationLength = 0;\n        let shouldTriggerRender = 0;\n        for(let targetIndex = 0; targetIndex < targetsLength; targetIndex++){\n            const target = parsedTargets[targetIndex];\n            const ti = index || targetIndex;\n            const tl = length || targetsLength;\n            let lastTransformGroupIndex = NaN;\n            let lastTransformGroupLength = NaN;\n            for(let p in params){\n                if (isKey(p)) {\n                    const tweenType = getTweenType(target, p);\n                    const propName = sanitizePropertyName(p, target, tweenType);\n                    let propValue = params[p];\n                    const isPropValueArray = isArr(propValue);\n                    if (fastSet && !isPropValueArray) {\n                        fastSetValuesArray[0] = propValue;\n                        fastSetValuesArray[1] = propValue;\n                        propValue = fastSetValuesArray;\n                    }\n                    // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })\n                    // Normalize property values to valid keyframe syntax:\n                    // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]\n                    // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];\n                    if (isPropValueArray) {\n                        const arrayLength = /** @type {Array} */ propValue.length;\n                        const isNotObjectValue = !isObj(propValue[0]);\n                        // Convert [x, y] to [{to: [x, y]}]\n                        if (arrayLength === 2 && isNotObjectValue) {\n                            keyObjectTarget.to = /** @type {unknown} */ propValue;\n                            keyframesTargetArray[0] = keyObjectTarget;\n                            keyframes = keyframesTargetArray;\n                        // Convert [x, y, z] to [[x, y], z]\n                        } else if (arrayLength > 2 && isNotObjectValue) {\n                            keyframes = [];\n                            /** @type {Array.<Number>} */ propValue.forEach((v, i)=>{\n                                if (!i) {\n                                    fastSetValuesArray[0] = v;\n                                } else if (i === 1) {\n                                    fastSetValuesArray[1] = v;\n                                    keyframes.push(fastSetValuesArray);\n                                } else {\n                                    keyframes.push(v);\n                                }\n                            });\n                        } else {\n                            keyframes = /** @type {Array.<TweenKeyValue>} */ propValue;\n                        }\n                    } else {\n                        keyframesTargetArray[0] = propValue;\n                        keyframes = keyframesTargetArray;\n                    }\n                    let siblings = null;\n                    let prevTween = null;\n                    let firstTweenChangeStartTime = NaN;\n                    let lastTweenChangeEndTime = 0;\n                    let tweenIndex = 0;\n                    for(let l = keyframes.length; tweenIndex < l; tweenIndex++){\n                        const keyframe = keyframes[tweenIndex];\n                        if (isObj(keyframe)) {\n                            key = keyframe;\n                        } else {\n                            keyObjectTarget.to = /** @type {TweenParamValue} */ keyframe;\n                            key = keyObjectTarget;\n                        }\n                        toFunctionStore.func = null;\n                        const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);\n                        let tweenToValue;\n                        // Allows function based values to return an object syntax value ({to: v})\n                        if (isObj(computedToValue) && !isUnd(computedToValue.to)) {\n                            key = computedToValue;\n                            tweenToValue = computedToValue.to;\n                        } else {\n                            tweenToValue = computedToValue;\n                        }\n                        const tweenFromValue = getFunctionValue(key.from, target, ti, tl);\n                        const keyEasing = key.ease;\n                        const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */ keyEasing.ease);\n                        // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time\n                        const tweenEasing = hasSpring ? /** @type {Spring} */ keyEasing.ease : keyEasing || tEasing;\n                        // Calculate default individual keyframe duration by dividing the tl of keyframes\n                        const tweenDuration = hasSpring ? /** @type {Spring} */ keyEasing.duration : getFunctionValue(setValue(key.duration, l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration), target, ti, tl);\n                        // Default delay value should only be applied to the first tween\n                        const tweenDelay = getFunctionValue(setValue(key.delay, !tweenIndex ? tDelay : 0), target, ti, tl);\n                        const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);\n                        const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];\n                        // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper\n                        const tweenModifier = key.modifier || tModifier;\n                        const hasFromvalue = !isUnd(tweenFromValue);\n                        const hasToValue = !isUnd(tweenToValue);\n                        const isFromToArray = isArr(tweenToValue);\n                        const isFromToValue = isFromToArray || hasFromvalue && hasToValue;\n                        const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;\n                        const absoluteStartTime = absoluteOffsetTime + tweenStartTime;\n                        // Force a onRender callback if the animation contains at least one from value and autoplay is set to false\n                        if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;\n                        let prevSibling = prevTween;\n                        if (tweenComposition !== compositionTypes.none) {\n                            if (!siblings) siblings = getTweenSiblings(target, propName);\n                            let nextSibling = siblings._head;\n                            // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time\n                            while(nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime){\n                                prevSibling = nextSibling;\n                                nextSibling = nextSibling._nextRep;\n                                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time\n                                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {\n                                    while(nextSibling){\n                                        overrideTween(nextSibling);\n                                        // This will ends both the current while loop and the upper one once all the next sibllings have been overriden\n                                        nextSibling = nextSibling._nextRep;\n                                    }\n                                }\n                            }\n                        }\n                        // Decompose values\n                        if (isFromToValue) {\n                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);\n                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);\n                            if (fromTargetObject.t === valueTypes.NUMBER) {\n                                if (prevSibling) {\n                                    if (prevSibling._valueType === valueTypes.UNIT) {\n                                        fromTargetObject.t = valueTypes.UNIT;\n                                        fromTargetObject.u = prevSibling._unit;\n                                    }\n                                } else {\n                                    decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue);\n                                    if (decomposedOriginalValue.t === valueTypes.UNIT) {\n                                        fromTargetObject.t = valueTypes.UNIT;\n                                        fromTargetObject.u = decomposedOriginalValue.u;\n                                    }\n                                }\n                            }\n                        } else {\n                            if (hasToValue) {\n                                decomposeRawValue(tweenToValue, toTargetObject);\n                            } else {\n                                if (prevTween) {\n                                    decomposeTweenValue(prevTween, toTargetObject);\n                                } else {\n                                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);\n                                }\n                            }\n                            if (hasFromvalue) {\n                                decomposeRawValue(tweenFromValue, fromTargetObject);\n                            } else {\n                                if (prevTween) {\n                                    decomposeTweenValue(prevTween, fromTargetObject);\n                                } else {\n                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value : // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline\n                                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);\n                                }\n                            }\n                        }\n                        // Apply operators\n                        if (fromTargetObject.o) {\n                            fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);\n                        }\n                        if (toTargetObject.o) {\n                            toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);\n                        }\n                        // Values omogenisation in cases of type difference between \"from\" and \"to\"\n                        if (fromTargetObject.t !== toTargetObject.t) {\n                            if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {\n                                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;\n                                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;\n                                notComplexValue.t = valueTypes.COMPLEX;\n                                notComplexValue.s = cloneArray(complexValue.s);\n                                notComplexValue.d = complexValue.d.map(()=>notComplexValue.n);\n                            } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {\n                                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;\n                                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;\n                                notUnitValue.t = valueTypes.UNIT;\n                                notUnitValue.u = unitValue.u;\n                            } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {\n                                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;\n                                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;\n                                notColorValue.t = valueTypes.COLOR;\n                                notColorValue.s = colorValue.s;\n                                notColorValue.d = [\n                                    0,\n                                    0,\n                                    0,\n                                    1\n                                ];\n                            }\n                        }\n                        // Unit conversion\n                        if (fromTargetObject.u !== toTargetObject.u) {\n                            let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;\n                            valueToConvert = convertValueUnit(/** @type {DOMTarget} */ target, valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);\n                        // TODO:\n                        // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);\n                        }\n                        // Fill in non existing complex values\n                        if (toTargetObject.d && fromTargetObject.d && toTargetObject.d.length !== fromTargetObject.d.length) {\n                            const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;\n                            const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;\n                            // TODO: Check if n should be used instead of 0 for default complex values\n                            shortestValue.d = longestValue.d.map((_, i)=>isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);\n                            shortestValue.s = cloneArray(longestValue.s);\n                        }\n                        // Tween factory\n                        // Rounding is necessary here to minimize floating point errors\n                        const tweenUpdateDuration = round(+tweenDuration || minValue, 12);\n                        /** @type {Tween} */ const tween = {\n                            parent: this,\n                            id: tweenId++,\n                            property: propName,\n                            target: target,\n                            _value: null,\n                            _func: toFunctionStore.func,\n                            _ease: parseEasings(tweenEasing),\n                            _fromNumbers: cloneArray(fromTargetObject.d),\n                            _toNumbers: cloneArray(toTargetObject.d),\n                            _strings: cloneArray(toTargetObject.s),\n                            _fromNumber: fromTargetObject.n,\n                            _toNumber: toTargetObject.n,\n                            _numbers: cloneArray(fromTargetObject.d),\n                            _number: fromTargetObject.n,\n                            _unit: toTargetObject.u,\n                            _modifier: tweenModifier,\n                            _currentTime: 0,\n                            _startTime: tweenStartTime,\n                            _delay: +tweenDelay,\n                            _updateDuration: tweenUpdateDuration,\n                            _changeDuration: tweenUpdateDuration,\n                            _absoluteStartTime: absoluteStartTime,\n                            // NOTE: Investigate bit packing to stores ENUM / BOOL\n                            _tweenType: tweenType,\n                            _valueType: toTargetObject.t,\n                            _composition: tweenComposition,\n                            _isOverlapped: 0,\n                            _isOverridden: 0,\n                            _renderTransforms: 0,\n                            _prevRep: null,\n                            _nextRep: null,\n                            _prevAdd: null,\n                            _nextAdd: null,\n                            _prev: null,\n                            _next: null\n                        };\n                        if (tweenComposition !== compositionTypes.none) {\n                            composeTween(tween, siblings);\n                        }\n                        if (isNaN(firstTweenChangeStartTime)) {\n                            firstTweenChangeStartTime = tween._startTime;\n                        }\n                        // Rounding is necessary here to minimize floating point errors\n                        lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);\n                        prevTween = tween;\n                        animationAnimationLength++;\n                        addChild(this, tween);\n                    }\n                    // Update animation timings with the added tweens properties\n                    if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {\n                        iterationDelay = firstTweenChangeStartTime;\n                    }\n                    if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {\n                        iterationDuration = lastTweenChangeEndTime;\n                    }\n                    // TODO: Find a way to inline tween._renderTransforms = 1 here\n                    if (tweenType === tweenTypes.TRANSFORM) {\n                        lastTransformGroupIndex = animationAnimationLength - tweenIndex;\n                        lastTransformGroupLength = animationAnimationLength;\n                    }\n                }\n            }\n            // Set _renderTransforms to last transform property to correctly render the transforms list\n            if (!isNaN(lastTransformGroupIndex)) {\n                let i = 0;\n                forEachChildren(this, (/** @type {Tween} */ tween)=>{\n                    if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {\n                        tween._renderTransforms = 1;\n                        if (tween._composition === compositionTypes.blend) {\n                            forEachChildren(additive.animation, (/** @type {Tween} */ additiveTween)=>{\n                                if (additiveTween.id === tween.id) {\n                                    additiveTween._renderTransforms = 1;\n                                }\n                            });\n                        }\n                    }\n                    i++;\n                });\n            }\n        }\n        if (!targetsLength) {\n            console.warn(\"No target found. Make sure the element you're trying to animate is accessible before creating your animation.\");\n        }\n        if (iterationDelay) {\n            forEachChildren(this, (/** @type {Tween} */ tween)=>{\n                // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too\n                if (!(tween._startTime - tween._delay)) {\n                    tween._delay -= iterationDelay;\n                }\n                tween._startTime -= iterationDelay;\n            });\n            iterationDuration -= iterationDelay;\n        } else {\n            iterationDelay = 0;\n        }\n        // Prevents iterationDuration to be NaN if no valid animatable props have been provided\n        // Prevents _iterationCount to be NaN if no valid animatable props have been provided\n        if (!iterationDuration) {\n            iterationDuration = minValue;\n            this.iterationCount = 0;\n        }\n        /** @type {TargetsArray} */ this.targets = parsedTargets;\n        /** @type {Number} */ this.duration = iterationDuration === minValue ? minValue : clampInfinity((iterationDuration + this._loopDelay) * this.iterationCount - this._loopDelay) || minValue;\n        /** @type {Callback<this>} */ this.onRender = onRender || animDefaults.onRender;\n        /** @type {EasingFunction} */ this._ease = animEase;\n        /** @type {Number} */ this._delay = iterationDelay;\n        // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.\n        // this._delay = parent ? 0 : iterationDelay;\n        // this._offset += parent ? iterationDelay : 0;\n        /** @type {Number} */ this.iterationDuration = iterationDuration;\n        /** @type {{}} */ this._inlineStyles = animInlineStyles;\n        if (!this._autoplay && shouldTriggerRender) this.onRender(this);\n    }\n}\n/**\n * @param {TargetsParam} targets\n * @param {AnimationParams} parameters\n * @return {JSAnimation}\n */ const animate = (targets, parameters)=>new JSAnimation(targets, parameters, null, 0, false).init();\n/**\n * Converts an easing function into a valid CSS linear() timing function string\n * @param {EasingFunction} fn\n * @param {number} [samples=100]\n * @returns {string} CSS linear() timing function\n */ const easingToLinear = function(fn) {\n    let samples = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n    const points = [];\n    for(let i = 0; i <= samples; i++)points.push(fn(i / samples));\n    return \"linear(\".concat(points.join(\", \"), \")\");\n};\nconst WAAPIEasesLookups = {\n    in: \"ease-in\",\n    out: \"ease-out\",\n    inOut: \"ease-in-out\"\n};\nconst WAAPIeases = /*#__PURE__*/ (()=>{\n    const list = {};\n    for(let type in easeTypes)list[type] = (a)=>easeTypes[type](easeInPower(a));\n    return /** @type {Record<String, EasingFunction>} */ list;\n})();\n/**\n * @param  {EasingParam} ease\n * @return {String}\n */ const parseWAAPIEasing = (ease)=>{\n    let parsedEase = WAAPIEasesLookups[ease];\n    if (parsedEase) return parsedEase;\n    parsedEase = \"linear\";\n    if (isStr(ease)) {\n        if (stringStartsWith(ease, \"linear\") || stringStartsWith(ease, \"cubic-\") || stringStartsWith(ease, \"steps\") || stringStartsWith(ease, \"ease\")) {\n            parsedEase = ease;\n        } else if (stringStartsWith(ease, \"cubicB\")) {\n            parsedEase = toLowerCase(ease);\n        } else {\n            const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);\n            if (isFnc(parsed)) parsedEase = parsed === none ? \"linear\" : easingToLinear(parsed);\n        }\n        WAAPIEasesLookups[ease] = parsedEase;\n    } else if (isFnc(ease)) {\n        const easing = easingToLinear(ease);\n        if (easing) parsedEase = easing;\n    } else if (/** @type {Spring} */ ease.ease) {\n        parsedEase = easingToLinear(/** @type {Spring} */ ease.ease);\n    }\n    return parsedEase;\n};\n/**\n * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue\n */ /**\n * @callback WAAPIFunctionvalue\n * @param {DOMTarget} target - The animated target\n * @param {Number} index - The target index\n * @param {Number} length - The total number of animated targets\n * @return {WAAPITweenValue}\n */ /**\n * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue\n */ /**\n * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback\n */ /**\n * @typedef {Object} WAAPITweenOptions\n * @property {WAAPIKeyframeValue} [to]\n * @property {WAAPIKeyframeValue} [from]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n */ /**\n * @typedef {Object} WAAPIAnimationOptions\n * @property {Number|Boolean} [loop]\n * @property {Boolean} [Reversed]\n * @property {Boolean} [Alternate]\n * @property {Boolean|ScrollObserver} [autoplay]\n * @property {Number} [playbackRate]\n * @property {Number|WAAPIFunctionvalue} [duration]\n * @property {Number|WAAPIFunctionvalue} [delay]\n * @property {EasingParam} [ease]\n * @property {CompositeOperation} [composition]\n * @property {WAAPICallback} [onComplete]\n */ /**\n * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams\n */ const transformsShorthands = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nconst commonDefaultPXProperties = [\n    \"perspective\",\n    \"width\",\n    \"height\",\n    \"margin\",\n    \"padding\",\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\",\n    \"borderWidth\",\n    \"fontSize\",\n    \"borderRadius\",\n    ...transformsShorthands\n];\nconst validIndividualTransforms = [\n    ...transformsShorthands,\n    ...validTransforms.filter((t)=>[\n            \"X\",\n            \"Y\",\n            \"Z\"\n        ].some((axis)=>t.endsWith(axis)))\n];\n// Setting it to true in case CSS.registerProperty is not supported will automatically skip the registration and fallback to no animation\nlet transformsPropertiesRegistered = isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, \"registerProperty\"));\nconst registerTransformsProperties = ()=>{\n    if (transformsPropertiesRegistered) return;\n    validTransforms.forEach((t)=>{\n        const isSkew = stringStartsWith(t, \"skew\");\n        const isScale = stringStartsWith(t, \"scale\");\n        const isRotate = stringStartsWith(t, \"rotate\");\n        const isTranslate = stringStartsWith(t, \"translate\");\n        const isAngle = isRotate || isSkew;\n        const syntax = isAngle ? \"<angle>\" : isScale ? \"<number>\" : isTranslate ? \"<length-percentage>\" : \"*\";\n        try {\n            CSS.registerProperty({\n                name: \"--\" + t,\n                syntax,\n                inherits: false,\n                initialValue: isTranslate ? \"0px\" : isAngle ? \"0deg\" : isScale ? \"1\" : \"0\"\n            });\n        } catch (e) {}\n    });\n    transformsPropertiesRegistered = true;\n};\nconst WAAPIAnimationsLookups = {\n    _head: null,\n    _tail: null\n};\n/**\n * @param {DOMTarget} $el\n * @param {String} [property]\n * @param {WAAPIAnimation} [parent]\n */ const removeWAAPIAnimation = ($el, property, parent)=>{\n    let nextLookup = WAAPIAnimationsLookups._head;\n    while(nextLookup){\n        const next = nextLookup._next;\n        const matchTarget = nextLookup.$el === $el;\n        const matchProperty = !property || nextLookup.property === property;\n        const matchParent = !parent || nextLookup.parent === parent;\n        if (matchTarget && matchProperty && matchParent) {\n            const anim = nextLookup.animation;\n            try {\n                anim.commitStyles();\n            } catch (e) {}\n            anim.cancel();\n            removeChild(WAAPIAnimationsLookups, nextLookup);\n            const lookupParent = nextLookup.parent;\n            if (lookupParent) {\n                lookupParent._completed++;\n                if (lookupParent.animations.length === lookupParent._completed) {\n                    lookupParent.completed = true;\n                    if (!lookupParent.muteCallbacks) {\n                        lookupParent.paused = true;\n                        lookupParent.onComplete(lookupParent);\n                        lookupParent._resolve(lookupParent);\n                    }\n                }\n            }\n        }\n        nextLookup = next;\n    }\n};\n/**\n * @param {WAAPIAnimation} parent\n * @param {DOMTarget} $el\n * @param {String} property\n * @param {PropertyIndexedKeyframes} keyframes\n * @param {KeyframeAnimationOptions} params\n * @retun {Animation}\n */ const addWAAPIAnimation = (parent, $el, property, keyframes, params)=>{\n    const animation = $el.animate(keyframes, params);\n    const animTotalDuration = params.delay + +params.duration * params.iterations;\n    animation.playbackRate = parent._speed;\n    if (parent.paused) animation.pause();\n    if (parent.duration < animTotalDuration) {\n        parent.duration = animTotalDuration;\n        parent.controlAnimation = animation;\n    }\n    parent.animations.push(animation);\n    removeWAAPIAnimation($el, property);\n    addChild(WAAPIAnimationsLookups, {\n        parent,\n        animation,\n        $el,\n        property,\n        _next: null,\n        _prev: null\n    });\n    const handleRemove = ()=>{\n        removeWAAPIAnimation($el, property, parent);\n    };\n    animation.onremove = handleRemove;\n    animation.onfinish = handleRemove;\n    return animation;\n};\n/**\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} value\n * @param  {DOMTarget} $el\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {String}\n */ const normalizeTweenValue = (propName, value, $el, i, targetsLength)=>{\n    let v = getFunctionValue(/** @type {any} */ value, $el, i, targetsLength);\n    if (!isNum(v)) return v;\n    if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, \"translate\")) return \"\".concat(v, \"px\");\n    if (stringStartsWith(propName, \"rotate\") || stringStartsWith(propName, \"skew\")) return \"\".concat(v, \"deg\");\n    return \"\".concat(v);\n};\n/**\n * @param  {DOMTarget} $el\n * @param  {String} propName\n * @param  {WAAPIKeyframeValue} from\n * @param  {WAAPIKeyframeValue} to\n * @param  {Number} i\n * @param  {Number} targetsLength\n * @return {WAAPITweenValue}\n */ const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength)=>{\n    /** @type {WAAPITweenValue} */ let tweenValue = \"0\";\n    const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];\n    if (!isUnd(from)) {\n        const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);\n        tweenValue = [\n            computedFrom,\n            computedTo\n        ];\n    } else {\n        tweenValue = isArr(to) ? to.map((/** @type {any} */ v)=>normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;\n    }\n    return tweenValue;\n};\nclass WAAPIAnimation {\n    /**\n   * @callback forEachCallback\n   * @param {globalThis.Animation} animation\n   */ /**\n   * @param  {forEachCallback|String} callback\n   * @return {this}\n   */ forEach(callback) {\n        const cb = isStr(callback) ? (a)=>a[callback]() : callback;\n        this.animations.forEach(cb);\n        return this;\n    }\n    get speed() {\n        return this._speed;\n    }\n    /** @param {Number} speed */ set speed(speed) {\n        this._speed = +speed;\n        this.forEach((anim)=>anim.playbackRate = speed);\n    }\n    get currentTime() {\n        const controlAnimation = this.controlAnimation;\n        const timeScale = globals.timeScale;\n        return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;\n    }\n    /** @param {Number} time */ set currentTime(time) {\n        const t = time * (globals.timeScale === 1 ? 1 : K);\n        this.forEach((anim)=>{\n            // Make sure the animation playState is not 'paused' in order to properly trigger an onfinish callback.\n            // The \"paused\" play state supersedes the \"finished\" play state; if the animation is both paused and finished, the \"paused\" state is the one that will be reported.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Animation/finish_event\n            if (t >= this.duration) anim.play();\n            anim.currentTime = t;\n        });\n    }\n    get progress() {\n        return this.currentTime / this.duration;\n    }\n    /** @param {Number} progress */ set progress(progress) {\n        this.forEach((anim)=>anim.currentTime = progress * this.duration || 0);\n    }\n    resume() {\n        if (!this.paused) return this;\n        this.paused = false;\n        // TODO: Store the current time, and seek back to the last position\n        return this.forEach(\"play\");\n    }\n    pause() {\n        if (this.paused) return this;\n        this.paused = true;\n        return this.forEach(\"pause\");\n    }\n    alternate() {\n        this.reversed = !this.reversed;\n        this.forEach(\"reverse\");\n        if (this.paused) this.forEach(\"pause\");\n        return this;\n    }\n    play() {\n        if (this.reversed) this.alternate();\n        return this.resume();\n    }\n    reverse() {\n        if (!this.reversed) this.alternate();\n        return this.resume();\n    }\n    /**\n  * @param {Number} time\n  * @param {Boolean} muteCallbacks\n  */ seek(time) {\n        let muteCallbacks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (muteCallbacks) this.muteCallbacks = true;\n        if (time < this.duration) this.completed = false;\n        this.currentTime = time;\n        this.muteCallbacks = false;\n        if (this.paused) this.pause();\n        return this;\n    }\n    restart() {\n        this.completed = false;\n        return this.seek(0, true).resume();\n    }\n    commitStyles() {\n        return this.forEach(\"commitStyles\");\n    }\n    complete() {\n        return this.seek(this.duration);\n    }\n    cancel() {\n        this.forEach(\"cancel\");\n        return this.pause();\n    }\n    revert() {\n        this.cancel();\n        this.targets.forEach(($el, i)=>$el.setAttribute(\"style\", this._inlineStyles[i]));\n        return this;\n    }\n    /**\n   * @param  {WAAPICallback} [callback]\n   * @return {Promise}\n   */ then() {\n        let callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : noop;\n        const then = this.then;\n        const onResolve = ()=>{\n            this.then = null;\n            callback(this);\n            this.then = then;\n            this._resolve = noop;\n        };\n        return new Promise((r)=>{\n            this._resolve = ()=>r(onResolve());\n            if (this.completed) this._resolve();\n            return this;\n        });\n    }\n    /**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n */ constructor(targets, params){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        registerTransformsProperties();\n        const parsedTargets = registerTargets(targets);\n        const targetsLength = parsedTargets.length;\n        if (!targetsLength) {\n            console.warn(\"No target found. Make sure the element you're trying to animate is accessible before creating your animation.\");\n        }\n        const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));\n        const spring = /** @type {Spring} */ ease.ease && ease;\n        const autoplay = setValue(params.autoplay, globals.defaults.autoplay);\n        const scroll = autoplay && /** @type {ScrollObserver} */ autoplay.link ? autoplay : false;\n        const alternate = params.alternate && /** @type {Boolean} */ params.alternate === true;\n        const reversed = params.reversed && /** @type {Boolean} */ params.reversed === true;\n        const loop = setValue(params.loop, globals.defaults.loop);\n        const iterations = /** @type {Number} */ loop === true || loop === Infinity ? Infinity : isNum(loop) ? loop + 1 : 1;\n        /** @type {PlaybackDirection} */ const direction = alternate ? reversed ? \"alternate-reverse\" : \"alternate\" : reversed ? \"reverse\" : \"normal\";\n        /** @type {FillMode} */ const fill = \"forwards\";\n        /** @type {String} */ const easing = parseWAAPIEasing(ease);\n        const timeScale = globals.timeScale === 1 ? 1 : K;\n        /** @type {DOMTargetsArray}] */ this.targets = parsedTargets;\n        /** @type {Array<globalThis.Animation>}] */ this.animations = [];\n        /** @type {globalThis.Animation}] */ this.controlAnimation = null;\n        /** @type {Callback<this>} */ this.onComplete = params.onComplete || noop;\n        /** @type {Number} */ this.duration = 0;\n        /** @type {Boolean} */ this.muteCallbacks = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Boolean} */ this.paused = !autoplay || scroll !== false;\n        /** @type {Boolean} */ this.reversed = reversed;\n        /** @type {Boolean|ScrollObserver} */ this.autoplay = autoplay;\n        /** @type {Number} */ this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);\n        /** @type {Function} */ this._resolve = noop; // Used by .then()\n        /** @type {Number} */ this._completed = 0;\n        /** @type {Array<Object>}] */ this._inlineStyles = parsedTargets.map(($el)=>$el.getAttribute(\"style\"));\n        parsedTargets.forEach(($el, i)=>{\n            const cachedTransforms = $el[transformsSymbol];\n            const hasIndividualTransforms = validIndividualTransforms.some((t)=>params.hasOwnProperty(t));\n            /** @type {Number} */ const duration = (spring ? /** @type {Spring} */ spring.duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;\n            /** @type {Number} */ const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;\n            /** @type {CompositeOperation} */ const composite = /** @type {CompositeOperation} */ setValue(params.composition, \"replace\");\n            for(let name in params){\n                if (!isKey(name)) continue;\n                /** @type {PropertyIndexedKeyframes} */ const keyframes = {};\n                /** @type {KeyframeAnimationOptions} */ const tweenParams = {\n                    iterations,\n                    direction,\n                    fill,\n                    easing,\n                    duration,\n                    delay,\n                    composite\n                };\n                const propertyValue = params[name];\n                const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;\n                let parsedPropertyValue;\n                if (isObj(propertyValue)) {\n                    const tweenOptions = /** @type {WAAPITweenOptions} */ propertyValue;\n                    const tweenOptionsEase = setValue(tweenOptions.ease, ease);\n                    const tweenOptionsSpring = /** @type {Spring} */ tweenOptionsEase.ease && tweenOptionsEase;\n                    const to = /** @type {WAAPITweenOptions} */ tweenOptions.to;\n                    const from = /** @type {WAAPITweenOptions} */ tweenOptions.from;\n                    /** @type {Number} */ tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */ tweenOptionsSpring.duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;\n                    /** @type {Number} */ tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;\n                    /** @type {CompositeOperation} */ tweenParams.composite = /** @type {CompositeOperation} */ setValue(tweenOptions.composition, composite);\n                    /** @type {String} */ tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);\n                    parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n                    if (individualTransformProperty) {\n                        keyframes[\"--\".concat(individualTransformProperty)] = parsedPropertyValue;\n                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n                    } else {\n                        keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);\n                    }\n                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n                    if (!isUnd(from)) {\n                        if (!individualTransformProperty) {\n                            $el.style[name] = keyframes[name][0];\n                        } else {\n                            const key = \"--\".concat(individualTransformProperty);\n                            $el.style.setProperty(key, keyframes[key][0]);\n                        }\n                    }\n                } else {\n                    parsedPropertyValue = isArr(propertyValue) ? propertyValue.map((/** @type {any} */ v)=>normalizeTweenValue(name, v, $el, i, targetsLength)) : normalizeTweenValue(name, /** @type {any} */ propertyValue, $el, i, targetsLength);\n                    if (individualTransformProperty) {\n                        keyframes[\"--\".concat(individualTransformProperty)] = parsedPropertyValue;\n                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;\n                    } else {\n                        keyframes[name] = parsedPropertyValue;\n                    }\n                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);\n                }\n            }\n            if (hasIndividualTransforms) {\n                let transforms = emptyString;\n                for(let t in cachedTransforms){\n                    transforms += \"\".concat(transformsFragmentStrings[t], \"var(--\").concat(t, \")) \");\n                }\n                $el.style.transform = transforms;\n            }\n        });\n        if (scroll) {\n            /** @type {ScrollObserver} */ this.autoplay.link(this);\n        }\n    }\n}\nconst waapi = {\n    /**\n * @param {DOMTargetsParam} targets\n * @param {WAAPIAnimationParams} params\n * @return {WAAPIAnimation}\n */ animate: (targets, params)=>new WAAPIAnimation(targets, params),\n    convertEase: easingToLinear\n};\n/**\n * @param  {Callback<Timer>} [callback]\n * @return {Timer}\n */ const sync = function() {\n    let callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : noop;\n    return new Timer({\n        duration: 1 * globals.timeScale,\n        onComplete: callback\n    }, null, 0).resume();\n};\n/**\n * @overload\n * @param  {DOMTargetSelector} targetSelector\n * @param  {String}            propName\n * @return {String}\n *\n * @overload\n * @param  {JSTargetsParam} targetSelector\n * @param  {String}         propName\n * @return {Number|String}\n *\n * @overload\n * @param  {DOMTargetsParam} targetSelector\n * @param  {String}          propName\n * @param  {String}          unit\n * @return {String}\n *\n * @overload\n * @param  {TargetsParam} targetSelector\n * @param  {String}       propName\n * @param  {Boolean}      unit\n * @return {Number}\n *\n * @param  {TargetsParam}   targetSelector\n * @param  {String}         propName\n * @param  {String|Boolean} [unit]\n */ function getTargetValue(targetSelector, propName, unit) {\n    const targets = registerTargets(targetSelector);\n    if (!targets.length) return;\n    const [target] = targets;\n    const tweenType = getTweenType(target, propName);\n    const normalizePropName = sanitizePropertyName(propName, target, tweenType);\n    let originalValue = getOriginalAnimatableValue(target, normalizePropName);\n    if (isUnd(unit)) {\n        return originalValue;\n    } else {\n        decomposeRawValue(originalValue, decomposedOriginalValue);\n        if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {\n            if (unit === false) {\n                return decomposedOriginalValue.n;\n            } else {\n                const convertedValue = convertValueUnit(/** @type {DOMTarget} */ target, decomposedOriginalValue, /** @type {String} */ unit, false);\n                return \"\".concat(round(convertedValue.n, globals.precision)).concat(convertedValue.u);\n            }\n        }\n    }\n}\n/**\n * @param  {TargetsParam}    targets\n * @param  {AnimationParams} parameters\n * @return {JSAnimation}\n */ const setTargetValues = (targets, parameters)=>{\n    if (isUnd(parameters)) return;\n    parameters.duration = minValue;\n    // Do not overrides currently active tweens by default\n    parameters.composition = setValue(parameters.composition, compositionTypes.none);\n    // Skip init() and force rendering by playing the animation\n    return new JSAnimation(targets, parameters, null, 0, true).resume();\n};\n/**\n * @param  {TargetsArray} targetsArray\n * @param  {JSAnimation}    animation\n * @param  {String}       [propertyName]\n * @return {Boolean}\n */ const removeTargetsFromAnimation = (targetsArray, animation, propertyName)=>{\n    let tweensMatchesTargets = false;\n    forEachChildren(animation, (/**@type {Tween} */ tween)=>{\n        const tweenTarget = tween.target;\n        if (targetsArray.includes(tweenTarget)) {\n            const tweenName = tween.property;\n            const tweenType = tween._tweenType;\n            const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);\n            if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {\n                // Make sure to flag the previous CSS transform tween to renderTransform\n                if (tween.parent._tail === tween && tween._tweenType === tweenTypes.TRANSFORM && tween._prev && tween._prev._tweenType === tweenTypes.TRANSFORM) {\n                    tween._prev._renderTransforms = 1;\n                }\n                // Removes the tween from the selected animation\n                removeChild(animation, tween);\n                // Detach the tween from its siblings to make sure blended tweens are correctlly removed\n                removeTweenSliblings(tween);\n                tweensMatchesTargets = true;\n            }\n        }\n    }, true);\n    return tweensMatchesTargets;\n};\n/**\n * @param  {TargetsParam} targets\n * @param  {Renderable|WAAPIAnimation} [renderable]\n * @param  {String}                    [propertyName]\n * @return {TargetsArray}\n */ const remove = (targets, renderable, propertyName)=>{\n    const targetsArray = parseTargets(targets);\n    const parent = /** @type {Renderable|typeof engine} **/ renderable ? renderable : engine;\n    const waapiAnimation = renderable && /** @type {WAAPIAnimation} */ renderable.controlAnimation && /** @type {WAAPIAnimation} */ renderable;\n    for(let i = 0, l = targetsArray.length; i < l; i++){\n        const $el = /** @type {DOMTarget}  */ targetsArray[i];\n        removeWAAPIAnimation($el, propertyName, waapiAnimation);\n    }\n    let removeMatches;\n    if (parent._hasChildren) {\n        let iterationDuration = 0;\n        forEachChildren(parent, (/** @type {Renderable} */ child)=>{\n            if (!child._hasChildren) {\n                removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */ child, propertyName);\n                // Remove the child from its parent if no tweens and no children left after the removal\n                if (removeMatches && !child._head) {\n                    child.cancel();\n                    removeChild(parent, child);\n                } else {\n                    // Calculate the new iterationDuration value to handle onComplete with last child in render()\n                    const childTLOffset = child._offset + child._delay;\n                    const childDur = childTLOffset + child.duration;\n                    if (childDur > iterationDuration) {\n                        iterationDuration = childDur;\n                    }\n                }\n            }\n            // Make sure to also remove engine's children targets\n            // NOTE: Avoid recursion?\n            if (child._head) {\n                remove(targets, child, propertyName);\n            } else {\n                child._hasChildren = false;\n            }\n        }, true);\n        // Update iterationDuration value to handle onComplete with last child in render()\n        if (!isUnd(/** @type {Renderable} */ parent.iterationDuration)) {\n            /** @type {Renderable} */ parent.iterationDuration = iterationDuration;\n        }\n    } else {\n        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */ parent, propertyName);\n    }\n    if (removeMatches && !parent._head) {\n        parent._hasChildren = false;\n        // Cancel the parent if there are no tweens and no children left after the removal\n        // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself\n        if (/** @type {Renderable} */ parent.cancel) /** @type {Renderable} */ parent.cancel();\n    }\n    return targetsArray;\n};\n/**\n * @param  {Number} min\n * @param  {Number} max\n * @param  {Number} [decimalLength]\n * @return {Number}\n */ const random = (min, max, decimalLength)=>{\n    const m = 10 ** (decimalLength || 0);\n    return floor((Math.random() * (max - min + 1 / m) + min) * m) / m;\n};\n/**\n * @param  {String|Array} items\n * @return {any}\n */ const randomPick = (items)=>items[random(0, items.length - 1)];\n/**\n * Adapted from https://bost.ocks.org/mike/shuffle/\n * @param  {Array} items\n * @return {Array}\n */ const shuffle = (items)=>{\n    let m = items.length, t, i;\n    while(m){\n        i = random(0, --m);\n        t = items[m];\n        items[m] = items[i];\n        items[i] = t;\n    }\n    return items;\n};\n/**\n * @param  {Number|String} v\n * @param  {Number} decimalLength\n * @return {String}\n */ const roundPad = (v, decimalLength)=>(+v).toFixed(decimalLength);\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */ const padStart = (v, totalLength, padString)=>\"\".concat(v).padStart(totalLength, padString);\n/**\n * @param  {Number} v\n * @param  {Number} totalLength\n * @param  {String} padString\n * @return {String}\n */ const padEnd = (v, totalLength, padString)=>\"\".concat(v).padEnd(totalLength, padString);\n/**\n * @param  {Number} v\n * @param  {Number} min\n * @param  {Number} max\n * @return {Number}\n */ const wrap = (v, min, max)=>((v - min) % (max - min) + (max - min)) % (max - min) + min;\n/**\n * @param  {Number} value\n * @param  {Number} inLow\n * @param  {Number} inHigh\n * @param  {Number} outLow\n * @param  {Number} outHigh\n * @return {Number}\n */ const mapRange = (value, inLow, inHigh, outLow, outHigh)=>outLow + (value - inLow) / (inHigh - inLow) * (outHigh - outLow);\n/**\n * @param  {Number} degrees\n * @return {Number}\n */ const degToRad = (degrees)=>degrees * PI / 180;\n/**\n * @param  {Number} radians\n * @return {Number}\n */ const radToDeg = (radians)=>radians * 180 / PI;\n/**\n * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * @param  {Number} start\n * @param  {Number} end\n * @param  {Number} amount\n * @param  {Renderable|Boolean} [renderable]\n * @return {Number}\n */ const lerp = (start, end, amount, renderable)=>{\n    let dt = K / globals.defaults.frameRate;\n    if (renderable !== false) {\n        const ticker = /** @type Renderable */ renderable || engine._hasChildren && engine;\n        if (ticker && ticker.deltaTime) {\n            dt = ticker.deltaTime;\n        }\n    }\n    const t = 1 - Math.exp(-amount * dt * .1);\n    return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;\n};\n// Chain-able utilities\n/**\n * @callback UtilityFunction\n * @param {...*} args\n * @return {Number|String}\n *\n * @param {UtilityFunction} fn\n * @param {Number} [last=0]\n * @return {function(...(Number|String)): function(Number|String): (Number|String)}\n */ const curry = function(fn) {\n    let last = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return last ? (v)=>fn(...args, v) : (v)=>fn(v, ...args);\n    };\n};\n/**\n * @param {Function} fn\n * @return {function(...(Number|String))}\n */ const chain = (fn)=>{\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const result = fn(...args);\n        return new Proxy(noop, {\n            apply: (_, __, param)=>{\n                let [v] = param;\n                return result(v);\n            },\n            get: (_, prop)=>chain(/**@param {...Number|String} nextArgs */ function() {\n                    for(var _len = arguments.length, nextArgs = new Array(_len), _key = 0; _key < _len; _key++){\n                        nextArgs[_key] = arguments[_key];\n                    }\n                    const nextResult = utils[prop](...nextArgs);\n                    return (/**@type {Number|String} */ v)=>nextResult(result(v));\n                })\n        });\n    };\n};\n/**\n * @param {UtilityFunction} fn\n * @param {Number} [right]\n * @return {function(...(Number|String)): UtilityFunction}\n */ const makeChainable = function(fn) {\n    let right = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);\n    };\n};\n/**\n * @callback ChainedUtilsResult\n * @param {Number} value\n * @return {Number}\n *\n * @typedef {Object} ChainableUtils\n * @property {ChainedClamp} clamp\n * @property {ChainedRound} round\n * @property {ChainedSnap} snap\n * @property {ChainedWrap} wrap\n * @property {ChainedInterpolate} interpolate\n * @property {ChainedMapRange} mapRange\n * @property {ChainedRoundPad} roundPad\n * @property {ChainedPadStart} padStart\n * @property {ChainedPadEnd} padEnd\n * @property {ChainedDegToRad} degToRad\n * @property {ChainedRadToDeg} radToDeg\n *\n * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil\n *\n * @callback ChainedClamp\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedRound\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedSnap\n * @param {Number} increment\n * @return {ChainableUtil}\n *\n * @callback ChainedWrap\n * @param {Number} min\n * @param {Number} max\n * @return {ChainableUtil}\n *\n * @callback ChainedInterpolate\n * @param {Number} start\n * @param {Number} end\n * @return {ChainableUtil}\n *\n * @callback ChainedMapRange\n * @param {Number} inLow\n * @param {Number} inHigh\n * @param {Number} outLow\n * @param {Number} outHigh\n * @return {ChainableUtil}\n *\n * @callback ChainedRoundPad\n * @param {Number} decimalLength\n * @return {ChainableUtil}\n *\n * @callback ChainedPadStart\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedPadEnd\n * @param {Number} totalLength\n * @param {String} padString\n * @return {ChainableUtil}\n *\n * @callback ChainedDegToRad\n * @return {ChainableUtil}\n *\n * @callback ChainedRadToDeg\n * @return {ChainableUtil}\n */ const utils = {\n    $: registerTargets,\n    get: getTargetValue,\n    set: setTargetValues,\n    remove,\n    cleanInlineStyles,\n    random,\n    randomPick,\n    shuffle,\n    lerp,\n    sync,\n    clamp: /** @type {typeof clamp & ChainedClamp} */ makeChainable(clamp),\n    round: /** @type {typeof round & ChainedRound} */ makeChainable(round),\n    snap: /** @type {typeof snap & ChainedSnap} */ makeChainable(snap),\n    wrap: /** @type {typeof wrap & ChainedWrap} */ makeChainable(wrap),\n    interpolate: /** @type {typeof interpolate & ChainedInterpolate} */ makeChainable(interpolate, 1),\n    mapRange: /** @type {typeof mapRange & ChainedMapRange} */ makeChainable(mapRange),\n    roundPad: /** @type {typeof roundPad & ChainedRoundPad} */ makeChainable(roundPad),\n    padStart: /** @type {typeof padStart & ChainedPadStart} */ makeChainable(padStart),\n    padEnd: /** @type {typeof padEnd & ChainedPadEnd} */ makeChainable(padEnd),\n    degToRad: /** @type {typeof degToRad & ChainedDegToRad} */ makeChainable(degToRad),\n    radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */ makeChainable(radToDeg)\n};\n/**\n * @typedef {Number|String|Function} TimePosition\n */ /**\n * Timeline's children offsets positions parser\n * @param  {Timeline} timeline\n * @param  {String} timePosition\n * @return {Number}\n */ const getPrevChildOffset = (timeline, timePosition)=>{\n    if (stringStartsWith(timePosition, \"<\")) {\n        const goToPrevAnimationOffset = timePosition[1] === \"<\";\n        const prevAnimation = /** @type {Tickable} */ timeline._tail;\n        const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;\n        return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;\n    }\n};\n/**\n * @param  {Timeline} timeline\n * @param  {TimePosition} [timePosition]\n * @return {Number}\n */ const parseTimelinePosition = (timeline, timePosition)=>{\n    let tlDuration = timeline.iterationDuration;\n    if (tlDuration === minValue) tlDuration = 0;\n    if (isUnd(timePosition)) return tlDuration;\n    if (isNum(+timePosition)) return +timePosition;\n    const timePosStr = /** @type {String} */ timePosition;\n    const tlLabels = timeline ? timeline.labels : null;\n    const hasLabels = !isNil(tlLabels);\n    const prevOffset = getPrevChildOffset(timeline, timePosStr);\n    const hasSibling = !isUnd(prevOffset);\n    const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);\n    if (matchedRelativeOperator) {\n        const fullOperator = matchedRelativeOperator[0];\n        const split = timePosStr.split(fullOperator);\n        const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;\n        const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;\n        const parsedNumericalOffset = +split[1];\n        return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);\n    } else {\n        return hasSibling ? prevOffset : hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] : tlDuration : tlDuration;\n    }\n};\n/**\n * @param {Timeline} tl\n * @return {Number}\n */ function getTimelineTotalDuration(tl) {\n    return clampInfinity((tl.iterationDuration + tl._loopDelay) * tl.iterationCount - tl._loopDelay) || minValue;\n}\n/**\n * @overload\n * @param  {TimerParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @return {Timeline}\n *\n * @overload\n * @param  {AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} targets\n * @param  {Number} [index]\n * @param  {Number} [length]\n * @return {Timeline}\n *\n * @param  {TimerParams|AnimationParams} childParams\n * @param  {Timeline} tl\n * @param  {Number} timePosition\n * @param  {TargetsParam} [targets]\n * @param  {Number} [index]\n * @param  {Number} [length]\n */ function addTlChild(childParams, tl, timePosition, targets, index, length) {\n    const isSetter = isNum(childParams.duration) && /** @type {Number} */ childParams.duration <= minValue;\n    // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position\n    const adjustedPosition = isSetter ? timePosition - minValue : timePosition;\n    tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);\n    const tlChild = targets ? new JSAnimation(targets, /** @type {AnimationParams} */ childParams, tl, adjustedPosition, false, index, length) : new Timer(/** @type {TimerParams} */ childParams, tl, adjustedPosition);\n    tlChild.init(1);\n    // TODO: Might be better to insert at a position relative to startTime?\n    addChild(tl, tlChild);\n    forEachChildren(tl, (/** @type {Renderable} */ child)=>{\n        const childTLOffset = child._offset + child._delay;\n        const childDur = childTLOffset + child.duration;\n        if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;\n    });\n    tl.duration = getTimelineTotalDuration(tl);\n    return tl;\n}\nclass Timeline extends Timer {\n    /**\n   * @overload\n   * @param {TargetsParam} a1\n   * @param {AnimationParams} a2\n   * @param {TimePosition} [a3]\n   * @return {this}\n   *\n   * @overload\n   * @param {TimerParams} a1\n   * @param {TimePosition} [a2]\n   * @return {this}\n   *\n   * @param {TargetsParam|TimerParams} a1\n   * @param {AnimationParams|TimePosition} a2\n   * @param {TimePosition} [a3]\n   */ add(a1, a2, a3) {\n        const isAnim = isObj(a2);\n        const isTimer = isObj(a1);\n        if (isAnim || isTimer) {\n            this._hasChildren = true;\n            if (isAnim) {\n                const childParams = /** @type {AnimationParams} */ a2;\n                // Check for function for children stagger positions\n                if (isFnc(a3)) {\n                    const staggeredPosition = /** @type {Function} */ a3;\n                    const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */ a1);\n                    // Store initial duration before adding new children that will change the duration\n                    const tlDuration = this.duration;\n                    // Store initial _iterationDuration before adding new children that will change the duration\n                    const tlIterationDuration = this.iterationDuration;\n                    // Store the original id in order to add specific indexes to the new animations ids\n                    const id = childParams.id;\n                    let i = 0;\n                    const parsedLength = parsedTargetsArray.length;\n                    parsedTargetsArray.forEach((/** @type {Target} */ target)=>{\n                        // Create a new parameter object for each staggered children\n                        const staggeredChildParams = {\n                            ...childParams\n                        };\n                        // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation\n                        this.duration = tlDuration;\n                        this.iterationDuration = tlIterationDuration;\n                        if (!isUnd(id)) staggeredChildParams.id = id + \"-\" + i;\n                        addTlChild(staggeredChildParams, this, staggeredPosition(target, i, parsedLength, this), target, i, parsedLength);\n                        i++;\n                    });\n                } else {\n                    addTlChild(childParams, this, parseTimelinePosition(this, a3), /** @type {TargetsParam} */ a1);\n                }\n            } else {\n                // It's a Timer\n                addTlChild(/** @type TimerParams */ a1, this, parseTimelinePosition(this, /** @type TimePosition */ a2));\n            }\n            return this.init(1); // 1 = internalRender\n        }\n    }\n    /**\n   * @overload\n   * @param {Tickable} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @overload\n   * @param {WAAPIAnimation} [synced]\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]\n   * @param {TimePosition} [position]\n   */ sync(synced, position) {\n        if (isUnd(synced) || synced && isUnd(synced.pause)) return this;\n        synced.pause();\n        const duration = +(/** @type {globalThis.Animation} */ synced.effect ? /** @type {globalThis.Animation} */ synced.effect.getTiming().duration : /** @type {Tickable} */ synced.duration);\n        return this.add(synced, {\n            currentTime: [\n                0,\n                duration\n            ],\n            duration,\n            ease: \"linear\"\n        }, position);\n    }\n    /**\n   * @param  {TargetsParam} targets\n   * @param  {AnimationParams} parameters\n   * @param  {TimePosition} [position]\n   * @return {this}\n   */ set(targets, parameters, position) {\n        if (isUnd(parameters)) return this;\n        parameters.duration = minValue;\n        parameters.composition = compositionTypes.replace;\n        return this.add(targets, parameters, position);\n    }\n    /**\n   * @param {Callback<Timer>} callback\n   * @param {TimePosition} [position]\n   * @return {this}\n   */ call(callback, position) {\n        if (isUnd(callback) || callback && !isFnc(callback)) return this;\n        return this.add({\n            duration: 0,\n            onComplete: ()=>callback(this)\n        }, position);\n    }\n    /**\n   * @param {String} labelName\n   * @param {TimePosition} [position]\n   * @return {this}\n   *\n   */ label(labelName, position) {\n        if (isUnd(labelName) || labelName && !isStr(labelName)) return this;\n        this.labels[labelName] = parseTimelinePosition(this, /** @type TimePosition */ position);\n        return this;\n    }\n    /**\n   * @param  {TargetsParam} targets\n   * @param  {String} [propertyName]\n   * @return {this}\n   */ remove(targets, propertyName) {\n        remove(targets, this, propertyName);\n        return this;\n    }\n    /**\n   * @param  {Number} newDuration\n   * @return {this}\n   */ stretch(newDuration) {\n        const currentDuration = this.duration;\n        if (currentDuration === normalizeTime(newDuration)) return this;\n        const timeScale = newDuration / currentDuration;\n        const labels = this.labels;\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>child.stretch(child.duration * timeScale));\n        for(let labelName in labels)labels[labelName] *= timeScale;\n        return super.stretch(newDuration);\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>{\n            if (child.refresh) child.refresh();\n        });\n        return this;\n    }\n    /**\n   * @return {this}\n   */ revert() {\n        super.revert();\n        forEachChildren(this, (/** @type {JSAnimation} */ child)=>child.revert, true);\n        return cleanInlineStyles(this);\n    }\n    /**\n   * @param  {Callback<this>} [callback]\n   * @return {Promise}\n   */ then(callback) {\n        return super.then(callback);\n    }\n    /**\n   * @param {TimelineParams} [parameters]\n   */ constructor(parameters = {}){\n        super(/** @type {TimerParams&TimelineParams} */ parameters, null, 0);\n        /** @type {Number} */ this.duration = 0; // TL duration starts at 0 and grows when adding children\n        /** @type {Record<String, Number>} */ this.labels = {};\n        const defaultsParams = parameters.defaults;\n        const globalDefaults = globals.defaults;\n        /** @type {DefaultsParams} */ this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;\n        /** @type {Callback<this>} */ this.onRender = parameters.onRender || globalDefaults.onRender;\n        const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);\n        this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;\n        /** @type {Number} */ this.iterationDuration = 0;\n    }\n}\n/**\n * @param {TimelineParams} [parameters]\n * @return {Timeline}\n */ const createTimeline = (parameters)=>new Timeline(parameters).init();\nclass Animatable {\n    revert() {\n        for(let propName in this.animations){\n            this[propName] = noop;\n            this.animations[propName].revert();\n        }\n        this.animations = {};\n        this.targets.length = 0;\n        return this;\n    }\n    /**\n   * @param {TargetsParam} targets\n   * @param {AnimatableParams} parameters\n   */ constructor(targets, parameters){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        /** @type {AnimationParams} */ const globalParams = {};\n        const properties = {};\n        this.targets = [];\n        this.animations = {};\n        if (isUnd(targets) || isUnd(parameters)) return;\n        for(let propName in parameters){\n            const paramValue = parameters[propName];\n            if (isKey(propName)) {\n                properties[propName] = paramValue;\n            } else {\n                globalParams[propName] = paramValue;\n            }\n        }\n        for(let propName in properties){\n            const propValue = properties[propName];\n            const isObjValue = isObj(propValue);\n            /** @type {TweenParamsOptions} */ let propParams = {};\n            let to = \"+=0\";\n            if (isObjValue) {\n                const unit = propValue.unit;\n                if (isStr(unit)) to += unit;\n            } else {\n                propParams.duration = propValue;\n            }\n            propParams[propName] = isObjValue ? mergeObjects({\n                to\n            }, propValue) : to;\n            const animParams = mergeObjects(globalParams, propParams);\n            animParams.composition = compositionTypes.replace;\n            animParams.autoplay = false;\n            const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();\n            if (!this.targets.length) this.targets.push(...animation.targets);\n            /** @type {AnimatableProperty} */ this[propName] = (to, duration, ease)=>{\n                const tween = /** @type {Tween} */ animation._head;\n                if (isUnd(to) && tween) {\n                    const numbers = tween._numbers;\n                    if (numbers && numbers.length) {\n                        return numbers;\n                    } else {\n                        return tween._modifier(tween._number);\n                    }\n                } else {\n                    forEachChildren(animation, (/** @type {Tween} */ tween)=>{\n                        if (isArr(to)) {\n                            for(let i = 0, l = /** @type {Array} */ to.length; i < l; i++){\n                                if (!isUnd(tween._numbers[i])) {\n                                    tween._fromNumbers[i] = /** @type {Number} */ tween._modifier(tween._numbers[i]);\n                                    tween._toNumbers[i] = to[i];\n                                }\n                            }\n                        } else {\n                            tween._fromNumber = /** @type {Number} */ tween._modifier(tween._number);\n                            tween._toNumber = /** @type {Number} */ to;\n                        }\n                        if (!isUnd(ease)) tween._ease = parseEasings(ease);\n                        tween._currentTime = 0;\n                    });\n                    if (!isUnd(duration)) animation.stretch(duration);\n                    animation.reset(1).resume();\n                    return this;\n                }\n            };\n        }\n    }\n}\n/**\n * @param {TargetsParam} targets\n * @param {AnimatableParams} parameters\n * @return {AnimatableObject}\n */ const createAnimatable = (targets, parameters)=>/** @type {AnimatableObject} */ new Animatable(targets, parameters);\n/*\n * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js\n * Webkit Copyright © 2016 Apple Inc\n */ /**\n * @typedef {Object} SpringParams\n * @property {Number} [mass=1] - Mass, default 1\n * @property {Number} [stiffness=100] - Stiffness, default 100\n * @property {Number} [damping=10] - Damping, default 10\n * @property {Number} [velocity=0] - Initial velocity, default 0\n */ class Spring {\n    /** @type {EasingFunction} */ solve(time) {\n        const { zeta, w0, wd, b } = this;\n        let t = time;\n        if (zeta < 1) {\n            t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));\n        } else {\n            t = (1 + b * t) * exp(-t * w0);\n        }\n        return 1 - t;\n    }\n    compute() {\n        const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;\n        const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);\n        const zeta = this.zeta = d / (2 * sqrt(s * m));\n        const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;\n        this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;\n        let solverTime = 0;\n        let restSteps = 0;\n        let iterations = 0;\n        while(restSteps < maxRestSteps && iterations < maxIterations){\n            if (abs(1 - this.solve(solverTime)) < restThreshold) {\n                restSteps++;\n            } else {\n                restSteps = 0;\n            }\n            this.solverDuration = solverTime;\n            solverTime += timeStep;\n            iterations++;\n        }\n        this.duration = round(this.solverDuration * K, 0) * globals.timeScale;\n    }\n    get mass() {\n        return this.m;\n    }\n    set mass(v) {\n        this.m = clamp(setValue(v, 1), 0, K);\n        this.compute();\n    }\n    get stiffness() {\n        return this.s;\n    }\n    set stiffness(v) {\n        this.s = clamp(setValue(v, 100), 1, K);\n        this.compute();\n    }\n    get damping() {\n        return this.d;\n    }\n    set damping(v) {\n        this.d = clamp(setValue(v, 10), .1, K);\n        this.compute();\n    }\n    get velocity() {\n        return this.v;\n    }\n    set velocity(v) {\n        this.v = clamp(setValue(v, 0), -1e3, K);\n        this.compute();\n    }\n    /**\n   * @param {SpringParams} [parameters]\n   */ constructor(parameters = {}){\n        this.timeStep = .02; // Interval fed to the solver to calculate duration\n        this.restThreshold = .0005; // Values below this threshold are considered resting position\n        this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold\n        this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)\n        this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation\n        this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration\n        this.m = clamp(setValue(parameters.mass, 1), 0, K);\n        this.s = clamp(setValue(parameters.stiffness, 100), 1, K);\n        this.d = clamp(setValue(parameters.damping, 10), .1, K);\n        this.v = clamp(setValue(parameters.velocity, 0), -1e3, K);\n        this.w0 = 0;\n        this.zeta = 0;\n        this.wd = 0;\n        this.b = 0;\n        this.solverDuration = 0;\n        this.duration = 0;\n        this.compute();\n        /** @type {EasingFunction} */ this.ease = (t)=>t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);\n    }\n}\n/**\n * @param {SpringParams} [parameters]\n * @returns {Spring}\n */ const createSpring = (parameters)=>new Spring(parameters);\n/**\n * @param {Event} e\n */ const preventDefault = (e)=>{\n    if (e.cancelable) e.preventDefault();\n};\nclass DOMProxy {\n    get x() {\n        return this.el.x || 0;\n    }\n    set x(v) {\n        this.el.x = v;\n    }\n    get y() {\n        return this.el.y || 0;\n    }\n    set y(v) {\n        this.el.y = v;\n    }\n    get width() {\n        return this.el.width || 0;\n    }\n    set width(v) {\n        this.el.width = v;\n    }\n    get height() {\n        return this.el.height || 0;\n    }\n    set height(v) {\n        this.el.height = v;\n    }\n    getBoundingClientRect() {\n        return {\n            top: this.y,\n            right: this.x,\n            bottom: this.y + this.height,\n            left: this.x + this.width\n        };\n    }\n    /** @param {Object} el */ constructor(el){\n        this.el = el;\n        this.zIndex = 0;\n        this.parentElement = null;\n        this.classList = {\n            add: noop,\n            remove: noop\n        };\n    }\n}\nclass Transforms {\n    /**\n   * @param {Number} x\n   * @param {Number} y\n   * @return {DOMPoint}\n   */ normalizePoint(x, y) {\n        this.point.x = x;\n        this.point.y = y;\n        return this.point.matrixTransform(this.inversedMatrix);\n    }\n    /**\n   * @callback TraverseParentsCallback\n   * @param {DOMTarget} $el\n   * @param {Number} i\n   */ /**\n   * @param {TraverseParentsCallback} cb\n   */ traverseUp(cb) {\n        let $el = /** @type {DOMTarget|Document} */ this.$el.parentElement, i = 0;\n        while($el && $el !== doc){\n            cb(/** @type {DOMTarget} */ $el, i);\n            $el = /** @type {DOMTarget} */ $el.parentElement;\n            i++;\n        }\n    }\n    getMatrix() {\n        const matrix = new DOMMatrix();\n        this.traverseUp(($el)=>{\n            const transformValue = getComputedStyle($el).transform;\n            if (transformValue) {\n                const elMatrix = new DOMMatrix(transformValue);\n                matrix.preMultiplySelf(elMatrix);\n            }\n        });\n        return matrix;\n    }\n    remove() {\n        this.traverseUp(($el, i)=>{\n            this.inlineTransforms[i] = $el.style.transform;\n            $el.style.transform = \"none\";\n        });\n    }\n    revert() {\n        this.traverseUp(($el, i)=>{\n            const ct = this.inlineTransforms[i];\n            if (ct === \"\") {\n                $el.style.removeProperty(\"transform\");\n            } else {\n                $el.style.transform = ct;\n            }\n        });\n    }\n    /**\n   * @param {DOMTarget|DOMProxy} $el\n   */ constructor($el){\n        this.$el = $el;\n        this.inlineTransforms = [];\n        this.point = new DOMPoint();\n        this.inversedMatrix = this.getMatrix().inverse();\n    }\n}\n/**\n * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T\n * @param {T | ((draggable: Draggable) => T)} value\n * @param {Draggable} draggable\n * @return {T}\n */ const parseDraggableFunctionParameter = (value, draggable)=>value && isFnc(value) ? /** @type {Function} */ value(draggable) : value;\nlet zIndex = 0;\nclass Draggable {\n    /**\n   * @param  {Number} dx\n   * @param  {Number} dy\n   * @return {Number}\n   */ computeVelocity(dx, dy) {\n        const prevTime = this.velocityTime;\n        const curTime = now();\n        const elapsed = curTime - prevTime;\n        if (elapsed < 17) return this.velocity;\n        this.velocityTime = curTime;\n        const velocityStack = this.velocityStack;\n        const vMul = this.velocityMultiplier;\n        const minV = this.minVelocity;\n        const maxV = this.maxVelocity;\n        const vi = this.velocityStackIndex;\n        velocityStack[vi] = round(clamp(sqrt(dx * dx + dy * dy) / elapsed * vMul, minV, maxV), 5);\n        const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);\n        this.velocity = velocity;\n        this.velocityStackIndex = (vi + 1) % 3;\n        return velocity;\n    }\n    /**\n   * @param {Number}  x\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */ setX(x) {\n        let muteUpdateCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (this.disabled[0]) return;\n        const v = round(x, 5);\n        this.overshootXTicker.pause();\n        this.manual = true;\n        this.updated = !muteUpdateCallback;\n        this.destX = v;\n        this.snapped[0] = snap(v, this.snapX);\n        this.animate[this.xProp](v, 0);\n        this.manual = false;\n        return this;\n    }\n    /**\n   * @param {Number}  y\n   * @param {Boolean} [muteUpdateCallback]\n   * @return {this}\n   */ setY(y) {\n        let muteUpdateCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (this.disabled[1]) return;\n        const v = round(y, 5);\n        this.overshootYTicker.pause();\n        this.manual = true;\n        this.updated = !muteUpdateCallback;\n        this.destY = v;\n        this.snapped[1] = snap(v, this.snapY);\n        this.animate[this.yProp](v, 0);\n        this.manual = false;\n        return this;\n    }\n    get x() {\n        return round(/** @type {Number} */ this.animate[this.xProp](), globals.precision);\n    }\n    set x(x) {\n        this.setX(x, false);\n    }\n    get y() {\n        return round(/** @type {Number} */ this.animate[this.yProp](), globals.precision);\n    }\n    set y(y) {\n        this.setY(y, false);\n    }\n    get progressX() {\n        return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);\n    }\n    set progressX(x) {\n        this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);\n    }\n    get progressY() {\n        return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);\n    }\n    set progressY(y) {\n        this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);\n    }\n    updateScrollCoords() {\n        const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);\n        const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        const threshold = this.scrollThreshold;\n        this.scroll.x = sx;\n        this.scroll.y = sy;\n        this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;\n        this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;\n        this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;\n        this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;\n    }\n    updateBoundingValues() {\n        const $container = this.$container;\n        const cx = this.x;\n        const cy = this.y;\n        const cx2 = this.coords[2];\n        const cy2 = this.coords[3];\n        // Prevents interfering with the scroll area in cases the target is outside of the container\n        // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates\n        this.coords[2] = 0;\n        this.coords[3] = 0;\n        this.setX(0, true);\n        this.setY(0, true);\n        this.transforms.remove();\n        const iw = this.window[0] = win.innerWidth;\n        const ih = this.window[1] = win.innerHeight;\n        const uw = this.useWin;\n        const sw = $container.scrollWidth;\n        const sh = $container.scrollHeight;\n        const fx = this.fixed;\n        const transformContainerRect = $container.getBoundingClientRect();\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        this.dragArea[0] = uw ? 0 : transformContainerRect.left;\n        this.dragArea[1] = uw ? 0 : transformContainerRect.top;\n        this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;\n        this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;\n        this.updateScrollCoords();\n        const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();\n        this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);\n        this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);\n        const containerOverflow = getTargetValue($container, \"overflow\");\n        const visibleOverflow = containerOverflow === \"visible\";\n        const hiddenOverflow = containerOverflow === \"hidden\";\n        this.canScroll = fx ? false : this.contained && ($container === doc.body && visibleOverflow || !hiddenOverflow && !visibleOverflow) && (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) && (!this.containerArray || this.containerArray && !isArr(this.containerArray));\n        if (this.contained) {\n            const sx = this.scroll.x;\n            const sy = this.scroll.y;\n            const canScroll = this.canScroll;\n            const targetRect = this.$target.getBoundingClientRect();\n            const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;\n            const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;\n            const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;\n            const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;\n            this.targetBounds[0] = round(targetRect.top + sy - (uw ? 0 : top), 0);\n            this.targetBounds[1] = round(targetRect.right + sx - (uw ? iw : right), 0);\n            this.targetBounds[2] = round(targetRect.bottom + sy - (uw ? ih : bottom), 0);\n            this.targetBounds[3] = round(targetRect.left + sx - (uw ? 0 : left), 0);\n            if (this.containerArray) {\n                this.containerBounds[0] = this.containerArray[0] + cpt;\n                this.containerBounds[1] = this.containerArray[1] - cpr;\n                this.containerBounds[2] = this.containerArray[2] - cpb;\n                this.containerBounds[3] = this.containerArray[3] + cpl;\n            } else {\n                this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);\n                this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);\n                this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);\n                this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);\n            }\n        }\n        this.transforms.revert();\n        // Restore coordinates\n        this.coords[2] = cx2;\n        this.coords[3] = cy2;\n        this.setX(cx, true);\n        this.setY(cy, true);\n    }\n    /**\n   * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB\n   *\n   * @param  {Array} bounds\n   * @param  {Number} x\n   * @param  {Number} y\n   * @return {Number}\n   */ isOutOfBounds(bounds, x, y) {\n        if (!this.contained) return 0;\n        const [bt, br, bb, bl] = bounds;\n        const [dx, dy] = this.disabled;\n        const obx = !dx && x < bl || !dx && x > br;\n        const oby = !dy && y < bt || !dy && y > bb;\n        return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;\n    }\n    refresh() {\n        const params = this.parameters;\n        const paramX = params.x;\n        const paramY = params.y;\n        const container = parseDraggableFunctionParameter(params.container, this);\n        const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;\n        const containerPadding = /** @type {[Number, Number, Number, Number]} */ isArr(cp) ? cp : [\n            cp,\n            cp,\n            cp,\n            cp\n        ];\n        const cx = this.x;\n        const cy = this.y;\n        const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);\n        const cursorStyles = {\n            onHover: \"grab\",\n            onGrab: \"grabbing\"\n        };\n        if (parsedCursorStyles) {\n            const { onHover, onGrab } = /** @type {DraggableCursorParams} */ parsedCursorStyles;\n            if (onHover) cursorStyles.onHover = onHover;\n            if (onGrab) cursorStyles.onGrab = onGrab;\n        }\n        this.containerArray = isArr(container) ? container : null;\n        this.$container = /** @type {HTMLElement} */ container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ container)[0] : doc.body;\n        this.useWin = this.$container === doc.body;\n        /** @type {Window | HTMLElement} */ this.$scrollContainer = this.useWin ? win : this.$container;\n        this.isFinePointer = matchMedia(\"(pointer:fine)\").matches;\n        this.containerPadding = setValue(containerPadding, [\n            0,\n            0,\n            0,\n            0\n        ]);\n        this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);\n        this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);\n        this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);\n        this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);\n        this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);\n        this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);\n        this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);\n        this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);\n        this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);\n        this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);\n        this.cursor = parsedCursorStyles === false ? false : cursorStyles;\n        this.updateBoundingValues();\n        // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);\n        // if (ob === 1 || ob === 3) this.progressX = px;\n        // if (ob === 2 || ob === 3) this.progressY = py;\n        // if (this.initialized && this.contained) {\n        //   if (this.progressX !== px) this.progressX = px;\n        //   if (this.progressY !== py) this.progressY = py;\n        // }\n        const [bt, br, bb, bl] = this.containerBounds;\n        this.setX(clamp(cx, bl, br), true);\n        this.setY(clamp(cy, bt, bb), true);\n    }\n    update() {\n        this.updateScrollCoords();\n        if (this.canScroll) {\n            const [cpt, cpr, cpb, cpl] = this.containerPadding;\n            const [sw, sh] = this.scrollView;\n            const daw = this.dragArea[2];\n            const dah = this.dragArea[3];\n            const csx = this.scroll.x;\n            const csy = this.scroll.y;\n            const nsw = this.$container.scrollWidth;\n            const nsh = this.$container.scrollHeight;\n            const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;\n            const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;\n            const swd = sw - csw;\n            const shd = sh - csh;\n            // Handle cases where the scrollarea dimensions changes during drag\n            if (this.dragged && swd > 0) {\n                this.coords[0] -= swd;\n                this.scrollView[0] = csw;\n            }\n            if (this.dragged && shd > 0) {\n                this.coords[1] -= shd;\n                this.scrollView[1] = csh;\n            }\n            // Handle autoscroll when target is at the edges of the scroll bounds\n            const s = this.scrollSpeed * 10;\n            const threshold = this.scrollThreshold;\n            const [x, y] = this.coords;\n            const [st, sr, sb, sl] = this.scrollBounds;\n            const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);\n            const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);\n            const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);\n            const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);\n            if (t || b || l || r) {\n                const [nx, ny] = this.disabled;\n                let scrollX = csx;\n                let scrollY = csy;\n                if (!nx) {\n                    scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);\n                    this.coords[0] -= csx - scrollX;\n                }\n                if (!ny) {\n                    scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);\n                    this.coords[1] -= csy - scrollY;\n                }\n                // Note: Safari mobile requires to use different scroll methods depending if using the window or not\n                if (this.useWin) {\n                    this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));\n                } else {\n                    this.$scrollContainer.scrollTo(scrollX, scrollY);\n                }\n            }\n        }\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const [px1, py1, px2, py2, px3, py3] = this.pointer;\n        this.coords[0] += (px1 - px3) * this.dragSpeed;\n        this.coords[1] += (py1 - py3) * this.dragSpeed;\n        this.pointer[4] = px1;\n        this.pointer[5] = py1;\n        const [cx, cy] = this.coords;\n        const [sx, sy] = this.snapped;\n        const cf = (1 - this.containerFriction) * this.dragSpeed;\n        this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);\n        this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);\n        this.computeVelocity(px1 - px3, py1 - py3);\n        this.angle = atan2(py1 - py2, px1 - px2);\n        const [nsx, nsy] = this.snapped;\n        if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {\n            this.onSnap(this);\n        }\n    }\n    stop() {\n        this.updateTicker.pause();\n        this.overshootXTicker.pause();\n        this.overshootYTicker.pause();\n        // Pauses the in bounds onRelease animations\n        for(let prop in this.animate.animations)this.animate.animations[prop].pause();\n        remove(this, null, \"x\");\n        remove(this, null, \"y\");\n        remove(this, null, \"progressX\");\n        remove(this, null, \"progressY\");\n        remove(this.scroll); // Removes any active animations on the container scroll\n        remove(this.overshootCoords); // Removes active overshoot animations\n        return this;\n    }\n    /**\n   * @param {Number} [duration]\n   * @param {Number} [gap]\n   * @param {EasingParam} [ease]\n   * @return {this}\n   */ scrollInView(duration) {\n        let gap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, ease = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : eases.inOutQuad;\n        this.updateScrollCoords();\n        const x = this.destX;\n        const y = this.destY;\n        const scroll = this.scroll;\n        const scrollBounds = this.scrollBounds;\n        const canScroll = this.canScroll;\n        if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {\n            const [st, sr, sb, sl] = scrollBounds;\n            const t = round(clamp(y - st, -1e12, 0), 0);\n            const r = round(clamp(x - sr, 0, maxValue), 0);\n            const b = round(clamp(y - sb, 0, maxValue), 0);\n            const l = round(clamp(x - sl, -1e12, 0), 0);\n            new JSAnimation(scroll, {\n                x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),\n                y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),\n                duration: isUnd(duration) ? 350 * globals.timeScale : duration,\n                ease,\n                onUpdate: ()=>{\n                    this.canScroll = false;\n                    this.$scrollContainer.scrollTo(scroll.x, scroll.y);\n                }\n            }).init().then(()=>{\n                this.canScroll = canScroll;\n            });\n        }\n        return this;\n    }\n    handleHover() {\n        if (this.isFinePointer && this.cursor && !this.cursorStyles) {\n            this.cursorStyles = setTargetValues(this.$trigger, {\n                cursor: /** @type {DraggableCursorParams} */ this.cursor.onHover\n            });\n        }\n    }\n    /**\n   * @param  {Number} [duration]\n   * @param  {Number} [gap]\n   * @param  {EasingParam} [ease]\n   * @return {this}\n   */ animateInView(duration) {\n        let gap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, ease = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : eases.inOutQuad;\n        this.stop();\n        this.updateBoundingValues();\n        const x = this.x;\n        const y = this.y;\n        const [cpt, cpr, cpb, cpl] = this.containerPadding;\n        const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;\n        const br = this.scroll.x - this.targetBounds[1] - cpr - gap;\n        const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;\n        const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;\n        const ob = this.isOutOfBounds([\n            bt,\n            br,\n            bb,\n            bl\n        ], x, y);\n        if (ob) {\n            const [disabledX, disabledY] = this.disabled;\n            const destX = clamp(snap(x, this.snapX), bl, br);\n            const destY = clamp(snap(y, this.snapY), bt, bb);\n            const dur = isUnd(duration) ? 350 * globals.timeScale : duration;\n            if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);\n            if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);\n        }\n        return this;\n    }\n    /**\n   * @param {MouseEvent|TouchEvent} e\n   */ handleDown(e) {\n        const $eTarget = /** @type {HTMLElement} */ e.target;\n        if (this.grabbed || /** @type {HTMLInputElement}  */ $eTarget.type === \"range\") return;\n        e.stopPropagation();\n        this.grabbed = true;\n        this.released = false;\n        this.stop();\n        this.updateBoundingValues();\n        const touches = /** @type {TouchEvent} */ e.changedTouches;\n        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ e.clientX;\n        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ e.clientY;\n        const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const cf = (1 - this.containerFriction) * this.dragSpeed;\n        const cx = this.x;\n        const cy = this.y;\n        this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;\n        this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;\n        this.pointer[0] = x;\n        this.pointer[1] = y;\n        this.pointer[2] = x;\n        this.pointer[3] = y;\n        this.pointer[4] = x;\n        this.pointer[5] = y;\n        this.pointer[6] = x;\n        this.pointer[7] = y;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.angle = 0;\n        if (this.targetStyles) {\n            this.targetStyles.revert();\n            this.targetStyles = null;\n        }\n        const z = /** @type {Number} */ getTargetValue(this.$target, \"zIndex\", false);\n        zIndex = (z > zIndex ? z : zIndex) + 1;\n        this.targetStyles = setTargetValues(this.$target, {\n            zIndex\n        });\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.cursorStyles) {\n            this.cursorStyles.revert();\n            this.cursorStyles = null;\n        }\n        if (this.isFinePointer && this.cursor) {\n            this.bodyStyles = setTargetValues(doc.body, {\n                cursor: /** @type {DraggableCursorParams} */ this.cursor.onGrab\n            });\n        }\n        this.scrollInView(100, 0, eases.out(3));\n        this.onGrab(this);\n        doc.addEventListener(\"touchmove\", this);\n        doc.addEventListener(\"touchend\", this);\n        doc.addEventListener(\"touchcancel\", this);\n        doc.addEventListener(\"mousemove\", this);\n        doc.addEventListener(\"mouseup\", this);\n        doc.addEventListener(\"selectstart\", this);\n    }\n    /**\n   * @param {MouseEvent|TouchEvent} e\n   */ handleMove(e) {\n        if (!this.grabbed) return;\n        const touches = /** @type {TouchEvent} */ e.changedTouches;\n        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ e.clientX;\n        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ e.clientY;\n        const { x, y } = this.transforms.normalizePoint(eventX, eventY);\n        const movedX = x - this.pointer[6];\n        const movedY = y - this.pointer[7];\n        let $parent = /** @type {HTMLElement} */ e.target;\n        let isAtTop = false;\n        let isAtBottom = false;\n        let canTouchScroll = false;\n        while(touches && $parent && $parent !== this.$trigger){\n            const overflowY = getTargetValue($parent, \"overflow-y\");\n            if (overflowY !== \"hidden\" && overflowY !== \"visible\") {\n                const { scrollTop, scrollHeight, clientHeight } = $parent;\n                if (scrollHeight > clientHeight) {\n                    canTouchScroll = true;\n                    isAtTop = scrollTop <= 3;\n                    isAtBottom = scrollTop >= scrollHeight - clientHeight - 3;\n                    break;\n                }\n            }\n            $parent = /** @type {HTMLElement} */ $parent.parentNode;\n        }\n        if (canTouchScroll && (!isAtTop && !isAtBottom || isAtTop && movedY < 0 || isAtBottom && movedY > 0)) {\n            this.pointer[0] = x;\n            this.pointer[1] = y;\n            this.pointer[2] = x;\n            this.pointer[3] = y;\n            this.pointer[4] = x;\n            this.pointer[5] = y;\n            this.pointer[6] = x;\n            this.pointer[7] = y;\n        } else {\n            preventDefault(e);\n            // Needed to prevents click on handleUp\n            if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, {\n                pointerEvents: \"none\"\n            });\n            // Needed to prevent page scroll while dragging on touch devvice\n            this.$trigger.addEventListener(\"touchstart\", preventDefault, {\n                passive: false\n            });\n            this.$trigger.addEventListener(\"touchmove\", preventDefault, {\n                passive: false\n            });\n            this.$trigger.addEventListener(\"touchend\", preventDefault);\n            if (!this.disabled[0] && abs(movedX) > 3 || !this.disabled[1] && abs(movedY) > 3) {\n                this.updateTicker.resume();\n                this.pointer[2] = this.pointer[0];\n                this.pointer[3] = this.pointer[1];\n                this.pointer[0] = x;\n                this.pointer[1] = y;\n                this.dragged = true;\n                this.released = false;\n                this.onDrag(this);\n            }\n        }\n    }\n    handleUp() {\n        if (!this.grabbed) return;\n        this.updateTicker.pause();\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.bodyStyles) {\n            this.bodyStyles.revert();\n            this.bodyStyles = null;\n        }\n        const [disabledX, disabledY] = this.disabled;\n        const [px1, py1, px2, py2, px3, py3] = this.pointer;\n        const [ct, cr, cb, cl] = this.containerBounds;\n        const [sx, sy] = this.snapped;\n        const springX = this.releaseXSpring;\n        const springY = this.releaseYSpring;\n        const releaseEase = this.releaseEase;\n        const hasReleaseSpring = this.hasReleaseSpring;\n        const overshootCoords = this.overshootCoords;\n        const cx = this.x;\n        const cy = this.y;\n        const pv = this.computeVelocity(px1 - px3, py1 - py3);\n        const pa = this.angle = atan2(py1 - py2, px1 - px2);\n        const ds = pv * 150;\n        const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;\n        const nx = cx + cos(pa) * ds;\n        const ny = cy + sin(pa) * ds;\n        const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;\n        const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;\n        const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);\n        const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);\n        const ob = this.isOutOfBounds(this.containerBounds, nx, ny);\n        let durationX = 0;\n        let durationY = 0;\n        let easeX = releaseEase;\n        let easeY = releaseEase;\n        let longestReleaseDuration = 0;\n        overshootCoords.x = cx;\n        overshootCoords.y = cy;\n        if (!disabledX) {\n            const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;\n            const distanceX = round(cx - dx, 0);\n            springX.velocity = disabledY && hasReleaseSpring ? distanceX ? ds * directionX / abs(distanceX) : 0 : pv;\n            const { ease, duration, restDuration } = springX;\n            durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n            if (hasReleaseSpring) easeX = ease;\n            if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;\n        }\n        if (!disabledY) {\n            const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;\n            const distanceY = round(cy - dy, 0);\n            springY.velocity = disabledX && hasReleaseSpring ? distanceY ? ds * directionY / abs(distanceY) : 0 : pv;\n            const { ease, duration, restDuration } = springY;\n            durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - restDuration * globals.timeScale;\n            if (hasReleaseSpring) easeY = ease;\n            if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;\n        }\n        if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {\n            const composition = compositionTypes.blend;\n            new JSAnimation(overshootCoords, {\n                x: {\n                    to: bx,\n                    duration: durationX * .65\n                },\n                y: {\n                    to: by,\n                    duration: durationY * .65\n                },\n                ease: releaseEase,\n                composition\n            }).init();\n            new JSAnimation(overshootCoords, {\n                x: {\n                    to: dx,\n                    duration: durationX\n                },\n                y: {\n                    to: dy,\n                    duration: durationY\n                },\n                ease: releaseEase,\n                composition\n            }).init();\n            this.overshootXTicker.stretch(durationX).restart();\n            this.overshootYTicker.stretch(durationY).restart();\n        } else {\n            if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);\n            if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);\n        }\n        this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);\n        let hasSnapped = false;\n        if (dx !== sx) {\n            this.snapped[0] = dx;\n            if (this.snapX) hasSnapped = true;\n        }\n        if (dy !== sy && this.snapY) {\n            this.snapped[1] = dy;\n            if (this.snapY) hasSnapped = true;\n        }\n        if (hasSnapped) this.onSnap(this);\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = true;\n        this.released = true;\n        // It's important to trigger the callback after the release animations to be able to cancel them\n        this.onRelease(this);\n        this.$trigger.removeEventListener(\"touchstart\", preventDefault);\n        this.$trigger.removeEventListener(\"touchmove\", preventDefault);\n        this.$trigger.removeEventListener(\"touchend\", preventDefault);\n        doc.removeEventListener(\"touchmove\", this);\n        doc.removeEventListener(\"touchend\", this);\n        doc.removeEventListener(\"touchcancel\", this);\n        doc.removeEventListener(\"mousemove\", this);\n        doc.removeEventListener(\"mouseup\", this);\n        doc.removeEventListener(\"selectstart\", this);\n    }\n    reset() {\n        this.stop();\n        this.resizeTicker.pause();\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.setX(0, true);\n        this.setY(0, true);\n        this.coords[0] = 0;\n        this.coords[1] = 0;\n        this.pointer[0] = 0;\n        this.pointer[1] = 0;\n        this.pointer[2] = 0;\n        this.pointer[3] = 0;\n        this.pointer[4] = 0;\n        this.pointer[5] = 0;\n        this.pointer[6] = 0;\n        this.pointer[7] = 0;\n        this.velocity = 0;\n        this.velocityStack[0] = 0;\n        this.velocityStack[1] = 0;\n        this.velocityStack[2] = 0;\n        this.velocityStackIndex = 0;\n        this.angle = 0;\n        return this;\n    }\n    enable() {\n        if (!this.enabled) {\n            this.enabled = true;\n            this.$target.classList.remove(\"is-disabled\");\n            this.touchActionStyles = setTargetValues(this.$trigger, {\n                touchAction: this.disabled[0] ? \"pan-x\" : this.disabled[1] ? \"pan-y\" : \"none\"\n            });\n            this.$trigger.addEventListener(\"touchstart\", this, {\n                passive: true\n            });\n            this.$trigger.addEventListener(\"mousedown\", this, {\n                passive: true\n            });\n            this.$trigger.addEventListener(\"mouseenter\", this);\n        }\n        return this;\n    }\n    disable() {\n        this.enabled = false;\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.touchActionStyles.revert();\n        if (this.cursorStyles) {\n            this.cursorStyles.revert();\n            this.cursorStyles = null;\n        }\n        if (this.triggerStyles) {\n            this.triggerStyles.revert();\n            this.triggerStyles = null;\n        }\n        if (this.bodyStyles) {\n            this.bodyStyles.revert();\n            this.bodyStyles = null;\n        }\n        if (this.targetStyles) {\n            this.targetStyles.revert();\n            this.targetStyles = null;\n        }\n        this.stop();\n        this.$target.classList.add(\"is-disabled\");\n        this.$trigger.removeEventListener(\"touchstart\", this);\n        this.$trigger.removeEventListener(\"mousedown\", this);\n        this.$trigger.removeEventListener(\"mouseenter\", this);\n        doc.removeEventListener(\"touchmove\", this);\n        doc.removeEventListener(\"touchend\", this);\n        doc.removeEventListener(\"touchcancel\", this);\n        doc.removeEventListener(\"mousemove\", this);\n        doc.removeEventListener(\"mouseup\", this);\n        doc.removeEventListener(\"selectstart\", this);\n        return this;\n    }\n    revert() {\n        this.reset();\n        this.disable();\n        this.$target.classList.remove(\"is-disabled\");\n        this.updateTicker.revert();\n        this.overshootXTicker.revert();\n        this.overshootYTicker.revert();\n        this.resizeTicker.revert();\n        this.animate.revert();\n        return this;\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"mousedown\":\n                this.handleDown(/** @type {MouseEvent} */ e);\n                break;\n            case \"touchstart\":\n                this.handleDown(/** @type {TouchEvent} */ e);\n                break;\n            case \"mousemove\":\n                this.handleMove(/** @type {MouseEvent} */ e);\n                break;\n            case \"touchmove\":\n                this.handleMove(/** @type {TouchEvent} */ e);\n                break;\n            case \"mouseup\":\n                this.handleUp();\n                break;\n            case \"touchend\":\n                this.handleUp();\n                break;\n            case \"touchcancel\":\n                this.handleUp();\n                break;\n            case \"mouseenter\":\n                this.handleHover();\n                break;\n            case \"selectstart\":\n                preventDefault(e);\n                break;\n        }\n    }\n    /**\n   * @param {TargetsParam} target\n   * @param {DraggableParams} [parameters]\n   */ constructor(target, parameters = {}){\n        if (!target) return;\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const paramX = parameters.x;\n        const paramY = parameters.y;\n        const trigger = parameters.trigger;\n        const modifier = parameters.modifier;\n        const ease = parameters.releaseEase;\n        const customEase = ease && parseEasings(ease);\n        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ ease.ease);\n        const xProp = /** @type {String} */ isObj(paramX) && !isUnd(/** @type {Object} */ paramX.mapTo) ? /** @type {Object} */ paramX.mapTo : \"translateX\";\n        const yProp = /** @type {String} */ isObj(paramY) && !isUnd(/** @type {Object} */ paramY.mapTo) ? /** @type {Object} */ paramY.mapTo : \"translateY\";\n        const container = parseDraggableFunctionParameter(parameters.container, this);\n        this.containerArray = isArr(container) ? container : null;\n        this.$container = /** @type {HTMLElement} */ container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ container)[0] : doc.body;\n        this.useWin = this.$container === doc.body;\n        /** @type {Window | HTMLElement} */ this.$scrollContainer = this.useWin ? win : this.$container;\n        this.$target = /** @type {HTMLElement} */ isObj(target) ? new DOMProxy(target) : parseTargets(target)[0];\n        this.$trigger = /** @type {HTMLElement} */ parseTargets(trigger ? trigger : target)[0];\n        this.fixed = getTargetValue(this.$target, \"position\") === \"fixed\";\n        // Refreshable parameters\n        this.isFinePointer = true;\n        /** @type {[Number, Number, Number, Number]} */ this.containerPadding = [\n            0,\n            0,\n            0,\n            0\n        ];\n        /** @type {Number} */ this.containerFriction = 0;\n        /** @type {Number} */ this.releaseContainerFriction = 0;\n        /** @type {Number|Array<Number>} */ this.snapX = 0;\n        /** @type {Number|Array<Number>} */ this.snapY = 0;\n        /** @type {Number} */ this.scrollSpeed = 0;\n        /** @type {Number} */ this.scrollThreshold = 0;\n        /** @type {Number} */ this.dragSpeed = 0;\n        /** @type {Number} */ this.maxVelocity = 0;\n        /** @type {Number} */ this.minVelocity = 0;\n        /** @type {Number} */ this.velocityMultiplier = 0;\n        /** @type {Boolean|DraggableCursorParams} */ this.cursor = false;\n        /** @type {Spring} */ this.releaseXSpring = hasSpring ? /** @type {Spring} */ ease : createSpring({\n            mass: setValue(parameters.releaseMass, 1),\n            stiffness: setValue(parameters.releaseStiffness, 80),\n            damping: setValue(parameters.releaseDamping, 20)\n        });\n        /** @type {Spring} */ this.releaseYSpring = hasSpring ? /** @type {Spring} */ ease : createSpring({\n            mass: setValue(parameters.releaseMass, 1),\n            stiffness: setValue(parameters.releaseStiffness, 80),\n            damping: setValue(parameters.releaseDamping, 20)\n        });\n        /** @type {EasingFunction} */ this.releaseEase = customEase || eases.outQuint;\n        /** @type {Boolean} */ this.hasReleaseSpring = hasSpring;\n        /** @type {Callback<this>} */ this.onGrab = parameters.onGrab || noop;\n        /** @type {Callback<this>} */ this.onDrag = parameters.onDrag || noop;\n        /** @type {Callback<this>} */ this.onRelease = parameters.onRelease || noop;\n        /** @type {Callback<this>} */ this.onUpdate = parameters.onUpdate || noop;\n        /** @type {Callback<this>} */ this.onSettle = parameters.onSettle || noop;\n        /** @type {Callback<this>} */ this.onSnap = parameters.onSnap || noop;\n        /** @type {Callback<this>} */ this.onResize = parameters.onResize || noop;\n        /** @type {Callback<this>} */ this.onAfterResize = parameters.onAfterResize || noop;\n        /** @type {[Number, Number]} */ this.disabled = [\n            0,\n            0\n        ];\n        /** @type {AnimatableParams} */ const animatableParams = {};\n        if (modifier) animatableParams.modifier = modifier;\n        if (isUnd(paramX) || paramX === true) {\n            animatableParams[xProp] = 0;\n        } else if (isObj(paramX)) {\n            const paramXObject = /** @type {DraggableAxisParam} */ paramX;\n            const animatableXParams = {};\n            if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;\n            if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;\n            animatableParams[xProp] = animatableXParams;\n        } else if (paramX === false) {\n            animatableParams[xProp] = 0;\n            this.disabled[0] = 1;\n        }\n        if (isUnd(paramY) || paramY === true) {\n            animatableParams[yProp] = 0;\n        } else if (isObj(paramY)) {\n            const paramYObject = /** @type {DraggableAxisParam} */ paramY;\n            const animatableYParams = {};\n            if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;\n            if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;\n            animatableParams[yProp] = animatableYParams;\n        } else if (paramY === false) {\n            animatableParams[yProp] = 0;\n            this.disabled[1] = 1;\n        }\n        /** @type {AnimatableObject} */ this.animate = /** @type {AnimatableObject} */ new Animatable(this.$target, animatableParams);\n        // Internal props\n        this.xProp = xProp;\n        this.yProp = yProp;\n        this.destX = 0;\n        this.destY = 0;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.scroll = {\n            x: 0,\n            y: 0\n        };\n        /** @type {[Number, Number, Number, Number]} */ this.coords = [\n            this.x,\n            this.y,\n            0,\n            0\n        ]; // x, y, temp x, temp y\n        /** @type {[Number, Number]} */ this.snapped = [\n            0,\n            0\n        ]; // x, y\n        /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */ this.pointer = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2\n        /** @type {[Number, Number]} */ this.scrollView = [\n            0,\n            0\n        ]; // w, h\n        /** @type {[Number, Number, Number, Number]} */ this.dragArea = [\n            0,\n            0,\n            0,\n            0\n        ]; // x, y, w, h\n        /** @type {[Number, Number, Number, Number]} */ this.containerBounds = [\n            -1e12,\n            maxValue,\n            maxValue,\n            -1e12\n        ]; // t, r, b, l\n        /** @type {[Number, Number, Number, Number]} */ this.scrollBounds = [\n            0,\n            0,\n            0,\n            0\n        ]; // t, r, b, l\n        /** @type {[Number, Number, Number, Number]} */ this.targetBounds = [\n            0,\n            0,\n            0,\n            0\n        ]; // t, r, b, l\n        /** @type {[Number, Number]} */ this.window = [\n            0,\n            0\n        ]; // w, h\n        /** @type {[Number, Number, Number]} */ this.velocityStack = [\n            0,\n            0,\n            0\n        ];\n        /** @type {Number} */ this.velocityStackIndex = 0;\n        /** @type {Number} */ this.velocityTime = now();\n        /** @type {Number} */ this.velocity = 0;\n        /** @type {Number} */ this.angle = 0;\n        /** @type {JSAnimation} */ this.cursorStyles = null;\n        /** @type {JSAnimation} */ this.triggerStyles = null;\n        /** @type {JSAnimation} */ this.bodyStyles = null;\n        /** @type {JSAnimation} */ this.targetStyles = null;\n        /** @type {JSAnimation} */ this.touchActionStyles = null;\n        this.transforms = new Transforms(this.$target);\n        this.overshootCoords = {\n            x: 0,\n            y: 0\n        };\n        this.overshootXTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.overshootYTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.updateTicker = new Timer({\n            autoplay: false\n        }, null, 0).init();\n        this.overshootXTicker.onUpdate = ()=>{\n            if (this.disabled[0]) return;\n            this.updated = true;\n            this.manual = true;\n            this.animate[this.xProp](this.overshootCoords.x, 0);\n        };\n        this.overshootXTicker.onComplete = ()=>{\n            if (this.disabled[0]) return;\n            this.manual = false;\n            this.animate[this.xProp](this.overshootCoords.x, 0);\n        };\n        this.overshootYTicker.onUpdate = ()=>{\n            if (this.disabled[1]) return;\n            this.updated = true;\n            this.manual = true;\n            this.animate[this.yProp](this.overshootCoords.y, 0);\n        };\n        this.overshootYTicker.onComplete = ()=>{\n            if (this.disabled[1]) return;\n            this.manual = false;\n            this.animate[this.yProp](this.overshootCoords.y, 0);\n        };\n        this.updateTicker.onUpdate = ()=>this.update();\n        this.contained = !isUnd(container);\n        this.manual = false;\n        this.grabbed = false;\n        this.dragged = false;\n        this.updated = false;\n        this.released = false;\n        this.canScroll = false;\n        this.enabled = false;\n        this.initialized = false;\n        this.activeProp = this.disabled[1] ? xProp : yProp;\n        this.animate.animations[this.activeProp].onRender = ()=>{\n            const hasUpdated = this.updated;\n            const hasMoved = this.grabbed && hasUpdated;\n            const hasReleased = !hasMoved && this.released;\n            const x = this.x;\n            const y = this.y;\n            const dx = x - this.coords[2];\n            const dy = y - this.coords[3];\n            this.deltaX = dx;\n            this.deltaY = dy;\n            this.coords[2] = x;\n            this.coords[3] = y;\n            if (hasUpdated) {\n                this.onUpdate(this);\n            }\n            if (!hasReleased) {\n                this.updated = false;\n            } else {\n                this.computeVelocity(dx, dy);\n                this.angle = atan2(dy, dx);\n            }\n        };\n        this.animate.animations[this.activeProp].onComplete = ()=>{\n            if (!this.grabbed && this.released) {\n                // Set eleased to false before calling onSettle to avoid recursion\n                this.released = false;\n            }\n            if (!this.manual) {\n                this.deltaX = 0;\n                this.deltaY = 0;\n                this.velocity = 0;\n                this.velocityStack[0] = 0;\n                this.velocityStack[1] = 0;\n                this.velocityStack[2] = 0;\n                this.velocityStackIndex = 0;\n                this.onSettle(this);\n            }\n        };\n        this.resizeTicker = new Timer({\n            autoplay: false,\n            duration: 150 * globals.timeScale,\n            onComplete: ()=>{\n                this.onResize(this);\n                this.refresh();\n                this.onAfterResize(this);\n            }\n        }).init();\n        this.parameters = parameters;\n        this.resizeObserver = new ResizeObserver(()=>{\n            if (this.initialized) {\n                this.resizeTicker.restart();\n            } else {\n                this.initialized = true;\n            }\n        });\n        this.enable();\n        this.refresh();\n        this.resizeObserver.observe(this.$container);\n        if (!isObj(target)) this.resizeObserver.observe(this.$target);\n    }\n}\n/**\n * @param {TargetsParam} target\n * @param {DraggableParams} [parameters]\n * @return {Draggable}\n */ const createDraggable = (target, parameters)=>new Draggable(target, parameters);\n/**\n * @typedef {Object} ReactRef\n * @property {HTMLElement|SVGElement|null} [current]\n */ /**\n * @typedef {Object} AngularRef\n * @property {HTMLElement|SVGElement} [nativeElement]\n */ /**\n * @typedef {Object} ScopeParams\n * @property {DOMTargetSelector|ReactRef|AngularRef} [root]\n * @property {DefaultsParams} [defaults]\n * @property {Record<String, String>} [mediaQueries]\n */ /**\n * @callback ScopeCleanup\n * @param {Scope} [scope]\n */ /**\n * @callback ScopeConstructor\n * @param {Scope} [scope]\n * @return {ScopeCleanup|void}\n */ /**\n * @callback ScopeMethod\n * @param {...*} args\n * @return {ScopeCleanup|void}\n */ class Scope {\n    /**\n   * @callback ScoppedCallback\n   * @param {this} scope\n   * @return {any}\n   *\n   * @param {ScoppedCallback} cb\n   * @return {this}\n   */ execute(cb) {\n        let activeScope = globals.scope;\n        let activeRoot = globals.root;\n        let activeDefaults = globals.defaults;\n        globals.scope = this;\n        globals.root = this.root;\n        globals.defaults = this.defaults;\n        const mqs = this.mediaQueryLists;\n        for(let mq in mqs)this.matches[mq] = mqs[mq].matches;\n        const returned = cb(this);\n        globals.scope = activeScope;\n        globals.root = activeRoot;\n        globals.defaults = activeDefaults;\n        return returned;\n    }\n    /**\n   * @return {this}\n   */ refresh() {\n        this.execute(()=>{\n            let i = this.revertibles.length;\n            let y = this.revertConstructors.length;\n            while(i--)this.revertibles[i].revert();\n            while(y--)this.revertConstructors[y](this);\n            this.revertibles.length = 0;\n            this.revertConstructors.length = 0;\n            this.constructors.forEach((constructor)=>{\n                const revertConstructor = constructor(this);\n                if (revertConstructor) {\n                    this.revertConstructors.push(revertConstructor);\n                }\n            });\n        });\n        return this;\n    }\n    /**\n   * @callback contructorCallback\n   * @param {this} self\n   *\n   * @overload\n   * @param {String} a1\n   * @param {ScopeMethod} a2\n   * @return {this}\n   *\n   * @overload\n   * @param {contructorCallback} a1\n   * @return {this}\n   *\n   * @param {String|contructorCallback} a1\n   * @param {ScopeMethod} [a2]\n   */ add(a1, a2) {\n        if (isFnc(a1)) {\n            const constructor = /** @type {contructorCallback} */ a1;\n            this.constructors.push(constructor);\n            this.execute(()=>{\n                const revertConstructor = constructor(this);\n                if (revertConstructor) {\n                    this.revertConstructors.push(revertConstructor);\n                }\n            });\n        } else {\n            var _this = this;\n            this.methods[/** @type {String} */ a1] = function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return _this.execute(()=>a2(...args));\n            };\n        }\n        return this;\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"change\":\n                this.refresh();\n                break;\n        }\n    }\n    revert() {\n        const revertibles = this.revertibles;\n        const revertConstructors = this.revertConstructors;\n        const mqs = this.mediaQueryLists;\n        let i = revertibles.length;\n        let y = revertConstructors.length;\n        while(i--)revertibles[i].revert();\n        while(y--)revertConstructors[y](this);\n        for(let mq in mqs)mqs[mq].removeEventListener(\"change\", this);\n        revertibles.length = 0;\n        revertConstructors.length = 0;\n        this.constructors.length = 0;\n        this.matches = {};\n        this.methods = {};\n        this.mediaQueryLists = {};\n        this.data = {};\n    }\n    /** @param {ScopeParams} [parameters] */ constructor(parameters = {}){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const rootParam = parameters.root;\n        /** @type {Document|DOMTarget} */ let root = doc;\n        if (rootParam) {\n            root = /** @type {ReactRef} */ rootParam.current || /** @type {AngularRef} */ rootParam.nativeElement || parseTargets(/** @type {DOMTargetSelector} */ rootParam)[0] || doc;\n        }\n        const scopeDefaults = parameters.defaults;\n        const globalDefault = globals.defaults;\n        const mediaQueries = parameters.mediaQueries;\n        /** @type {DefaultsParams} */ this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;\n        /** @type {Document|DOMTarget} */ this.root = root;\n        /** @type {Array<ScopeConstructor>} */ this.constructors = [];\n        /** @type {Array<Function>} */ this.revertConstructors = [];\n        /** @type {Array<Revertible>} */ this.revertibles = [];\n        /** @type {Record<String, Function>} */ this.methods = {};\n        /** @type {Record<String, Boolean>} */ this.matches = {};\n        /** @type {Record<String, MediaQueryList>} */ this.mediaQueryLists = {};\n        /** @type {Record<String, any>} */ this.data = {};\n        if (mediaQueries) {\n            for(let mq in mediaQueries){\n                const _mq = win.matchMedia(mediaQueries[mq]);\n                this.mediaQueryLists[mq] = _mq;\n                _mq.addEventListener(\"change\", this);\n            }\n        }\n    }\n}\n/**\n * @param {ScopeParams} [params]\n * @return {Scope}\n */ const createScope = (params)=>new Scope(params);\n/**\n * @typedef {String|Number} ScrollThresholdValue\n */ /**\n * @return {Number}\n */ const getMaxViewHeight = ()=>{\n    const $el = document.createElement(\"div\");\n    doc.body.appendChild($el);\n    $el.style.height = \"100lvh\";\n    const height = $el.offsetHeight;\n    doc.body.removeChild($el);\n    return height;\n};\n/**\n * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T\n * @param {T | ((observer: ScrollObserver) => T)} value\n * @param {ScrollObserver} scroller\n * @return {T}\n */ const parseScrollObserverFunctionParameter = (value, scroller)=>value && isFnc(value) ? /** @type {Function} */ value(scroller) : value;\nconst scrollContainers = new Map();\nclass ScrollContainer {\n    updateScrollCoords() {\n        const useWin = this.useWin;\n        const $el = this.element;\n        this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);\n        this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);\n    }\n    updateWindowBounds() {\n        this.winWidth = win.innerWidth;\n        this.winHeight = getMaxViewHeight();\n    }\n    updateBounds() {\n        const style = getComputedStyle(this.element);\n        const $el = this.element;\n        this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        this.updateWindowBounds();\n        let width, height;\n        if (this.useWin) {\n            width = this.winWidth;\n            height = this.winHeight;\n        } else {\n            const elRect = $el.getBoundingClientRect();\n            width = elRect.width;\n            height = elRect.height;\n            this.top = elRect.top;\n            this.left = elRect.left;\n        }\n        this.width = width;\n        this.height = height;\n    }\n    refreshScrollObservers() {\n        forEachChildren(this, (/** @type {ScrollObserver} */ child)=>{\n            if (child._debug) {\n                child.removeDebug();\n            }\n        });\n        this.updateBounds();\n        forEachChildren(this, (/** @type {ScrollObserver} */ child)=>{\n            child.refresh();\n            if (child._debug) {\n                child.debug();\n            }\n        });\n    }\n    refresh() {\n        this.updateWindowBounds();\n        this.updateBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n    }\n    handleScroll() {\n        this.updateScrollCoords();\n        this.wakeTicker.restart();\n    }\n    /**\n   * @param {Event} e\n   */ handleEvent(e) {\n        switch(e.type){\n            case \"scroll\":\n                this.handleScroll();\n                break;\n        }\n    }\n    revert() {\n        this.scrollTicker.cancel();\n        this.dataTimer.cancel();\n        this.resizeTicker.cancel();\n        this.wakeTicker.cancel();\n        this.resizeObserver.unobserve(this.element);\n        (this.useWin ? win : this.element).removeEventListener(\"scroll\", this);\n        scrollContainers.delete(this.element);\n    }\n    /**\n   * @param {HTMLElement} $el\n   */ constructor($el){\n        /** @type {HTMLElement} */ this.element = $el;\n        /** @type {Boolean} */ this.useWin = this.element === doc.body;\n        /** @type {Number} */ this.winWidth = 0;\n        /** @type {Number} */ this.winHeight = 0;\n        /** @type {Number} */ this.width = 0;\n        /** @type {Number} */ this.height = 0;\n        /** @type {Number} */ this.left = 0;\n        /** @type {Number} */ this.top = 0;\n        /** @type {Number} */ this.zIndex = 0;\n        /** @type {Number} */ this.scrollX = 0;\n        /** @type {Number} */ this.scrollY = 0;\n        /** @type {Number} */ this.prevScrollX = 0;\n        /** @type {Number} */ this.prevScrollY = 0;\n        /** @type {Number} */ this.scrollWidth = 0;\n        /** @type {Number} */ this.scrollHeight = 0;\n        /** @type {Number} */ this.velocity = 0;\n        /** @type {Boolean} */ this.backwardX = false;\n        /** @type {Boolean} */ this.backwardY = false;\n        /** @type {Timer} */ this.scrollTicker = new Timer({\n            autoplay: false,\n            onBegin: ()=>this.dataTimer.resume(),\n            onUpdate: ()=>{\n                const backwards = this.backwardX || this.backwardY;\n                forEachChildren(this, (/** @type {ScrollObserver} */ child)=>child.handleScroll(), backwards);\n            },\n            onComplete: ()=>this.dataTimer.pause()\n        }).init();\n        /** @type {Timer} */ this.dataTimer = new Timer({\n            autoplay: false,\n            frameRate: 30,\n            onUpdate: (self)=>{\n                const dt = self.deltaTime;\n                const px = this.prevScrollX;\n                const py = this.prevScrollY;\n                const nx = this.scrollX;\n                const ny = this.scrollY;\n                const dx = px - nx;\n                const dy = py - ny;\n                this.prevScrollX = nx;\n                this.prevScrollY = ny;\n                if (dx) this.backwardX = px > nx;\n                if (dy) this.backwardY = py > ny;\n                this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);\n            }\n        }).init();\n        /** @type {Timer} */ this.resizeTicker = new Timer({\n            autoplay: false,\n            duration: 250 * globals.timeScale,\n            onComplete: ()=>{\n                this.updateWindowBounds();\n                this.refreshScrollObservers();\n                this.handleScroll();\n            }\n        }).init();\n        /** @type {Timer} */ this.wakeTicker = new Timer({\n            autoplay: false,\n            duration: 500 * globals.timeScale,\n            onBegin: ()=>{\n                this.scrollTicker.resume();\n            },\n            onComplete: ()=>{\n                this.scrollTicker.pause();\n            }\n        }).init();\n        /** @type {ScrollObserver} */ this._head = null;\n        /** @type {ScrollObserver} */ this._tail = null;\n        this.updateScrollCoords();\n        this.updateWindowBounds();\n        this.updateBounds();\n        this.refreshScrollObservers();\n        this.handleScroll();\n        this.resizeObserver = new ResizeObserver(()=>this.resizeTicker.restart());\n        this.resizeObserver.observe(this.element);\n        (this.useWin ? win : this.element).addEventListener(\"scroll\", this, false);\n    }\n}\n/**\n * @param {TargetsParam} target\n * @return {ScrollContainer}\n */ const registerAndGetScrollContainer = (target)=>{\n    const $el = /** @type {HTMLElement} */ target ? parseTargets(target)[0] || doc.body : doc.body;\n    let scrollContainer = scrollContainers.get($el);\n    if (!scrollContainer) {\n        scrollContainer = new ScrollContainer($el);\n        scrollContainers.set($el, scrollContainer);\n    }\n    return scrollContainer;\n};\n/**\n * @param {HTMLElement} $el\n * @param {Number|string} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */ const convertValueToPx = ($el, v, size, under, over)=>{\n    const clampMin = v === \"min\";\n    const clampMax = v === \"max\";\n    const value = v === \"top\" || v === \"left\" || v === \"start\" || clampMin ? 0 : v === \"bottom\" || v === \"right\" || v === \"end\" || clampMax ? \"100%\" : v === \"center\" ? \"50%\" : v;\n    const { n, u } = decomposeRawValue(value, decomposedOriginalValue);\n    let px = n;\n    if (u === \"%\") {\n        px = n / 100 * size;\n    } else if (u) {\n        px = convertValueUnit($el, decomposedOriginalValue, \"px\", true).n;\n    }\n    if (clampMax && under < 0) px += under;\n    if (clampMin && over > 0) px += over;\n    return px;\n};\n/**\n * @param {HTMLElement} $el\n * @param {ScrollThresholdValue} v\n * @param {Number} size\n * @param {Number} [under]\n * @param {Number} [over]\n * @return {Number}\n */ const parseBoundValue = ($el, v, size, under, over)=>{\n    /** @type {Number} */ let value;\n    if (isStr(v)) {\n        const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */ v);\n        if (matchedOperator) {\n            const splitter = matchedOperator[0];\n            const operator = splitter[0];\n            const splitted = /** @type {String} */ v.split(splitter);\n            const clampMin = splitted[0] === \"min\";\n            const clampMax = splitted[0] === \"max\";\n            const valueAPx = convertValueToPx($el, splitted[0], size, under, over);\n            const valueBPx = convertValueToPx($el, splitted[1], size, under, over);\n            if (clampMin) {\n                const min = getRelativeValue(convertValueToPx($el, \"min\", size), valueBPx, operator);\n                value = min < valueAPx ? valueAPx : min;\n            } else if (clampMax) {\n                const max = getRelativeValue(convertValueToPx($el, \"max\", size), valueBPx, operator);\n                value = max > valueAPx ? valueAPx : max;\n            } else {\n                value = getRelativeValue(valueAPx, valueBPx, operator);\n            }\n        } else {\n            value = convertValueToPx($el, v, size, under, over);\n        }\n    } else {\n        value = /** @type {Number} */ v;\n    }\n    return round(value, 0);\n};\n/**\n * @param {JSAnimation} linked\n * @return {HTMLElement}\n */ const getAnimationDomTarget = (linked)=>{\n    let $linkedTarget;\n    const linkedTargets = linked.targets;\n    for(let i = 0, l = linkedTargets.length; i < l; i++){\n        const target = linkedTargets[i];\n        if (target[isDomSymbol]) {\n            $linkedTarget = /** @type {HTMLElement} */ target;\n            break;\n        }\n    }\n    return $linkedTarget;\n};\nlet scrollerIndex = 0;\nconst debugColors = [\n    \"#FF4B4B\",\n    \"#FF971B\",\n    \"#FFC730\",\n    \"#F9F640\",\n    \"#7AFF5A\",\n    \"#18FF74\",\n    \"#17E09B\",\n    \"#3CFFEC\",\n    \"#05DBE9\",\n    \"#33B3F1\",\n    \"#638CF9\",\n    \"#C563FE\",\n    \"#FF4FCF\",\n    \"#F93F8A\"\n];\n/**\n * @typedef {Object} ScrollThresholdParam\n * @property {ScrollThresholdValue} [target]\n * @property {ScrollThresholdValue} [container]\n */ /**\n * @callback ScrollObserverAxisCallback\n * @param {ScrollObserver} self\n * @return {'x'|'y'}\n */ /**\n * @callback ScrollThresholdCallback\n * @param {ScrollObserver} self\n * @return {ScrollThresholdValue|ScrollThresholdParam}\n */ /**\n * @typedef {Object} ScrollObserverParams\n * @property {Number|String} [id]\n * @property {Boolean|Number|String|EasingParam} [sync]\n * @property {TargetsParam} [container]\n * @property {TargetsParam} [target]\n * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]\n * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]\n * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]\n * @property {Boolean} [debug]\n * @property {Callback<ScrollObserver>} [onEnter]\n * @property {Callback<ScrollObserver>} [onLeave]\n * @property {Callback<ScrollObserver>} [onEnterForward]\n * @property {Callback<ScrollObserver>} [onLeaveForward]\n * @property {Callback<ScrollObserver>} [onEnterBackward]\n * @property {Callback<ScrollObserver>} [onLeaveBackward]\n * @property {Callback<ScrollObserver>} [onUpdate]\n * @property {Callback<ScrollObserver>} [onSyncComplete]\n */ class ScrollObserver {\n    /**\n   * @param {Tickable|WAAPIAnimation} linked\n   */ link(linked) {\n        if (linked) {\n            // Make sure to pause the linked object in case it's added later\n            linked.pause();\n            this.linked = linked;\n            // Try to use a target of the linked object if no target parameters specified\n            if (!this._params.target) {\n                /** @type {HTMLElement} */ let $linkedTarget;\n                if (!isUnd(/** @type {JSAnimation} */ linked.targets)) {\n                    $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ linked);\n                } else {\n                    forEachChildren(/** @type {Timeline} */ linked, (/** @type {JSAnimation} */ child)=>{\n                        if (child.targets && !$linkedTarget) {\n                            $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ child);\n                        }\n                    });\n                }\n                // Fallback to body if no target found\n                this.target = $linkedTarget || doc.body;\n                this.refresh();\n            }\n        }\n        return this;\n    }\n    get velocity() {\n        return this.container.velocity;\n    }\n    get backward() {\n        return this.horizontal ? this.container.backwardX : this.container.backwardY;\n    }\n    get scroll() {\n        return this.horizontal ? this.container.scrollX : this.container.scrollY;\n    }\n    get progress() {\n        const p = (this.scroll - this.offsetStart) / this.distance;\n        return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);\n    }\n    refresh() {\n        this.reverted = false;\n        const params = this._params;\n        this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);\n        this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), \"y\") === \"x\";\n        this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), \"end start\");\n        this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), \"start end\");\n        this.updateBounds();\n        this.handleScroll();\n        return this;\n    }\n    removeDebug() {\n        if (this.$debug) {\n            this.$debug.parentNode.removeChild(this.$debug);\n            this.$debug = null;\n        }\n        if (this.debugStyles) {\n            this.debugStyles.revert();\n            this.$debug = null;\n        }\n        return this;\n    }\n    debug() {\n        this.removeDebug();\n        const container = this.container;\n        const isHori = this.horizontal;\n        const $existingDebug = container.element.querySelector(\":scope > .animejs-onscroll-debug\");\n        const $debug = doc.createElement(\"div\");\n        const $thresholds = doc.createElement(\"div\");\n        const $triggers = doc.createElement(\"div\");\n        const color = debugColors[this.index % debugColors.length];\n        const useWin = container.useWin;\n        const containerWidth = useWin ? container.winWidth : container.width;\n        const containerHeight = useWin ? container.winHeight : container.height;\n        const scrollWidth = container.scrollWidth;\n        const scrollHeight = container.scrollHeight;\n        const size = this.container.width > 360 ? 320 : 260;\n        const offLeft = isHori ? 0 : 10;\n        const offTop = isHori ? 10 : 0;\n        const half = isHori ? 24 : size / 2;\n        const labelHeight = isHori ? half : 15;\n        const labelWidth = isHori ? 60 : half;\n        const labelSize = isHori ? labelWidth : labelHeight;\n        const repeat = isHori ? \"repeat-x\" : \"repeat-y\";\n        /**\n     * @param {Number} v\n     * @return {String}\n     */ const gradientOffset = (v)=>isHori ? \"0px \" + v + \"px\" : v + \"px\" + \" 2px\";\n        /**\n     * @param {String} c\n     * @return {String}\n     */ const lineCSS = (c)=>\"linear-gradient(\".concat(isHori ? 90 : 0, \"deg, \").concat(c, \" 2px, transparent 1px)\");\n        /**\n     * @param {String} p\n     * @param {Number} l\n     * @param {Number} t\n     * @param {Number} w\n     * @param {Number} h\n     * @return {String}\n     */ const baseCSS = (p, l, t, w, h)=>\"position:\".concat(p, \";left:\").concat(l, \"px;top:\").concat(t, \"px;width:\").concat(w, \"px;height:\").concat(h, \"px;\");\n        $debug.style.cssText = \"\".concat(baseCSS(\"absolute\", offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight), \"\\n      pointer-events: none;\\n      z-index: \").concat(this.container.zIndex++, \";\\n      display: flex;\\n      flex-direction: \").concat(isHori ? \"column\" : \"row\", \";\\n      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));\\n    \");\n        $thresholds.style.cssText = \"\".concat(baseCSS(\"sticky\", 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight));\n        if (!$existingDebug) {\n            $thresholds.style.cssText += \"background:\\n        \".concat(lineCSS(\"#FFFF\")).concat(gradientOffset(half - 10), \" / \").concat(isHori ? \"100px 100px\" : \"100px 100px\", \" \").concat(repeat, \",\\n        \").concat(lineCSS(\"#FFF8\")).concat(gradientOffset(half - 10), \" / \").concat(isHori ? \"10px 10px\" : \"10px 10px\", \" \").concat(repeat, \";\\n      \");\n        }\n        $triggers.style.cssText = \"\".concat(baseCSS(\"relative\", 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight));\n        if (!$existingDebug) {\n            $triggers.style.cssText += \"background:\\n        \".concat(lineCSS(\"#FFFF\")).concat(gradientOffset(0), \" / \").concat(isHori ? \"100px 10px\" : \"10px 100px\", \" \").concat(repeat, \",\\n        \").concat(lineCSS(\"#FFF8\")).concat(gradientOffset(0), \" / \").concat(isHori ? \"10px 0px\" : \"0px 10px\", \" \").concat(repeat, \";\\n      \");\n        }\n        const labels = [\n            \" enter: \",\n            \" leave: \"\n        ];\n        this.coords.forEach((v, i)=>{\n            const isView = i > 1;\n            const value = (isView ? 0 : this.offset) + v;\n            const isTail = i % 2;\n            const isFirst = value < labelSize;\n            const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;\n            const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;\n            const $label = doc.createElement(\"div\");\n            const $text = doc.createElement(\"div\");\n            const dirProp = isHori ? isFlip ? \"right\" : \"left\" : isFlip ? \"bottom\" : \"top\";\n            const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;\n            // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;\n            $text.innerHTML = \"\".concat(this.id).concat(labels[isTail]).concat(this.thresholds[i]);\n            $label.style.cssText = \"\".concat(baseCSS(\"absolute\", 0, 0, labelWidth, labelHeight), \"\\n        display: flex;\\n        flex-direction: \").concat(isHori ? \"column\" : \"row\", \";\\n        justify-content: flex-\").concat(isView ? \"start\" : \"end\", \";\\n        align-items: flex-\").concat(isFlip ? \"end\" : \"start\", \";\\n        border-\").concat(dirProp, \": 2px \").concat(isTail ? \"solid\" : \"solid\", \" \").concat(color, \";\\n      \");\n            $text.style.cssText = \"\\n        overflow: hidden;\\n        max-width: \".concat(size / 2 - 10, \"px;\\n        height: \").concat(labelHeight, \";\\n        margin-\").concat(isHori ? isFlip ? \"right\" : \"left\" : isFlip ? \"bottom\" : \"top\", \": -2px;\\n        padding: 1px;\\n        font-family: ui-monospace, monospace;\\n        font-size: 10px;\\n        letter-spacing: -.025em;\\n        line-height: 9px;\\n        font-weight: 600;\\n        text-align: \").concat(isHori && isFlip || !isHori && !isView ? \"right\" : \"left\", \";\\n        white-space: pre;\\n        text-overflow: ellipsis;\\n        color: \").concat(isTail ? color : \"rgba(0,0,0,.75)\", \";\\n        background-color: \").concat(isTail ? \"rgba(0,0,0,.65)\" : color, \";\\n        border: 2px solid \").concat(isTail ? color : \"transparent\", \";\\n        border-\").concat(isHori ? isFlip ? \"top-left\" : \"top-right\" : isFlip ? \"top-left\" : \"bottom-left\", \"-radius: 5px;\\n        border-\").concat(isHori ? isFlip ? \"bottom-left\" : \"bottom-right\" : isFlip ? \"top-right\" : \"bottom-right\", \"-radius: 5px;\\n      \");\n            $label.appendChild($text);\n            let position = value - flipOffset + (isHori ? 1 : 0);\n            $label.style[isHori ? \"left\" : \"top\"] = \"\".concat(position, \"px\");\n            // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';\n            (isView ? $thresholds : $triggers).appendChild($label);\n        });\n        $debug.appendChild($thresholds);\n        $debug.appendChild($triggers);\n        container.element.appendChild($debug);\n        if (!$existingDebug) $debug.classList.add(\"animejs-onscroll-debug\");\n        this.$debug = $debug;\n        const containerPosition = getTargetValue(container.element, \"position\");\n        if (containerPosition === \"static\") {\n            this.debugStyles = setTargetValues(container.element, {\n                position: \"relative \"\n            });\n        }\n    }\n    updateBounds() {\n        if (this._debug) {\n            this.removeDebug();\n        }\n        let stickys;\n        const $target = this.target;\n        const container = this.container;\n        const isHori = this.horizontal;\n        const linked = this.linked;\n        let linkedTime;\n        let $el = $target;\n        let offsetX = 0;\n        let offsetY = 0;\n        /** @type {Element} */ let $offsetParent = $el;\n        if (linked) {\n            linkedTime = linked.currentTime;\n            linked.seek(0, true);\n        }\n        const isContainerStatic = getTargetValue(container.element, \"position\") === \"static\" ? setTargetValues(container.element, {\n            position: \"relative \"\n        }) : false;\n        while($el && $el !== container.element && $el !== doc.body){\n            const isSticky = getTargetValue($el, \"position\") === \"sticky\" ? setTargetValues($el, {\n                position: \"static\"\n            }) : false;\n            if ($el === $offsetParent) {\n                offsetX += $el.offsetLeft || 0;\n                offsetY += $el.offsetTop || 0;\n                $offsetParent = $el.offsetParent;\n            }\n            $el = /** @type {HTMLElement} */ $el.parentElement;\n            if (isSticky) {\n                if (!stickys) stickys = [];\n                stickys.push(isSticky);\n            }\n        }\n        if (isContainerStatic) isContainerStatic.revert();\n        const offset = isHori ? offsetX : offsetY;\n        const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;\n        const containerSize = isHori ? container.width : container.height;\n        const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;\n        const maxScroll = scrollSize - containerSize;\n        const enter = this.enter;\n        const leave = this.leave;\n        /** @type {ScrollThresholdValue} */ let enterTarget = \"start\";\n        /** @type {ScrollThresholdValue} */ let leaveTarget = \"end\";\n        /** @type {ScrollThresholdValue} */ let enterContainer = \"end\";\n        /** @type {ScrollThresholdValue} */ let leaveContainer = \"start\";\n        if (isStr(enter)) {\n            const splitted = /** @type {String} */ enter.split(\" \");\n            enterContainer = splitted[0];\n            enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;\n        } else if (isObj(enter)) {\n            const e = /** @type {ScrollThresholdParam} */ enter;\n            if (!isUnd(e.container)) enterContainer = e.container;\n            if (!isUnd(e.target)) enterTarget = e.target;\n        } else if (isNum(enter)) {\n            enterContainer = /** @type {Number} */ enter;\n        }\n        if (isStr(leave)) {\n            const splitted = /** @type {String} */ leave.split(\" \");\n            leaveContainer = splitted[0];\n            leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;\n        } else if (isObj(leave)) {\n            const t = /** @type {ScrollThresholdParam} */ leave;\n            if (!isUnd(t.container)) leaveContainer = t.container;\n            if (!isUnd(t.target)) leaveTarget = t.target;\n        } else if (isNum(leave)) {\n            leaveContainer = /** @type {Number} */ leave;\n        }\n        const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);\n        const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);\n        const under = parsedEnterTarget + offset - containerSize;\n        const over = parsedLeaveTarget + offset - maxScroll;\n        const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);\n        const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);\n        const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;\n        const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;\n        const scrollDelta = offsetEnd - offsetStart;\n        this.offsets[0] = offsetX;\n        this.offsets[1] = offsetY;\n        this.offset = offset;\n        this.offsetStart = offsetStart;\n        this.offsetEnd = offsetEnd;\n        this.distance = scrollDelta <= 0 ? 0 : scrollDelta;\n        this.thresholds = [\n            enterTarget,\n            leaveTarget,\n            enterContainer,\n            leaveContainer\n        ];\n        this.coords = [\n            parsedEnterTarget,\n            parsedLeaveTarget,\n            parsedEnterContainer,\n            parsedLeaveContainer\n        ];\n        if (stickys) {\n            stickys.forEach((sticky)=>sticky.revert());\n        }\n        if (linked) {\n            linked.seek(linkedTime, true);\n        }\n        if (this._debug) {\n            this.debug();\n        }\n    }\n    handleScroll() {\n        const linked = this.linked;\n        const sync = this.sync;\n        const syncEase = this.syncEase;\n        const syncSmooth = this.syncSmooth;\n        const shouldSeek = linked && (syncEase || syncSmooth);\n        const isHori = this.horizontal;\n        const container = this.container;\n        const scroll = this.scroll;\n        const isBefore = scroll <= this.offsetStart;\n        const isAfter = scroll >= this.offsetEnd;\n        const isInView = !isBefore && !isAfter;\n        const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;\n        const forceEnter = !this.hasEntered && isOnTheEdge;\n        const $debug = this._debug && this.$debug;\n        let hasUpdated = false;\n        let syncCompleted = false;\n        let p = this.progress;\n        if (isBefore && this.began) {\n            this.began = false;\n        }\n        if (p > 0 && !this.began) {\n            this.began = true;\n        }\n        if (shouldSeek) {\n            const lp = linked.progress;\n            if (syncSmooth && isNum(syncSmooth)) {\n                if (/** @type {Number} */ syncSmooth < 1) {\n                    const step = 0.0001;\n                    const snap = lp < p && p === 1 ? step : lp > p && !p ? -1e-4 : 0;\n                    p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */ syncSmooth), false) + snap, 6);\n                }\n            } else if (syncEase) {\n                p = syncEase(p);\n            }\n            hasUpdated = p !== this.prevProgress;\n            syncCompleted = lp === 1;\n            if (hasUpdated && !syncCompleted && syncSmooth && lp) {\n                container.wakeTicker.restart();\n            }\n        }\n        if ($debug) {\n            const sticky = isHori ? container.scrollY : container.scrollX;\n            $debug.style[isHori ? \"top\" : \"left\"] = sticky + 10 + \"px\";\n        }\n        // Trigger enter callbacks if already in view or when entering the view\n        if (isInView && !this.isInView || forceEnter && !this.forceEnter && !this.hasEntered) {\n            if (isInView) this.isInView = true;\n            if (!this.forceEnter || !this.hasEntered) {\n                if ($debug && isInView) $debug.style.zIndex = \"\".concat(this.container.zIndex++);\n                this.onSyncEnter(this);\n                this.onEnter(this);\n                if (this.backward) {\n                    this.onSyncEnterBackward(this);\n                    this.onEnterBackward(this);\n                } else {\n                    this.onSyncEnterForward(this);\n                    this.onEnterForward(this);\n                }\n                this.hasEntered = true;\n                if (forceEnter) this.forceEnter = true;\n            } else if (isInView) {\n                this.forceEnter = false;\n            }\n        }\n        if (isInView || !isInView && this.isInView) {\n            hasUpdated = true;\n        }\n        if (hasUpdated) {\n            if (shouldSeek) linked.seek(linked.duration * p);\n            this.onUpdate(this);\n        }\n        if (!isInView && this.isInView) {\n            this.isInView = false;\n            this.onSyncLeave(this);\n            this.onLeave(this);\n            if (this.backward) {\n                this.onSyncLeaveBackward(this);\n                this.onLeaveBackward(this);\n            } else {\n                this.onSyncLeaveForward(this);\n                this.onLeaveForward(this);\n            }\n            if (sync && !syncSmooth) {\n                syncCompleted = true;\n            }\n        }\n        if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {\n            if (sync) {\n                this.onSyncComplete(this);\n            }\n            this.completed = true;\n            if (!this.repeat && !linked || !this.repeat && linked && linked.completed) {\n                this.revert();\n            }\n        }\n        if (p < 1 && this.completed) {\n            this.completed = false;\n        }\n        this.prevProgress = p;\n    }\n    revert() {\n        if (this.reverted) return;\n        const container = this.container;\n        removeChild(container, this);\n        if (!container._head) {\n            container.revert();\n        }\n        if (this._debug) {\n            this.removeDebug();\n        }\n        this.reverted = true;\n        return this;\n    }\n    /**\n   * @param {ScrollObserverParams} parameters\n   */ constructor(parameters = {}){\n        if (globals.scope) globals.scope.revertibles.push(this);\n        const syncMode = setValue(parameters.sync, \"play pause\");\n        const ease = syncMode ? parseEasings(/** @type {EasingParam} */ syncMode) : null;\n        const isLinear = syncMode && (syncMode === \"linear\" || syncMode === none);\n        const isEase = syncMode && !(ease === none && !isLinear);\n        const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);\n        const isMethods = syncMode && isStr(syncMode) && !isEase && !isSmooth;\n        const syncMethods = isMethods ? /** @type {String} */ syncMode.split(\" \").map((/** @type {String} */ m)=>()=>{\n                const linked = this.linked;\n                return linked && linked[m] ? linked[m]() : null;\n            }) : null;\n        const biDirSync = isMethods && syncMethods.length > 2;\n        /** @type {Number} */ this.index = scrollerIndex++;\n        /** @type {String|Number} */ this.id = !isUnd(parameters.id) ? parameters.id : this.index;\n        /** @type {ScrollContainer} */ this.container = registerAndGetScrollContainer(parameters.container);\n        /** @type {HTMLElement} */ this.target = null;\n        /** @type {Tickable|WAAPIAnimation} */ this.linked = null;\n        /** @type {Boolean} */ this.repeat = null;\n        /** @type {Boolean} */ this.horizontal = null;\n        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */ this.enter = null;\n        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */ this.leave = null;\n        /** @type {Boolean} */ this.sync = isEase || isSmooth || !!syncMethods;\n        /** @type {EasingFunction} */ this.syncEase = isEase ? ease : null;\n        /** @type {Number} */ this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */ syncMode : null;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnter = parameters.onEnter || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeave = parameters.onLeave || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnterForward = parameters.onEnterForward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeaveForward = parameters.onLeaveForward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onEnterBackward = parameters.onEnterBackward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onLeaveBackward = parameters.onLeaveBackward || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onUpdate = parameters.onUpdate || noop;\n        /** @type {Callback<ScrollObserver>} */ this.onSyncComplete = parameters.onSyncComplete || noop;\n        /** @type {Boolean} */ this.reverted = false;\n        /** @type {Boolean} */ this.completed = false;\n        /** @type {Boolean} */ this.began = false;\n        /** @type {Boolean} */ this.isInView = false;\n        /** @type {Boolean} */ this.forceEnter = false;\n        /** @type {Boolean} */ this.hasEntered = false;\n        /** @type {Array.<Number>} */ this.offsets = [];\n        /** @type {Number} */ this.offset = 0;\n        /** @type {Number} */ this.offsetStart = 0;\n        /** @type {Number} */ this.offsetEnd = 0;\n        /** @type {Number} */ this.distance = 0;\n        /** @type {Number} */ this.prevProgress = 0;\n        /** @type {Array} */ this.thresholds = [\n            \"start\",\n            \"end\",\n            \"end\",\n            \"start\"\n        ];\n        /** @type {[Number, Number, Number, Number]} */ this.coords = [\n            0,\n            0,\n            0,\n            0\n        ];\n        /** @type {JSAnimation} */ this.debugStyles = null;\n        /** @type {HTMLElement} */ this.$debug = null;\n        /** @type {ScrollObserverParams} */ this._params = parameters;\n        /** @type {Boolean} */ this._debug = setValue(parameters.debug, false);\n        /** @type {ScrollObserver} */ this._next = null;\n        /** @type {ScrollObserver} */ this._prev = null;\n        addChild(this.container, this);\n        // Wait for the next frame to add to the container in order to handle calls to link()\n        sync(()=>{\n            if (this.reverted) return;\n            if (!this.target) {\n                const target = /** @type {HTMLElement} */ parseTargets(parameters.target)[0];\n                this.target = target || doc.body;\n                this.refresh();\n            }\n            if (this._debug) this.debug();\n        });\n    }\n}\n/**\n * @param {ScrollObserverParams} [parameters={}]\n * @return {ScrollObserver}\n */ const onScroll = function() {\n    let parameters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return new ScrollObserver(parameters);\n};\n/**\n * @typedef  {Object} StaggerParameters\n * @property {Number|String} [start]\n * @property {Number|'first'|'center'|'last'} [from]\n * @property {Boolean} [reversed]\n * @property {Array.<Number>} [grid]\n * @property {('x'|'y')} [axis]\n * @property {EasingParam} [ease]\n * @property {TweenModifier} [modifier]\n */ /**\n * @callback StaggerFunction\n * @param {Target} [target]\n * @param {Number} [index]\n * @param {Number} [length]\n * @param {Timeline} [tl]\n * @return {Number|String}\n */ /**\n * @param  {Number|String|[Number|String,Number|String]} val\n * @param  {StaggerParameters} params\n * @return {StaggerFunction}\n */ const stagger = function(val) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    let values = [];\n    let maxValue = 0;\n    const from = params.from;\n    const reversed = params.reversed;\n    const ease = params.ease;\n    const hasEasing = !isUnd(ease);\n    const hasSpring = hasEasing && !isUnd(/** @type {Spring} */ ease.ease);\n    const staggerEase = hasSpring ? /** @type {Spring} */ ease.ease : hasEasing ? parseEasings(ease) : null;\n    const grid = params.grid;\n    const axis = params.axis;\n    const fromFirst = isUnd(from) || from === 0 || from === \"first\";\n    const fromCenter = from === \"center\";\n    const fromLast = from === \"last\";\n    const isRange = isArr(val);\n    const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);\n    const val2 = isRange ? parseNumber(val[1]) : 0;\n    const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);\n    const start = params.start || 0 + (isRange ? val1 : 0);\n    let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;\n    return (_, i, t, tl)=>{\n        if (fromCenter) fromIndex = (t - 1) / 2;\n        if (fromLast) fromIndex = t - 1;\n        if (!values.length) {\n            for(let index = 0; index < t; index++){\n                if (!grid) {\n                    values.push(abs(fromIndex - index));\n                } else {\n                    const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;\n                    const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;\n                    const toX = index % grid[0];\n                    const toY = floor(index / grid[0]);\n                    const distanceX = fromX - toX;\n                    const distanceY = fromY - toY;\n                    let value = sqrt(distanceX * distanceX + distanceY * distanceY);\n                    if (axis === \"x\") value = -distanceX;\n                    if (axis === \"y\") value = -distanceY;\n                    values.push(value);\n                }\n                maxValue = max(...values);\n            }\n            if (staggerEase) values = values.map((val)=>staggerEase(val / maxValue) * maxValue);\n            if (reversed) values = values.map((val)=>axis ? val < 0 ? val * -1 : -val : abs(maxValue - val));\n        }\n        const spacing = isRange ? (val2 - val1) / maxValue : val1;\n        const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */ start;\n        /** @type {String|Number} */ let output = offset + (spacing * round(values[i], 2) || 0);\n        if (params.modifier) output = params.modifier(output);\n        if (unitMatch) output = \"\".concat(output).concat(unitMatch[2]);\n        return output;\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbmltZWpzL2xpYi9hbmltZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FFRCwrQ0FBK0MsR0FDL0MseUNBQXlDLEdBQ3pDLDJEQUEyRCxHQUMzRCw2RUFBNkUsR0FFN0U7Ozs7OztDQU1DLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0JDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7OztDQUlDLEdBRUQ7O0NBRUMsR0FFRCxrRUFBa0U7QUFDbEUsOEVBQThFO0FBQzlFLG9GQUFvRixHQUVwRixnREFBZ0QsR0FDaEQsNENBQTRDLEdBQzVDLHlDQUF5QyxHQUN6QyxxREFBcUQsR0FDckQsMkRBQTJELEdBQzNELDJFQUEyRSxHQUMzRSxpREFBaUQsR0FDakQsd0RBQXdELEdBQ3hELCtDQUErQyxHQUMvQyxrRUFBa0UsR0FDbEUsMkNBQTJDLEdBRTNDOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FFRCwyREFBMkQsR0FFM0Q7Ozs7OztDQU1DLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FFRDs7Ozs7Ozs7Q0FRQyxHQUVELDRFQUE0RSxHQUM1RSxrRUFBa0UsR0FDbEUsa0VBQWtFLEdBQ2xFLCtEQUErRCxHQUUvRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRDs7OztDQUlDLEdBRUQ7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUVEOzs7OztDQUtDLEdBRUQ7O0NBRUMsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7O0NBRUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUVEOztDQUVDLEdBRUQ7O0NBRUMs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QUk1RixXQUFXMjNDO1FBQy9GO1FBQ0EsTUFBTS94QixVQUFVc3lCLFVBQVUsQ0FBQ0UsT0FBT0QsSUFBRyxJQUFLbjRDLFdBQVdtNEM7UUFDckQsTUFBTTNzQixTQUFTM2EsS0FBSyttQixzQkFBc0IvbUIsSUFBSW5NLE1BQU02bkIsT0FBT3ZsQixLQUFLLElBQUk2SixHQUFHbEcsaUJBQWlCLEdBQUczRCxTQUFTLG1CQUFtQixHQUFHQTtRQUMxSCwwQkFBMEIsR0FDMUIsSUFBSTB4QyxTQUFTbHRCLFNBQVUsV0FBV25sQixNQUFNa1QsTUFBTSxDQUFDakgsRUFBRSxFQUFFLE1BQU87UUFDMUQsSUFBSWlhLE9BQU9qcUIsUUFBUSxFQUFFbzJDLFNBQVNuc0IsT0FBT2pxQixRQUFRLENBQUNvMkM7UUFDOUMsSUFBSXQ2QixXQUFXczZCLFNBQVMsR0FBWXQ2QixPQUFUczZCLFFBQXNCLE9BQWJ0NkIsU0FBUyxDQUFDLEVBQUU7UUFDaEQsT0FBT3M2QjtJQUNUO0FBQ0Y7QUFFeVIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FuaW1lanMvbGliL2FuaW1lLmVzbS5qcz9iODVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogYW5pbWUuanMgLSBFU01cbiAqIEB2ZXJzaW9uIHY0LjAuMlxuICogQGF1dGhvciBKdWxpYW4gR2FybmllclxuICogQGxpY2Vuc2UgTUlUXG4gKiBAY29weXJpZ2h0IChjKSAyMDI1IEp1bGlhbiBHYXJuaWVyXG4gKiBAc2VlIGh0dHBzOi8vYW5pbWVqcy5jb21cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzUGFyYW1zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7UGVyY2VudGFnZUtleWZyYW1lc3xEdXJhdGlvbktleWZyYW1lc30gW2tleWZyYW1lc11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3BsYXliYWNrUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZnJhbWVSYXRlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8Qm9vbGVhbn0gW2xvb3BdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxTY3JvbGxPYnNlcnZlcn0gW2F1dG9wbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb25WYWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb25WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7J25vbmUnfCdyZXBsYWNlJ3wnYmxlbmQnfGNvbXBvc2l0aW9uVHlwZXN9IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7KHY6IGFueSkgPT4gYW55fSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHsodGlja2FibGU6IFRpY2thYmxlKSA9PiB2b2lkfSBbb25CZWZvcmVVcGRhdGVdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvblVwZGF0ZV1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7KHRpY2thYmxlOiBUaWNrYWJsZSkgPT4gdm9pZH0gW29uUGF1c2VdXG4gKiBAcHJvcGVydHkgeyh0aWNrYWJsZTogVGlja2FibGUpID0+IHZvaWR9IFtvbkNvbXBsZXRlXVxuICogQHByb3BlcnR5IHsocmVuZGVyYWJsZTogUmVuZGVyYWJsZSkgPT4gdm9pZH0gW29uUmVuZGVyXVxuICovXG5cbi8qKiBAdHlwZWRlZiB7SlNBbmltYXRpb258VGltZWxpbmV9IFJlbmRlcmFibGUgKi9cbi8qKiBAdHlwZWRlZiB7VGltZXJ8UmVuZGVyYWJsZX0gVGlja2FibGUgKi9cbi8qKiBAdHlwZWRlZiB7VGltZXImSlNBbmltYXRpb24mVGltZWxpbmV9IENhbGxiYWNrQXJndW1lbnQgKi9cbi8qKiBAdHlwZWRlZiB7QW5pbWF0YWJsZXxUaWNrYWJsZXxEcmFnZ2FibGV8U2Nyb2xsT2JzZXJ2ZXJ8U2NvcGV9IFJldmVydGlibGUgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEcmFnZ2FibGVBeGlzUGFyYW1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbWFwVG9dXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8QXJyYXk8TnVtYmVyPnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXJ8QXJyYXk8TnVtYmVyPil9IFtzbmFwXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRHJhZ2dhYmxlQ3Vyc29yUGFyYW1zXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29uSG92ZXJdXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW29uR3JhYl1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERyYWdnYWJsZVBhcmFtc1xuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3Rvcn0gW3RyaWdnZXJdXG4gKiBAcHJvcGVydHkge0RPTVRhcmdldFNlbGVjdG9yfEFycmF5PE51bWJlcj58KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gRE9NVGFyZ2V0U2VsZWN0b3J8QXJyYXk8TnVtYmVyPil9IFtjb250YWluZXJdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58RHJhZ2dhYmxlQXhpc1BhcmFtfSBbeF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxEcmFnZ2FibGVBeGlzUGFyYW19IFt5XVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge051bWJlcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcnxBcnJheTxOdW1iZXI+KX0gW3NuYXBdXG4gKiBAcHJvcGVydHkge051bWJlcnxBcnJheTxOdW1iZXI+fCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcnxBcnJheTxOdW1iZXI+KX0gW2NvbnRhaW5lclBhZGRpbmddXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbY29udGFpbmVyRnJpY3Rpb25dXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbcmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gTnVtYmVyKX0gW2RyYWdTcGVlZF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtzY3JvbGxTcGVlZF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IE51bWJlcil9IFtzY3JvbGxUaHJlc2hvbGRdXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbbWluVmVsb2NpdHldXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbbWF4VmVsb2NpdHldXG4gKiBAcHJvcGVydHkge051bWJlcnwoKGRyYWdnYWJsZTogRHJhZ2dhYmxlKSA9PiBOdW1iZXIpfSBbdmVsb2NpdHlNdWx0aXBsaWVyXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyZWxlYXNlTWFzc11cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZVN0aWZmbmVzc11cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmVsZWFzZURhbXBpbmddXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZWxlYXNlRGFtcGluZ11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtyZWxlYXNlRWFzZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN8KChkcmFnZ2FibGU6IERyYWdnYWJsZSkgPT4gQm9vbGVhbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXMpfSBbY3Vyc29yXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25HcmFiXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25EcmFnXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25SZWxlYXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25VcGRhdGVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPERyYWdnYWJsZT59IFtvblNldHRsZV1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uU25hcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8RHJhZ2dhYmxlPn0gW29uUmVzaXplXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxEcmFnZ2FibGU+fSBbb25BZnRlclJlc2l6ZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtTVkdHZW9tZXRyeUVsZW1lbnQgJiB7XG4gKiAgIHNldEF0dHJpYnV0ZShuYW1lOiAnZHJhdycsIHZhbHVlOiBgJHtudW1iZXJ9ICR7bnVtYmVyfWApOiB2b2lkO1xuICogICBkcmF3OiBgJHtudW1iZXJ9ICR7bnVtYmVyfWA7XG4gKiB9fSBEcmF3YWJsZVNWR0dlb21ldHJ5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWFzaW5nRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KCdsaW5lYXInfCdsaW5lYXIoeDEsIHgyIDI1JSwgeDMpJ3wnaW4nfCdvdXQnfCdpbk91dCd8J2luUXVhZCd8J291dFF1YWQnfCdpbk91dFF1YWQnfCdpbkN1YmljJ3wnb3V0Q3ViaWMnfCdpbk91dEN1YmljJ3wnaW5RdWFydCd8J291dFF1YXJ0J3wnaW5PdXRRdWFydCd8J2luUXVpbnQnfCdvdXRRdWludCd8J2luT3V0UXVpbnQnfCdpblNpbmUnfCdvdXRTaW5lJ3wnaW5PdXRTaW5lJ3wnaW5DaXJjJ3wnb3V0Q2lyYyd8J2luT3V0Q2lyYyd8J2luRXhwbyd8J291dEV4cG8nfCdpbk91dEV4cG8nfCdpbkJvdW5jZSd8J291dEJvdW5jZSd8J2luT3V0Qm91bmNlJ3wnaW5CYWNrJ3wnb3V0QmFjayd8J2luT3V0QmFjayd8J2luRWxhc3RpYyd8J291dEVsYXN0aWMnfCdpbk91dEVsYXN0aWMnfCdpcnJlZ3VsYXInfCdjdWJpY0Jlemllcid8J3N0ZXBzJ3wnaW4ocCA9IDEuNjc1KSd8J291dChwID0gMS42NzUpJ3wnaW5PdXQocCA9IDEuNjc1KSd8J2luQmFjayhvdmVyc2hvb3QgPSAxLjcwMTU4KSd8J291dEJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdpbk91dEJhY2sob3ZlcnNob290ID0gMS43MDE1OCknfCdpbkVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnb3V0RWxhc3RpYyhhbXBsaXR1ZGUgPSAxLCBwZXJpb2QgPSAuMyknfCdpbk91dEVsYXN0aWMoYW1wbGl0dWRlID0gMSwgcGVyaW9kID0gLjMpJ3wnaXJyZWd1bGFyKGxlbmd0aCA9IDEwLCByYW5kb21uZXNzID0gMSknfCdjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5MiknfCdzdGVwcyhzdGVwcyA9IDEwKScpfSBFYXNlU3RyaW5nUGFyYW1OYW1lc1xuICovXG5cbi8vIEEgaGFjayB0byBnZXQgYm90aCBlYXNlIG5hbWVzIHN1Z2dlc3Rpb25zIEFORCBhbGxvdyBhbnkgc3RyaW5nc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yOTcyOSNpc3N1ZWNvbW1lbnQtNDYwMzQ2NDIxXG4vKiogQHR5cGVkZWYgeyhTdHJpbmcgJiB7fSl8RWFzZVN0cmluZ1BhcmFtTmFtZXN8RWFzaW5nRnVuY3Rpb258U3ByaW5nfSBFYXNpbmdQYXJhbSAqL1xuXG4vKiogQHR5cGVkZWYge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IERPTVRhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBhbnk+fSBKU1RhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtET01UYXJnZXR8SlNUYXJnZXR9IFRhcmdldCAqL1xuLyoqIEB0eXBlZGVmIHtUYXJnZXR8Tm9kZUxpc3R8U3RyaW5nfSBUYXJnZXRTZWxlY3RvciAqL1xuLyoqIEB0eXBlZGVmIHtET01UYXJnZXR8Tm9kZUxpc3R8U3RyaW5nfSBET01UYXJnZXRTZWxlY3RvciAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48RE9NVGFyZ2V0U2VsZWN0b3I+fERPTVRhcmdldFNlbGVjdG9yfSBET01UYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPERPTVRhcmdldD59IERPTVRhcmdldHNBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48SlNUYXJnZXQ+fEpTVGFyZ2V0fSBKU1RhcmdldHNQYXJhbSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48SlNUYXJnZXQ+fSBKU1RhcmdldHNBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtBcnJheS48VGFyZ2V0U2VsZWN0b3I+fFRhcmdldFNlbGVjdG9yfSBUYXJnZXRzUGFyYW0gKi9cbi8qKiBAdHlwZWRlZiB7QXJyYXkuPFRhcmdldD59IFRhcmdldHNBcnJheSAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBGdW5jdGlvblZhbHVlXG4gKiBAcGFyYW0ge1RhcmdldH0gdGFyZ2V0IC0gVGhlIGFuaW1hdGVkIHRhcmdldFxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIHRhcmdldCBpbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgYW5pbWF0ZWQgdGFyZ2V0c1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ3xUd2Vlbk9iamVjdFZhbHVlfEFycmF5LjxOdW1iZXJ8U3RyaW5nfFR3ZWVuT2JqZWN0VmFsdWU+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFR3ZWVuTW9kaWZpZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSBhbmltYXRlZCB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqL1xuXG4vKiogQHR5cGVkZWYge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSBDb2xvckFycmF5ICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBDYWxsYmFja1xuICogQHBhcmFtIHtUfSBzZWxmIC0gUmV0dXJucyBpdHNlbGZcbiAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBbZV1cbiAqIEByZXR1cm4geyp9XG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gVGlja2FibGVDYWxsYmFja3NcbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvbkJlZ2luXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQmVmb3JlVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uTG9vcF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8VD59IFtvblBhdXNlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUge29iamVjdH0gVFxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyYWJsZUNhbGxiYWNrc1xuICogQHByb3BlcnR5IHtDYWxsYmFjazxUPn0gW29uUmVuZGVyXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHdlZW5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICogQHByb3BlcnR5IHtKU0FuaW1hdGlvbn0gcGFyZW50XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwcm9wZXJ0eSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfE51bWJlcn0gX3ZhbHVlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IF9mdW5jXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBfZWFzZVxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gX2Zyb21OdW1iZXJzXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBfdG9OdW1iZXJzXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBfc3RyaW5nc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9mcm9tTnVtYmVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3RvTnVtYmVyXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBfbnVtYmVyc1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9udW1iZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBfdW5pdFxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBfbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfY3VycmVudFRpbWVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZGVsYXlcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfdXBkYXRlRHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfc3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2NoYW5nZUR1cmF0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gX2Fic29sdXRlU3RhcnRUaW1lXG4gKiBAcHJvcGVydHkge3R3ZWVuVHlwZXN9IF90d2VlblR5cGVcbiAqIEBwcm9wZXJ0eSB7dmFsdWVUeXBlc30gX3ZhbHVlVHlwZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9jb21wb3NpdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9pc092ZXJsYXBwZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfaXNPdmVycmlkZGVuXG4gKiBAcHJvcGVydHkge051bWJlcn0gX3JlbmRlclRyYW5zZm9ybXNcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9wcmV2UmVwXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfbmV4dFJlcFxuICogQHByb3BlcnR5IHtUd2Vlbn0gX3ByZXZBZGRcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9uZXh0QWRkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfcHJldlxuICogQHByb3BlcnR5IHtUd2Vlbn0gX25leHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFR3ZWVuRGVjb21wb3NlZFZhbHVlXG4gKiBAcHJvcGVydHkge051bWJlcn0gdCAtIFR5cGVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBuIC0gU2luZ2xlIG51bWJlciB2YWx1ZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHUgLSBWYWx1ZSB1bml0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gbyAtIFZhbHVlIG9wZXJhdG9yXG4gKiBAcHJvcGVydHkge0FycmF5LjxOdW1iZXI+fSBkIC0gQXJyYXkgb2YgTnVtYmVycyAoaW4gY2FzZSBvZiBjb21wbGV4IHZhbHVlIHR5cGUpXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBzIC0gU3RyaW5ncyAoaW4gY2FzZSBvZiBjb21wbGV4IHZhbHVlIHR5cGUpXG4gKi9cblxuLyoqIEB0eXBlZGVmIHt7X2hlYWQ6IG51bGx8VHdlZW4sIF90YWlsOiBudWxsfFR3ZWVufX0gVHdlZW5Qcm9wZXJ0eVNpYmxpbmdzICovXG4vKiogQHR5cGVkZWYge1JlY29yZDxTdHJpbmcsIFR3ZWVuUHJvcGVydHlTaWJsaW5ncz59IFR3ZWVuTG9va3VwcyAqL1xuLyoqIEB0eXBlZGVmIHtXZWFrTWFwLjxUYXJnZXQsIFR3ZWVuTG9va3Vwcz59IFR3ZWVuUmVwbGFjZUxvb2t1cHMgKi9cbi8qKiBAdHlwZWRlZiB7TWFwLjxUYXJnZXQsIFR3ZWVuTG9va3Vwcz59IFR3ZWVuQWRkaXRpdmVMb29rdXBzICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsb29wRGVsYXldXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXZlcnNlZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FsdGVybmF0ZV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSBbYXV0b3BsYXldXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ZyYW1lUmF0ZV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICovXG5cbi8qKlxuXG4vKipcbiAqIEB0eXBlZGVmIHtUaW1lck9wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxUaW1lcj59IFRpbWVyUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfFN0cmluZ3xGdW5jdGlvblZhbHVlfSBUd2VlblBhcmFtVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtVmFsdWV8W1R3ZWVuUGFyYW1WYWx1ZSwgVHdlZW5QYXJhbVZhbHVlXX0gVHdlZW5Qcm9wVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoU3RyaW5nICYge30pfCdub25lJ3wncmVwbGFjZSd8J2JsZW5kJ3xjb21wb3NpdGlvblR5cGVzfSBUd2VlbkNvbXBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUd2VlblBhcmFtc09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge1R3ZWVuUGFyYW1WYWx1ZX0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gKiBAcHJvcGVydHkge1R3ZWVuTW9kaWZpZXJ9IFttb2RpZmllcl1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Db21wb3NpdGlvbn0gW2NvbXBvc2l0aW9uXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHdlZW5WYWx1ZXNcbiAqIEBwcm9wZXJ0eSB7VHdlZW5QYXJhbVZhbHVlfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Qcm9wVmFsdWV9IFt0b11cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Qcm9wVmFsdWV9IFtmcm9tVG9dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7VHdlZW5QYXJhbXNPcHRpb25zICYgVHdlZW5WYWx1ZXN9IFR3ZWVuS2V5VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheS48VHdlZW5LZXlWYWx1ZXxUd2VlblByb3BWYWx1ZT59IEFycmF5U3ludGF4VmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtUd2VlblBhcmFtVmFsdWV8QXJyYXlTeW50YXhWYWx1ZXxUd2VlbktleVZhbHVlfSBUd2Vlbk9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtQYXJ0aWFsPHt0bzogVHdlZW5QYXJhbVZhbHVlfEFycmF5LjxUd2VlblBhcmFtVmFsdWU+OyBmcm9tOiBUd2VlblBhcmFtVmFsdWV8QXJyYXkuPFR3ZWVuUGFyYW1WYWx1ZT47IGZyb21UbzogVHdlZW5QYXJhbVZhbHVlfEFycmF5LjxUd2VlblBhcmFtVmFsdWU+O30+fSBUd2Vlbk9iamVjdFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJjZW50YWdlS2V5ZnJhbWVPcHRpb25zXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblBhcmFtVmFsdWU+fSBQZXJjZW50YWdlS2V5ZnJhbWVQYXJhbXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBQZXJjZW50YWdlS2V5ZnJhbWVQYXJhbXMgJiBQZXJjZW50YWdlS2V5ZnJhbWVPcHRpb25zPn0gUGVyY2VudGFnZUtleWZyYW1lc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5PFJlY29yZDxTdHJpbmcsIFR3ZWVuT3B0aW9ucyB8IFR3ZWVuTW9kaWZpZXIgfCBib29sZWFuPiAmIFR3ZWVuUGFyYW1zT3B0aW9ucz59IER1cmF0aW9uS2V5ZnJhbWVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge1BlcmNlbnRhZ2VLZXlmcmFtZXN8RHVyYXRpb25LZXlmcmFtZXN9IFtrZXlmcmFtZXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbcGxheWJhY2tFYXNlXVxuICovXG5cbi8vIFRPRE86IEN1cnJlbnRseSBzZXR0aW5nIFR3ZWVuTW9kaWZpZXIgdG8gdGhlIGludGVyc2VjdGVkIFJlY29yZDw+IG1ha2VzIHRoZSBGdW5jdGlvblZhbHVlIHR5cGUgdGFyZ2V0IHBhcmFtIGFueSBpZiBvbmx5IG9uZSBwYXJhbWV0ZXIgaXMgc2V0XG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2Vlbk9wdGlvbnMgfCBDYWxsYmFjazxKU0FuaW1hdGlvbj4gfCBUd2Vlbk1vZGlmaWVyIHwgYm9vbGVhbiB8IFBlcmNlbnRhZ2VLZXlmcmFtZXMgfCBEdXJhdGlvbktleWZyYW1lcyB8IFNjcm9sbE9ic2VydmVyPiAmIFRpbWVyT3B0aW9ucyAmIEFuaW1hdGlvbk9wdGlvbnMgJiBUd2VlblBhcmFtc09wdGlvbnMgJiBUaWNrYWJsZUNhbGxiYWNrczxKU0FuaW1hdGlvbj4gJiBSZW5kZXJhYmxlQ2FsbGJhY2tzPEpTQW5pbWF0aW9uPn0gQW5pbWF0aW9uUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lbGluZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7RGVmYXVsdHNQYXJhbXN9IFtkZWZhdWx0c11cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtwbGF5YmFja0Vhc2VdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7VGltZXJPcHRpb25zICYgVGltZWxpbmVPcHRpb25zICYgVGlja2FibGVDYWxsYmFja3M8VGltZWxpbmU+ICYgUmVuZGVyYWJsZUNhbGxiYWNrczxUaW1lbGluZT59IFRpbWVsaW5lUGFyYW1zXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQW5pbWF0YWJsZVByb3BlcnR5U2V0dGVyXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59IHRvXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtkdXJhdGlvbl1cbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEByZXR1cm4ge0FuaW1hdGFibGVPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQW5pbWF0YWJsZVByb3BlcnR5R2V0dGVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QW5pbWF0YWJsZVByb3BlcnR5U2V0dGVyICYgQW5pbWF0YWJsZVByb3BlcnR5R2V0dGVyfSBBbmltYXRhYmxlUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtBbmltYXRhYmxlICYgUmVjb3JkPFN0cmluZywgQW5pbWF0YWJsZVByb3BlcnR5Pn0gQW5pbWF0YWJsZU9iamVjdFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0YWJsZVByb3BlcnR5UGFyYW1zT3B0aW9uc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFt1bml0XVxuICogQHByb3BlcnR5IHtUd2VlblBhcmFtVmFsdWV9IFtkdXJhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHByb3BlcnR5IHtUd2Vlbk1vZGlmaWVyfSBbbW9kaWZpZXJdXG4gKiBAcHJvcGVydHkge1R3ZWVuQ29tcG9zaXRpb259IFtjb21wb3NpdGlvbl1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3RyaW5nLCBUd2VlblBhcmFtVmFsdWUgfCBFYXNpbmdQYXJhbSB8IFR3ZWVuTW9kaWZpZXIgfCBUd2VlbkNvbXBvc2l0aW9uIHwgQW5pbWF0YWJsZVByb3BlcnR5UGFyYW1zT3B0aW9ucz4gJiBBbmltYXRhYmxlUHJvcGVydHlQYXJhbXNPcHRpb25zfSBBbmltYXRhYmxlUGFyYW1zXG4gKi9cblxuXG4vLyBFbnZpcm9ubWVudHNcblxuLy8gVE9ETzogRG8gd2UgbmVlZCB0byBjaGVjayBpZiB3ZSdyZSBydW5uaW5nIGluc2lkZSBhIHdvcmtlciA/XG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyoqIEB0eXBlIHtPYmplY3R8TnVsbH0gKi9cbmNvbnN0IHdpbiA9IGlzQnJvd3NlciA/IHdpbmRvdyA6IG51bGw7XG5cbi8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG5jb25zdCBkb2MgPSBpc0Jyb3dzZXIgPyBkb2N1bWVudCA6IG51bGw7XG5cbi8vIEVudW1zXG5cbi8qKiBAZW51bSB7TnVtYmVyfSAqL1xuY29uc3QgdHdlZW5UeXBlcyA9IHtcbiAgT0JKRUNUOiAwLFxuICBBVFRSSUJVVEU6IDEsXG4gIENTUzogMixcbiAgVFJBTlNGT1JNOiAzLFxuICBDU1NfVkFSOiA0LFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCB2YWx1ZVR5cGVzID0ge1xuICBOVU1CRVI6IDAsXG4gIFVOSVQ6IDEsXG4gIENPTE9SOiAyLFxuICBDT01QTEVYOiAzLFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCB0aWNrTW9kZXMgPSB7XG4gIE5PTkU6IDAsXG4gIEFVVE86IDEsXG4gIEZPUkNFOiAyLFxufTtcblxuLyoqIEBlbnVtIHtOdW1iZXJ9ICovXG5jb25zdCBjb21wb3NpdGlvblR5cGVzID0ge1xuICByZXBsYWNlOiAwLFxuICBub25lOiAxLFxuICBibGVuZDogMixcbn07XG5cbi8vIENhY2hlIHN5bWJvbHNcblxuY29uc3QgaXNSZWdpc3RlcmVkVGFyZ2V0U3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBpc0RvbVN5bWJvbCA9IFN5bWJvbCgpO1xuY29uc3QgaXNTdmdTeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IHRyYW5zZm9ybXNTeW1ib2wgPSBTeW1ib2woKTtcbmNvbnN0IG1vcnBoUG9pbnRzU3ltYm9sID0gU3ltYm9sKCk7XG5jb25zdCBwcm94eVRhcmdldFN5bWJvbCA9IFN5bWJvbCgpO1xuXG4vLyBOdW1iZXJzXG5cbmNvbnN0IG1pblZhbHVlID0gMWUtMTE7XG5jb25zdCBtYXhWYWx1ZSA9IDFlMTI7XG5jb25zdCBLID0gMWUzO1xuY29uc3QgbWF4RnBzID0gMTIwO1xuXG4vLyBTdHJpbmdzXG5cbmNvbnN0IGVtcHR5U3RyaW5nID0gJyc7XG5jb25zdCBzaG9ydFRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG5cbnNob3J0VHJhbnNmb3Jtcy5zZXQoJ3gnLCAndHJhbnNsYXRlWCcpO1xuc2hvcnRUcmFuc2Zvcm1zLnNldCgneScsICd0cmFuc2xhdGVZJyk7XG5zaG9ydFRyYW5zZm9ybXMuc2V0KCd6JywgJ3RyYW5zbGF0ZVonKTtcblxuY29uc3QgdmFsaWRUcmFuc2Zvcm1zID0gW1xuICAndHJhbnNsYXRlWCcsXG4gICd0cmFuc2xhdGVZJyxcbiAgJ3RyYW5zbGF0ZVonLFxuICAncm90YXRlJyxcbiAgJ3JvdGF0ZVgnLFxuICAncm90YXRlWScsXG4gICdyb3RhdGVaJyxcbiAgJ3NjYWxlJyxcbiAgJ3NjYWxlWCcsXG4gICdzY2FsZVknLFxuICAnc2NhbGVaJyxcbiAgJ3NrZXcnLFxuICAnc2tld1gnLFxuICAnc2tld1knLFxuICAncGVyc3BlY3RpdmUnLFxuICAnbWF0cml4JyxcbiAgJ21hdHJpeDNkJyxcbl07XG5cbmNvbnN0IHRyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3MgPSB2YWxpZFRyYW5zZm9ybXMucmVkdWNlKChhLCB2KSA9PiAoey4uLmEsIFt2XTogdiArICcoJ30pLCB7fSk7XG5cbi8vIEZ1bmN0aW9uc1xuXG4vKiogQHJldHVybiB7dm9pZH0gKi9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLy8gUmVnZXhcblxuY29uc3QgaGV4VGVzdFJneCA9IC8oXiMoW1xcZGEtZl17M30pezEsMn0kKXwoXiMoW1xcZGEtZl17NH0pezEsMn0kKS9pO1xuY29uc3QgcmdiRXhlY1JneCA9IC9yZ2JcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKS9pO1xuY29uc3QgcmdiYUV4ZWNSZ3ggPSAvcmdiYVxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccypcXCkvaTtcbmNvbnN0IGhzbEV4ZWNSZ3ggPSAvaHNsXFwoXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKyklXFxzKixcXHMqKC0/XFxkK3wtP1xcZCouXFxkKyklXFxzKlxcKS9pO1xuY29uc3QgaHNsYUV4ZWNSZ3ggPSAvaHNsYVxcKFxccyooLT9cXGQrfC0/XFxkKi5cXGQrKVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspJVxccyosXFxzKigtP1xcZCt8LT9cXGQqLlxcZCspXFxzKlxcKS9pO1xuLy8gZXhwb3J0IGNvbnN0IGRpZ2l0V2l0aEV4cG9uZW50Umd4ID0gL1stK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/L2c7XG5jb25zdCBkaWdpdFdpdGhFeHBvbmVudFJneCA9IC9bLStdP1xcZCpcXC4/XFxkKyg/OmVbLStdP1xcZCk/L2dpO1xuLy8gZXhwb3J0IGNvbnN0IHVuaXRzRXhlY1JneCA9IC9eKFstK10/XFxkKlxcLj9cXGQrKD86W2VFXVstK10/XFxkKyk/KSsoW2Etel0rfCUpJC9pO1xuY29uc3QgdW5pdHNFeGVjUmd4ID0gL14oWy0rXT9cXGQqXFwuP1xcZCsoPzplWy0rXT9cXGQrKT8pKFthLXpdK3wlKSQvaTtcbmNvbnN0IGxvd2VyQ2FzZVJneCA9IC8oW2Etel0pKFtBLVpdKS9nO1xuY29uc3QgdHJhbnNmb3Jtc0V4ZWNSZ3ggPSAvKFxcdyspKFxcKFteKV0rXFwpKykvZzsgLy8gTWF0Y2ggaW5saW5lIHRyYW5zZm9ybXMgd2l0aCBjYWNsKCkgdmFsdWVzLCByZXR1cm5zIHRoZSB2YWx1ZSB3cmFwcGVkIGluICgpXG5jb25zdCByZWxhdGl2ZVZhbHVlc0V4ZWNSZ3ggPSAvKFxcKj18XFwrPXwtPSkvO1xuXG5cblxuXG4vKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGlkOiBudWxsLFxuICBrZXlmcmFtZXM6IG51bGwsXG4gIHBsYXliYWNrRWFzZTogbnVsbCxcbiAgcGxheWJhY2tSYXRlOiAxLFxuICBmcmFtZVJhdGU6IG1heEZwcyxcbiAgbG9vcDogMCxcbiAgcmV2ZXJzZWQ6IGZhbHNlLFxuICBhbHRlcm5hdGU6IGZhbHNlLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgZHVyYXRpb246IEssXG4gIGRlbGF5OiAwLFxuICBsb29wRGVsYXk6IDAsXG4gIGVhc2U6ICdvdXQoMiknLFxuICBjb21wb3NpdGlvbjogY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlLFxuICBtb2RpZmllcjogdiA9PiB2LFxuICBvbkJlZ2luOiBub29wLFxuICBvbkJlZm9yZVVwZGF0ZTogbm9vcCxcbiAgb25VcGRhdGU6IG5vb3AsXG4gIG9uTG9vcDogbm9vcCxcbiAgb25QYXVzZTogbm9vcCxcbiAgb25Db21wbGV0ZTogbm9vcCxcbiAgb25SZW5kZXI6IG5vb3AsXG59O1xuXG5jb25zdCBnbG9iYWxzID0ge1xuICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICBkZWZhdWx0cyxcbiAgLyoqIEB0eXBlIHtEb2N1bWVudHxET01UYXJnZXR9ICovXG4gIHJvb3Q6IGRvYyxcbiAgLyoqIEB0eXBlIHtTY29wZX0gKi9cbiAgc2NvcGU6IG51bGwsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICBwcmVjaXNpb246IDQsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aW1lU2NhbGU6IDEsXG4gIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICB0aWNrVGhyZXNob2xkOiAyMDAsXG59O1xuXG5jb25zdCBnbG9iYWxWZXJzaW9ucyA9IHsgdmVyc2lvbjogJzQuMC4yJywgZW5naW5lOiBudWxsIH07XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgaWYgKCF3aW4uQW5pbWVKUykgd2luLkFuaW1lSlMgPSBbXTtcbiAgd2luLkFuaW1lSlMucHVzaChnbG9iYWxWZXJzaW9ucyk7XG59XG5cbi8vIFN0cmluZ3NcblxuLyoqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCB0b0xvd2VyQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZShsb3dlckNhc2VSZ3gsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogUHJpb3JpdGl6ZSB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIHJlZ2V4IHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN1YlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3Qgc3RyaW5nU3RhcnRzV2l0aCA9IChzdHIsIHN1YikgPT4gc3RyLmluZGV4T2Yoc3ViKSA9PT0gMDtcblxuLy8gVGltZVxuLy8gTm90ZTogRGF0ZS5ub3cgaXMgdXNlZCBpbnN0ZWFkIG9mIHBlcmZvcm1hbmNlLm5vdyBzaW5jZSBpdCBpcyBwcmVjaXNlIGVub3VnaCBmb3IgdGltaW5ncyBjYWxjdWxhdGlvbnMsIHBlcmZvcm1zIHNsaWdodGx5IGZhc3RlciBhbmQgd29ya3MgaW4gTm9kZS5qcyBlbnZpcm9uZW1lbnQuXG5jb25zdCBub3cgPSBEYXRlLm5vdztcblxuLy8gVHlwZXMgY2hlY2tlcnNcblxuY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBSZWNvcmQ8U3RyaW5nLCBhbnk+fSAqL1xuY29uc3QgaXNPYmogPSBhID0+IGEgJiYgYS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7YSBpcyBOdW1iZXJ9ICovXG5jb25zdCBpc051bSA9IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInICYmICFpc05hTihhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU3RyaW5nfSAqL1xuY29uc3QgaXNTdHIgPSBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJztcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgRnVuY3Rpb259ICovXG5jb25zdCBpc0ZuYyA9IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIHVuZGVmaW5lZH0gKi9cbmNvbnN0IGlzVW5kID0gYSA9PiB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCc7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHthIGlzIG51bGwgfCB1bmRlZmluZWR9ICovXG5jb25zdCBpc05pbCA9IGEgPT4gaXNVbmQoYSkgfHwgYSA9PT0gbnVsbDtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge2EgaXMgU1ZHRWxlbWVudH0gKi9cbmNvbnN0IGlzU3ZnID0gYSA9PiBpc0Jyb3dzZXIgJiYgYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIZXggPSBhID0+IGhleFRlc3RSZ3gudGVzdChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc1JnYiA9IGEgPT4gc3RyaW5nU3RhcnRzV2l0aChhLCAncmdiJyk7XG4vKipAcGFyYW0ge2FueX0gYSBAcmV0dXJuIHtCb29sZWFufSAqL1xuY29uc3QgaXNIc2wgPSBhID0+IHN0cmluZ1N0YXJ0c1dpdGgoYSwgJ2hzbCcpO1xuLyoqQHBhcmFtIHthbnl9IGEgQHJldHVybiB7Qm9vbGVhbn0gKi9cbmNvbnN0IGlzQ29sID0gYSA9PiBpc0hleChhKSB8fCBpc1JnYihhKSB8fCBpc0hzbChhKTtcbi8qKkBwYXJhbSB7YW55fSBhIEByZXR1cm4ge0Jvb2xlYW59ICovXG5jb25zdCBpc0tleSA9IGEgPT4gIWdsb2JhbHMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoYSk7XG5cbi8vIE51bWJlclxuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZU51bWJlciA9IHN0ciA9PiBpc1N0cihzdHIpID9cbiAgcGFyc2VGbG9hdCgvKiogQHR5cGUge1N0cmluZ30gKi8oc3RyKSkgOlxuICAvKiogQHR5cGUge051bWJlcn0gKi8oc3RyKTtcblxuLy8gTWF0aFxuXG5jb25zdCBwb3cgPSBNYXRoLnBvdztcbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5jb25zdCBzaW4gPSBNYXRoLnNpbjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBleHAgPSBNYXRoLmV4cDtcbmNvbnN0IGNlaWwgPSBNYXRoLmNlaWw7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBhc2luID0gTWF0aC5hc2luO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBfcm91bmQgPSBNYXRoLnJvdW5kO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdlxuICogQHBhcmFtICB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wID0gKHYsIG1pbiwgbWF4KSA9PiB2IDwgbWluID8gbWluIDogdiA+IG1heCA/IG1heCA6IHY7XG5cbmNvbnN0IHBvd0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgcm91bmQgPSAodiwgZGVjaW1hbExlbmd0aCkgPT4ge1xuICBpZiAoZGVjaW1hbExlbmd0aCA8IDApIHJldHVybiB2O1xuICBpZiAoIWRlY2ltYWxMZW5ndGgpIHJldHVybiBfcm91bmQodik7XG4gIGxldCBwID0gcG93Q2FjaGVbZGVjaW1hbExlbmd0aF07XG4gIGlmICghcCkgcCA9IHBvd0NhY2hlW2RlY2ltYWxMZW5ndGhdID0gMTAgKiogZGVjaW1hbExlbmd0aDtcbiAgcmV0dXJuIF9yb3VuZCh2ICogcCkgLyBwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheTxOdW1iZXI+fSBpbmNyZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3Qgc25hcCA9ICh2LCBpbmNyZW1lbnQpID0+IGlzQXJyKGluY3JlbWVudCkgPyBpbmNyZW1lbnQucmVkdWNlKChjbG9zZXN0LCBjdikgPT4gKGFicyhjdiAtIHYpIDwgYWJzKGNsb3Nlc3QgLSB2KSA/IGN2IDogY2xvc2VzdCkpIDogaW5jcmVtZW50ID8gX3JvdW5kKHYgLyBpbmNyZW1lbnQpICogaW5jcmVtZW50IDogdjtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBpbnRlcnBvbGF0ZSA9IChzdGFydCwgZW5kLCBwcm9ncmVzcykgPT4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcHJvZ3Jlc3M7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNsYW1wSW5maW5pdHkgPSB2ID0+IHYgPT09IEluZmluaXR5ID8gbWF4VmFsdWUgOiB2ID09PSAtSW5maW5pdHkgPyAtMWUxMiA6IHY7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVRpbWUgPSB2ID0+IHYgPD0gbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGNsYW1wSW5maW5pdHkocm91bmQodiwgMTEpKTtcblxuLy8gQXJyYXlzXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VFtdfSBhXG4gKiBAcmV0dXJuIHtUW119XG4gKi9cbmNvbnN0IGNsb25lQXJyYXkgPSBhID0+IGlzQXJyKGEpID8gWyAuLi5hIF0gOiBhO1xuXG4vLyBPYmplY3RzXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBVXG4gKiBAcGFyYW0ge1R9IG8xXG4gKiBAcGFyYW0ge1V9IG8yXG4gKiBAcmV0dXJuIHtUICYgVX1cbiAqL1xuY29uc3QgbWVyZ2VPYmplY3RzID0gKG8xLCBvMikgPT4ge1xuICBjb25zdCBtZXJnZWQgPSAvKiogQHR5cGUge1QgJiBVfSAqLyh7IC4uLm8xIH0pO1xuICBmb3IgKGxldCBwIGluIG8yKSB7XG4gICAgY29uc3QgbzFwID0gLyoqIEB0eXBlIHtUICYgVX0gKi8obzEpW3BdO1xuICAgIG1lcmdlZFtwXSA9IGlzVW5kKG8xcCkgPyAvKiogQHR5cGUge1QgJiBVfSAqLyhvMilbcF0gOiBvMXA7XG4gIH0gIHJldHVybiBtZXJnZWQ7XG59O1xuXG4vLyBMaW5rZWQgbGlzdHNcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJzZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldlByb3BdXG4gKiBAcGFyYW0ge1N0cmluZ30gW25leHRQcm9wXVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaENoaWxkcmVuID0gKHBhcmVudCwgY2FsbGJhY2ssIHJldmVyc2UsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGxldCBuZXh0ID0gcGFyZW50Ll9oZWFkO1xuICBsZXQgYWRqdXN0ZWROZXh0UHJvcCA9IG5leHRQcm9wO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG5leHQgPSBwYXJlbnQuX3RhaWw7XG4gICAgYWRqdXN0ZWROZXh0UHJvcCA9IHByZXZQcm9wO1xuICB9XG4gIHdoaWxlIChuZXh0KSB7XG4gICAgY29uc3QgY3VycmVudE5leHQgPSBuZXh0W2FkanVzdGVkTmV4dFByb3BdO1xuICAgIGNhbGxiYWNrKG5leHQpO1xuICAgIG5leHQgPSBjdXJyZW50TmV4dDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtICB7T2JqZWN0fSBjaGlsZFxuICogQHBhcmFtICB7U3RyaW5nfSBbcHJldlByb3BdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtuZXh0UHJvcF1cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHJlbW92ZUNoaWxkID0gKHBhcmVudCwgY2hpbGQsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGNvbnN0IHByZXYgPSBjaGlsZFtwcmV2UHJvcF07XG4gIGNvbnN0IG5leHQgPSBjaGlsZFtuZXh0UHJvcF07XG4gIHByZXYgPyBwcmV2W25leHRQcm9wXSA9IG5leHQgOiBwYXJlbnQuX2hlYWQgPSBuZXh0O1xuICBuZXh0ID8gbmV4dFtwcmV2UHJvcF0gPSBwcmV2IDogcGFyZW50Ll90YWlsID0gcHJldjtcbiAgY2hpbGRbcHJldlByb3BdID0gbnVsbDtcbiAgY2hpbGRbbmV4dFByb3BdID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJlbnRcbiAqIEBwYXJhbSAge09iamVjdH0gY2hpbGRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbc29ydE1ldGhvZF1cbiAqIEBwYXJhbSAge1N0cmluZ30gcHJldlByb3BcbiAqIEBwYXJhbSAge1N0cmluZ30gbmV4dFByb3BcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IGFkZENoaWxkID0gKHBhcmVudCwgY2hpbGQsIHNvcnRNZXRob2QsIHByZXZQcm9wID0gJ19wcmV2JywgbmV4dFByb3AgPSAnX25leHQnKSA9PiB7XG4gIGxldCBwcmV2ID0gcGFyZW50Ll90YWlsO1xuICB3aGlsZSAocHJldiAmJiBzb3J0TWV0aG9kICYmIHNvcnRNZXRob2QocHJldiwgY2hpbGQpKSBwcmV2ID0gcHJldltwcmV2UHJvcF07XG4gIGNvbnN0IG5leHQgPSBwcmV2ID8gcHJldltuZXh0UHJvcF0gOiBwYXJlbnQuX2hlYWQ7XG4gIHByZXYgPyBwcmV2W25leHRQcm9wXSA9IGNoaWxkIDogcGFyZW50Ll9oZWFkID0gY2hpbGQ7XG4gIG5leHQgPyBuZXh0W3ByZXZQcm9wXSA9IGNoaWxkIDogcGFyZW50Ll90YWlsID0gY2hpbGQ7XG4gIGNoaWxkW3ByZXZQcm9wXSA9IHByZXY7XG4gIGNoaWxkW25leHRQcm9wXSA9IG5leHQ7XG59O1xuXG4vKlxuICogQmFzZSBjbGFzcyB0byBjb250cm9sIGZyYW1lcmF0ZSBhbmQgcGxheWJhY2sgcmF0ZS5cbiAqIEluaGVyaXRlZCBieSBFbmdpbmUsIFRpbWVyLCBBbmltYXRpb24gYW5kIFRpbWVsaW5lLlxuICovXG5jbGFzcyBDbG9jayB7XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdFRpbWVdICovXG4gIGNvbnN0cnVjdG9yKGluaXRUaW1lID0gMCkge1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IGluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gaW5pdFRpbWU7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fbGFzdFRpbWUgPSBpbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcmFtZUR1cmF0aW9uID0gcm91bmQoSyAvIG1heEZwcywgMCk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZnBzID0gbWF4RnBzO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3NwZWVkID0gMTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFR3ZWVufSAqL1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7VGlja2FibGV8VHdlZW59ICovXG4gICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICBnZXQgZnBzKCkge1xuICAgIHJldHVybiB0aGlzLl9mcHM7XG4gIH1cblxuICBzZXQgZnBzKGZyYW1lUmF0ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzRnJhbWVEdXJhdGlvbiA9IHRoaXMuX2ZyYW1lRHVyYXRpb247XG4gICAgY29uc3QgZnIgPSArZnJhbWVSYXRlO1xuICAgIGNvbnN0IGZwcyA9IGZyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IGZyO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSByb3VuZChLIC8gZnBzLCAwKTtcbiAgICB0aGlzLl9mcHMgPSBmcHM7XG4gICAgdGhpcy5fZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5fc2NoZWR1bGVkVGltZSArPSBmcmFtZUR1cmF0aW9uIC0gcHJldmlvdXNGcmFtZUR1cmF0aW9uO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZDtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICBjb25zdCBwYnIgPSArcGxheWJhY2tSYXRlO1xuICAgIHRoaXMuX3NwZWVkID0gcGJyIDwgbWluVmFsdWUgPyBtaW5WYWx1ZSA6IHBicjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVcbiAgICogQHJldHVybiB7dGlja01vZGVzfVxuICAgKi9cbiAgcmVxdWVzdFRpY2sodGltZSkge1xuICAgIGNvbnN0IHNjaGVkdWxlZFRpbWUgPSB0aGlzLl9zY2hlZHVsZWRUaW1lO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gdGhpcy5fZWxhcHNlZFRpbWU7XG4gICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gKHRpbWUgLSBlbGFwc2VkVGltZSk7XG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgdGltZSBpcyBsb3dlciB0aGFuIHRoZSBzY2hlZHVsZWQgdGltZVxuICAgIC8vIHRoaXMgbWVhbnMgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgdG8gaGl0IG9uZSBmcmFtZUR1cmF0aW9uXG4gICAgLy8gc28gc2tpcCB0aGF0IGZyYW1lXG4gICAgaWYgKGVsYXBzZWRUaW1lIDwgc2NoZWR1bGVkVGltZSkgcmV0dXJuIHRpY2tNb2Rlcy5OT05FO1xuICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSB0aGlzLl9mcmFtZUR1cmF0aW9uO1xuICAgIGNvbnN0IGZyYW1lRGVsdGEgPSBlbGFwc2VkVGltZSAtIHNjaGVkdWxlZFRpbWU7XG4gICAgLy8gRW5zdXJlcyB0aGF0IF9zY2hlZHVsZWRUaW1lIHByb2dyZXNzZXMgaW4gc3RlcHMgb2YgYXQgbGVhc3QgMSBmcmFtZUR1cmF0aW9uLlxuICAgIC8vIFNraXBzIGFoZWFkIGlmIHRoZSBhY3R1YWwgZWxhcHNlZCB0aW1lIGlzIGhpZ2hlci5cbiAgICB0aGlzLl9zY2hlZHVsZWRUaW1lICs9IGZyYW1lRGVsdGEgPCBmcmFtZUR1cmF0aW9uID8gZnJhbWVEdXJhdGlvbiA6IGZyYW1lRGVsdGE7XG4gICAgcmV0dXJuIHRpY2tNb2Rlcy5BVVRPO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb21wdXRlRGVsdGFUaW1lKHRpbWUpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRpbWUgLSB0aGlzLl9sYXN0VGltZTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IGRlbHRhO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZTtcbiAgICByZXR1cm4gZGVsdGE7XG4gIH1cblxufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge3RpY2tNb2Rlc30gdGlja01vZGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmVuZGVyID0gKHRpY2thYmxlLCB0aW1lLCBtdXRlQ2FsbGJhY2tzLCBpbnRlcm5hbFJlbmRlciwgdGlja01vZGUpID0+IHtcblxuICBjb25zdCBwYXJlbnQgPSB0aWNrYWJsZS5wYXJlbnQ7XG4gIGNvbnN0IGR1cmF0aW9uID0gdGlja2FibGUuZHVyYXRpb247XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHRpY2thYmxlLmNvbXBsZXRlZDtcbiAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aWNrYWJsZS5pdGVyYXRpb25EdXJhdGlvbjtcbiAgY29uc3QgaXRlcmF0aW9uQ291bnQgPSB0aWNrYWJsZS5pdGVyYXRpb25Db3VudDtcbiAgY29uc3QgX2N1cnJlbnRJdGVyYXRpb24gPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbjtcbiAgY29uc3QgX2xvb3BEZWxheSA9IHRpY2thYmxlLl9sb29wRGVsYXk7XG4gIGNvbnN0IF9yZXZlcnNlZCA9IHRpY2thYmxlLl9yZXZlcnNlZDtcbiAgY29uc3QgX2FsdGVybmF0ZSA9IHRpY2thYmxlLl9hbHRlcm5hdGU7XG4gIGNvbnN0IF9oYXNDaGlsZHJlbiA9IHRpY2thYmxlLl9oYXNDaGlsZHJlbjtcbiAgY29uc3QgdGlja2FibGVEZWxheSA9IHRpY2thYmxlLl9kZWxheTtcbiAgY29uc3QgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lID0gdGlja2FibGUuX2N1cnJlbnRUaW1lOyAvLyBUT0RPOiByZW5hbWUgLl9jdXJyZW50VGltZSB0byAuX2Fic29sdXRlQ3VycmVudFRpbWVcblxuICBjb25zdCB0aWNrYWJsZUVuZFRpbWUgPSB0aWNrYWJsZURlbGF5ICsgaXRlcmF0aW9uRHVyYXRpb247XG4gIGNvbnN0IHRpY2thYmxlQWJzb2x1dGVUaW1lID0gdGltZSAtIHRpY2thYmxlRGVsYXk7XG4gIGNvbnN0IHRpY2thYmxlUHJldlRpbWUgPSBjbGFtcCh0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWUsIC10aWNrYWJsZURlbGF5LCBkdXJhdGlvbik7XG4gIGNvbnN0IHRpY2thYmxlQ3VycmVudFRpbWUgPSBjbGFtcCh0aWNrYWJsZUFic29sdXRlVGltZSwgLXRpY2thYmxlRGVsYXksIGR1cmF0aW9uKTtcbiAgY29uc3QgZGVsdGFUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWUgLSB0aWNrYWJsZVByZXZBYnNvbHV0ZVRpbWU7XG4gIGNvbnN0IGlzQ3VycmVudFRpbWVBYm92ZVplcm8gPSB0aWNrYWJsZUN1cnJlbnRUaW1lID4gMDtcbiAgY29uc3QgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID0gdGlja2FibGVDdXJyZW50VGltZSA+PSBkdXJhdGlvbjtcbiAgY29uc3QgaXNTZXR0ZXIgPSBkdXJhdGlvbiA8PSBtaW5WYWx1ZTtcbiAgY29uc3QgZm9yY2VkVGljayA9IHRpY2tNb2RlID09PSB0aWNrTW9kZXMuRk9SQ0U7XG5cbiAgbGV0IGlzT2RkID0gMDtcbiAgbGV0IGl0ZXJhdGlvbkVsYXBzZWRUaW1lID0gdGlja2FibGVBYnNvbHV0ZVRpbWU7XG4gIC8vIFJlbmRlciBjaGVja3NcbiAgLy8gVXNlZCB0byBhbHNvIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIHJlbmRlcmVkIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIG9uUmVuZGVyIGNhbGxiYWNrIG9uIHRoZSBwYXJlbnQgdGltZXJcbiAgbGV0IGhhc1JlbmRlcmVkID0gMDtcblxuICAvLyBFeGVjdXRlIHRoZSBcImV4cGVuc2l2ZVwiIGl0ZXJhdGlvbnMgY2FsY3VsYXRpb25zIG9ubHkgd2hlbiBuZWNlc3NhcnlcbiAgaWYgKGl0ZXJhdGlvbkNvdW50ID4gMSkge1xuICAgIC8vIGJpdHdpc2UgTk9UIG9wZXJhdG9yIHNlZW1zIHRvIGJlIGdlbmVyYWxseSBmYXN0ZXIgdGhhbiBNYXRoLmZsb29yKCkgYWNyb3NzIGJyb3dzZXJzXG4gICAgY29uc3QgY3VycmVudEl0ZXJhdGlvbiA9IH5+KHRpY2thYmxlQ3VycmVudFRpbWUgLyAoaXRlcmF0aW9uRHVyYXRpb24gKyAoaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gMCA6IF9sb29wRGVsYXkpKSk7XG4gICAgdGlja2FibGUuX2N1cnJlbnRJdGVyYXRpb24gPSBjbGFtcChjdXJyZW50SXRlcmF0aW9uLCAwLCBpdGVyYXRpb25Db3VudCk7XG4gICAgLy8gUHJldmVudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIGdvIGFib3ZlIHRoZSBtYXggaXRlcmF0aW9ucyB3aGVuIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxuICAgIGlmIChpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uLS07XG4gICAgaXNPZGQgPSB0aWNrYWJsZS5fY3VycmVudEl0ZXJhdGlvbiAlIDI7XG4gICAgaXRlcmF0aW9uRWxhcHNlZFRpbWUgPSB0aWNrYWJsZUN1cnJlbnRUaW1lICUgKGl0ZXJhdGlvbkR1cmF0aW9uICsgX2xvb3BEZWxheSkgfHwgMDtcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiBleGFjdGx5IG9uZSBvZiBfcmV2ZXJzZWQgYW5kIChfYWx0ZXJuYXRlICYmIGlzT2RkKSBpcyB0cnVlXG4gIGNvbnN0IGlzUmV2ZXJzZWQgPSBfcmV2ZXJzZWQgXiAoX2FsdGVybmF0ZSAmJiBpc09kZCk7XG4gIGNvbnN0IF9lYXNlID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqLyh0aWNrYWJsZSkuX2Vhc2U7XG4gIGxldCBpdGVyYXRpb25UaW1lID0gaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uID8gaXNSZXZlcnNlZCA/IDAgOiBkdXJhdGlvbiA6IGlzUmV2ZXJzZWQgPyBpdGVyYXRpb25EdXJhdGlvbiAtIGl0ZXJhdGlvbkVsYXBzZWRUaW1lIDogaXRlcmF0aW9uRWxhcHNlZFRpbWU7XG4gIGlmIChfZWFzZSkgaXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvbkR1cmF0aW9uICogX2Vhc2UoaXRlcmF0aW9uVGltZSAvIGl0ZXJhdGlvbkR1cmF0aW9uKSB8fCAwO1xuICBjb25zdCBpc1J1bm5pbmdCYWNrd2FyZHMgPSAocGFyZW50ID8gcGFyZW50LmJhY2t3YXJkcyA6IHRpY2thYmxlQWJzb2x1dGVUaW1lIDwgdGlja2FibGVQcmV2QWJzb2x1dGVUaW1lKSA/ICFpc1JldmVyc2VkIDogISFpc1JldmVyc2VkO1xuXG4gIHRpY2thYmxlLl9jdXJyZW50VGltZSA9IHRpY2thYmxlQWJzb2x1dGVUaW1lO1xuICB0aWNrYWJsZS5faXRlcmF0aW9uVGltZSA9IGl0ZXJhdGlvblRpbWU7XG4gIHRpY2thYmxlLmJhY2t3YXJkcyA9IGlzUnVubmluZ0JhY2t3YXJkcztcblxuICBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiAhdGlja2FibGUuYmVnYW4pIHtcbiAgICB0aWNrYWJsZS5iZWdhbiA9IHRydWU7XG4gICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICB0aWNrYWJsZS5vbkJlZ2luKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGlja2FibGUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gMCkge1xuICAgIHRpY2thYmxlLmJlZ2FuID0gZmFsc2U7XG4gIH1cblxuICAvLyBPbmx5IHRyaWdnZXJzIG9uTG9vcCBmb3IgdGlja2FibGUgd2l0aG91dCBjaGlsZHJlbiwgb3RoZXJ3aXNlIGNhbGwgdGhlIHRoZSBvbkxvb3AgY2FsbGJhY2sgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgLy8gTWFrZSBzdXJlIHRvIHRyaWdnZXIgdGhlIG9uTG9vcCBiZWZvcmUgcmVuZGVyaW5nIHRvIGFsbG93IC5yZWZyZXNoKCkgdG8gcGlja3VwIHRoZSBjdXJyZW50IHZhbHVlc1xuICBpZiAoIW11dGVDYWxsYmFja3MgJiYgIV9oYXNDaGlsZHJlbiAmJiBpc0N1cnJlbnRUaW1lQWJvdmVaZXJvICYmIHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uICE9PSBfY3VycmVudEl0ZXJhdGlvbikge1xuICAgIHRpY2thYmxlLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gIH1cblxuICBpZiAoXG4gICAgZm9yY2VkVGljayB8fFxuICAgIHRpY2tNb2RlID09PSB0aWNrTW9kZXMuQVVUTyAmJiAoXG4gICAgICB0aW1lID49IHRpY2thYmxlRGVsYXkgJiYgdGltZSA8PSB0aWNrYWJsZUVuZFRpbWUgfHwgLy8gTm9ybWFsIHJlbmRlclxuICAgICAgdGltZSA8PSB0aWNrYWJsZURlbGF5ICYmIHRpY2thYmxlUHJldlRpbWUgPiB0aWNrYWJsZURlbGF5IHx8IC8vIFBsYXloZWFkIGlzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0IHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGluaXRpYWwgc3RhdGVcbiAgICAgIHRpbWUgPj0gdGlja2FibGVFbmRUaW1lICYmIHRpY2thYmxlUHJldlRpbWUgIT09IGR1cmF0aW9uIC8vIFBsYXloZWFkIGlzIGFmdGVyIHRoZSBhbmltYXRpb24gZW5kIHRpbWUgc28gbWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgYXQgaXRzIGVuZCBzdGF0ZVxuICAgICkgfHxcbiAgICBpdGVyYXRpb25UaW1lID49IHRpY2thYmxlRW5kVGltZSAmJiB0aWNrYWJsZVByZXZUaW1lICE9PSBkdXJhdGlvbiB8fFxuICAgIGl0ZXJhdGlvblRpbWUgPD0gdGlja2FibGVEZWxheSAmJiB0aWNrYWJsZVByZXZUaW1lID4gMCB8fFxuICAgIHRpbWUgPD0gdGlja2FibGVQcmV2VGltZSAmJiB0aWNrYWJsZVByZXZUaW1lID09PSBkdXJhdGlvbiAmJiBjb21wbGV0ZWQgfHwgLy8gRm9yY2UgYSByZW5kZXIgaWYgYSBzZWVrIG9jY3VycyBvbiBhbiBjb21wbGV0ZWQgYW5pbWF0aW9uXG4gICAgaXNDdXJyZW50VGltZUVxdWFsT3JBYm92ZUR1cmF0aW9uICYmICFjb21wbGV0ZWQgJiYgaXNTZXR0ZXIgLy8gVGhpcyBwcmV2ZW50cyAwIGR1cmF0aW9uIHRpY2thYmxlcyB0byBiZSBza2lwcGVkXG4gICkge1xuXG4gICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIHtcbiAgICAgIC8vIFRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYmVmb3JlIHJlbmRlcmluZ1xuICAgICAgdGlja2FibGUuY29tcHV0ZURlbHRhVGltZSh0aWNrYWJsZVByZXZUaW1lKTtcbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcykgdGlja2FibGUub25CZWZvcmVVcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHR3ZWVucyByZW5kZXJpbmdcbiAgICBpZiAoIV9oYXNDaGlsZHJlbikge1xuXG4gICAgICAvLyBUaW1lIGhhcyBqdW1wZWQgbW9yZSB0aGFuIGdsb2JhbHMudGlja1RocmVzaG9sZCBzbyBjb25zaWRlciB0aGlzIHRpY2sgbWFudWFsXG4gICAgICBjb25zdCBmb3JjZWRSZW5kZXIgPSBmb3JjZWRUaWNrIHx8IChpc1J1bm5pbmdCYWNrd2FyZHMgPyBkZWx0YVRpbWUgKiAtMSA6IGRlbHRhVGltZSkgPj0gZ2xvYmFscy50aWNrVGhyZXNob2xkO1xuICAgICAgY29uc3QgYWJzb2x1dGVUaW1lID0gdGlja2FibGUuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApICsgdGlja2FibGVEZWxheSArIGl0ZXJhdGlvblRpbWU7XG5cbiAgICAgIC8vIE9ubHkgQW5pbWF0aW9uIGNhbiBoYXZlIHR3ZWVucywgVGltZXIgcmV0dXJucyB1bmRlZmluZWRcbiAgICAgIGxldCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKHRpY2thYmxlKS5faGVhZCk7XG4gICAgICBsZXQgdHdlZW5UYXJnZXQ7XG4gICAgICBsZXQgdHdlZW5TdHlsZTtcbiAgICAgIGxldCB0d2VlblRhcmdldFRyYW5zZm9ybXM7XG4gICAgICBsZXQgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllcztcbiAgICAgIGxldCB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcblxuICAgICAgd2hpbGUgKHR3ZWVuKSB7XG5cbiAgICAgICAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5DdXJyZW50VGltZSA9IHR3ZWVuLl9jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgdHdlZW5DaGFuZ2VEdXJhdGlvbiA9IHR3ZWVuLl9jaGFuZ2VEdXJhdGlvbjtcbiAgICAgICAgY29uc3QgdHdlZW5BYnNFbmRUaW1lID0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICsgdHdlZW4uX2NoYW5nZUR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0d2Vlbk5leHRSZXAgPSB0d2Vlbi5fbmV4dFJlcDtcbiAgICAgICAgY29uc3QgdHdlZW5QcmV2UmVwID0gdHdlZW4uX3ByZXZSZXA7XG4gICAgICAgIGNvbnN0IHR3ZWVuSGFzQ29tcG9zaXRpb24gPSB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmU7XG5cbiAgICAgICAgaWYgKChmb3JjZWRSZW5kZXIgfHwgKFxuICAgICAgICAgICAgKHR3ZWVuQ3VycmVudFRpbWUgIT09IHR3ZWVuQ2hhbmdlRHVyYXRpb24gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuQWJzRW5kVGltZSArICh0d2Vlbk5leHRSZXAgPyB0d2Vlbk5leHRSZXAuX2RlbGF5IDogMCkpICYmXG4gICAgICAgICAgICAodHdlZW5DdXJyZW50VGltZSAhPT0gMCB8fCBhYnNvbHV0ZVRpbWUgPj0gdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lKVxuICAgICAgICAgICkpICYmICghdHdlZW5IYXNDb21wb3NpdGlvbiB8fCAoXG4gICAgICAgICAgICAhdHdlZW4uX2lzT3ZlcnJpZGRlbiAmJlxuICAgICAgICAgICAgKCF0d2Vlbi5faXNPdmVybGFwcGVkIHx8IGFic29sdXRlVGltZSA8PSB0d2VlbkFic0VuZFRpbWUpICYmXG4gICAgICAgICAgICAoIXR3ZWVuTmV4dFJlcCB8fCAodHdlZW5OZXh0UmVwLl9pc092ZXJyaWRkZW4gfHwgYWJzb2x1dGVUaW1lIDw9IHR3ZWVuTmV4dFJlcC5fYWJzb2x1dGVTdGFydFRpbWUpKSAmJlxuICAgICAgICAgICAgKCF0d2VlblByZXZSZXAgfHwgKHR3ZWVuUHJldlJlcC5faXNPdmVycmlkZGVuIHx8IChhYnNvbHV0ZVRpbWUgPj0gKHR3ZWVuUHJldlJlcC5fYWJzb2x1dGVTdGFydFRpbWUgKyB0d2VlblByZXZSZXAuX2NoYW5nZUR1cmF0aW9uKSArIHR3ZWVuLl9kZWxheSkpKVxuICAgICAgICAgICkpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5OZXdUaW1lID0gdHdlZW4uX2N1cnJlbnRUaW1lID0gY2xhbXAoaXRlcmF0aW9uVGltZSAtIHR3ZWVuLl9zdGFydFRpbWUsIDAsIHR3ZWVuQ2hhbmdlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvZ3Jlc3MgPSB0d2Vlbi5fZWFzZSh0d2Vlbk5ld1RpbWUgLyB0d2Vlbi5fdXBkYXRlRHVyYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuTW9kaWZpZXIgPSB0d2Vlbi5fbW9kaWZpZXI7XG4gICAgICAgICAgY29uc3QgdHdlZW5WYWx1ZVR5cGUgPSB0d2Vlbi5fdmFsdWVUeXBlO1xuICAgICAgICAgIGNvbnN0IHR3ZWVuVHlwZSA9IHR3ZWVuLl90d2VlblR5cGU7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc09iamVjdCA9IHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5PQkpFQ1Q7XG4gICAgICAgICAgY29uc3QgdHdlZW5Jc051bWJlciA9IHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLk5VTUJFUjtcbiAgICAgICAgICAvLyBPbmx5IHJvdW5kIHRoZSBpbi1iZXR3ZWVuIGZyYW1lcyB2YWx1ZXMgaWYgdGhlIGZpbmFsIHZhbHVlIGlzIGEgc3RyaW5nXG4gICAgICAgICAgY29uc3QgdHdlZW5QcmVjaXNpb24gPSAodHdlZW5Jc051bWJlciAmJiB0d2VlbklzT2JqZWN0KSB8fCB0d2VlblByb2dyZXNzID09PSAwIHx8IHR3ZWVuUHJvZ3Jlc3MgPT09IDEgPyAtMSA6IGdsb2JhbHMucHJlY2lzaW9uO1xuXG4gICAgICAgICAgLy8gUmVjb21wb3NlIHR3ZWVuIHZhbHVlXG4gICAgICAgICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICAgICBsZXQgbnVtYmVyO1xuXG4gICAgICAgICAgaWYgKHR3ZWVuSXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbiApKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0d2VlblZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyB0aGUgdmFsdWVzIHNwZWVkIHVwIHN0cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgICAgbnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIocm91bmQoaW50ZXJwb2xhdGUodHdlZW4uX2Zyb21OdW1iZXIsIHR3ZWVuLl90b051bWJlciwgIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgIHZhbHVlID0gYCR7bnVtYmVyfSR7dHdlZW4uX3VuaXR9YDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR3ZWVuLl9mcm9tTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHRuID0gdHdlZW4uX3RvTnVtYmVycztcbiAgICAgICAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihpbnRlcnBvbGF0ZShmblswXSwgdG5bMF0sIHR3ZWVuUHJvZ3Jlc3MpKSksIDAsIDI1NSksIDApO1xuICAgICAgICAgICAgY29uc3QgZyA9IHJvdW5kKGNsYW1wKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0d2Vlbk1vZGlmaWVyKGludGVycG9sYXRlKGZuWzFdLCB0blsxXSwgdHdlZW5Qcm9ncmVzcykpKSwgMCwgMjU1KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuTW9kaWZpZXIoaW50ZXJwb2xhdGUoZm5bMl0sIHRuWzJdLCB0d2VlblByb2dyZXNzKSkpLCAwLCAyNTUpLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcCgvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZShmblszXSwgdG5bM10sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKSwgMCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGByZ2JhKCR7cn0sJHtnfSwke2J9LCR7YX0pYDtcbiAgICAgICAgICAgIGlmICh0d2Vlbkhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5zID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgICAgIG5zWzBdID0gcjtcbiAgICAgICAgICAgICAgbnNbMV0gPSBnO1xuICAgICAgICAgICAgICBuc1syXSA9IGI7XG4gICAgICAgICAgICAgIG5zWzNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHdlZW4uX3N0cmluZ3NbMF07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbCA9IHR3ZWVuLl90b051bWJlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW5Nb2RpZmllcihyb3VuZChpbnRlcnBvbGF0ZSh0d2Vlbi5fZnJvbU51bWJlcnNbal0sIHR3ZWVuLl90b051bWJlcnNbal0sIHR3ZWVuUHJvZ3Jlc3MpLCB0d2VlblByZWNpc2lvbikpKTtcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHR3ZWVuLl9zdHJpbmdzW2ogKyAxXTtcbiAgICAgICAgICAgICAgdmFsdWUgKz0gYCR7cyA/IG4gKyBzIDogbn1gO1xuICAgICAgICAgICAgICBpZiAodHdlZW5IYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHR3ZWVuLl9udW1iZXJzW2pdID0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciBhZGRpdGl2ZSB0d2VlbnMgYW5kIEFuaW1hdGFibGVzXG4gICAgICAgICAgaWYgKHR3ZWVuSGFzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHR3ZWVuLl9udW1iZXIgPSBudW1iZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbFJlbmRlciAmJiB0d2VlbkNvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgICAgICAgIHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Jc09iamVjdCkge1xuICAgICAgICAgICAgICB0d2VlblRhcmdldFt0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc2V0QXR0cmlidXRlKHR3ZWVuUHJvcGVydHksIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW5TdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgICAgICAgIGlmICh0d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR3ZWVuVGFyZ2V0ICE9PSB0d2VlblRhcmdldFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3JtcyA9IHR3ZWVuVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgLy8gTk9URTogUmVmZXJlbmNpbmcgdGhlIGNhY2hlZFRyYW5zZm9ybXMgaW4gdGhlIHR3ZWVuIHByb3BlcnR5IGRpcmVjdGx5IGNhbiBiZSBhIGxpdHRsZSBiaXQgZmFzdGVyIGJ1dCBhcHBlYXJzIHRvIGluY3JlYXNlIG1lbW9yeSB1c2FnZS5cbiAgICAgICAgICAgICAgICAgIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHdlZW5UYXJnZXRUcmFuc2Zvcm1zUHJvcGVydGllc1t0d2VlblByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlW3R3ZWVuUHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkNTU19WQVIpIHtcbiAgICAgICAgICAgICAgICB0d2VlblN0eWxlLnNldFByb3BlcnR5KHR3ZWVuUHJvcGVydHksLyoqIEB0eXBlIHtTdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ3VycmVudFRpbWVBYm92ZVplcm8pIGhhc1JlbmRlcmVkID0gMTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2VkIGZvciBjb21wb3NpbmcgdGltZWxpbmUgdHdlZW5zIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGEgcmVhbCByZW5kZXJcbiAgICAgICAgICAgIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTk9URTogUG9zc2libGUgaW1wcm92ZW1lbnQ6IFVzZSB0cmFuc2xhdGUoeCx5KSAvIHRyYW5zbGF0ZTNkKHgseSx6KSBzeW50YXhcbiAgICAgICAgLy8gdG8gcmVkdWNlIG1lbW9yeSB1c2FnZSBvbiBzdHJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgaWYgKHR3ZWVuVHJhbnNmb3Jtc05lZWRVcGRhdGUgJiYgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMpIHtcbiAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHR3ZWVuVGFyZ2V0VHJhbnNmb3Jtc1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHN0ciArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW2tleV19JHt0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzW2tleV19KSBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0d2VlblN0eWxlLnRyYW5zZm9ybSA9IHN0cjtcbiAgICAgICAgICB0d2VlblRyYW5zZm9ybXNOZWVkVXBkYXRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuID0gdHdlZW4uX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiBoYXNSZW5kZXJlZCkge1xuICAgICAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqLyh0aWNrYWJsZSkub25SZW5kZXIoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8odGlja2FibGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgaXNDdXJyZW50VGltZUFib3ZlWmVybykge1xuICAgICAgdGlja2FibGUub25VcGRhdGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgIH1cblxuICB9XG5cbiAgLy8gRW5kIHR3ZWVucyByZW5kZXJpbmdcblxuICAvLyBIYW5kbGUgc2V0dGVycyBvbiB0aW1lbGluZSBkaWZmZXJlbnRseSBhbmQgYWxsb3cgcmUtdHJpZ2VyaW5nIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gc2Vla2luZyBiYWNrd2FyZHNcbiAgaWYgKHBhcmVudCAmJiBpc1NldHRlcikge1xuICAgIGlmICghbXV0ZUNhbGxiYWNrcyAmJiAoXG4gICAgICAocGFyZW50LmJlZ2FuICYmICFpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPj0gZHVyYXRpb24gJiYgIWNvbXBsZXRlZCkgfHxcbiAgICAgIChpc1J1bm5pbmdCYWNrd2FyZHMgJiYgdGlja2FibGVBYnNvbHV0ZVRpbWUgPD0gbWluVmFsdWUgJiYgY29tcGxldGVkKVxuICAgICkpIHtcbiAgICAgIHRpY2thYmxlLm9uQ29tcGxldGUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgdGlja2FibGUuY29tcGxldGVkID0gIWlzUnVubmluZ0JhY2t3YXJkcztcbiAgICB9XG4gIC8vIElmIGN1cnJlbnRUaW1lIGlzIGJvdGggYWJvdmUgMCBhbmQgYXQgbGVhc3QgZXF1YWxzIHRvIGR1cmF0aW9uLCBoYW5kbGVzIG5vcm1hbCBvbkNvbXBsZXRlIG9yIGluZmluaXRlIGxvb3BzXG4gIH0gZWxzZSBpZiAoaXNDdXJyZW50VGltZUFib3ZlWmVybyAmJiBpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24pIHtcbiAgICBpZiAoaXRlcmF0aW9uQ291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAvLyBPZmZzZXQgdGhlIHRpY2thYmxlIF9zdGFydFRpbWUgd2l0aCBpdHMgZHVyYXRpb24gdG8gcmVzZXQgX2N1cnJlbnRUaW1lIHRvIDAgYW5kIGNvbnRpbnVlIHRoZSBpbmZpbml0ZSB0aW1lclxuICAgICAgdGlja2FibGUuX3N0YXJ0VGltZSArPSB0aWNrYWJsZS5kdXJhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uID49IGl0ZXJhdGlvbkNvdW50IC0gMSkge1xuICAgICAgLy8gQnkgc2V0dGluZyBwYXVzZWQgdG8gdHJ1ZSwgd2UgdGVsbCB0aGUgZW5naW5lIGxvb3AgdG8gbm90IHJlbmRlciB0aGlzIHRpY2thYmxlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGxpc3Qgb24gdGhlIG5leHQgdGlja1xuICAgICAgdGlja2FibGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICghY29tcGxldGVkICYmICFfaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRpY2thYmxlIGhhcyBjaGlsZHJlbiwgdHJpZ2dlcnMgb25Db21wbGV0ZSgpIG9ubHkgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBjb21wbGV0ZWQgaW4gdGhlIHRpY2sgZnVuY3Rpb25cbiAgICAgICAgdGlja2FibGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtdXRlQ2FsbGJhY2tzICYmICEocGFyZW50ICYmIChpc1J1bm5pbmdCYWNrd2FyZHMgfHwgIXBhcmVudC5iZWdhbikpKSB7XG4gICAgICAgICAgdGlja2FibGUub25Db21wbGV0ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRpY2thYmxlKSk7XG4gICAgICAgICAgdGlja2FibGUuX3Jlc29sdmUoLyoqIEB0eXBlIHtDYWxsYmFja0FyZ3VtZW50fSAqLyh0aWNrYWJsZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBjb21wbGV0ZWQgZmxhZyB0byBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHRpY2thYmxlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gTk9URTogaGFzUmVuZGVyZWQgKiBkaXJlY3Rpb24gKG5lZ2F0aXZlIGZvciBiYWNrd2FyZHMpIHRoaXMgd2F5IHdlIGNhbiByZW1vdmUgdGhlIHRpY2thYmxlLmJhY2t3YXJkcyBwcm9wZXJ0eSBjb21wbGV0bHkgP1xuICByZXR1cm4gaGFzUmVuZGVyZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpY2thYmxlfSB0aWNrYWJsZVxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG11dGVDYWxsYmFja3NcbiAqIEBwYXJhbSAge051bWJlcn0gaW50ZXJuYWxSZW5kZXJcbiAqIEBwYXJhbSAge051bWJlcn0gdGlja01vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmNvbnN0IHRpY2sgPSAodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSkgPT4ge1xuICBjb25zdCBfY3VycmVudEl0ZXJhdGlvbiA9IHRpY2thYmxlLl9jdXJyZW50SXRlcmF0aW9uO1xuICByZW5kZXIodGlja2FibGUsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZSk7XG4gIGlmICh0aWNrYWJsZS5faGFzQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0bCA9IC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKHRpY2thYmxlKTtcbiAgICBjb25zdCB0bElzUnVubmluZ0JhY2t3YXJkcyA9IHRsLmJhY2t3YXJkcztcbiAgICBjb25zdCB0bENoaWxkcmVuVGltZSA9IGludGVybmFsUmVuZGVyID8gdGltZSA6IHRsLl9pdGVyYXRpb25UaW1lO1xuICAgIGNvbnN0IHRsQ2lsZHJlblRpY2tUaW1lID0gbm93KCk7XG5cbiAgICBsZXQgdGxDaGlsZHJlbkhhc1JlbmRlcmVkID0gMDtcbiAgICBsZXQgdGxDaGlsZHJlbkhhdmVDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgLy8gSWYgdGhlIHRpbWVsaW5lIGhhcyBsb29wZWQgZm9yd2FyZCwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VycyBjaGlsZHJlbiBza2lwcGVkIGNhbGxiYWNrc1xuICAgIGlmICghaW50ZXJuYWxSZW5kZXIgJiYgdGwuX2N1cnJlbnRJdGVyYXRpb24gIT09IF9jdXJyZW50SXRlcmF0aW9uKSB7XG4gICAgICBjb25zdCB0bEl0ZXJhdGlvbkR1cmF0aW9uID0gdGwuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGwsICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgIGlmICghdGxJc1J1bm5pbmdCYWNrd2FyZHMpIHtcbiAgICAgICAgICAvLyBGb3JjZSBhbiBpbnRlcm5hbCByZW5kZXIgdG8gdHJpZ2dlciB0aGUgY2FsbGJhY2tzIGlmIHRoZSBjaGlsZCBoYXMgbm90IGNvbXBsZXRlZCBvbiBsb29wXG4gICAgICAgICAgaWYgKCFjaGlsZC5jb21wbGV0ZWQgJiYgIWNoaWxkLmJhY2t3YXJkcyAmJiBjaGlsZC5fY3VycmVudFRpbWUgPCBjaGlsZC5pdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgcmVuZGVyKGNoaWxkLCB0bEl0ZXJhdGlvbkR1cmF0aW9uLCBtdXRlQ2FsbGJhY2tzLCAxLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGVpciBiZWdhbiBhbmQgY29tcGxldGVkIGZsYWdzIHRvIGFsbG93IHJldHJpZ2VyaW5nIGNhbGxiYWNrcyBvbiB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICBjaGlsZC5iZWdhbiA9IGZhbHNlO1xuICAgICAgICAgIGNoaWxkLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyYXRpb24gPSBjaGlsZC5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjaGlsZFN0YXJ0VGltZSA9IGNoaWxkLl9vZmZzZXQgKyBjaGlsZC5fZGVsYXk7XG4gICAgICAgICAgY29uc3QgY2hpbGRFbmRUaW1lID0gY2hpbGRTdGFydFRpbWUgKyBjaGlsZER1cmF0aW9uO1xuICAgICAgICAgIC8vIFRyaWdnZXJzIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIG9uIHJldmVyc2UgZm9yIGNoaWxkcmVuIG9uIHRoZSBlZGdlcyBvZiB0aGUgdGltZWxpbmVcbiAgICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgY2hpbGREdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAoIWNoaWxkU3RhcnRUaW1lIHx8IGNoaWxkRW5kVGltZSA9PT0gdGxJdGVyYXRpb25EdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGNoaWxkLm9uQ29tcGxldGUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHRsLm9uTG9vcCgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgfVxuXG4gICAgZm9yRWFjaENoaWxkcmVuKHRsLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRUaW1lID0gcm91bmQoKHRsQ2hpbGRyZW5UaW1lIC0gY2hpbGQuX29mZnNldCkgKiBjaGlsZC5fc3BlZWQsIDEyKTsgLy8gUm91bmRpbmcgaXMgbmVlZGVkIHdoZW4gdXNpbmcgc2Vjb25kc1xuICAgICAgY29uc3QgY2hpbGRUaWNrTW9kZSA9IGNoaWxkLl9mcHMgPCB0bC5fZnBzID8gY2hpbGQucmVxdWVzdFRpY2sodGxDaWxkcmVuVGlja1RpbWUpIDogdGlja01vZGU7XG4gICAgICB0bENoaWxkcmVuSGFzUmVuZGVyZWQgKz0gcmVuZGVyKGNoaWxkLCBjaGlsZFRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCBjaGlsZFRpY2tNb2RlKTtcbiAgICAgIGlmICghY2hpbGQuY29tcGxldGVkICYmIHRsQ2hpbGRyZW5IYXZlQ29tcGxldGVkKSB0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0sIHRsSXNSdW5uaW5nQmFja3dhcmRzKTtcblxuICAgIC8vIFJlbmRlcnMgb24gdGltZWxpbmUgYXJlIHRyaWdnZXJlZCBieSBpdHMgY2hpbGRyZW4gc28gaXQgbmVlZHMgdG8gYmUgc2V0IGFmdGVyIHJlbmRlcmluZyB0aGUgY2hpbGRyZW5cbiAgICBpZiAoIW11dGVDYWxsYmFja3MgJiYgdGxDaGlsZHJlbkhhc1JlbmRlcmVkKSB0bC5vblJlbmRlcigvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG5cbiAgICAvLyBUcmlnZ2VycyB0aGUgdGltZWxpbmUgb25Db21wbGV0ZSgpIG9uY2UgYWxsIGNoaW5kcmVuIGFsbCBjb21wbGV0ZWQgYW5kIHRoZSBjdXJyZW50IHRpbWUgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmICh0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCAmJiB0bC5fY3VycmVudFRpbWUgPj0gdGwuZHVyYXRpb24pIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGF1c2VkIGZsYWcgaXMgZmFsc2UgaW4gY2FzZSBpdCBoYXMgYmVlbiBza2lwcGVkIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgIHRsLnBhdXNlZCA9IHRydWU7XG4gICAgICBpZiAoIXRsLmNvbXBsZXRlZCkge1xuICAgICAgICB0bC5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIW11dGVDYWxsYmFja3MpIHtcbiAgICAgICAgICB0bC5vbkNvbXBsZXRlKC8qKiBAdHlwZSB7Q2FsbGJhY2tBcmd1bWVudH0gKi8odGwpKTtcbiAgICAgICAgICB0bC5fcmVzb2x2ZSgvKiogQHR5cGUge0NhbGxiYWNrQXJndW1lbnR9ICovKHRsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cblxuXG5cbmNvbnN0IGFkZGl0aXZlID0ge1xuICBhbmltYXRpb246IG51bGwsXG4gIHVwZGF0ZTogbm9vcCxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgQWRkaXRpdmVBbmltYXRpb25cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkdXJhdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IF9vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBfZGVsYXlcbiAqIEBwcm9wZXJ0eSB7VHdlZW59IF9oZWFkXG4gKiBAcHJvcGVydHkge1R3ZWVufSBfdGFpbFxuICovXG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW5BZGRpdGl2ZUxvb2t1cHN9IGxvb2t1cHNcbiAqIEByZXR1cm4ge0FkZGl0aXZlQW5pbWF0aW9ufVxuICovXG5jb25zdCBhZGRBZGRpdGl2ZUFuaW1hdGlvbiA9IGxvb2t1cHMgPT4ge1xuICBsZXQgYW5pbWF0aW9uID0gYWRkaXRpdmUuYW5pbWF0aW9uO1xuICBpZiAoIWFuaW1hdGlvbikge1xuICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgIGR1cmF0aW9uOiBtaW5WYWx1ZSxcbiAgICAgIGNvbXB1dGVEZWx0YVRpbWU6IG5vb3AsXG4gICAgICBfb2Zmc2V0OiAwLFxuICAgICAgX2RlbGF5OiAwLFxuICAgICAgX2hlYWQ6IG51bGwsXG4gICAgICBfdGFpbDogbnVsbCxcbiAgICB9O1xuICAgIGFkZGl0aXZlLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICBhZGRpdGl2ZS51cGRhdGUgPSAoKSA9PiB7XG4gICAgICBsb29rdXBzLmZvckVhY2gocHJvcGVydHlBbmltYXRpb24gPT4ge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydHlBbmltYXRpb24pIHtcbiAgICAgICAgICBjb25zdCB0d2VlbnMgPSBwcm9wZXJ0eUFuaW1hdGlvbltwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIGNvbnN0IGxvb2t1cFR3ZWVuID0gdHdlZW5zLl9oZWFkO1xuICAgICAgICAgIGlmIChsb29rdXBUd2Vlbikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gbG9va3VwVHdlZW4uX3ZhbHVlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aXZlVmFsdWVzID0gdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTVBMRVggfHwgdmFsdWVUeXBlID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gY2xvbmVBcnJheShsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnMpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhZGRpdGl2ZVZhbHVlID0gbG9va3VwVHdlZW4uX2Zyb21OdW1iZXI7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0d2VlbnMuX3RhaWw7XG4gICAgICAgICAgICB3aGlsZSAodHdlZW4gJiYgdHdlZW4gIT09IGxvb2t1cFR3ZWVuKSB7XG4gICAgICAgICAgICAgIGlmIChhZGRpdGl2ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdHdlZW4uX251bWJlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSBhZGRpdGl2ZVZhbHVlc1tpXSArPSB0d2Vlbi5fbnVtYmVyc1tpXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRpdGl2ZVZhbHVlICs9IHR3ZWVuLl9udW1iZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHdlZW4gPSB0d2Vlbi5fcHJldkFkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb2t1cFR3ZWVuLl90b051bWJlciA9IGFkZGl0aXZlVmFsdWU7XG4gICAgICAgICAgICBsb29rdXBUd2Vlbi5fdG9OdW1iZXJzID0gYWRkaXRpdmVWYWx1ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIFRPRE86IEF2b2lkIHBvbHltb3JwaGlzbSBoZXJlLCBpZGVhbHkgdGhlIGFkZGl0aXZlIGFuaW1hdGlvbiBzaG91bGQgYmUgYSByZWd1bGFyIGFuaW1hdGlvbiB3aXRoIGEgaGlnaGVyIHByaW9yaXR5IGluIHRoZSByZW5kZXIgbG9vcFxuICAgICAgcmVuZGVyKGFuaW1hdGlvbiwgMSwgMSwgMCwgdGlja01vZGVzLkZPUkNFKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBhbmltYXRpb247XG59O1xuXG5jb25zdCBlbmdpbmVUaWNrTWV0aG9kID0gaXNCcm93c2VyID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0SW1tZWRpYXRlO1xuY29uc3QgZW5naW5lQ2FuY2VsTWV0aG9kID0gaXNCcm93c2VyID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhckltbWVkaWF0ZTtcblxuY2xhc3MgRW5naW5lIGV4dGVuZHMgQ2xvY2sge1xuXG4gIC8qKiBAcGFyYW0ge051bWJlcn0gW2luaXRUaW1lXSAqL1xuICBjb25zdHJ1Y3Rvcihpbml0VGltZSkge1xuICAgIHN1cGVyKGluaXRUaW1lKTtcbiAgICB0aGlzLnVzZURlZmF1bHRNYWluTG9vcCA9IHRydWU7XG4gICAgdGhpcy5wYXVzZU9uRG9jdW1lbnRIaWRkZW4gPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7RGVmYXVsdHNQYXJhbXN9ICovXG4gICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIHRoaXMucGF1c2VkID0gaXNCcm93c2VyICYmIGRvYy5oaWRkZW4gPyB0cnVlICA6IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfE5vZGVKUy5JbW1lZGlhdGV9ICovXG4gICAgdGhpcy5yZXFJZCA9IG51bGw7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMuX2N1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgaWYgKHRoaXMucmVxdWVzdFRpY2sodGltZSkpIHtcbiAgICAgIHRoaXMuY29tcHV0ZURlbHRhVGltZSh0aW1lKTtcbiAgICAgIGNvbnN0IGVuZ2luZVNwZWVkID0gdGhpcy5fc3BlZWQ7XG4gICAgICBjb25zdCBlbmdpbmVGcHMgPSB0aGlzLl9mcHM7XG4gICAgICBsZXQgYWN0aXZlVGlja2FibGUgPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aGlzLl9oZWFkKTtcbiAgICAgIHdoaWxlIChhY3RpdmVUaWNrYWJsZSkge1xuICAgICAgICBjb25zdCBuZXh0VGlja2FibGUgPSBhY3RpdmVUaWNrYWJsZS5fbmV4dDtcbiAgICAgICAgaWYgKCFhY3RpdmVUaWNrYWJsZS5wYXVzZWQpIHtcbiAgICAgICAgICB0aWNrKFxuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUsXG4gICAgICAgICAgICAodGltZSAtIGFjdGl2ZVRpY2thYmxlLl9zdGFydFRpbWUpICogYWN0aXZlVGlja2FibGUuX3NwZWVkICogZW5naW5lU3BlZWQsXG4gICAgICAgICAgICAwLCAvLyAhbXV0ZUNhbGxiYWNrc1xuICAgICAgICAgICAgMCwgLy8gIWludGVybmFsUmVuZGVyXG4gICAgICAgICAgICBhY3RpdmVUaWNrYWJsZS5fZnBzIDwgZW5naW5lRnBzID8gYWN0aXZlVGlja2FibGUucmVxdWVzdFRpY2sodGltZSkgOiB0aWNrTW9kZXMuQVVUT1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQodGhpcywgYWN0aXZlVGlja2FibGUpO1xuICAgICAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gISF0aGlzLl90YWlsO1xuICAgICAgICAgIGFjdGl2ZVRpY2thYmxlLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGFjdGl2ZVRpY2thYmxlLmNvbXBsZXRlZCAmJiAhYWN0aXZlVGlja2FibGUuX2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgYWN0aXZlVGlja2FibGUuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVRpY2thYmxlID0gbmV4dFRpY2thYmxlO1xuICAgICAgfVxuICAgICAgYWRkaXRpdmUudXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgd2FrZSgpIHtcbiAgICBpZiAodGhpcy51c2VEZWZhdWx0TWFpbkxvb3AgJiYgIXRoaXMucmVxSWQgJiYgIXRoaXMucGF1c2VkKSB7XG4gICAgICB0aGlzLnJlcUlkID0gZW5naW5lVGlja01ldGhvZCh0aWNrRW5naW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIGtpbGxFbmdpbmUoKTtcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoIXRoaXMucGF1c2VkKSByZXR1cm47XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VGlja2FibGV9ICovY2hpbGQpID0+IGNoaWxkLnJlc2V0VGltZSgpKTtcbiAgICByZXR1cm4gdGhpcy53YWtlKCk7XG4gIH1cblxuICAvLyBHZXR0ZXIgYW5kIHNldHRlciBmb3Igc3BlZWRcbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zcGVlZCAqIChnbG9iYWxzLnRpbWVTY2FsZSA9PT0gMSA/IDEgOiBLKTtcbiAgfVxuXG4gIHNldCBzcGVlZChwbGF5YmFja1JhdGUpIHtcbiAgICB0aGlzLl9zcGVlZCA9IHBsYXliYWNrUmF0ZSAqIGdsb2JhbHMudGltZVNjYWxlO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi9jaGlsZCkgPT4gY2hpbGQuc3BlZWQgPSBjaGlsZC5fc3BlZWQpO1xuICB9XG5cbiAgLy8gR2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHRpbWVVbml0XG4gIGdldCB0aW1lVW5pdCgpIHtcbiAgICByZXR1cm4gZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAnbXMnIDogJ3MnO1xuICB9O1xuXG4gIHNldCB0aW1lVW5pdCh1bml0KSB7XG4gICAgY29uc3Qgc2Vjb25kc1NjYWxlID0gMC4wMDE7XG4gICAgY29uc3QgaXNTZWNvbmQgPSB1bml0ID09PSAncyc7XG4gICAgY29uc3QgbmV3U2NhbGUgPSBpc1NlY29uZCA/IHNlY29uZHNTY2FsZSA6IDE7XG4gICAgaWYgKGdsb2JhbHMudGltZVNjYWxlICE9PSBuZXdTY2FsZSkge1xuICAgICAgZ2xvYmFscy50aW1lU2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgIGdsb2JhbHMudGlja1RocmVzaG9sZCA9IDIwMCAqIG5ld1NjYWxlO1xuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpc1NlY29uZCA/IHNlY29uZHNTY2FsZSA6IEs7XG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgICh0aGlzLmRlZmF1bHRzLmR1cmF0aW9uKSAqPSBzY2FsZUZhY3RvcjtcbiAgICAgIHRoaXMuX3NwZWVkICo9IHNjYWxlRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlciBhbmQgc2V0dGVyIGZvciBwcmVjaXNpb25cbiAgZ2V0IHByZWNpc2lvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFscy5wcmVjaXNpb247XG4gIH1cblxuICBzZXQgcHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIGdsb2JhbHMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB9XG5cbn1cbmNvbnN0IGVuZ2luZSA9IC8qI19fUFVSRV9fKi8oKCkgPT4ge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgRW5naW5lKG5vdygpKTtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIGdsb2JhbFZlcnNpb25zLmVuZ2luZSA9IGVuZ2luZTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmICghZW5naW5lLnBhdXNlT25Eb2N1bWVudEhpZGRlbikgcmV0dXJuO1xuICAgICAgZG9jLmhpZGRlbiA/IGVuZ2luZS5wYXVzZSgpIDogZW5naW5lLnJlc3VtZSgpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmdpbmU7XG59KSgpO1xuXG5cbmNvbnN0IHRpY2tFbmdpbmUgPSAoKSA9PiB7XG4gIGlmIChlbmdpbmUuX2hlYWQpIHtcbiAgICBlbmdpbmUucmVxSWQgPSBlbmdpbmVUaWNrTWV0aG9kKHRpY2tFbmdpbmUpO1xuICAgIGVuZ2luZS51cGRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBlbmdpbmUucmVxSWQgPSAwO1xuICB9XG59O1xuXG5jb25zdCBraWxsRW5naW5lID0gKCkgPT4ge1xuICBlbmdpbmVDYW5jZWxNZXRob2QoLyoqIEB0eXBlIHtOb2RlSlMuSW1tZWRpYXRlICYgTnVtYmVyfSAqLyhlbmdpbmUucmVxSWQpKTtcbiAgZW5naW5lLnJlcUlkID0gMDtcbiAgcmV0dXJuIGVuZ2luZTtcbn07XG5cblxuXG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlSW5saW5lVHJhbnNmb3JtcyA9ICh0YXJnZXQsIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpID0+IHtcbiAgY29uc3QgaW5saW5lVHJhbnNmb3JtcyA9IHRhcmdldC5zdHlsZS50cmFuc2Zvcm07XG4gIGxldCBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZTtcbiAgaWYgKGlubGluZVRyYW5zZm9ybXMpIHtcbiAgICBjb25zdCBjYWNoZWRUcmFuc2Zvcm1zID0gdGFyZ2V0W3RyYW5zZm9ybXNTeW1ib2xdO1xuICAgIGxldCB0OyB3aGlsZSAodCA9IHRyYW5zZm9ybXNFeGVjUmd4LmV4ZWMoaW5saW5lVHJhbnNmb3JtcykpIHtcbiAgICAgIGNvbnN0IGlubGluZVByb3BlcnR5TmFtZSA9IHRbMV07XG4gICAgICAvLyBjb25zdCBpbmxpbmVQcm9wZXJ0eVZhbHVlID0gdFsyXTtcbiAgICAgIGNvbnN0IGlubGluZVByb3BlcnR5VmFsdWUgPSB0WzJdLnNsaWNlKDEsIC0xKTtcbiAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5saW5lUHJvcGVydHlOYW1lXSA9IGlubGluZVByb3BlcnR5VmFsdWU7XG4gICAgICBpZiAoaW5saW5lUHJvcGVydHlOYW1lID09PSBwcm9wTmFtZSkge1xuICAgICAgICBpbmxpbmVkU3R5bGVzUHJvcGVydHlWYWx1ZSA9IGlubGluZVByb3BlcnR5VmFsdWU7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBuZXcgcGFyc2VkIGlubGluZSBzdHlsZXMgaWYgYW5pbWF0aW9uSW5saW5lU3R5bGVzIGlzIHByb3ZpZGVkXG4gICAgICAgIGlmIChhbmltYXRpb25JbmxpbmVTdHlsZXMpIHtcbiAgICAgICAgICBhbmltYXRpb25JbmxpbmVTdHlsZXNbcHJvcE5hbWVdID0gaW5saW5lUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5saW5lVHJhbnNmb3JtcyAmJiAhaXNVbmQoaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUpID8gaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUgOlxuICAgIHN0cmluZ1N0YXJ0c1dpdGgocHJvcE5hbWUsICdzY2FsZScpID8gJzEnIDpcbiAgICBzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSA/ICcwZGVnJyA6ICcwcHgnO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW18VGFyZ2V0c1BhcmFtfSB2XG4gKiBAcmV0dXJuIHtOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUxpc3Qodikge1xuICBjb25zdCBuID0gaXNTdHIodikgPyBnbG9iYWxzLnJvb3QucXVlcnlTZWxlY3RvckFsbCh2KSA6IHY7XG4gIGlmIChuIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbiBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7RE9NVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7SlNUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge0pTVGFyZ2V0c0FycmF5fVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtUYXJnZXRzQXJyYXl9XG4gKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfEpTVGFyZ2V0c1BhcmFtfFRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBwYXJzZVRhcmdldHModGFyZ2V0cykge1xuICBpZiAoaXNOaWwodGFyZ2V0cykpIHJldHVybiAvKiogQHR5cGUge1RhcmdldHNBcnJheX0gKi8oW10pO1xuICBpZiAoaXNBcnIodGFyZ2V0cykpIHtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSB0YXJnZXRzLmZsYXQoSW5maW5pdHkpO1xuICAgIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqL1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZmxhdHRlbmVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGZsYXR0ZW5lZFtpXTtcbiAgICAgIGlmICghaXNOaWwoaXRlbSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZUxpc3QgPSBnZXROb2RlTGlzdChpdGVtKTtcbiAgICAgICAgaWYgKG5vZGVMaXN0KSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpsID0gbm9kZUxpc3QubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViSXRlbSA9IG5vZGVMaXN0W2pdO1xuICAgICAgICAgICAgaWYgKCFpc05pbChzdWJJdGVtKSkge1xuICAgICAgICAgICAgICBsZXQgaXNEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDAsIGtsID0gcGFyc2VkLmxlbmd0aDsgayA8IGtsOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkW2tdID09PSBzdWJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICBpc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHN1Ykl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpc0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHBhcnNlZC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkW2pdID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgIGlzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGlmICghaXNCcm93c2VyKSByZXR1cm4gLyoqIEB0eXBlIHtKU1RhcmdldHNBcnJheX0gKi8oW3RhcmdldHNdKTtcbiAgY29uc3Qgbm9kZUxpc3QgPSBnZXROb2RlTGlzdCh0YXJnZXRzKTtcbiAgaWYgKG5vZGVMaXN0KSByZXR1cm4gLyoqIEB0eXBlIHtET01UYXJnZXRzQXJyYXl9ICovKEFycmF5LmZyb20obm9kZUxpc3QpKTtcbiAgcmV0dXJuIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqLyhbdGFyZ2V0c10pO1xufVxuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcmV0dXJuIHtET01UYXJnZXRzQXJyYXl9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtKU1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHJldHVybiB7SlNUYXJnZXRzQXJyYXl9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEByZXR1cm4ge1RhcmdldHNBcnJheX1cbiAqXG4gKiBAcGFyYW0gIHtET01UYXJnZXRzUGFyYW18SlNUYXJnZXRzUGFyYW18VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIGNvbnN0IHBhcnNlZFRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyc2VkVGFyZ2V0c0xlbmd0aCA9IHBhcnNlZFRhcmdldHNBcnJheS5sZW5ndGg7XG4gIGlmIChwYXJzZWRUYXJnZXRzTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRUYXJnZXRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHBhcnNlZFRhcmdldHNBcnJheVtpXTtcbiAgICAgIGlmICghdGFyZ2V0W2lzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbF0pIHtcbiAgICAgICAgdGFyZ2V0W2lzUmVnaXN0ZXJlZFRhcmdldFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1N2Z1R5cGUgPSBpc1N2Zyh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpc0RvbSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLm5vZGVUeXBlIHx8IGlzU3ZnVHlwZTtcbiAgICAgICAgaWYgKGlzRG9tKSB7XG4gICAgICAgICAgdGFyZ2V0W2lzRG9tU3ltYm9sXSA9IHRydWU7XG4gICAgICAgICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSA9IGlzU3ZnVHlwZTtcbiAgICAgICAgICB0YXJnZXRbdHJhbnNmb3Jtc1N5bWJvbF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkVGFyZ2V0c0FycmF5O1xufVxuXG5cblxuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gcGF0aFxuICogQHJldHVybiB7U1ZHR2VvbWV0cnlFbGVtZW50fHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgZ2V0UGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcGFyc2VUYXJnZXRzKHBhdGgpO1xuICBjb25zdCAkcGFyc2VkU3ZnID0gLyoqIEB0eXBlIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICovKHBhcnNlZFRhcmdldHNbMF0pO1xuICBpZiAoISRwYXJzZWRTdmcgfHwgIWlzU3ZnKCRwYXJzZWRTdmcpKSByZXR1cm47XG4gIHJldHVybiAkcGFyc2VkU3ZnO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHBhdGgyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dXG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBtb3JwaFRvID0gKHBhdGgyLCBwcmVjaXNpb24gPSAuMzMpID0+ICgkcGF0aDEpID0+IHtcbiAgY29uc3QgJHBhdGgyID0gLyoqIEB0eXBlIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICovKGdldFBhdGgocGF0aDIpKTtcbiAgaWYgKCEkcGF0aDIpIHJldHVybjtcbiAgY29uc3QgaXNQYXRoID0gJHBhdGgxLnRhZ05hbWUgPT09ICdwYXRoJztcbiAgY29uc3Qgc2VwYXJhdG9yID0gaXNQYXRoID8gJyAnIDogJywnO1xuICBjb25zdCBwcmV2aW91c1BvaW50cyA9ICRwYXRoMVttb3JwaFBvaW50c1N5bWJvbF07XG4gIGlmIChwcmV2aW91c1BvaW50cykgJHBhdGgxLnNldEF0dHJpYnV0ZShpc1BhdGggPyAnZCcgOiAncG9pbnRzJywgcHJldmlvdXNQb2ludHMpO1xuXG4gIGxldCB2MSA9ICcnLCB2MiA9ICcnO1xuXG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdjEgPSAkcGF0aDEuZ2V0QXR0cmlidXRlKGlzUGF0aCA/ICdkJyA6ICdwb2ludHMnKTtcbiAgICB2MiA9ICRwYXRoMi5nZXRBdHRyaWJ1dGUoaXNQYXRoID8gJ2QnIDogJ3BvaW50cycpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlbmd0aDEgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJHBhdGgxKS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGNvbnN0IGxlbmd0aDIgPSAkcGF0aDIuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBjb25zdCBtYXhQb2ludHMgPSBNYXRoLm1heChNYXRoLmNlaWwobGVuZ3RoMSAqIHByZWNpc2lvbiksIE1hdGguY2VpbChsZW5ndGgyICogcHJlY2lzaW9uKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhQb2ludHM7IGkrKykge1xuICAgICAgY29uc3QgdCA9IGkgLyAobWF4UG9pbnRzIC0gMSk7XG4gICAgICBjb25zdCBwb2ludE9uUGF0aDEgPSAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJHBhdGgxKS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aDEgKiB0KTtcbiAgICAgIGNvbnN0IHBvaW50T25QYXRoMiA9ICRwYXRoMi5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aDIgKiB0KTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGlzUGF0aCA/IChpID09PSAwID8gJ00nIDogJ0wnKSA6ICcnO1xuICAgICAgdjEgKz0gcHJlZml4ICsgcm91bmQocG9pbnRPblBhdGgxLngsIDMpICsgc2VwYXJhdG9yICsgcG9pbnRPblBhdGgxLnkgKyAnICc7XG4gICAgICB2MiArPSBwcmVmaXggKyByb3VuZChwb2ludE9uUGF0aDIueCwgMykgKyBzZXBhcmF0b3IgKyBwb2ludE9uUGF0aDIueSArICcgJztcbiAgICB9XG4gIH1cblxuICAkcGF0aDFbbW9ycGhQb2ludHNTeW1ib2xdID0gdjI7XG5cbiAgcmV0dXJuIFt2MSwgdjJdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gWyRlbF1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0U2NhbGVGYWN0b3IgPSAkZWwgPT4ge1xuICBsZXQgc2NhbGVGYWN0b3IgPSAxO1xuICBpZiAoJGVsICYmICRlbC5nZXRDVE0pIHtcbiAgICBjb25zdCBjdG0gPSAkZWwuZ2V0Q1RNKCk7XG4gICAgaWYgKGN0bSkge1xuICAgICAgY29uc3Qgc2NhbGVYID0gc3FydChjdG0uYSAqIGN0bS5hICsgY3RtLmIgKiBjdG0uYik7XG4gICAgICBjb25zdCBzY2FsZVkgPSBzcXJ0KGN0bS5jICogY3RtLmMgKyBjdG0uZCAqIGN0bS5kKTtcbiAgICAgIHNjYWxlRmFjdG9yID0gKHNjYWxlWCArIHNjYWxlWSkgLyAyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NhbGVGYWN0b3I7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSB0aGF0IHdyYXBzIGFuIFNWR0dlb21ldHJ5RWxlbWVudCBhbmQgYWRkcyBkcmF3aW5nIGZ1bmN0aW9uYWxpdHkuXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJGVsIC0gVGhlIFNWRyBlbGVtZW50IHRvIHRyYW5zZm9ybSBpbnRvIGEgZHJhd2FibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIFN0YXJ0aW5nIHBvc2l0aW9uICgwLTEpXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gRW5kaW5nIHBvc2l0aW9uICgwLTEpXG4gKiBAcmV0dXJuIHtEcmF3YWJsZVNWR0dlb21ldHJ5fSAtIFJldHVybnMgYSBwcm94eSB0aGF0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgZWxlbWVudCdzIHR5cGUgd2l0aCBhZGRpdGlvbmFsICdkcmF3JyBhdHRyaWJ1dGUgZnVuY3Rpb25hbGl0eVxuICovXG5jb25zdCBjcmVhdGVEcmF3YWJsZVByb3h5ID0gKCRlbCwgc3RhcnQsIGVuZCkgPT4ge1xuICBjb25zdCBwYXRoTGVuZ3RoID0gSztcbiAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKCRlbCk7XG4gIGNvbnN0IHN0cm9rZUxpbmVDYXAgPSBjb21wdXRlZFN0eWxlcy5zdHJva2VMaW5lY2FwO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0ICRzY2FsbGVkID0gY29tcHV0ZWRTdHlsZXMudmVjdG9yRWZmZWN0ID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJyA/ICRlbCA6IG51bGw7XG4gIGxldCBjdXJyZW50Q2FwID0gc3Ryb2tlTGluZUNhcDtcblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSgkZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgaWYgKHByb3BlcnR5ID09PSBwcm94eVRhcmdldFN5bWJvbCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3NldEF0dHJpYnV0ZScpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGFyZ3NbMF0gPT09ICdkcmF3Jykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IHYxID0gK3ZhbHVlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gK3ZhbHVlc1sxXTtcbiAgICAgICAgICAgIC8vIFRPVE86IEJlbmNobWFyayBpZiBwZXJmb3JtaW5nIHR3byBzbGljZXMgaXMgbW9yZSBwZXJmb3JtYW50IHRoYW4gb25lIHNwbGl0XG4gICAgICAgICAgICAvLyBjb25zdCBzcGFjZUluZGV4ID0gdmFsdWUuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgLy8gY29uc3QgdjEgPSByb3VuZCgrdmFsdWUuc2xpY2UoMCwgc3BhY2VJbmRleCksIHByZWNpc2lvbik7XG4gICAgICAgICAgICAvLyBjb25zdCB2MiA9IHJvdW5kKCt2YWx1ZS5zbGljZShzcGFjZUluZGV4ICsgMSksIHByZWNpc2lvbik7XG4gICAgICAgICAgICBjb25zdCBzY2FsZUZhY3RvciA9IGdldFNjYWxlRmFjdG9yKCRzY2FsbGVkKTtcbiAgICAgICAgICAgIGNvbnN0IG9zID0gdjEgKiAtMWUzICogc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBjb25zdCBkMSA9ICh2MiAqIHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvcikgKyBvcztcbiAgICAgICAgICAgIGNvbnN0IGQyID0gKHBhdGhMZW5ndGggKiBzY2FsZUZhY3RvciArXG4gICAgICAgICAgICAgICAgICAgICAgKCh2MSA9PT0gMCAmJiB2MiA9PT0gMSkgfHwgKHYxID09PSAxICYmIHYyID09PSAwKSA/IDAgOiAxMCAqIHNjYWxlRmFjdG9yKSAtIGQxKTtcbiAgICAgICAgICAgIGlmIChzdHJva2VMaW5lQ2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FwID0gdjEgPT09IHYyID8gJ2J1dHQnIDogc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYXAgIT09IG5ld0NhcCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zdHJva2VMaW5lY2FwID0gYCR7bmV3Q2FwfWA7XG4gICAgICAgICAgICAgICAgY3VycmVudENhcCA9IG5ld0NhcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBgJHtvc31gKTtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBgJHtkMX0gJHtkMn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodmFsdWUsIHRhcmdldCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBSZWZsZWN0LmFwcGx5KHZhbHVlLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCRlbC5nZXRBdHRyaWJ1dGUoJ3BhdGhMZW5ndGgnKSAhPT0gYCR7cGF0aExlbmd0aH1gKSB7XG4gICAgJGVsLnNldEF0dHJpYnV0ZSgncGF0aExlbmd0aCcsIGAke3BhdGhMZW5ndGh9YCk7XG4gICAgcHJveHkuc2V0QXR0cmlidXRlKCdkcmF3JywgYCR7c3RhcnR9ICR7ZW5kfWApO1xuICB9XG5cbiAgcmV0dXJuIC8qKiBAdHlwZSB7RHJhd2FibGVTVkdHZW9tZXRyeX0gKi8ocHJveHkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGRyYXdhYmxlIHByb3hpZXMgZm9yIG11bHRpcGxlIFNWRyBlbGVtZW50cy5cbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSBzZWxlY3RvciAtIENTUyBzZWxlY3RvciwgU1ZHIGVsZW1lbnQsIG9yIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydGluZyBwb3NpdGlvbiAoMC0xKVxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9MF0gLSBFbmRpbmcgcG9zaXRpb24gKDAtMSlcbiAqIEByZXR1cm4ge0FycmF5PERyYXdhYmxlU1ZHR2VvbWV0cnk+fSAtIEFycmF5IG9mIHByb3hpZWQgZWxlbWVudHMgd2l0aCBkcmF3aW5nIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgY3JlYXRlRHJhd2FibGUgPSAoc2VsZWN0b3IsIHN0YXJ0ID0gMCwgZW5kID0gMCkgPT4ge1xuICBjb25zdCBlbHMgPSBwYXJzZVRhcmdldHMoc2VsZWN0b3IpO1xuICByZXR1cm4gZWxzLm1hcCgkZWwgPT4gY3JlYXRlRHJhd2FibGVQcm94eShcbiAgICAvKiogQHR5cGUge1NWR0dlb21ldHJ5RWxlbWVudH0gKi8oJGVsKSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSk7XG59O1xuXG4vLyBNb3Rpb24gcGF0aCBhbmltYXRpb25cblxuLyoqXG4gKiBAcGFyYW0ge1NWR0dlb21ldHJ5RWxlbWVudH0gJHBhdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9bG9va3VwXG4gKiBAcmV0dXJuIHtET01Qb2ludH1cbiAqL1xuY29uc3QgZ2V0UGF0aFBvaW50ID0gKCRwYXRoLCBwcm9ncmVzcywgbG9va3VwID0gMCkgPT4ge1xuICByZXR1cm4gJHBhdGguZ2V0UG9pbnRBdExlbmd0aChwcm9ncmVzcyArIGxvb2t1cCA+PSAxID8gcHJvZ3Jlc3MgKyBsb29rdXAgOiAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTVkdHZW9tZXRyeUVsZW1lbnR9ICRwYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFByb3BlcnR5XG4gKiBAcmV0dXJuIHtGdW5jdGlvblZhbHVlfVxuICovXG5jb25zdCBnZXRQYXRoUHJvZ2VzcyA9ICgkcGF0aCwgcGF0aFByb3BlcnR5KSA9PiB7XG4gIHJldHVybiAkZWwgPT4ge1xuICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gKygkcGF0aC5nZXRUb3RhbExlbmd0aCgpKTtcbiAgICBjb25zdCBpblN2ZyA9ICRlbFtpc1N2Z1N5bWJvbF07XG4gICAgY29uc3QgY3RtID0gJHBhdGguZ2V0Q1RNKCk7XG4gICAgLyoqIEB0eXBlIHtUd2Vlbk9iamVjdFZhbHVlfSAqL1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IHRvdGFsTGVuZ3RoLFxuICAgICAgLyoqIEB0eXBlIHtUd2Vlbk1vZGlmaWVyfSAqL1xuICAgICAgbW9kaWZpZXI6IHByb2dyZXNzID0+IHtcbiAgICAgICAgaWYgKHBhdGhQcm9wZXJ0eSA9PT0gJ2EnKSB7XG4gICAgICAgICAgY29uc3QgcDAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAtMSk7XG4gICAgICAgICAgY29uc3QgcDEgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAxKTtcbiAgICAgICAgICByZXR1cm4gYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSAqIDE4MCAvIFBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHAgPSBnZXRQYXRoUG9pbnQoJHBhdGgsIHByb2dyZXNzLCAwKTtcbiAgICAgICAgICByZXR1cm4gcGF0aFByb3BlcnR5ID09PSAneCcgP1xuICAgICAgICAgICAgaW5TdmcgfHwgIWN0bSA/IHAueCA6IHAueCAqIGN0bS5hICsgcC55ICogY3RtLmMgKyBjdG0uZSA6XG4gICAgICAgICAgICBpblN2ZyB8fCAhY3RtID8gcC55IDogcC54ICogY3RtLmIgKyBwLnkgKiBjdG0uZCArIGN0bS5mXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHBhdGhcbiAqL1xuY29uc3QgY3JlYXRlTW90aW9uUGF0aCA9IHBhdGggPT4ge1xuICBjb25zdCAkcGF0aCA9IGdldFBhdGgocGF0aCk7XG4gIGlmICghJHBhdGgpIHJldHVybjtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3gnKSxcbiAgICB0cmFuc2xhdGVZOiBnZXRQYXRoUHJvZ2VzcygkcGF0aCwgJ3knKSxcbiAgICByb3RhdGU6IGdldFBhdGhQcm9nZXNzKCRwYXRoLCAnYScpLFxuICB9XG59O1xuXG4vLyBDaGVjayBmb3IgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuXG5jb25zdCBjc3NSZXNlcnZlZFByb3BlcnRpZXMgPSBbJ29wYWNpdHknLCAncm90YXRlJywgJ292ZXJmbG93JywgJ2NvbG9yJ107XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSBlbFxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRTVkdBdHRyaWJ1dGUgPSAoZWwsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAvLyBSZXR1cm4gZWFybHkgYW5kIHVzZSBDU1Mgb3BhY2l0eSBhbmltYXRpb24gaW5zdGVhZCAoYWxyZWFkeSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZXMgKG9wYWNpdHk6IDEgaW5zdGVhZCBvZiAwKSkgYW5kIHJvdGF0ZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHRyYW5zZm9ybVxuICBpZiAoY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3BlcnR5TmFtZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eU5hbWUpIHx8IHByb3BlcnR5TmFtZSBpbiBlbCkge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdzY2FsZScpIHsgLy8gU2NhbGVcbiAgICAgIGNvbnN0IGVsUGFyZW50Tm9kZSA9IC8qKiBAdHlwZSB7U1ZHR2VvbWV0cnlFbGVtZW50fSAqLygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oZWwpLnBhcmVudE5vZGUpO1xuICAgICAgLy8gT25seSBjb25zaWRlciBzY2FsZSBhcyBhIHZhbGlkIFNWRyBhdHRyaWJ1dGUgb24gZmlsdGVyIGVsZW1lbnRcbiAgICAgIHJldHVybiBlbFBhcmVudE5vZGUgJiYgZWxQYXJlbnROb2RlLnRhZ05hbWUgPT09ICdmaWx0ZXInO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3Qgc3ZnID0ge1xuICBtb3JwaFRvLFxuICBjcmVhdGVNb3Rpb25QYXRoLFxuICBjcmVhdGVEcmF3YWJsZSxcbn07XG5cblxuXG5cbi8qKlxuICogUkdCIC8gUkdCQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gcmdiVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IHJnYlRvUmdiYSA9IHJnYlZhbHVlID0+IHtcbiAgY29uc3QgcmdiYSA9IHJnYkV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSkgfHwgcmdiYUV4ZWNSZ3guZXhlYyhyZ2JWYWx1ZSk7XG4gIGNvbnN0IGEgPSAhaXNVbmQocmdiYVs0XSkgPyArcmdiYVs0XSA6IDE7XG4gIHJldHVybiBbXG4gICAgK3JnYmFbMV0sXG4gICAgK3JnYmFbMl0sXG4gICAgK3JnYmFbM10sXG4gICAgYVxuICBdXG59O1xuXG4vKipcbiAqIEhFWDMgLyBIRVgzQSAvIEhFWDYgLyBIRVg2QSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaGV4VmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhleFRvUmdiYSA9IGhleFZhbHVlID0+IHtcbiAgY29uc3QgaGV4TGVuZ3RoID0gaGV4VmFsdWUubGVuZ3RoO1xuICBjb25zdCBpc1Nob3J0ID0gaGV4TGVuZ3RoID09PSA0IHx8IGhleExlbmd0aCA9PT0gNTtcbiAgcmV0dXJuIFtcbiAgICArKCcweCcgKyBoZXhWYWx1ZVsxXSArIGhleFZhbHVlW2lzU2hvcnQgPyAxIDogMl0pLFxuICAgICsoJzB4JyArIGhleFZhbHVlW2lzU2hvcnQgPyAyIDogM10gKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMiA6IDRdKSxcbiAgICArKCcweCcgKyBoZXhWYWx1ZVtpc1Nob3J0ID8gMyA6IDVdICsgaGV4VmFsdWVbaXNTaG9ydCA/IDMgOiA2XSksXG4gICAgKChoZXhMZW5ndGggPT09IDUgfHwgaGV4TGVuZ3RoID09PSA5KSA/ICsoKygnMHgnICsgaGV4VmFsdWVbaXNTaG9ydCA/IDQgOiA3XSArIGhleFZhbHVlW2lzU2hvcnQgPyA0IDogOF0pIC8gMjU1KS50b0ZpeGVkKDMpIDogMSlcbiAgXVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBcbiAqIEBwYXJhbSAge051bWJlcn0gcVxuICogQHBhcmFtICB7TnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGh1ZTJyZ2IgPSAocCwgcSwgdCkgPT4ge1xuICBpZiAodCA8IDApIHQgKz0gMTtcbiAgaWYgKHQgPiAxKSB0IC09IDE7XG4gIHJldHVybiB0IDwgMSAvIDYgPyBwICsgKHEgLSBwKSAqIDYgKiB0IDpcbiAgICAgICAgIHQgPCAxIC8gMiA/IHEgOlxuICAgICAgICAgdCA8IDIgLyAzID8gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDYgOlxuICAgICAgICAgcDtcbn07XG5cbi8qKlxuICogSFNMIC8gSFNMQSBDb2xvciB2YWx1ZSBzdHJpbmcgLT4gUkdCQSB2YWx1ZXMgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gaHNsVmFsdWVcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGhzbFRvUmdiYSA9IGhzbFZhbHVlID0+IHtcbiAgY29uc3QgaHNsYSA9IGhzbEV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSkgfHwgaHNsYUV4ZWNSZ3guZXhlYyhoc2xWYWx1ZSk7XG4gIGNvbnN0IGggPSAraHNsYVsxXSAvIDM2MDtcbiAgY29uc3QgcyA9ICtoc2xhWzJdIC8gMTAwO1xuICBjb25zdCBsID0gK2hzbGFbM10gLyAxMDA7XG4gIGNvbnN0IGEgPSAhaXNVbmQoaHNsYVs0XSkgPyAraHNsYVs0XSA6IDE7XG4gIGxldCByLCBnLCBiO1xuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcSA9IGwgPCAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSByb3VuZChodWUycmdiKHAsIHEsIGggKyAxIC8gMykgKiAyNTUsIDApO1xuICAgIGcgPSByb3VuZChodWUycmdiKHAsIHEsIGgpICogMjU1LCAwKTtcbiAgICBiID0gcm91bmQoaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpICogMjU1LCAwKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufTtcblxuLyoqXG4gKiBBbGwgaW4gb25lIGNvbG9yIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIGEgY29sb3Igc3RyaW5nIHZhbHVlIGludG8gYW4gYXJyYXkgb2YgUkdCQSB2YWx1ZXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sb3JTdHJpbmdcbiAqIEByZXR1cm4ge0NvbG9yQXJyYXl9XG4gKi9cbmNvbnN0IGNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5ID0gY29sb3JTdHJpbmcgPT4ge1xuICByZXR1cm4gaXNSZ2IoY29sb3JTdHJpbmcpID8gcmdiVG9SZ2JhKGNvbG9yU3RyaW5nKSA6XG4gICAgICAgICBpc0hleChjb2xvclN0cmluZykgPyBoZXhUb1JnYmEoY29sb3JTdHJpbmcpIDpcbiAgICAgICAgIGlzSHNsKGNvbG9yU3RyaW5nKSA/IGhzbFRvUmdiYShjb2xvclN0cmluZykgOlxuICAgICAgICAgWzAsIDAsIDAsIDFdO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCwgRFxuICogQHBhcmFtIHtUfHVuZGVmaW5lZH0gdGFyZ2V0VmFsdWVcbiAqIEBwYXJhbSB7RH0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJuIHtUfER9XG4gKi9cbmNvbnN0IHNldFZhbHVlID0gKHRhcmdldFZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzVW5kKHRhcmdldFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHRhcmdldFZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2VlblByb3BWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtzdG9yZV1cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgZ2V0RnVuY3Rpb25WYWx1ZSA9ICh2YWx1ZSwgdGFyZ2V0LCBpbmRleCwgdG90YWwsIHN0b3JlKSA9PiB7XG4gIGlmIChpc0ZuYyh2YWx1ZSkpIHtcbiAgICBjb25zdCBmdW5jID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkodGFyZ2V0LCBpbmRleCwgdG90YWwpO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gMCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB1bmRlZmluZWQgLyBOYU4gLyBudWxsIC8gZmFsc2UgLyAwXG4gICAgICByZXR1cm4gIWlzTmFOKCtjb21wdXRlZCkgPyArY29tcHV0ZWQgOiBjb21wdXRlZCB8fCAwO1xuICAgIH07XG4gICAgaWYgKHN0b3JlKSB7XG4gICAgICBzdG9yZS5mdW5jID0gZnVuYztcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7dHdlZW5UeXBlc31cbiAqL1xuY29uc3QgZ2V0VHdlZW5UeXBlID0gKHRhcmdldCwgcHJvcCkgPT4ge1xuICByZXR1cm4gIXRhcmdldFtpc0RvbVN5bWJvbF0gPyB0d2VlblR5cGVzLk9CSkVDVCA6XG4gICAgLy8gSGFuZGxlIFNWRyBhdHRyaWJ1dGVzXG4gICAgdGFyZ2V0W2lzU3ZnU3ltYm9sXSAmJiBpc1ZhbGlkU1ZHQXR0cmlidXRlKHRhcmdldCwgcHJvcCkgPyB0d2VlblR5cGVzLkFUVFJJQlVURSA6XG4gICAgLy8gSGFuZGxlIENTUyBUcmFuc2Zvcm0gcHJvcGVydGllcyBkaWZmZXJlbnRseSB0aGFuIENTUyB0byBhbGxvdyBpbmRpdmlkdWFsIGFuaW1hdGlvbnNcbiAgICB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMocHJvcCkgfHwgc2hvcnRUcmFuc2Zvcm1zLmdldChwcm9wKSA/IHR3ZWVuVHlwZXMuVFJBTlNGT1JNIDpcbiAgICAvLyBDU1MgdmFyaWFibGVzXG4gICAgc3RyaW5nU3RhcnRzV2l0aChwcm9wLCAnLS0nKSA/IHR3ZWVuVHlwZXMuQ1NTX1ZBUiA6XG4gICAgLy8gQWxsIG90aGVyIENTUyBwcm9wZXJ0aWVzXG4gICAgcHJvcCBpbiAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KS5zdHlsZSA/IHR3ZWVuVHlwZXMuQ1NTIDpcbiAgICAvLyBIYW5kbGUgb3RoZXIgRE9NIEF0dHJpYnV0ZXNcbiAgICBwcm9wIGluIHRhcmdldCA/IHR3ZWVuVHlwZXMuT0JKRUNUIDpcbiAgICB0d2VlblR5cGVzLkFUVFJJQlVURTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYW5pbWF0aW9uSW5saW5lU3R5bGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGdldENTU1ZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgPT4ge1xuICBjb25zdCBpbmxpbmVTdHlsZXMgPSB0YXJnZXQuc3R5bGVbcHJvcE5hbWVdO1xuICBpZiAoaW5saW5lU3R5bGVzICYmIGFuaW1hdGlvbklubGluZVN0eWxlcykge1xuICAgIGFuaW1hdGlvbklubGluZVN0eWxlc1twcm9wTmFtZV0gPSBpbmxpbmVTdHlsZXM7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBpbmxpbmVTdHlsZXMgfHwgZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRbcHJveHlUYXJnZXRTeW1ib2xdIHx8IHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gIHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gJzAnIDogdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHt0d2VlblR5cGVzfSBbdHdlZW5UeXBlXVxuICogQHBhcmFtIHtPYmplY3R8dm9pZH0gW2FuaW1hdGlvbklubGluZVN0eWxlc11cbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlID0gKHRhcmdldCwgcHJvcE5hbWUsIHR3ZWVuVHlwZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKSA9PiB7XG4gIGNvbnN0IHR5cGUgPSAhaXNVbmQodHdlZW5UeXBlKSA/IHR3ZWVuVHlwZSA6IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgcmV0dXJuIHR5cGUgPT09IHR3ZWVuVHlwZXMuT0JKRUNUID8gdGFyZ2V0W3Byb3BOYW1lXSB8fCAwIDpcbiAgICAgICAgIHR5cGUgPT09IHR3ZWVuVHlwZXMuQVRUUklCVVRFID8gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuZ2V0QXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICB0eXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSA/IHBhcnNlSW5saW5lVHJhbnNmb3JtcygvKiogQHR5cGUge0RPTVRhcmdldH0gKi8odGFyZ2V0KSwgcHJvcE5hbWUsIGFuaW1hdGlvbklubGluZVN0eWxlcykgOlxuICAgICAgICAgdHlwZSA9PT0gdHdlZW5UeXBlcy5DU1NfVkFSID8gZ2V0Q1NTVmFsdWUoLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCksIHByb3BOYW1lLCBhbmltYXRpb25JbmxpbmVTdHlsZXMpLnRyaW1TdGFydCgpIDpcbiAgICAgICAgIGdldENTU1ZhbHVlKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBwcm9wTmFtZSwgYW5pbWF0aW9uSW5saW5lU3R5bGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSAge1N0cmluZ30gb3BlcmF0b3JcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZ2V0UmVsYXRpdmVWYWx1ZSA9ICh4LCB5LCBvcGVyYXRvcikgPT4ge1xuICByZXR1cm4gb3BlcmF0b3IgPT09ICctJyA/IHggLSB5IDpcbiAgICAgICAgIG9wZXJhdG9yID09PSAnKycgPyB4ICsgeSA6XG4gICAgICAgICB4ICogeTtcbn07XG5cbi8qKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gKi9cbmNvbnN0IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gICAgdDogdmFsdWVUeXBlcy5OVU1CRVIsXG4gICAgbjogMCxcbiAgICB1OiBudWxsLFxuICAgIG86IG51bGwsXG4gICAgZDogbnVsbCxcbiAgICBzOiBudWxsLFxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9IHJhd1ZhbHVlXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlUmF3VmFsdWUgPSAocmF3VmFsdWUsIHRhcmdldE9iamVjdCkgPT4ge1xuICAvKiogQHR5cGUge3ZhbHVlVHlwZXN9ICovXG4gIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5OVU1CRVI7XG4gIHRhcmdldE9iamVjdC5uID0gMDtcbiAgdGFyZ2V0T2JqZWN0LnUgPSBudWxsO1xuICB0YXJnZXRPYmplY3QubyA9IG51bGw7XG4gIHRhcmdldE9iamVjdC5kID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LnMgPSBudWxsO1xuICBpZiAoIXJhd1ZhbHVlKSByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICBjb25zdCBudW0gPSArcmF3VmFsdWU7XG4gIGlmICghaXNOYU4obnVtKSkge1xuICAgIC8vIEl0J3MgYSBudW1iZXJcbiAgICB0YXJnZXRPYmplY3QubiA9IG51bTtcbiAgICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIC8vIGxldCBzdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8ocmF3VmFsdWUpLnRyaW0oKTtcbiAgICBsZXQgc3RyID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKHJhd1ZhbHVlKTtcbiAgICAvLyBQYXJzaW5nIG9wZXJhdG9ycyAoKz0sIC09LCAqPSkgbWFudWFsbHkgaXMgbXVjaCBmYXN0ZXIgdGhhbiB1c2luZyByZWdleCBoZXJlXG4gICAgaWYgKHN0clsxXSA9PT0gJz0nKSB7XG4gICAgICB0YXJnZXRPYmplY3QubyA9IHN0clswXTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcbiAgICB9XG4gICAgLy8gU2tpcCBleGVjIHJlZ2V4IGlmIHRoZSB2YWx1ZSB0eXBlIGlzIGNvbXBsZXggb3IgY29sb3IgdG8gYXZvaWQgbG9uZyByZWdleCBiYWNrdHJhY2tpbmdcbiAgICBjb25zdCB1bml0TWF0Y2ggPSBzdHIuaW5jbHVkZXMoJyAnKSA/IGZhbHNlIDogdW5pdHNFeGVjUmd4LmV4ZWMoc3RyKTtcbiAgICBpZiAodW5pdE1hdGNoKSB7XG4gICAgICAvLyBIYXMgYSBudW1iZXIgYW5kIGEgdW5pdFxuICAgICAgdGFyZ2V0T2JqZWN0LnQgPSB2YWx1ZVR5cGVzLlVOSVQ7XG4gICAgICB0YXJnZXRPYmplY3QubiA9ICt1bml0TWF0Y2hbMV07XG4gICAgICB0YXJnZXRPYmplY3QudSA9IHVuaXRNYXRjaFsyXTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRPYmplY3Qubykge1xuICAgICAgLy8gSGFzIGFuIG9wZXJhdG9yICgrPSwgLT0sICo9KVxuICAgICAgdGFyZ2V0T2JqZWN0Lm4gPSArc3RyO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9IGVsc2UgaWYgKGlzQ29sKHN0cikpIHtcbiAgICAgIC8vIElzIGEgY29sb3JcbiAgICAgIHRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5DT0xPUjtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gY29udmVydENvbG9yU3RyaW5nVmFsdWVzVG9SZ2JhQXJyYXkoc3RyKTtcbiAgICAgIHJldHVybiB0YXJnZXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElzIGEgbW9yZSBjb21wbGV4IHN0cmluZyAoZ2VuZXJhbGx5IHN2ZyBjb29yZHMsIGNhbGMoKSBvciBmaWx0ZXJzIENTUyB2YWx1ZXMpXG4gICAgICBjb25zdCBtYXRjaGVkTnVtYmVycyA9IHN0ci5tYXRjaChkaWdpdFdpdGhFeHBvbmVudFJneCk7XG4gICAgICB0YXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgIHRhcmdldE9iamVjdC5kID0gbWF0Y2hlZE51bWJlcnMgPyBtYXRjaGVkTnVtYmVycy5tYXAoTnVtYmVyKSA6IFtdO1xuICAgICAgdGFyZ2V0T2JqZWN0LnMgPSBzdHIuc3BsaXQoZGlnaXRXaXRoRXhwb25lbnRSZ3gpIHx8IFtdO1xuICAgICAgcmV0dXJuIHRhcmdldE9iamVjdDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtICB7VHdlZW59IHR3ZWVuXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gdGFyZ2V0T2JqZWN0XG4gKiBAcmV0dXJuIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX1cbiAqL1xuY29uc3QgZGVjb21wb3NlVHdlZW5WYWx1ZSA9ICh0d2VlbiwgdGFyZ2V0T2JqZWN0KSA9PiB7XG4gIHRhcmdldE9iamVjdC50ID0gdHdlZW4uX3ZhbHVlVHlwZTtcbiAgdGFyZ2V0T2JqZWN0Lm4gPSB0d2Vlbi5fdG9OdW1iZXI7XG4gIHRhcmdldE9iamVjdC51ID0gdHdlZW4uX3VuaXQ7XG4gIHRhcmdldE9iamVjdC5vID0gbnVsbDtcbiAgdGFyZ2V0T2JqZWN0LmQgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICB0YXJnZXRPYmplY3QucyA9IGNsb25lQXJyYXkodHdlZW4uX3N0cmluZ3MpO1xuICByZXR1cm4gdGFyZ2V0T2JqZWN0O1xufTtcblxuY29uc3QgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWUgPSBjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QoKTtcblxuXG5cblxuY29uc3QgbG9va3VwcyA9IHtcbiAgLyoqIEB0eXBlIHtUd2VlblJlcGxhY2VMb29rdXBzfSAqL1xuICBfcmVwOiBuZXcgV2Vha01hcCgpLFxuICAvKiogQHR5cGUge1R3ZWVuQWRkaXRpdmVMb29rdXBzfSAqL1xuICBfYWRkOiBuZXcgTWFwKCksXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGxvb2t1cFxuICogQHJldHVybiB7VHdlZW5Qcm9wZXJ0eVNpYmxpbmdzfVxuICovXG5jb25zdCBnZXRUd2VlblNpYmxpbmdzID0gKHRhcmdldCwgcHJvcGVydHksIGxvb2t1cCA9ICdfcmVwJykgPT4ge1xuICBjb25zdCBsb29rdXBNYXAgPSBsb29rdXBzW2xvb2t1cF07XG4gIGxldCB0YXJnZXRMb29rdXAgPSBsb29rdXBNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TG9va3VwKSB7XG4gICAgdGFyZ2V0TG9va3VwID0ge307XG4gICAgbG9va3VwTWFwLnNldCh0YXJnZXQsIHRhcmdldExvb2t1cCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldExvb2t1cFtwcm9wZXJ0eV0gPyB0YXJnZXRMb29rdXBbcHJvcGVydHldIDogdGFyZ2V0TG9va3VwW3Byb3BlcnR5XSA9IHtcbiAgICBfaGVhZDogbnVsbCxcbiAgICBfdGFpbDogbnVsbCxcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gcFxuICogQHBhcmFtICB7VHdlZW59IGNcbiAqIEByZXR1cm4ge051bWJlcnxCb29sZWFufVxuICovXG5jb25zdCBhZGRUd2VlblNvcnRNZXRob2QgPSAocCwgYykgPT4ge1xuICByZXR1cm4gcC5faXNPdmVycmlkZGVuIHx8IHAuX2Fic29sdXRlU3RhcnRUaW1lID4gYy5fYWJzb2x1dGVTdGFydFRpbWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuXG4gKi9cbmNvbnN0IG92ZXJyaWRlVHdlZW4gPSB0d2VlbiA9PiB7XG4gIHR3ZWVuLl9pc092ZXJsYXBwZWQgPSAxO1xuICB0d2Vlbi5faXNPdmVycmlkZGVuID0gMTtcbiAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbWluVmFsdWU7XG4gIHR3ZWVuLl9jdXJyZW50VGltZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEBwYXJhbSAge1R3ZWVuUHJvcGVydHlTaWJsaW5nc30gc2libGluZ3NcbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCBjb21wb3NlVHdlZW4gPSAodHdlZW4sIHNpYmxpbmdzKSA9PiB7XG5cbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvblR5cGUgPSB0d2Vlbi5fY29tcG9zaXRpb247XG5cbiAgLy8gSGFuZGxlIHJlcGxhY2VkIHR3ZWVuc1xuXG4gIGlmICh0d2VlbkNvbXBvc2l0aW9uVHlwZSA9PT0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlKSB7XG5cbiAgICBjb25zdCB0d2VlbkFic1N0YXJ0VGltZSA9IHR3ZWVuLl9hYnNvbHV0ZVN0YXJ0VGltZTtcblxuICAgIGFkZENoaWxkKHNpYmxpbmdzLCB0d2VlbiwgYWRkVHdlZW5Tb3J0TWV0aG9kLCAnX3ByZXZSZXAnLCAnX25leHRSZXAnKTtcblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdHdlZW4uX3ByZXZSZXA7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByZXZpb3VzIHNpYmxpbmdzIGZvciBjb21wb3NpdGlvbiByZXBsYWNlIHR3ZWVuc1xuXG4gICAgaWYgKHByZXZTaWJsaW5nKSB7XG5cbiAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBwcmV2U2libGluZy5wYXJlbnQ7XG4gICAgICBjb25zdCBwcmV2QWJzRW5kVGltZSA9IHByZXZTaWJsaW5nLl9hYnNvbHV0ZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl9jaGFuZ2VEdXJhdGlvbjtcblxuICAgICAgLy8gSGFuZGxlIGxvb3BlZCBhbmltYXRpb25zIHR3ZWVuXG5cbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHR3ZWVuIGlzIGZyb20gYSBkaWZmZXJlbnQgYW5pbWF0aW9uXG4gICAgICAgIHR3ZWVuLnBhcmVudC5pZCAhPT0gcHJldlBhcmVudC5pZCAmJlxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYW5pbWF0aW9uIGhhcyBsb29wc1xuICAgICAgICBwcmV2UGFyZW50Lml0ZXJhdGlvbkNvdW50PiAxICYmXG4gICAgICAgIC8vIENoZWNrIGlmIF9hYnNvbHV0ZUNoYW5nZUVuZFRpbWUgb2YgbGFzdCBsb29wIG92ZXJsYXBzIHRoZSBjdXJyZW50IHR3ZWVuXG4gICAgICAgIHByZXZBYnNFbmRUaW1lICsgKHByZXZQYXJlbnQuZHVyYXRpb24gLSBwcmV2UGFyZW50Lml0ZXJhdGlvbkR1cmF0aW9uKSA+IHR3ZWVuQWJzU3RhcnRUaW1lXG4gICAgICApIHtcblxuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgd2F5IHRvIG9ubHkgb3ZlcnJpZGUgdGhlIGl0ZXJhdGlvbnMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgdHdlZW5cbiAgICAgICAgb3ZlcnJpZGVUd2VlbihwcmV2U2libGluZyk7XG5cbiAgICAgICAgbGV0IHByZXZQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLl9wcmV2UmVwO1xuXG4gICAgICAgIC8vIElmIHRoZSB0d2VlbiB3YXMgcGFydCBvZiBhIHNldCBvZiBrZXlmcmFtZXMsIG92ZXJyaWRlIGl0cyBzaWJsaW5nc1xuICAgICAgICB3aGlsZSAocHJldlByZXZTaWJsaW5nICYmIHByZXZQcmV2U2libGluZy5wYXJlbnQuaWQgPT09IHByZXZQYXJlbnQuaWQpIHtcbiAgICAgICAgICBvdmVycmlkZVR3ZWVuKHByZXZQcmV2U2libGluZyk7XG4gICAgICAgICAgcHJldlByZXZTaWJsaW5nID0gcHJldlByZXZTaWJsaW5nLl9wcmV2UmVwO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgY29uc3QgYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgPSB0d2VlbkFic1N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheTtcblxuICAgICAgaWYgKHByZXZBYnNFbmRUaW1lID4gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUpIHtcblxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlU3RhcnRUaW1lID0gcHJldlNpYmxpbmcuX3N0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJldlRMT2Zmc2V0ID0gcHJldkFic0VuZFRpbWUgLSAocHJldkNoYW5nZVN0YXJ0VGltZSArIHByZXZTaWJsaW5nLl91cGRhdGVEdXJhdGlvbik7XG5cbiAgICAgICAgcHJldlNpYmxpbmcuX2NoYW5nZUR1cmF0aW9uID0gYWJzb2x1dGVVcGRhdGVTdGFydFRpbWUgLSBwcmV2VExPZmZzZXQgLSBwcmV2Q2hhbmdlU3RhcnRUaW1lO1xuICAgICAgICBwcmV2U2libGluZy5fY3VycmVudFRpbWUgPSBwcmV2U2libGluZy5fY2hhbmdlRHVyYXRpb247XG4gICAgICAgIHByZXZTaWJsaW5nLl9pc092ZXJsYXBwZWQgPSAxO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZy5fY2hhbmdlRHVyYXRpb24gPCBtaW5WYWx1ZSkge1xuICAgICAgICAgIG92ZXJyaWRlVHdlZW4ocHJldlNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFBhdXNlIChhbmQgY2FuY2VsKSB0aGUgcGFyZW50IGlmIGl0IG9ubHkgY29udGFpbnMgb3ZlcmxhcHBlZCB0d2VlbnNcblxuICAgICAgbGV0IHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgIGZvckVhY2hDaGlsZHJlbihwcmV2UGFyZW50LCAoLyoqIEB0eXBlIFR3ZWVuICovdCkgPT4ge1xuICAgICAgICBpZiAoIXQuX2lzT3ZlcmxhcHBlZCkgcGF1c2VQcmV2UGFyZW50QW5pbWF0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhdXNlUHJldlBhcmVudEFuaW1hdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2UGFyZW50VEwgPSBwcmV2UGFyZW50LnBhcmVudDtcbiAgICAgICAgaWYgKHByZXZQYXJlbnRUTCkge1xuICAgICAgICAgIGxldCBwYXVzZVByZXZQYXJlbnRUTCA9IHRydWU7XG4gICAgICAgICAgZm9yRWFjaENoaWxkcmVuKHByZXZQYXJlbnRUTCwgKC8qKiBAdHlwZSBKU0FuaW1hdGlvbiAqL2EpID0+IHtcbiAgICAgICAgICAgIGlmIChhICE9PSBwcmV2UGFyZW50KSB7XG4gICAgICAgICAgICAgIGZvckVhY2hDaGlsZHJlbihhLCAoLyoqIEB0eXBlIFR3ZWVuICovdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdC5faXNPdmVybGFwcGVkKSBwYXVzZVByZXZQYXJlbnRUTCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGF1c2VQcmV2UGFyZW50VEwpIHtcbiAgICAgICAgICAgIHByZXZQYXJlbnRUTC5jYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlBhcmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAvLyBQcmV2aW91c2x5LCBjYWxsaW5nIC5jYW5jZWwoKSBvbiBhIHRpbWVsaW5lIGNoaWxkIHdvdWxkIGFmZmVjdCB0aGUgcmVuZGVyIG9yZGVyIG9mIG90aGVyIGNoaWxkcmVuXG4gICAgICAgICAgLy8gV29ya2VkIGFyb3VuZCB0aGlzIGJ5IG1hcmtpbmcgaXQgYXMgLmNvbXBsZXRlZCBhbmQgdXNpbmcgLnBhdXNlKCkgZm9yIHNhZmUgcmVtb3ZhbCBpbiB0aGUgZW5naW5lIGxvb3BcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgc2luY2UgdGltZWxpbmUgdHdlZW4gY29tcG9zaXRpb24gaXMgbm93IGhhbmRsZWQgc2VwYXJhdGx5XG4gICAgICAgICAgLy8gS2VlcGluZyB0aGlzIGhlcmUgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgIC8vIHByZXZQYXJlbnQuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwcmV2UGFyZW50LnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGxldCBuZXh0U2libGluZyA9IHR3ZWVuLl9uZXh0UmVwO1xuXG4gICAgLy8gLy8gQWxsIHRoZSBuZXh0IHNpYmxpbmdzIGFyZSBhdXRvbWF0aWNhbGx5IG92ZXJyaWRkZW5cblxuICAgIC8vIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPj0gdHdlZW5BYnNTdGFydFRpbWUpIHtcbiAgICAvLyAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgIC8vICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAvLyAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICAvLyBpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcuX2Fic29sdXRlU3RhcnRUaW1lIDwgdHdlZW5BYnNTdGFydFRpbWUpIHtcbiAgICAvLyAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgIC8vICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2codHdlZW4uaWQsIG5leHRTaWJsaW5nLmlkKTtcbiAgICAvLyAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5fbmV4dFJlcDtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgLy8gSGFuZGxlIGFkZGl0aXZlIHR3ZWVucyBjb21wb3NpdGlvblxuXG4gIH0gZWxzZSBpZiAodHdlZW5Db21wb3NpdGlvblR5cGUgPT09IGNvbXBvc2l0aW9uVHlwZXMuYmxlbmQpIHtcblxuICAgIGNvbnN0IGFkZGl0aXZlVHdlZW5TaWJsaW5ncyA9IGdldFR3ZWVuU2libGluZ3ModHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgJ19hZGQnKTtcbiAgICBjb25zdCBhZGRpdGl2ZUFuaW1hdGlvbiA9IGFkZEFkZGl0aXZlQW5pbWF0aW9uKGxvb2t1cHMuX2FkZCk7XG5cbiAgICBsZXQgbG9va3VwVHdlZW4gPSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX2hlYWQ7XG5cbiAgICBpZiAoIWxvb2t1cFR3ZWVuKSB7XG4gICAgICBsb29rdXBUd2VlbiA9IHsgLi4udHdlZW4gfTtcbiAgICAgIGxvb2t1cFR3ZWVuLl9jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICAgIGxvb2t1cFR3ZWVuLl91cGRhdGVEdXJhdGlvbiA9IG1pblZhbHVlO1xuICAgICAgbG9va3VwVHdlZW4uX3N0YXJ0VGltZSA9IDA7XG4gICAgICBsb29rdXBUd2Vlbi5fbnVtYmVycyA9IGNsb25lQXJyYXkodHdlZW4uX2Zyb21OdW1iZXJzKTtcbiAgICAgIGxvb2t1cFR3ZWVuLl9udW1iZXIgPSAwO1xuICAgICAgbG9va3VwVHdlZW4uX25leHQgPSBudWxsO1xuICAgICAgbG9va3VwVHdlZW4uX3ByZXYgPSBudWxsO1xuICAgICAgYWRkQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCBsb29rdXBUd2Vlbik7XG4gICAgICBhZGRDaGlsZChhZGRpdGl2ZUFuaW1hdGlvbiwgbG9va3VwVHdlZW4pO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlcyBvZiBUTyB0byBGUk9NIGFuZCBzZXQgVE8gdG8gMFxuXG4gICAgY29uc3QgdG9OdW1iZXIgPSB0d2Vlbi5fdG9OdW1iZXI7XG4gICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlciAtIHRvTnVtYmVyO1xuICAgIHR3ZWVuLl90b051bWJlciA9IDA7XG4gICAgdHdlZW4uX251bWJlcnMgPSBjbG9uZUFycmF5KHR3ZWVuLl9mcm9tTnVtYmVycyk7XG4gICAgdHdlZW4uX251bWJlciA9IDA7XG4gICAgbG9va3VwVHdlZW4uX2Zyb21OdW1iZXIgPSB0b051bWJlcjtcblxuICAgIGlmICh0d2Vlbi5fdG9OdW1iZXJzKSB7XG4gICAgICBjb25zdCB0b051bWJlcnMgPSBjbG9uZUFycmF5KHR3ZWVuLl90b051bWJlcnMpO1xuICAgICAgaWYgKHRvTnVtYmVycykge1xuICAgICAgICB0b051bWJlcnMuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICB0d2Vlbi5fZnJvbU51bWJlcnNbaV0gPSBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnNbaV0gLSB2YWx1ZTtcbiAgICAgICAgICB0d2Vlbi5fdG9OdW1iZXJzW2ldID0gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb29rdXBUd2Vlbi5fZnJvbU51bWJlcnMgPSB0b051bWJlcnM7XG4gICAgfVxuXG4gICAgYWRkQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCB0d2VlbiwgbnVsbCwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG5cbiAgfVxuXG4gIHJldHVybiB0d2VlbjtcblxufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtUd2Vlbn0gdHdlZW5cbiAqIEByZXR1cm4ge1R3ZWVufVxuICovXG5jb25zdCByZW1vdmVUd2VlblNsaWJsaW5ncyA9IHR3ZWVuID0+IHtcbiAgY29uc3QgdHdlZW5Db21wb3NpdGlvbiA9IHR3ZWVuLl9jb21wb3NpdGlvbjtcbiAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgIGNvbnN0IHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICBjb25zdCByZXBsYWNlVHdlZW5zTG9va3VwID0gbG9va3Vwcy5fcmVwO1xuICAgIGNvbnN0IHJlcGxhY2VUYXJnZXRQcm9wcyA9IHJlcGxhY2VUd2VlbnNMb29rdXAuZ2V0KHR3ZWVuVGFyZ2V0KTtcbiAgICBjb25zdCB0d2VlblJlcGxhY2VTaWJsaW5ncyA9IHJlcGxhY2VUYXJnZXRQcm9wc1t0d2VlblByb3BlcnR5XTtcbiAgICByZW1vdmVDaGlsZCh0d2VlblJlcGxhY2VTaWJsaW5ncywgdHdlZW4sICdfcHJldlJlcCcsICdfbmV4dFJlcCcpO1xuICAgIGlmICh0d2VlbkNvbXBvc2l0aW9uID09PSBjb21wb3NpdGlvblR5cGVzLmJsZW5kKSB7XG4gICAgICBjb25zdCBhZGRUd2VlbnNMb29rdXAgPSBsb29rdXBzLl9hZGQ7XG4gICAgICBjb25zdCBhZGRUYXJnZXRQcm9wcyA9IGFkZFR3ZWVuc0xvb2t1cC5nZXQodHdlZW5UYXJnZXQpO1xuICAgICAgaWYgKCFhZGRUYXJnZXRQcm9wcykgcmV0dXJuO1xuICAgICAgY29uc3QgYWRkaXRpdmVUd2VlblNpYmxpbmdzID0gYWRkVGFyZ2V0UHJvcHNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICBjb25zdCBhZGRpdGl2ZUFuaW1hdGlvbiA9IGFkZGl0aXZlLmFuaW1hdGlvbjtcbiAgICAgIHJlbW92ZUNoaWxkKGFkZGl0aXZlVHdlZW5TaWJsaW5ncywgdHdlZW4sICdfcHJldkFkZCcsICdfbmV4dEFkZCcpO1xuICAgICAgLy8gSWYgb25seSBvbmUgdHdlZW4gaXMgbGVmdCBpbiB0aGUgYWRkaXRpdmUgbG9va3VwLCBpdCdzIHRoZSB0d2VlbiBsb29rdXBcbiAgICAgIGNvbnN0IGxvb2t1cFR3ZWVuID0gYWRkaXRpdmVUd2VlblNpYmxpbmdzLl9oZWFkO1xuICAgICAgaWYgKGxvb2t1cFR3ZWVuICYmIGxvb2t1cFR3ZWVuID09PSBhZGRpdGl2ZVR3ZWVuU2libGluZ3MuX3RhaWwpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoYWRkaXRpdmVUd2VlblNpYmxpbmdzLCBsb29rdXBUd2VlbiwgJ19wcmV2QWRkJywgJ19uZXh0QWRkJyk7XG4gICAgICAgIHJlbW92ZUNoaWxkKGFkZGl0aXZlQW5pbWF0aW9uLCBsb29rdXBUd2Vlbik7XG4gICAgICAgIGxldCBzaG91bGRDbGVhbiA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gYWRkVGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICBpZiAoYWRkVGFyZ2V0UHJvcHNbcHJvcF0uX2hlYWQpIHtcbiAgICAgICAgICAgIHNob3VsZENsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENsZWFuKSB7XG4gICAgICAgICAgYWRkVHdlZW5zTG9va3VwLmRlbGV0ZSh0d2VlblRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR3ZWVuO1xufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtUaW1lcn0gdGltZXJcbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCByZXNldFRpbWVyUHJvcGVydGllcyA9IHRpbWVyID0+IHtcbiAgdGltZXIucGF1c2VkID0gdHJ1ZTtcbiAgdGltZXIuYmVnYW4gPSBmYWxzZTtcbiAgdGltZXIuY29tcGxldGVkID0gZmFsc2U7XG4gIHJldHVybiB0aW1lcjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7VGltZXJ9IHRpbWVyXG4gKiBAcmV0dXJuIHtUaW1lcn1cbiAqL1xuY29uc3QgcmV2aXZlVGltZXIgPSB0aW1lciA9PiB7XG4gIGlmICghdGltZXIuX2NhbmNlbGxlZCkgcmV0dXJuIHRpbWVyO1xuICBpZiAodGltZXIuX2hhc0NoaWxkcmVuKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRpbWVyLCByZXZpdmVUaW1lcik7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRpbWVyLCAoLyoqIEB0eXBlIHtUd2Vlbn0gdHdlZW4qL3R3ZWVuKSA9PiB7XG4gICAgICBpZiAodHdlZW4uX2NvbXBvc2l0aW9uICE9PSBjb21wb3NpdGlvblR5cGVzLm5vbmUpIHtcbiAgICAgICAgY29tcG9zZVR3ZWVuKHR3ZWVuLCBnZXRUd2VlblNpYmxpbmdzKHR3ZWVuLnRhcmdldCwgdHdlZW4ucHJvcGVydHkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0aW1lci5fY2FuY2VsbGVkID0gMDtcbiAgcmV0dXJuIHRpbWVyO1xufTtcblxubGV0IHRpbWVySWQgPSAwO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdXNlZCB0byBjcmVhdGUgVGltZXJzLCBBbmltYXRpb25zIGFuZCBUaW1lbGluZXNcbiAqL1xuY2xhc3MgVGltZXIgZXh0ZW5kcyBDbG9jayB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICogQHBhcmFtIHtUaW1lbGluZX0gW3BhcmVudF1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJlbnRQb3NpdGlvbl1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSwgcGFyZW50ID0gbnVsbCwgcGFyZW50UG9zaXRpb24gPSAwKSB7XG5cbiAgICBzdXBlcigwKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZGVsYXksXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHJldmVyc2VkLFxuICAgICAgYWx0ZXJuYXRlLFxuICAgICAgbG9vcCxcbiAgICAgIGxvb3BEZWxheSxcbiAgICAgIGF1dG9wbGF5LFxuICAgICAgZnJhbWVSYXRlLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uTG9vcCxcbiAgICAgIG9uUGF1c2UsXG4gICAgICBvbkJlZ2luLFxuICAgICAgb25CZWZvcmVVcGRhdGUsXG4gICAgICBvblVwZGF0ZSxcbiAgICB9ID0gcGFyYW1ldGVycztcblxuICAgIGlmIChnbG9iYWxzLnNjb3BlKSBnbG9iYWxzLnNjb3BlLnJldmVydGlibGVzLnB1c2godGhpcyk7XG5cbiAgICBjb25zdCB0aW1lckluaXRUaW1lID0gcGFyZW50ID8gMCA6IGVuZ2luZS5fZWxhcHNlZFRpbWU7XG4gICAgY29uc3QgdGltZXJEZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgdGltZXJEZWxheSA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhpc0ZuYyhkZWxheSkgfHwgaXNVbmQoZGVsYXkpID8gdGltZXJEZWZhdWx0cy5kZWxheSA6ICtkZWxheSk7XG4gICAgY29uc3QgdGltZXJEdXJhdGlvbiA9IGlzRm5jKGR1cmF0aW9uKSB8fCBpc1VuZChkdXJhdGlvbikgPyBJbmZpbml0eSA6ICtkdXJhdGlvbjtcbiAgICBjb25zdCB0aW1lckxvb3AgPSBzZXRWYWx1ZShsb29wLCB0aW1lckRlZmF1bHRzLmxvb3ApO1xuICAgIGNvbnN0IHRpbWVyTG9vcERlbGF5ID0gc2V0VmFsdWUobG9vcERlbGF5LCB0aW1lckRlZmF1bHRzLmxvb3BEZWxheSk7XG4gICAgY29uc3QgdGltZXJJdGVyYXRpb25Db3VudCA9IHRpbWVyTG9vcCA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvb3AgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyh0aW1lckxvb3ApIDwgMCA/IEluZmluaXR5IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRpbWVyTG9vcCkgKyAxO1xuXG4gICAgbGV0IG9mZnNldFBvc2l0aW9uID0gMDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG9mZnNldFBvc2l0aW9uID0gcGFyZW50UG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byB0aWNrIHRoZSBlbmdpbmUgb25jZSBpZiBzdXNwZW5kZWQgdG8gYXZvaWQgYmlnIGdhcHMgd2l0aCB0aGUgZm9sbG93aW5nIG9mZnNldFBvc2l0aW9uIGNhbGN1bGF0aW9uXG4gICAgICBpZiAoZW5naW5lLnBhdXNlZCkge1xuICAgICAgICBlbmdpbmUucmVxdWVzdFRpY2soc3RhcnRUaW1lKTtcbiAgICAgICAgc3RhcnRUaW1lID0gZW5naW5lLl9lbGFwc2VkVGltZTtcbiAgICAgIH1cbiAgICAgIG9mZnNldFBvc2l0aW9uID0gc3RhcnRUaW1lIC0gZW5naW5lLl9zdGFydFRpbWU7XG4gICAgfVxuXG4gICAgLy8gVGltZXIncyBwYXJhbWV0ZXJzXG4gICAgdGhpcy5pZCA9ICFpc1VuZChpZCkgPyBpZCA6ICsrdGltZXJJZDtcbiAgICAvKiogQHR5cGUge1RpbWVsaW5lfSAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8vIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0aW1lclxuICAgIHRoaXMuZHVyYXRpb24gPSBjbGFtcEluZmluaXR5KCgodGltZXJEdXJhdGlvbiArIHRpbWVyTG9vcERlbGF5KSAqIHRpbWVySXRlcmF0aW9uQ291bnQpIC0gdGltZXJMb29wRGVsYXkpIHx8IG1pblZhbHVlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkcyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuYmVnYW4gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25CZWdpbiA9IG9uQmVnaW4gfHwgdGltZXJEZWZhdWx0cy5vbkJlZ2luO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vbkJlZm9yZVVwZGF0ZSA9IG9uQmVmb3JlVXBkYXRlIHx8IHRpbWVyRGVmYXVsdHMub25CZWZvcmVVcGRhdGU7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGUgfHwgdGltZXJEZWZhdWx0cy5vblVwZGF0ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25Mb29wID0gb25Mb29wIHx8IHRpbWVyRGVmYXVsdHMub25Mb29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblBhdXNlID0gb25QYXVzZSB8fCB0aW1lckRlZmF1bHRzLm9uUGF1c2U7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlIHx8IHRpbWVyRGVmYXVsdHMub25Db21wbGV0ZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gdGltZXJEdXJhdGlvbjsgLy8gRHVyYXRpb24gb2Ygb25lIGxvb3BcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLml0ZXJhdGlvbkNvdW50ID0gdGltZXJJdGVyYXRpb25Db3VudDsgLy8gTnVtYmVyIG9mIGxvb3BzXG4gICAgLyoqIEB0eXBlIHtCb29sZWFufFNjcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX2F1dG9wbGF5ID0gcGFyZW50ID8gZmFsc2UgOiBzZXRWYWx1ZShhdXRvcGxheSwgdGltZXJEZWZhdWx0cy5hdXRvcGxheSk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0UG9zaXRpb247XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSB0aW1lckRlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xvb3BEZWxheSA9IHRpbWVyTG9vcERlbGF5O1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2l0ZXJhdGlvblRpbWUgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24gPSAwOyAvLyBDdXJyZW50IGxvb3AgaW5kZXhcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSBub29wOyAvLyBVc2VkIGJ5IC50aGVuKClcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX3JldmVyc2VkID0gK3NldFZhbHVlKHJldmVyc2VkLCB0aW1lckRlZmF1bHRzLnJldmVyc2VkKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9yZXZlcnNlID0gdGhpcy5fcmV2ZXJzZWQ7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gMDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5fYWx0ZXJuYXRlID0gc2V0VmFsdWUoYWx0ZXJuYXRlLCB0aW1lckRlZmF1bHRzLmFsdGVybmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL1xuICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9cbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcblxuICAgIC8vIENsb2NrJ3MgcGFyYW1ldGVyc1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFRpbWUgPSB0aW1lckluaXRUaW1lO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuX2xhc3RUaW1lID0gdGltZXJJbml0VGltZTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9mcHMgPSBzZXRWYWx1ZShmcmFtZVJhdGUsIHRpbWVyRGVmYXVsdHMuZnJhbWVSYXRlKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLl9zcGVlZCA9IHNldFZhbHVlKHBsYXliYWNrUmF0ZSwgdGltZXJEZWZhdWx0cy5wbGF5YmFja1JhdGUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9jYW5jZWxsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxsZWQgICovXG4gIHNldCBjYW5jZWxsZWQoY2FuY2VsbGVkKSB7XG4gICAgY2FuY2VsbGVkID8gdGhpcy5jYW5jZWwoKSA6IHRoaXMucmVzZXQoMSkucGxheSgpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9jdXJyZW50VGltZSwgZ2xvYmFscy5wcmVjaXNpb24pLCAtdGhpcy5fZGVsYXksIHRoaXMuZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgY3VycmVudFRpbWUodGltZSkge1xuICAgIGNvbnN0IHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuICAgIC8vIFBhdXNpbmcgdGhlIHRpbWVyIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCB0aW1lIGp1bXBzIG9uIGEgcnVubmluZyBpbnN0YW5jZVxuICAgIHRoaXMucGF1c2UoKS5zZWVrKCt0aW1lKTtcbiAgICBpZiAoIXBhdXNlZCkgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGdldCBpdGVyYXRpb25DdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gcm91bmQodGhpcy5faXRlcmF0aW9uVGltZSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICAqL1xuICBzZXQgaXRlcmF0aW9uQ3VycmVudFRpbWUodGltZSkge1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRoaXMuX2N1cnJlbnRJdGVyYXRpb24pICsgdGltZTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gY2xhbXAocm91bmQodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uLCA1KSwgMCwgMSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzICAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5kdXJhdGlvbiAqIHByb2dyZXNzO1xuICB9XG5cbiAgZ2V0IGl0ZXJhdGlvblByb2dyZXNzKCkge1xuICAgIHJldHVybiBjbGFtcChyb3VuZCh0aGlzLl9pdGVyYXRpb25UaW1lIC8gdGhpcy5pdGVyYXRpb25EdXJhdGlvbiwgNSksIDAsIDEpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAgKi9cbiAgc2V0IGl0ZXJhdGlvblByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgY29uc3QgaXRlcmF0aW9uRHVyYXRpb24gPSB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAoaXRlcmF0aW9uRHVyYXRpb24gKiB0aGlzLl9jdXJyZW50SXRlcmF0aW9uKSArIChpdGVyYXRpb25EdXJhdGlvbiAqIHByb2dyZXNzKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50SXRlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50SXRlcmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRpb25Db3VudCAgKi9cbiAgc2V0IGN1cnJlbnRJdGVyYXRpb24oaXRlcmF0aW9uQ291bnQpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gKHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gKiBjbGFtcCgraXRlcmF0aW9uQ291bnQsIDAsIHRoaXMuaXRlcmF0aW9uQ291bnQgLSAxKSk7XG4gIH1cblxuICBnZXQgcmV2ZXJzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcmV2ZXJzZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtCb29sZWFufSByZXZlcnNlICAqL1xuICBzZXQgcmV2ZXJzZWQocmV2ZXJzZSkge1xuICAgIHJldmVyc2UgPyB0aGlzLnJldmVyc2UoKSA6IHRoaXMucGxheSgpO1xuICB9XG5cbiAgZ2V0IHNwZWVkKCkge1xuICAgIHJldHVybiBzdXBlci5zcGVlZDtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge051bWJlcn0gcGxheWJhY2tSYXRlICAqL1xuICBzZXQgc3BlZWQocGxheWJhY2tSYXRlKSB7XG4gICAgc3VwZXIuc3BlZWQgPSBwbGF5YmFja1JhdGU7XG4gICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVybmFsUmVuZGVyXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXNldChpbnRlcm5hbFJlbmRlciA9IDApIHtcbiAgICAvLyBJZiBjYW5jZWxsZWQsIHJldml2ZSB0aGUgdGltZXIgYmVmb3JlIHJlbmRlcmluZyBpbiBvcmRlciB0byBoYXZlIHByb3BlcnRseSBjb21wb3NlZCB0d2VlbnMgc2libGluZ3NcbiAgICByZXZpdmVUaW1lcih0aGlzKTtcbiAgICBpZiAodGhpcy5fcmV2ZXJzZWQgJiYgIXRoaXMuX3JldmVyc2UpIHRoaXMucmV2ZXJzZWQgPSBmYWxzZTtcbiAgICAvLyBSZW5kZXJpbmcgYmVmb3JlIHVwZGF0aW5nIHRoZSBjb21wbGV0ZWQgZmxhZyB0byBwcmV2ZW50IHNraXBzIGFuZCB0byBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBvdmVycmlkZGVuXG4gICAgLy8gU2V0dGluZyB0aGUgaXRlcmF0aW9uVGltZSBhdCB0aGUgZW5kIHRvIGZvcmNlIHRoZSByZW5kZXJpbmcgdG8gaGFwcGVuZCBiYWNrd2FyZHMsIG90aGVyd2lzZSBjYWxsaW5nIC5yZXNldCgpIG9uIFRpbWVsaW5lcyBtaWdodCBub3QgcmVuZGVyIGNoaWxkcmVuIGluIHRoZSByaWdodCBvcmRlclxuICAgIC8vIE5PVEU6IFRoaXMgaXMgb25seSByZXF1aXJlZCBmb3IgVGltZWxpbmVzIGFuZCBtaWdodCBiZSBiZXR0ZXIgdG8gbW92ZSB0byB0aGUgVGltZWxpbmUgY2xhc3M/XG4gICAgdGhpcy5faXRlcmF0aW9uVGltZSA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgLy8gU2V0IHRpY2tNb2RlIHRvIHRpY2tNb2Rlcy5GT1JDRSB0byBmb3JjZSByZW5kZXJpbmdcbiAgICB0aWNrKHRoaXMsIDAsIDEsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIC8vIFJlc2V0IHRpbWVyIHByb3BlcnRpZXMgYWZ0ZXIgcmV2aXZlIC8gcmVuZGVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJvcHMgYXJlIG5vdCB1cGRhdGVkIGFnYWluXG4gICAgcmVzZXRUaW1lclByb3BlcnRpZXModGhpcyk7XG4gICAgLy8gQWxzbyByZXNldCBjaGlsZHJlbiBwcm9wZXJ0aWVzXG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgcmVzZXRUaW1lclByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGludGVybmFsUmVuZGVyXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBpbml0KGludGVybmFsUmVuZGVyID0gMCkge1xuICAgIHRoaXMuZnBzID0gdGhpcy5fZnBzO1xuICAgIHRoaXMuc3BlZWQgPSB0aGlzLl9zcGVlZDtcbiAgICAvLyBNYW51YWxseSBjYWxsaW5nIC5pbml0KCkgb24gdGltZWxpbmVzIHNob3VsZCByZW5kZXIgYWxsIGNoaWxkcmVuIGludGlhbCBzdGF0ZVxuICAgIC8vIEZvcmNlcyBhbGwgY2hpbGRyZW4gdG8gcmVuZGVyIG9uY2UgdGhlbiByZW5kZXIgdG8gMCB3aGVuIHJlc2V0ZWRcbiAgICBpZiAoIWludGVybmFsUmVuZGVyICYmIHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICB0aWNrKHRoaXMsIHRoaXMuZHVyYXRpb24sIDEsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZXMuRk9SQ0UpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KGludGVybmFsUmVuZGVyKTtcbiAgICAvLyBNYWtlIHN1cmUgdG8gc2V0IGF1dG9wbGF5IHRvIGZhbHNlIHRvIGNoaWxkIHRpbWVycyBzbyBpdCBkb2Vzbid0IGF0dGVtcHQgdG8gYXV0b3BsYXkgLyBsaW5rXG4gICAgY29uc3QgYXV0b3BsYXkgPSB0aGlzLl9hdXRvcGxheTtcbiAgICBpZiAoYXV0b3BsYXkgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgfSBlbHNlIGlmIChhdXRvcGxheSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8oYXV0b3BsYXkpLmxpbmtlZCkpIHtcbiAgICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovKGF1dG9wbGF5KS5saW5rKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXNldFRpbWUoKSB7XG4gICAgY29uc3QgdGltZVNjYWxlID0gMSAvICh0aGlzLl9zcGVlZCAqIGVuZ2luZS5fc3BlZWQpO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5vdygpIC0gKHRoaXMuX2N1cnJlbnRUaW1lICsgdGhpcy5fZGVsYXkpICogdGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMub25QYXVzZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKCF0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAvLyBXZSBjYW4gc2FmZWx5IGltZWRpYXRseSByZW5kZXIgYSB0aW1lciB0aGF0IGhhcyBubyBkdXJhdGlvbiBhbmQgbm8gY2hpbGRyZW5cbiAgICBpZiAodGhpcy5kdXJhdGlvbiA8PSBtaW5WYWx1ZSAmJiAhdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIHRpY2sodGhpcywgbWluVmFsdWUsIDAsIDAsIHRpY2tNb2Rlcy5GT1JDRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICBhZGRDaGlsZChlbmdpbmUsIHRoaXMpO1xuICAgICAgICBlbmdpbmUuX2hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VGltZSgpO1xuICAgICAgLy8gRm9yY2VzIHRoZSB0aW1lciB0byBhZHZhbmNlIGJ5IGF0IGxlYXN0IG9uZSBmcmFtZSB3aGVuIHRoZSBuZXh0IHRpY2sgb2NjdXJzXG4gICAgICB0aGlzLl9zdGFydFRpbWUgLT0gMTI7XG4gICAgICBlbmdpbmUud2FrZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnJlc2V0KDApLnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gdGltZVxuICAgKiBAcGFyYW0gIHtCb29sZWFufE51bWJlcn0gW211dGVDYWxsYmFja3NdXG4gICAqIEBwYXJhbSAge0Jvb2xlYW58TnVtYmVyfSBbaW50ZXJuYWxSZW5kZXJdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSAwLCBpbnRlcm5hbFJlbmRlciA9IDApIHtcbiAgICAvLyBSZWNvbXBvc2UgdGhlIHR3ZWVuIHNpYmxpbmdzIGluIGNhc2UgdGhlIHRpbWVyIGhhcyBiZWVuIGNhbmNlbGxlZFxuICAgIHJldml2ZVRpbWVyKHRoaXMpO1xuICAgIC8vIElmIHlvdSBzZWVrIGEgY29tcGxldGVkIGFuaW1hdGlvbiwgb3RoZXJ3aXNlIHRoZSBuZXh0IHBsYXkgd2lsbCBzdGFydHMgYXQgMFxuICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2U7XG4gICAgY29uc3QgaXNQYXVzZWQgPSB0aGlzLnBhdXNlZDtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgLy8gdGltZXIsIHRpbWUsIG11dGVDYWxsYmFja3MsIGludGVybmFsUmVuZGVyLCB0aWNrTW9kZVxuICAgIHRpY2sodGhpcywgdGltZSArIHRoaXMuX2RlbGF5LCB+fm11dGVDYWxsYmFja3MsIH5+aW50ZXJuYWxSZW5kZXIsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgICByZXR1cm4gaXNQYXVzZWQgPyB0aGlzIDogdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBhbHRlcm5hdGUoKSB7XG4gICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLl9yZXZlcnNlZDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuaXRlcmF0aW9uQ291bnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBpdGVyYXRpb25zIHBvc3NpYmxlIGdpdmVuIHRoZSBpdGVyYXRpb24gZHVyYXRpb25cbiAgICBjb25zdCBpdGVyYXRpb25zID0gY291bnQgPT09IEluZmluaXR5ID8gZmxvb3IobWF4VmFsdWUgLyBkdXJhdGlvbikgOiBjb3VudDtcbiAgICB0aGlzLl9yZXZlcnNlZCA9ICsodGhpcy5fYWx0ZXJuYXRlICYmICEoaXRlcmF0aW9ucyAlIDIpID8gcmV2ZXJzZWQgOiAhcmV2ZXJzZWQpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHtcbiAgICAgIC8vIEhhbmRsZSBpbmZpbml0ZSBsb29wcyB0byBsb29wIG9uIHRoZW1zZWxmXG4gICAgICB0aGlzLml0ZXJhdGlvblByb2dyZXNzID0gdGhpcy5fcmV2ZXJzZWQgPyAxIC0gdGhpcy5pdGVyYXRpb25Qcm9ncmVzcyA6IHRoaXMuaXRlcmF0aW9uUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VlaygoZHVyYXRpb24gKiBpdGVyYXRpb25zKSAtIHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRpbWUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHt0aGlzfSAqL1xuICByZXZlcnNlKCkge1xuICAgIGlmICghdGhpcy5fcmV2ZXJzZWQpIHRoaXMuYWx0ZXJuYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICAvLyBUT0RPOiBNb3ZlIGFsbCB0aGUgYW5pbWF0aW9uIC8gdHdlZW5zIC8gY2hpbGRyZW4gcmVsYXRlZCBjb2RlIHRvIEFuaW1hdGlvbiAvIFRpbWVsaW5lXG5cbiAgLyoqIEByZXR1cm4ge3RoaXN9ICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtSZW5kZXJhYmxlfSAqL2NoaWxkKSA9PiBjaGlsZC5jYW5jZWwoKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCByZW1vdmVUd2VlblNsaWJsaW5ncyk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxlZCA9IDE7XG4gICAgLy8gUGF1c2luZyB0aGUgdGltZXIgcmVtb3ZlcyBpdCBmcm9tIHRoZSBlbmdpbmVcbiAgICByZXR1cm4gdGhpcy5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGNvbnN0IG5vcm1saXplZER1cmF0aW9uID0gbm9ybWFsaXplVGltZShuZXdEdXJhdGlvbik7XG4gICAgaWYgKGN1cnJlbnREdXJhdGlvbiA9PT0gbm9ybWxpemVkRHVyYXRpb24pIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IG5ld0R1cmF0aW9uIC8gY3VycmVudER1cmF0aW9uO1xuICAgIGNvbnN0IGlzU2V0dGVyID0gbmV3RHVyYXRpb24gPD0gbWluVmFsdWU7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGlzU2V0dGVyID8gbWluVmFsdWUgOiBub3JtbGl6ZWREdXJhdGlvbjtcbiAgICB0aGlzLml0ZXJhdGlvbkR1cmF0aW9uID0gaXNTZXR0ZXIgPyBtaW5WYWx1ZSA6IG5vcm1hbGl6ZVRpbWUodGhpcy5pdGVyYXRpb25EdXJhdGlvbiAqIHRpbWVTY2FsZSk7XG4gICAgdGhpcy5fb2Zmc2V0ICo9IHRpbWVTY2FsZTtcbiAgICB0aGlzLl9kZWxheSAqPSB0aW1lU2NhbGU7XG4gICAgdGhpcy5fbG9vcERlbGF5ICo9IHRpbWVTY2FsZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gLyoqXG4gICAqIENhbmNlbHMgdGhlIHRpbWVyIGJ5IHNlZWtpbmcgaXQgYmFjayB0byAwIGFuZCByZXZlcnRpbmcgdGhlIGF0dGFjaGVkIHNjcm9sbGVyIGlmIG5lY2Vzc2FyeVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHRpY2sodGhpcywgMCwgMSwgMCwgdGlja01vZGVzLkFVVE8pO1xuICAgIGNvbnN0IGFwID0gLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8odGhpcy5fYXV0b3BsYXkpO1xuICAgIGlmIChhcCAmJiBhcC5saW5rZWQgJiYgYXAubGlua2VkID09PSB0aGlzKSBhcC5yZXZlcnQoKTtcbiAgICByZXR1cm4gdGhpcy5jYW5jZWwoKTtcbiAgfVxuXG4gLyoqXG4gICAqIEltZWRpYXRseSBjb21wbGV0ZXMgdGhlIHRpbWVyLCBjYW5jZWxzIGl0IGFuZCB0cmlnZ2VycyB0aGUgb25Db21wbGV0ZSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKS5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtDYWxsYmFjazx0aGlzPn0gW2NhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdGhlbihjYWxsYmFjayA9IG5vb3ApIHtcbiAgICBjb25zdCB0aGVuID0gdGhpcy50aGVuO1xuICAgIGNvbnN0IG9uUmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgIC8vIHRoaXMudGhlbiA9IG51bGwgcHJldmVudHMgaW5maW5pdGUgcmVjdXJzaW9uIGlmIHJldHVybmVkIGJ5IGFuIGFzeW5jIGZ1bmN0aW9uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFuZ2Fybmllcm9yZy9hbmltZS1iZXRhL2lzc3Vlcy8yNlxuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlc29sdmUgaW1lZGlhdGx5IGlmIHRoZSB0aW1lciBoYXMgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlZCkgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH1cblxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtUaW1lclBhcmFtc30gW3BhcmFtZXRlcnNdXG4gKiBAcmV0dXJuIHtUaW1lcn1cbiAqL1xuY29uc3QgY3JlYXRlVGltZXIgPSBwYXJhbWV0ZXJzID0+IG5ldyBUaW1lcihwYXJhbWV0ZXJzLCBudWxsLCAwKS5pbml0KCk7XG5cblxuXG5cbi8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG5jb25zdCBub25lID0gdCA9PiB0O1xuXG4vLyBDdWJpYyBCZXppZXIgc29sdmVyIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNlIMKpIEdhw6t0YW4gUmVuYXVkZWF1XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSBhVFxuICogQHBhcmFtICB7TnVtYmVyfSBhQTFcbiAqIEBwYXJhbSAge051bWJlcn0gYUEyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGNhbGNCZXppZXIgPSAoYVQsIGFBMSwgYUEyKSA9PiAoKCgxIC0gMyAqIGFBMiArIDMgKiBhQTEpICogYVQgKyAoMyAqIGFBMiAtIDYgKiBhQTEpKSAqIGFUICsgKDMgKiBhQTEpKSAqIGFUO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gYVhcbiAqIEBwYXJhbSAge051bWJlcn0gbVgxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1YMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBiaW5hcnlTdWJkaXZpZGUgPSAoYVgsIG1YMSwgbVgyKSA9PiB7XG4gIGxldCBhQSA9IDAsIGFCID0gMSwgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKGFicyhjdXJyZW50WCkgPiAuMDAwMDAwMSAmJiArK2kgPCAxMDApO1xuICByZXR1cm4gY3VycmVudFQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gW21YMV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMV1cbiAqIEBwYXJhbSAge051bWJlcn0gW21YMl1cbiAqIEBwYXJhbSAge051bWJlcn0gW21ZMl1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGN1YmljQmV6aWVyID0gKG1YMSA9IDAuNSwgbVkxID0gMC4wLCBtWDIgPSAwLjUsIG1ZMiA9IDEuMCkgPT4gKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSA/IG5vbmUgOlxuICB0ID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOlxuICBjYWxjQmV6aWVyKGJpbmFyeVN1YmRpdmlkZSh0LCBtWDEsIG1YMiksIG1ZMSwgbVkyKTtcblxuLyoqXG4gKiBTdGVwcyBlYXNlIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0NTUy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuICogT25seSBjb3ZlcnMgJ2VuZCcgYW5kICdzdGFydCcganVtcHRlcm1zXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0ZXBzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZnJvbVN0YXJ0XVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IHN0ZXBzID0gKHN0ZXBzID0gMTAsIGZyb21TdGFydCkgPT4ge1xuICBjb25zdCByb3VuZE1ldGhvZCA9IGZyb21TdGFydCA/IGNlaWwgOiBmbG9vcjtcbiAgcmV0dXJuIHQgPT4gcm91bmRNZXRob2QoY2xhbXAodCwgMCwgMSkgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTtcbn07XG5cbi8qKlxuICogV2l0aG91dCBwYXJhbWV0ZXJzLCB0aGUgbGluZWFyIGZ1bmN0aW9uIGNyZWF0ZXMgYSBub24tZWFzZWQgdHJhbnNpdGlvbi5cbiAqIFBhcmFtZXRlcnMsIGlmIHVzZWQsIGNyZWF0ZXMgYSBwaWVjZXdpc2UgbGluZWFyIGVhc2luZyBieSBpbnRlcnBvbGF0aW5nIGxpbmVhcmx5IGJldHdlZW4gdGhlIHNwZWNpZmllZCBwb2ludHMuXG4gKiBAcGFyYW0gIHsuLi5TdHJpbmd8TnVtYmVyfSBbYXJnc10gLSBQb2ludHNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBsaW5lYXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIGlmICghYXJnc0xlbmd0aCkgcmV0dXJuIG5vbmU7XG4gIGNvbnN0IHRvdGFsUG9pbnRzID0gYXJnc0xlbmd0aCAtIDE7XG4gIGNvbnN0IGZpcnN0QXJnID0gYXJnc1swXTtcbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbdG90YWxQb2ludHNdO1xuICBjb25zdCB4UG9pbnRzID0gWzBdO1xuICBjb25zdCB5UG9pbnRzID0gW3BhcnNlTnVtYmVyKGZpcnN0QXJnKV07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxQb2ludHM7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgY29uc3Qgc3BsaXRWYWx1ZSA9IGlzU3RyKGFyZykgP1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqLyhhcmcpLnRyaW0oKS5zcGxpdCgnICcpIDpcbiAgICBbYXJnXTtcbiAgICBjb25zdCB2YWx1ZSA9IHNwbGl0VmFsdWVbMF07XG4gICAgY29uc3QgcGVyY2VudCA9IHNwbGl0VmFsdWVbMV07XG4gICAgeFBvaW50cy5wdXNoKCFpc1VuZChwZXJjZW50KSA/IHBhcnNlTnVtYmVyKHBlcmNlbnQpIC8gMTAwIDogaSAvIHRvdGFsUG9pbnRzKTtcbiAgICB5UG9pbnRzLnB1c2gocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICB5UG9pbnRzLnB1c2gocGFyc2VOdW1iZXIobGFzdEFyZykpO1xuICB4UG9pbnRzLnB1c2goMSk7XG4gIHJldHVybiBmdW5jdGlvbiBlYXNlTGluZWFyKHQpIHtcbiAgICBmb3IgKGxldCBpID0gMSwgbCA9IHhQb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50WCA9IHhQb2ludHNbaV07XG4gICAgICBpZiAodCA8PSBjdXJyZW50WCkge1xuICAgICAgICBjb25zdCBwcmV2WCA9IHhQb2ludHNbaSAtIDFdO1xuICAgICAgICBjb25zdCBwcmV2WSA9IHlQb2ludHNbaSAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlkgKyAoeVBvaW50c1tpXSAtIHByZXZZKSAqICh0IC0gcHJldlgpIC8gKGN1cnJlbnRYIC0gcHJldlgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geVBvaW50c1t5UG9pbnRzLmxlbmd0aCAtIDFdO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHJhbmRvbSBzdGVwc1xuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXSAtIFRoZSBudW1iZXIgb2Ygc3RlcHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3JhbmRvbW5lc3NdIC0gSG93IHN0cm9uZyB0aGUgcmFuZG9tbmVzcyBpc1xuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IGlycmVndWxhciA9IChsZW5ndGggPSAxMCwgcmFuZG9tbmVzcyA9IDEpID0+IHtcbiAgY29uc3QgdmFsdWVzID0gWzBdO1xuICBjb25zdCB0b3RhbCA9IGxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWw7IGkrKykge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB2YWx1ZXNbaSAtIDFdO1xuICAgIGNvbnN0IHNwYWNpbmcgPSBpIC8gdG90YWw7XG4gICAgY29uc3Qgc2VnbWVudEVuZCA9IChpICsgMSkgLyB0b3RhbDtcbiAgICBjb25zdCByYW5kb21WYXJpYXRpb24gPSBzcGFjaW5nICsgKHNlZ21lbnRFbmQgLSBzcGFjaW5nKSAqIE1hdGgucmFuZG9tKCk7XG4gICAgLy8gTWl4IHRoZSBldmVuIHNwYWNpbmcgYW5kIHJhbmRvbSB2YXJpYXRpb24gYmFzZWQgb24gdGhlIHJhbmRvbW5lc3MgcGFyYW1ldGVyXG4gICAgY29uc3QgcmFuZG9tVmFsdWUgPSBzcGFjaW5nICogKDEgLSByYW5kb21uZXNzKSArIHJhbmRvbVZhcmlhdGlvbiAqIHJhbmRvbW5lc3M7XG4gICAgdmFsdWVzLnB1c2goY2xhbXAocmFuZG9tVmFsdWUsIHByZXZpb3VzVmFsdWUsIDEpKTtcbiAgfVxuICB2YWx1ZXMucHVzaCgxKTtcbiAgcmV0dXJuIGxpbmVhciguLi52YWx1ZXMpO1xufTtcblxuLy8gRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2UgwqkgUm9iZXJ0IFBlbm5lclxuXG4vKipcbiAqIEBjYWxsYmFjayBQb3dlckVhc2luZ1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbcG93ZXI9MS42NzVdXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBCYWNrRWFzaW5nXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvdmVyc2hvb3Q9MS43MDE1OF1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEVsYXN0aWNFYXNpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2FtcGxpdHVkZT0xXVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbcGVyaW9kPS4zXVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgRWFzZUZhY3RvcnlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BhcmFtQV1cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW3BhcmFtQl1cbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufE51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGVkZWYge1Bvd2VyRWFzaW5nfEJhY2tFYXNpbmd8RWxhc3RpY0Vhc2luZ30gRWFzZXNGYWN0b3J5ICovXG5cbmNvbnN0IGhhbGZQSSA9IFBJIC8gMjtcbmNvbnN0IGRvdWJsZVBJID0gUEkgKiAyO1xuLyoqIEB0eXBlIHtQb3dlckVhc2luZ30gKi9cbmNvbnN0IGVhc2VJblBvd2VyID0gKHAgPSAxLjY4KSA9PiB0ID0+IHBvdyh0LCArcCk7XG5cbi8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgRWFzZXNGYWN0b3J5fEVhc2luZ0Z1bmN0aW9uPn0gKi9cbmNvbnN0IGVhc2VJbkZ1bmN0aW9ucyA9IHtcbiAgW2VtcHR5U3RyaW5nXTogZWFzZUluUG93ZXIsXG4gIFF1YWQ6IGVhc2VJblBvd2VyKDIpLFxuICBDdWJpYzogZWFzZUluUG93ZXIoMyksXG4gIFF1YXJ0OiBlYXNlSW5Qb3dlcig0KSxcbiAgUXVpbnQ6IGVhc2VJblBvd2VyKDUpLFxuICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICBTaW5lOiB0ID0+IDEgLSBjb3ModCAqIGhhbGZQSSksXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIENpcmM6IHQgPT4gMSAtIHNxcnQoMSAtIHQgKiB0KSxcbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgRXhwbzogdCA9PiB0ID8gcG93KDIsIDEwICogdCAtIDEwKSA6IDAsXG4gIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gIEJvdW5jZTogdCA9PiB7XG4gICAgbGV0IHBvdzIsIGIgPSA0O1xuICAgIHdoaWxlICh0IDwgKChwb3cyID0gcG93KDIsIC0tYikpIC0gMSkgLyAxMSk7XG4gICAgcmV0dXJuIDEgLyBwb3coNCwgMyAtIGIpIC0gNy41NjI1ICogcG93KChwb3cyICogMyAtIDIpIC8gMjIgLSB0LCAyKTtcbiAgfSxcbiAgLyoqIEB0eXBlIHtCYWNrRWFzaW5nfSAqL1xuICBCYWNrOiAob3ZlcnNob290ID0gMS43MDE1OCkgPT4gdCA9PiAoK292ZXJzaG9vdCArIDEpICogdCAqIHQgKiB0IC0gK292ZXJzaG9vdCAqIHQgKiB0LFxuICAvKiogQHR5cGUge0VsYXN0aWNFYXNpbmd9ICovXG4gIEVsYXN0aWM6IChhbXBsaXR1ZGUgPSAxLCBwZXJpb2QgPSAuMykgPT4ge1xuICAgIGNvbnN0IGEgPSBjbGFtcCgrYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgY29uc3QgcCA9IGNsYW1wKCtwZXJpb2QsIG1pblZhbHVlLCAyKTtcbiAgICBjb25zdCBzID0gKHAgLyBkb3VibGVQSSkgKiBhc2luKDEgLyBhKTtcbiAgICBjb25zdCBlID0gZG91YmxlUEkgLyBwO1xuICAgIHJldHVybiB0ID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAtYSAqIHBvdygyLCAtMTAgKiAoMSAtIHQpKSAqIHNpbigoKDEgLSB0KSAtIHMpICogZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEVhc2VUeXBlXG4gKiBAcGFyYW0ge0Vhc2luZ0Z1bmN0aW9ufSBFYXNlXG4gKiBAcmV0dXJuIHtFYXNpbmdGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2VUeXBlPn0gKi9cbmNvbnN0IGVhc2VUeXBlcyA9IHtcbiAgaW46IGVhc2VJbiA9PiB0ID0+IGVhc2VJbih0KSxcbiAgb3V0OiBlYXNlSW4gPT4gdCA9PiAxIC0gZWFzZUluKDEgLSB0KSxcbiAgaW5PdXQ6IGVhc2VJbiA9PiB0ID0+IHQgPCAuNSA/IGVhc2VJbih0ICogMikgLyAyIDogMSAtIGVhc2VJbih0ICogLTIgKyAyKSAvIDIsXG4gIG91dEluOiBlYXNlSW4gPT4gdCA9PiB0IDwgLjUgPyAoMSAtIGVhc2VJbigxIC0gdCAqIDIpKSAvIDIgOiAoZWFzZUluKHQgKiAyIC0gMSkgKyAxKSAvIDIsXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0gIHtSZWNvcmQ8U3RyaW5nLCBFYXNlc0ZhY3Rvcnl8RWFzaW5nRnVuY3Rpb24+fSBlYXNlc0Z1bmN0aW9uc1xuICogQHBhcmFtICB7T2JqZWN0fSBlYXNlc0xvb2t1cHNcbiAqIEByZXR1cm4ge0Vhc2luZ0Z1bmN0aW9ufVxuICovXG5jb25zdCBwYXJzZUVhc2VTdHJpbmcgPSAoc3RyaW5nLCBlYXNlc0Z1bmN0aW9ucywgZWFzZXNMb29rdXBzKSA9PiB7XG4gIGlmIChlYXNlc0xvb2t1cHNbc3RyaW5nXSkgcmV0dXJuIGVhc2VzTG9va3Vwc1tzdHJpbmddO1xuICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA8PSAtMSkge1xuICAgIGNvbnN0IGhhc1BhcmFtcyA9IGVhc2VUeXBlc1tzdHJpbmddIHx8IHN0cmluZy5pbmNsdWRlcygnQmFjaycpIHx8IHN0cmluZy5pbmNsdWRlcygnRWxhc3RpYycpO1xuICAgIGNvbnN0IHBhcnNlZEZuID0gLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi8oaGFzUGFyYW1zID8gLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl9ICovKGVhc2VzRnVuY3Rpb25zW3N0cmluZ10pKCkgOiBlYXNlc0Z1bmN0aW9uc1tzdHJpbmddKTtcbiAgICByZXR1cm4gcGFyc2VkRm4gPyBlYXNlc0xvb2t1cHNbc3RyaW5nXSA9IHBhcnNlZEZuIDogbm9uZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzcGxpdCA9IHN0cmluZy5zbGljZSgwLCAtMSkuc3BsaXQoJygnKTtcbiAgICBjb25zdCBwYXJzZWRGbiA9IC8qKiBAdHlwZSB7RWFzZXNGYWN0b3J5fSAqLyhlYXNlc0Z1bmN0aW9uc1tzcGxpdFswXV0pO1xuICAgIHJldHVybiBwYXJzZWRGbiA/IGVhc2VzTG9va3Vwc1tzdHJpbmddID0gcGFyc2VkRm4oLi4uc3BsaXRbMV0uc3BsaXQoJywnKSkgOiBub25lO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBFYXNlc0Z1bmN0aW9uc1xuICogQHByb3BlcnR5IHt0eXBlb2YgbGluZWFyfSBsaW5lYXJcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGlycmVndWxhcn0gaXJyZWd1bGFyXG4gKiBAcHJvcGVydHkge3R5cGVvZiBzdGVwc30gc3RlcHNcbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGN1YmljQmV6aWVyfSBjdWJpY0JlemllclxuICogQHByb3BlcnR5IHtQb3dlckVhc2luZ30gaW5cbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IG91dFxuICogQHByb3BlcnR5IHtQb3dlckVhc2luZ30gaW5PdXRcbiAqIEBwcm9wZXJ0eSB7UG93ZXJFYXNpbmd9IG91dEluXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0UXVhZFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5RdWFkXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkN1YmljXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRDdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5PdXRDdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5DdWJpY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gaW5RdWFydFxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0UXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0UXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluUXVpbnRcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dFF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBvdXRJblF1aW50XG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpblNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0U2luZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5TaW5lXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkNpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dENpcmNcbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0Q2lyY1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5DaXJjXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IG91dEV4cG9cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nRnVuY3Rpb259IGluT3V0RXhwb1xuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5FeHBvXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbkJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0Qm91bmNlXG4gKiBAcHJvcGVydHkge0Vhc2luZ0Z1bmN0aW9ufSBpbk91dEJvdW5jZVxuICogQHByb3BlcnR5IHtFYXNpbmdGdW5jdGlvbn0gb3V0SW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7QmFja0Vhc2luZ30gaW5CYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IG91dEJhY2tcbiAqIEBwcm9wZXJ0eSB7QmFja0Vhc2luZ30gaW5PdXRCYWNrXG4gKiBAcHJvcGVydHkge0JhY2tFYXNpbmd9IG91dEluQmFja1xuICogQHByb3BlcnR5IHtFbGFzdGljRWFzaW5nfSBpbkVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gb3V0RWxhc3RpY1xuICogQHByb3BlcnR5IHtFbGFzdGljRWFzaW5nfSBpbk91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RWxhc3RpY0Vhc2luZ30gb3V0SW5FbGFzdGljXG4gKi9cblxuY29uc3QgZWFzZXMgPSAoLyojX19QVVJFX18qLyAoKCkgPT4ge1xuICBjb25zdCBsaXN0ID0geyBsaW5lYXIsIGlycmVndWxhciwgc3RlcHMsIGN1YmljQmV6aWVyIH07XG4gIGZvciAobGV0IHR5cGUgaW4gZWFzZVR5cGVzKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBlYXNlSW5GdW5jdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVhc2VJbiA9IGVhc2VJbkZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgIGNvbnN0IGVhc2VUeXBlID0gZWFzZVR5cGVzW3R5cGVdO1xuICAgICAgbGlzdFt0eXBlICsgbmFtZV0gPSAvKiogQHR5cGUge0Vhc2VzRmFjdG9yeXxFYXNpbmdGdW5jdGlvbn0gKi8oXG4gICAgICAgIG5hbWUgPT09IGVtcHR5U3RyaW5nIHx8IG5hbWUgPT09ICdCYWNrJyB8fCBuYW1lID09PSAnRWxhc3RpYycgP1xuICAgICAgICAoYSwgYikgPT4gZWFzZVR5cGUoLyoqIEB0eXBlIHtFYXNlc0ZhY3Rvcnl9ICovKGVhc2VJbikoYSwgYikpIDpcbiAgICAgICAgZWFzZVR5cGUoLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi8oZWFzZUluKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0Vhc2VzRnVuY3Rpb25zfSAqLyhsaXN0KTtcbn0pKCkpO1xuXG4vKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi9cbmNvbnN0IEpTRWFzZXNMb29rdXBzID0geyBsaW5lYXI6IG5vbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0gIHtFYXNpbmdQYXJhbX0gZWFzZVxuICogQHJldHVybiB7RWFzaW5nRnVuY3Rpb259XG4gKi9cbmNvbnN0IHBhcnNlRWFzaW5ncyA9IGVhc2UgPT4gaXNGbmMoZWFzZSkgPyBlYXNlIDpcbiAgaXNTdHIoZWFzZSkgPyBwYXJzZUVhc2VTdHJpbmcoLyoqIEB0eXBlIHtTdHJpbmd9ICovKGVhc2UpLCBlYXNlcywgSlNFYXNlc0xvb2t1cHMpIDpcbiAgbm9uZTtcblxuXG5cblxuY29uc3QgcHJvcGVydHlOYW1lc0NhY2hlID0ge307XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAqIEBwYXJhbSAge1RhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHt0d2VlblR5cGVzfSB0d2VlblR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3Qgc2FuaXRpemVQcm9wZXJ0eU5hbWUgPSAocHJvcGVydHlOYW1lLCB0YXJnZXQsIHR3ZWVuVHlwZSkgPT4ge1xuICBpZiAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgIGNvbnN0IHQgPSBzaG9ydFRyYW5zZm9ybXMuZ2V0KHByb3BlcnR5TmFtZSk7XG4gICAgcmV0dXJuIHQgPyB0IDogcHJvcGVydHlOYW1lO1xuICB9IGVsc2UgaWYgKFxuICAgIHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5DU1MgfHxcbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlcyB3aGVyZSBwcm9wZXJ0aWVzIGxpa2UgXCJzdHJva2VEYXNob2Zmc2V0XCIgbmVlZHMgdG8gYmUgc2V0IGFzIFwic3Ryb2tlLWRhc2hvZmZzZXRcIlxuICAgIC8vIGJ1dCBwcm9wZXJ0aWVzIGxpa2UgXCJiYXNlRnJlcXVlbmN5XCIgc2hvdWxkIHN0YXkgaW4gbG93ZXJDYW1lbENhc2VcbiAgICAodHdlZW5UeXBlID09PSB0d2VlblR5cGVzLkFUVFJJQlVURSAmJiAoaXNTdmcodGFyZ2V0KSAmJiBwcm9wZXJ0eU5hbWUgaW4gLyoqIEB0eXBlIHtET01UYXJnZXR9ICovKHRhcmdldCkuc3R5bGUpKVxuICApIHtcbiAgICBjb25zdCBjYWNoZWRQcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzQ2FjaGVbcHJvcGVydHlOYW1lXTtcbiAgICBpZiAoY2FjaGVkUHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvcGVydHlOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsb3dlckNhc2VOYW1lID0gcHJvcGVydHlOYW1lID8gdG9Mb3dlckNhc2UocHJvcGVydHlOYW1lKSA6IHByb3BlcnR5TmFtZTtcbiAgICAgIHByb3BlcnR5TmFtZXNDYWNoZVtwcm9wZXJ0eU5hbWVdID0gbG93ZXJDYXNlTmFtZTtcbiAgICAgIHJldHVybiBsb3dlckNhc2VOYW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcGVydHlOYW1lO1xuICB9XG59O1xuXG5cblxuXG5jb25zdCBhbmdsZVVuaXRzTWFwID0geyAnZGVnJzogMSwgJ3JhZCc6IDE4MCAvIFBJLCAndHVybic6IDM2MCB9O1xuY29uc3QgY29udmVydGVkVmFsdWVzQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0gIHtET01UYXJnZXR9IGVsXG4gKiBAcGFyYW0gIHtUd2VlbkRlY29tcG9zZWRWYWx1ZX0gZGVjb21wb3NlZFZhbHVlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVuaXRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm4ge1R3ZWVuRGVjb21wb3NlZFZhbHVlfVxuICovXG5jb25zdCBjb252ZXJ0VmFsdWVVbml0ID0gKGVsLCBkZWNvbXBvc2VkVmFsdWUsIHVuaXQsIGZvcmNlID0gZmFsc2UpID0+IHtcbiAgY29uc3QgY3VycmVudFVuaXQgPSBkZWNvbXBvc2VkVmFsdWUudTtcbiAgY29uc3QgY3VycmVudE51bWJlciA9IGRlY29tcG9zZWRWYWx1ZS5uO1xuICBpZiAoZGVjb21wb3NlZFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCAmJiBjdXJyZW50VW5pdCA9PT0gdW5pdCkgeyAvLyBUT0RPOiBDaGVjayBpZiBjaGVja2luZyBhZ2FpbnN0IHRoZSBzYW1lIHVuaXQgc3RyaW5nIGlzIG5lY2Vzc2FyeVxuICAgIHJldHVybiBkZWNvbXBvc2VkVmFsdWU7XG4gIH1cbiAgY29uc3QgY2FjaGVkS2V5ID0gY3VycmVudE51bWJlciArIGN1cnJlbnRVbml0ICsgdW5pdDtcbiAgY29uc3QgY2FjaGVkID0gY29udmVydGVkVmFsdWVzQ2FjaGVbY2FjaGVkS2V5XTtcbiAgaWYgKCFpc1VuZChjYWNoZWQpICYmICFmb3JjZSkge1xuICAgIGRlY29tcG9zZWRWYWx1ZS5uID0gY2FjaGVkO1xuICB9IGVsc2Uge1xuICAgIGxldCBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBpZiAoY3VycmVudFVuaXQgaW4gYW5nbGVVbml0c01hcCkge1xuICAgICAgY29udmVydGVkVmFsdWUgPSBjdXJyZW50TnVtYmVyICogYW5nbGVVbml0c01hcFtjdXJyZW50VW5pdF0gLyBhbmdsZVVuaXRzTWFwW3VuaXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiYXNlbGluZSA9IDEwMDtcbiAgICAgIGNvbnN0IHRlbXBFbCA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhlbC5jbG9uZU5vZGUoKSk7XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIGNvbnN0IHBhcmVudEVsID0gKHBhcmVudE5vZGUgJiYgKHBhcmVudE5vZGUgIT09IGRvYykpID8gcGFyZW50Tm9kZSA6IGRvYy5ib2R5O1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGVtcEVsKTtcbiAgICAgIGNvbnN0IGVsU3R5bGUgPSB0ZW1wRWwuc3R5bGU7XG4gICAgICBlbFN0eWxlLndpZHRoID0gYmFzZWxpbmUgKyBjdXJyZW50VW5pdDtcbiAgICAgIGNvbnN0IGN1cnJlbnRVbml0V2lkdGggPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyh0ZW1wRWwpLm9mZnNldFdpZHRoIHx8IGJhc2VsaW5lO1xuICAgICAgZWxTdHlsZS53aWR0aCA9IGJhc2VsaW5lICsgdW5pdDtcbiAgICAgIGNvbnN0IG5ld1VuaXRXaWR0aCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHRlbXBFbCkub2Zmc2V0V2lkdGggfHwgYmFzZWxpbmU7XG4gICAgICBjb25zdCBmYWN0b3IgPSBjdXJyZW50VW5pdFdpZHRoIC8gbmV3VW5pdFdpZHRoO1xuICAgICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgICAgIGNvbnZlcnRlZFZhbHVlID0gZmFjdG9yICogY3VycmVudE51bWJlcjtcbiAgICB9XG4gICAgZGVjb21wb3NlZFZhbHVlLm4gPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICBjb252ZXJ0ZWRWYWx1ZXNDYWNoZVtjYWNoZWRLZXldID0gY29udmVydGVkVmFsdWU7XG4gIH1cbiAgZGVjb21wb3NlZFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVDtcbiAgZGVjb21wb3NlZFZhbHVlLnUgPSB1bml0O1xuICByZXR1cm4gZGVjb21wb3NlZFZhbHVlO1xufTtcblxuXG5cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlbmRlcmFibGV9IFRcbiAqIEBwYXJhbSB7VH0gcmVuZGVyYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgY2xlYW5JbmxpbmVTdHlsZXMgPSByZW5kZXJhYmxlID0+IHtcbiAgLy8gQWxsb3cgY2xlYW5JbmxpbmVTdHlsZXMoKSB0byBiZSBjYWxsZWQgb24gdGltZWxpbmVzXG4gIGlmIChyZW5kZXJhYmxlLl9oYXNDaGlsZHJlbikge1xuICAgIGZvckVhY2hDaGlsZHJlbihyZW5kZXJhYmxlLCBjbGVhbklubGluZVN0eWxlcywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocmVuZGVyYWJsZSk7XG4gICAgYW5pbWF0aW9uLnBhdXNlKCk7XG4gICAgZm9yRWFjaENoaWxkcmVuKGFuaW1hdGlvbiwgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIGNvbnN0IHR3ZWVuUHJvcGVydHkgPSB0d2Vlbi5wcm9wZXJ0eTtcbiAgICAgIGNvbnN0IHR3ZWVuVGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuICAgICAgaWYgKHR3ZWVuVGFyZ2V0W2lzRG9tU3ltYm9sXSkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdHlsZSA9IC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0d2VlblRhcmdldCkuc3R5bGU7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5saW5lZFZhbHVlID0gYW5pbWF0aW9uLl9pbmxpbmVTdHlsZXNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICAgIGlmICh0d2Vlbi5fdHdlZW5UeXBlID09PSB0d2VlblR5cGVzLlRSQU5TRk9STSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSB0d2VlblRhcmdldFt0cmFuc2Zvcm1zU3ltYm9sXTtcbiAgICAgICAgICBpZiAoaXNVbmQob3JpZ2luYWxJbmxpbmVkVmFsdWUpIHx8IG9yaWdpbmFsSW5saW5lZFZhbHVlID09PSBlbXB0eVN0cmluZykge1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlZFRyYW5zZm9ybXNbdHdlZW5Qcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbdHdlZW5Qcm9wZXJ0eV0gPSBvcmlnaW5hbElubGluZWRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGNhY2hlZFRyYW5zZm9ybXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0YXJnZXRTdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgc3RyID0gZW1wdHlTdHJpbmc7XG4gICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBjYWNoZWRUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHRyYW5zZm9ybXNGcmFnbWVudFN0cmluZ3Nba2V5XSArIGNhY2hlZFRyYW5zZm9ybXNba2V5XSArICcpICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0U3R5bGUudHJhbnNmb3JtID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmQob3JpZ2luYWxJbmxpbmVkVmFsdWUpIHx8IG9yaWdpbmFsSW5saW5lZFZhbHVlID09PSBlbXB0eVN0cmluZykge1xuICAgICAgICAgICAgdGFyZ2V0U3R5bGUucmVtb3ZlUHJvcGVydHkodHdlZW5Qcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFN0eWxlW3R3ZWVuUHJvcGVydHldID0gb3JpZ2luYWxJbmxpbmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24uX3RhaWwgPT09IHR3ZWVuKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgIGlmICh0LmdldEF0dHJpYnV0ZSAmJiB0LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA9PT0gZW1wdHlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB9ICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmFibGU7XG59O1xuXG4vLyBEZWZpbmVzIGRlY29tcG9zZWQgdmFsdWVzIHRhcmdldCBvYmplY3RzIG9ubHkgb25jZSBhbmQgbXV0YXRlIHRoZWlyIHByb3BlcnRpZXMgbGF0ZXIgdG8gYXZvaWQgR0Ncbi8vIFRPRE86IE1heWJlIG1vdmUgdGhlIG9iamVjdHMgY3JlYXRpb24gdG8gdmFsdWVzLmpzIGFuZCB1c2UgdGhlIGRlY29tcG9zZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGJhc2Ugb2JqZWN0XG5jb25zdCBmcm9tVGFyZ2V0T2JqZWN0ID0gY3JlYXRlRGVjb21wb3NlZFZhbHVlVGFyZ2V0T2JqZWN0KCk7XG5jb25zdCB0b1RhcmdldE9iamVjdCA9IGNyZWF0ZURlY29tcG9zZWRWYWx1ZVRhcmdldE9iamVjdCgpO1xuY29uc3QgdG9GdW5jdGlvblN0b3JlID0geyBmdW5jOiBudWxsIH07XG5jb25zdCBrZXlmcmFtZXNUYXJnZXRBcnJheSA9IFtudWxsXTtcbmNvbnN0IGZhc3RTZXRWYWx1ZXNBcnJheSA9IFtudWxsLCBudWxsXTtcbi8qKiBAdHlwZSB7VHdlZW5LZXlWYWx1ZX0gKi9cbmNvbnN0IGtleU9iamVjdFRhcmdldCA9IHsgdG86IG51bGwgfTtcblxubGV0IHR3ZWVuSWQgPSAwO1xubGV0IGtleWZyYW1lcztcbi8qKiBAdHlwZSB7VHdlZW5QYXJhbXNPcHRpb25zICYgVHdlZW5WYWx1ZXN9ICovXG5sZXQga2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7RHVyYXRpb25LZXlmcmFtZXMgfCBQZXJjZW50YWdlS2V5ZnJhbWVzfSBrZXlmcmFtZXNcbiAqIEBwYXJhbSB7QW5pbWF0aW9uUGFyYW1zfSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtBbmltYXRpb25QYXJhbXN9XG4gKi9cbmNvbnN0IGdlbmVyYXRlS2V5ZnJhbWVzID0gKGtleWZyYW1lcywgcGFyYW1ldGVycykgPT4ge1xuICAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi9cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICBpZiAoaXNBcnIoa2V5ZnJhbWVzKSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBbXS5jb25jYXQoLi4uLyoqIEB0eXBlIHtEdXJhdGlvbktleWZyYW1lc30gKi8oa2V5ZnJhbWVzKS5tYXAoa2V5ID0+IE9iamVjdC5rZXlzKGtleSkpKS5maWx0ZXIoaXNLZXkpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgICAgIGNvbnN0IHByb3BBcnJheSA9IC8qKiBAdHlwZSB7RHVyYXRpb25LZXlmcmFtZXN9ICovKGtleWZyYW1lcykubWFwKGtleSA9PiB7XG4gICAgICAgIC8qKiBAdHlwZSB7VHdlZW5LZXlWYWx1ZX0gKi9cbiAgICAgICAgY29uc3QgbmV3S2V5ID0ge307XG4gICAgICAgIGZvciAobGV0IHAgaW4ga2V5KSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSAvKiogQHR5cGUge1R3ZWVuUHJvcFZhbHVlfSAqLyhrZXlbcF0pO1xuICAgICAgICAgIGlmIChpc0tleShwKSkge1xuICAgICAgICAgICAgaWYgKHAgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIG5ld0tleS50byA9IGtleVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICAgIH0pO1xuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSAvKiogQHR5cGUge0FycmF5U3ludGF4VmFsdWV9ICovKHByb3BBcnJheSk7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzZXRWYWx1ZShwYXJhbWV0ZXJzLmR1cmF0aW9uLCBnbG9iYWxzLmRlZmF1bHRzLmR1cmF0aW9uKSk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGtleWZyYW1lcylcbiAgICAubWFwKGtleSA9PiB7IHJldHVybiB7bzogcGFyc2VGbG9hdChrZXkpIC8gMTAwLCBwOiBrZXlmcmFtZXNba2V5XX0gfSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5vIC0gYi5vKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGtleS5vO1xuICAgICAgY29uc3QgcHJvcCA9IGtleS5wO1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm9wKSB7XG4gICAgICAgIGlmIChpc0tleShuYW1lKSkge1xuICAgICAgICAgIGxldCBwcm9wQXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhwcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgICAgICBpZiAoIXByb3BBcnJheSkgcHJvcEFycmF5ID0gcHJvcGVydGllc1tuYW1lXSA9IFtdO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gb2Zmc2V0ICogdG90YWxEdXJhdGlvbjtcbiAgICAgICAgICBsZXQgbGVuZ3RoID0gcHJvcEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBsZXQgcHJldktleSA9IHByb3BBcnJheVtsZW5ndGggLSAxXTtcbiAgICAgICAgICBjb25zdCBrZXlPYmogPSB7IHRvOiBwcm9wW25hbWVdIH07XG4gICAgICAgICAgbGV0IGR1clByb2dyZXNzID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkdXJQcm9ncmVzcyArPSBwcm9wQXJyYXlbaV0uZHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGtleU9iai5mcm9tID0gcHJldktleS50bztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3AuZWFzZSkge1xuICAgICAgICAgICAga2V5T2JqLmVhc2UgPSBwcm9wLmVhc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleU9iai5kdXJhdGlvbiA9IGR1cmF0aW9uIC0gKGxlbmd0aCA/IGR1clByb2dyZXNzIDogMCk7XG4gICAgICAgICAgcHJvcEFycmF5LnB1c2goa2V5T2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9KTtcblxuICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgY29uc3QgcHJvcEFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8ocHJvcGVydGllc1tuYW1lXSk7XG4gICAgICBsZXQgcHJldkVhc2U7XG4gICAgICAvLyBsZXQgZHVyUHJvZ3Jlc3MgPSAwXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHByb3BBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BBcnJheVtpXTtcbiAgICAgICAgLy8gRW11bGF0ZSBXQVBQSSBlYXNpbmcgcGFyYW1ldGVyIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFYXNlID0gcHJvcC5lYXNlO1xuICAgICAgICBwcm9wLmVhc2UgPSBwcmV2RWFzZSA/IHByZXZFYXNlIDogdW5kZWZpbmVkO1xuICAgICAgICBwcmV2RWFzZSA9IGN1cnJlbnRFYXNlO1xuICAgICAgICAvLyBkdXJQcm9ncmVzcyArPSBwcm9wLmR1cmF0aW9uO1xuICAgICAgICAvLyBpZiAoaSA9PT0gbCAtIDEgJiYgZHVyUHJvZ3Jlc3MgIT09IHRvdGFsRHVyYXRpb24pIHtcbiAgICAgICAgLy8gICBwcm9wQXJyYXkucHVzaCh7IGZyb206IHByb3AudG8sIGVhc2U6IHByb3AuZWFzZSwgZHVyYXRpb246IHRvdGFsRHVyYXRpb24gLSBkdXJQcm9ncmVzcyB9KVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoIXByb3BBcnJheVswXS5kdXJhdGlvbikge1xuICAgICAgICBwcm9wQXJyYXkuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuY2xhc3MgSlNBbmltYXRpb24gZXh0ZW5kcyBUaW1lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGlvblBhcmFtc30gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge1RpbWVsaW5lfSBbcGFyZW50XVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmVudFBvc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmYXN0U2V0PWZhbHNlXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4PTBdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGVuZ3RoPTBdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0YXJnZXRzLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBvc2l0aW9uLFxuICAgIGZhc3RTZXQgPSBmYWxzZSxcbiAgICBpbmRleCA9IDAsXG4gICAgbGVuZ3RoID0gMFxuICApIHtcblxuICAgIHN1cGVyKC8qKiBAdHlwZSB7VGltZXJQYXJhbXMmQW5pbWF0aW9uUGFyYW1zfSAqLyhwYXJhbWV0ZXJzKSwgcGFyZW50LCBwYXJlbnRQb3NpdGlvbik7XG5cbiAgICBjb25zdCBwYXJzZWRUYXJnZXRzID0gcmVnaXN0ZXJUYXJnZXRzKHRhcmdldHMpO1xuICAgIGNvbnN0IHRhcmdldHNMZW5ndGggPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIC8vIElmIHRoZSBwYXJhbWV0ZXJzIG9iamVjdCBjb250YWlucyBhIFwia2V5ZnJhbWVzXCIgcHJvcGVydHksIGNvbnZlcnQgYWxsIHRoZSBrZXlmcmFtZXMgdmFsdWVzIHRvIHJlZ3VsYXIgcHJvcGVydGllc1xuXG4gICAgY29uc3Qga2ZQYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8ocGFyYW1ldGVycykua2V5ZnJhbWVzO1xuICAgIGNvbnN0IHBhcmFtcyA9IC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqLyhrZlBhcmFtcyA/IG1lcmdlT2JqZWN0cyhnZW5lcmF0ZUtleWZyYW1lcygvKiogQHR5cGUge0R1cmF0aW9uS2V5ZnJhbWVzfSAqLyhrZlBhcmFtcyksIHBhcmFtZXRlcnMpLCBwYXJhbWV0ZXJzKSA6IHBhcmFtZXRlcnMpO1xuXG4gICAgY29uc3Qge1xuICAgICAgZGVsYXksXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2UsXG4gICAgICBwbGF5YmFja0Vhc2UsXG4gICAgICBtb2RpZmllcixcbiAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgb25SZW5kZXIsXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGNvbnN0IGFuaW1EZWZhdWx0cyA9IHBhcmVudCA/IHBhcmVudC5kZWZhdWx0cyA6IGdsb2JhbHMuZGVmYXVsdHM7XG4gICAgY29uc3QgYW5pbWFQbGF5YmFja0Vhc2UgPSBzZXRWYWx1ZShwbGF5YmFja0Vhc2UsIGFuaW1EZWZhdWx0cy5wbGF5YmFja0Vhc2UpO1xuICAgIGNvbnN0IGFuaW1FYXNlID0gYW5pbWFQbGF5YmFja0Vhc2UgPyBwYXJzZUVhc2luZ3MoYW5pbWFQbGF5YmFja0Vhc2UpIDogbnVsbDtcbiAgICBjb25zdCBoYXNTcHJpbmcgPSAhaXNVbmQoZWFzZSkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgICBjb25zdCB0RWFzaW5nID0gaGFzU3ByaW5nID8gLyoqIEB0eXBlIHtTcHJpbmd9ICovKGVhc2UpLmVhc2UgOiBzZXRWYWx1ZShlYXNlLCBhbmltRWFzZSA/ICdsaW5lYXInIDogYW5pbURlZmF1bHRzLmVhc2UpO1xuICAgIGNvbnN0IHREdXJhdGlvbiA9IGhhc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5kdXJhdGlvbiA6IHNldFZhbHVlKGR1cmF0aW9uLCBhbmltRGVmYXVsdHMuZHVyYXRpb24pO1xuICAgIGNvbnN0IHREZWxheSA9IHNldFZhbHVlKGRlbGF5LCBhbmltRGVmYXVsdHMuZGVsYXkpO1xuICAgIGNvbnN0IHRNb2RpZmllciA9IG1vZGlmaWVyIHx8IGFuaW1EZWZhdWx0cy5tb2RpZmllcjtcbiAgICAvLyBJZiBubyBjb21wb3NpdGlvbiBpcyBkZWZpbmVkIGFuZCB0aGUgdGFyZ2V0cyBsZW5ndGggaXMgaGlnaCAoPj0gMTAwMCkgc2V0IHRoZSBjb21wb3NpdGlvbiB0byAnbm9uZScgKDApIGZvciBmYXN0ZXIgdHdlZW4gY3JlYXRpb25cbiAgICBjb25zdCB0Q29tcG9zaXRpb24gPSBpc1VuZChjb21wb3NpdGlvbikgJiYgdGFyZ2V0c0xlbmd0aCA+PSBLID8gY29tcG9zaXRpb25UeXBlcy5ub25lIDogIWlzVW5kKGNvbXBvc2l0aW9uKSA/IGNvbXBvc2l0aW9uIDogYW5pbURlZmF1bHRzLmNvbXBvc2l0aW9uO1xuICAgIC8vIFRPRE86IERvIG5vdCBjcmVhdGUgYW4gZW1wdHkgb2JqZWN0IHVudGlsIHdlIGtub3cgdGhlIGFuaW1hdGlvbiB3aWxsIGdlbmVyYXRlIGlubGluZSBzdHlsZXNcbiAgICBjb25zdCBhbmltSW5saW5lU3R5bGVzID0ge307XG4gICAgLy8gY29uc3QgYWJzb2x1dGVPZmZzZXRUaW1lID0gdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0VGltZSA9IHRoaXMuX29mZnNldCArIChwYXJlbnQgPyBwYXJlbnQuX29mZnNldCA6IDApO1xuXG4gICAgbGV0IGl0ZXJhdGlvbkR1cmF0aW9uID0gTmFOO1xuICAgIGxldCBpdGVyYXRpb25EZWxheSA9IE5hTjtcbiAgICBsZXQgYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoID0gMDtcbiAgICBsZXQgc2hvdWxkVHJpZ2dlclJlbmRlciA9IDA7XG5cbiAgICBmb3IgKGxldCB0YXJnZXRJbmRleCA9IDA7IHRhcmdldEluZGV4IDwgdGFyZ2V0c0xlbmd0aDsgdGFyZ2V0SW5kZXgrKykge1xuXG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXJzZWRUYXJnZXRzW3RhcmdldEluZGV4XTtcbiAgICAgIGNvbnN0IHRpID0gaW5kZXggfHwgdGFyZ2V0SW5kZXg7XG4gICAgICBjb25zdCB0bCA9IGxlbmd0aCB8fCB0YXJnZXRzTGVuZ3RoO1xuXG4gICAgICBsZXQgbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggPSBOYU47XG4gICAgICBsZXQgbGFzdFRyYW5zZm9ybUdyb3VwTGVuZ3RoID0gTmFOO1xuXG4gICAgICBmb3IgKGxldCBwIGluIHBhcmFtcykge1xuXG4gICAgICAgIGlmIChpc0tleShwKSkge1xuXG4gICAgICAgICAgY29uc3QgdHdlZW5UeXBlID0gZ2V0VHdlZW5UeXBlKHRhcmdldCwgcCk7XG5cbiAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHNhbml0aXplUHJvcGVydHlOYW1lKHAsIHRhcmdldCwgdHdlZW5UeXBlKTtcblxuICAgICAgICAgIGxldCBwcm9wVmFsdWUgPSBwYXJhbXNbcF07XG5cbiAgICAgICAgICBjb25zdCBpc1Byb3BWYWx1ZUFycmF5ID0gaXNBcnIocHJvcFZhbHVlKTtcblxuICAgICAgICAgIGlmIChmYXN0U2V0ICYmICFpc1Byb3BWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMF0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSBmYXN0U2V0VmFsdWVzQXJyYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogQWxsb3cgbmVzdGVkIGtleWZyYW1lcyBpbnNpZGUgT2JqZWN0VmFsdWUgdmFsdWUgKHByb3A6IHsgdG86IFsuNSwgMSwgLjc1LCAyLCAzXSB9KVxuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBwcm9wZXJ0eSB2YWx1ZXMgdG8gdmFsaWQga2V5ZnJhbWUgc3ludGF4OlxuICAgICAgICAgIC8vIFt4LCB5XSB0byBbe3RvOiBbeCwgeV19XSBvciB7dG86IHh9IHRvIFt7dG86IHh9XSBvciBrZWVwIGtleXMgc3ludGF4IFt7fSwge30sIHt9Li4uXVxuICAgICAgICAgIC8vIGNvbnN0IGtleWZyYW1lcyA9IGlzQXJyKHByb3BWYWx1ZSkgPyBwcm9wVmFsdWUubGVuZ3RoID09PSAyICYmICFpc09iaihwcm9wVmFsdWVbMF0pID8gW3sgdG86IHByb3BWYWx1ZSB9XSA6IHByb3BWYWx1ZSA6IFtwcm9wVmFsdWVdO1xuICAgICAgICAgIGlmIChpc1Byb3BWYWx1ZUFycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHByb3BWYWx1ZSkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaXNOb3RPYmplY3RWYWx1ZSA9ICFpc09iaihwcm9wVmFsdWVbMF0pO1xuICAgICAgICAgICAgLy8gQ29udmVydCBbeCwgeV0gdG8gW3t0bzogW3gsIHldfV1cbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PT0gMiAmJiBpc05vdE9iamVjdFZhbHVlKSB7XG4gICAgICAgICAgICAgIGtleU9iamVjdFRhcmdldC50byA9IC8qKiBAdHlwZSB7VHdlZW5QYXJhbVZhbHVlfSAqLygvKiogQHR5cGUge3Vua25vd259ICovKHByb3BWYWx1ZSkpO1xuICAgICAgICAgICAgICBrZXlmcmFtZXNUYXJnZXRBcnJheVswXSA9IGtleU9iamVjdFRhcmdldDtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzVGFyZ2V0QXJyYXk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFt4LCB5LCB6XSB0byBbW3gsIHldLCB6XVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJheUxlbmd0aCA+IDIgJiYgaXNOb3RPYmplY3RWYWx1ZSkge1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48TnVtYmVyPn0gKi8ocHJvcFZhbHVlKS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICBmYXN0U2V0VmFsdWVzQXJyYXlbMF0gPSB2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgZmFzdFNldFZhbHVlc0FycmF5WzFdID0gdjtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcy5wdXNoKGZhc3RTZXRWYWx1ZXNBcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lcy5wdXNoKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPSAvKiogQHR5cGUge0FycmF5LjxUd2VlbktleVZhbHVlPn0gKi8ocHJvcFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ZnJhbWVzVGFyZ2V0QXJyYXlbMF0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBrZXlmcmFtZXNUYXJnZXRBcnJheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc2libGluZ3MgPSBudWxsO1xuICAgICAgICAgIGxldCBwcmV2VHdlZW4gPSBudWxsO1xuICAgICAgICAgIGxldCBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lID0gTmFOO1xuICAgICAgICAgIGxldCBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lID0gMDtcbiAgICAgICAgICBsZXQgdHdlZW5JbmRleCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGxldCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgdHdlZW5JbmRleCA8IGw7IHR3ZWVuSW5kZXgrKykge1xuXG4gICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IGtleWZyYW1lc1t0d2VlbkluZGV4XTtcblxuICAgICAgICAgICAgaWYgKGlzT2JqKGtleWZyYW1lKSkge1xuICAgICAgICAgICAgICBrZXkgPSBrZXlmcmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGtleU9iamVjdFRhcmdldC50byA9IC8qKiBAdHlwZSB7VHdlZW5QYXJhbVZhbHVlfSAqLyhrZXlmcmFtZSk7XG4gICAgICAgICAgICAgIGtleSA9IGtleU9iamVjdFRhcmdldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9GdW5jdGlvblN0b3JlLmZ1bmMgPSBudWxsO1xuXG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFRvVmFsdWUgPSBnZXRGdW5jdGlvblZhbHVlKGtleS50bywgdGFyZ2V0LCB0aSwgdGwsIHRvRnVuY3Rpb25TdG9yZSk7XG5cbiAgICAgICAgICAgIGxldCB0d2VlblRvVmFsdWU7XG4gICAgICAgICAgICAvLyBBbGxvd3MgZnVuY3Rpb24gYmFzZWQgdmFsdWVzIHRvIHJldHVybiBhbiBvYmplY3Qgc3ludGF4IHZhbHVlICh7dG86IHZ9KVxuICAgICAgICAgICAgaWYgKGlzT2JqKGNvbXB1dGVkVG9WYWx1ZSkgJiYgIWlzVW5kKGNvbXB1dGVkVG9WYWx1ZS50bykpIHtcbiAgICAgICAgICAgICAga2V5ID0gY29tcHV0ZWRUb1ZhbHVlO1xuICAgICAgICAgICAgICB0d2VlblRvVmFsdWUgPSBjb21wdXRlZFRvVmFsdWUudG87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0d2VlblRvVmFsdWUgPSBjb21wdXRlZFRvVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0d2VlbkZyb21WYWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUoa2V5LmZyb20sIHRhcmdldCwgdGksIHRsKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUVhc2luZyA9IGtleS5lYXNlO1xuICAgICAgICAgICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGtleUVhc2luZykgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhrZXlFYXNpbmcpLmVhc2UpO1xuICAgICAgICAgICAgLy8gRWFzaW5nIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5IGFuZCBkb24ndCBhY2NlcHQgZnVuY3Rpb24gYmFzZWQgdmFsdWUgdG8gcHJldmVudCBoYXZpbmcgdG8gcGFzcyBhIGZ1bmN0aW9uIHdyYXBwZXIgdGhhdCByZXR1cm5zIGFuIG90aGVyIGZ1bmN0aW9uIGFsbCB0aGUgdGltZVxuICAgICAgICAgICAgY29uc3QgdHdlZW5FYXNpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5lYXNlIDoga2V5RWFzaW5nIHx8IHRFYXNpbmc7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZGVmYXVsdCBpbmRpdmlkdWFsIGtleWZyYW1lIGR1cmF0aW9uIGJ5IGRpdmlkaW5nIHRoZSB0bCBvZiBrZXlmcmFtZXNcbiAgICAgICAgICAgIGNvbnN0IHR3ZWVuRHVyYXRpb24gPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oa2V5RWFzaW5nKS5kdXJhdGlvbiA6IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmR1cmF0aW9uLCAobCA+IDEgPyBnZXRGdW5jdGlvblZhbHVlKHREdXJhdGlvbiwgdGFyZ2V0LCB0aSwgdGwpIC8gbCA6IHREdXJhdGlvbikpLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGRlbGF5IHZhbHVlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGZpcnN0IHR3ZWVuXG4gICAgICAgICAgICBjb25zdCB0d2VlbkRlbGF5ID0gZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShrZXkuZGVsYXksICghdHdlZW5JbmRleCA/IHREZWxheSA6IDApKSwgdGFyZ2V0LCB0aSwgdGwpO1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRDb21wb3NpdGlvbiA9IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUoa2V5LmNvbXBvc2l0aW9uLCB0Q29tcG9zaXRpb24pLCB0YXJnZXQsIHRpLCB0bCk7XG4gICAgICAgICAgICBjb25zdCB0d2VlbkNvbXBvc2l0aW9uID0gaXNOdW0oY29tcHV0ZWRDb21wb3NpdGlvbikgPyBjb21wdXRlZENvbXBvc2l0aW9uIDogY29tcG9zaXRpb25UeXBlc1tjb21wdXRlZENvbXBvc2l0aW9uXTtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgYWNjZXB0IGZ1bmN0aW9uIGJhc2VkIHZhbHVlIHRvIHByZXZlbnQgaGF2aW5nIHRvIHBhc3MgYSBmdW5jdGlvbiB3cmFwcGVyXG4gICAgICAgICAgICBjb25zdCB0d2Vlbk1vZGlmaWVyID0ga2V5Lm1vZGlmaWVyIHx8IHRNb2RpZmllcjtcbiAgICAgICAgICAgIGNvbnN0IGhhc0Zyb212YWx1ZSA9ICFpc1VuZCh0d2VlbkZyb21WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNUb1ZhbHVlID0gIWlzVW5kKHR3ZWVuVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBpc0Zyb21Ub0FycmF5ID0gaXNBcnIodHdlZW5Ub1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnJvbVRvVmFsdWUgPSBpc0Zyb21Ub0FycmF5IHx8IChoYXNGcm9tdmFsdWUgJiYgaGFzVG9WYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCB0d2VlblN0YXJ0VGltZSA9IHByZXZUd2VlbiA/IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgKyB0d2VlbkRlbGF5IDogdHdlZW5EZWxheTtcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlU3RhcnRUaW1lID0gYWJzb2x1dGVPZmZzZXRUaW1lICsgdHdlZW5TdGFydFRpbWU7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGEgb25SZW5kZXIgY2FsbGJhY2sgaWYgdGhlIGFuaW1hdGlvbiBjb250YWlucyBhdCBsZWFzdCBvbmUgZnJvbSB2YWx1ZSBhbmQgYXV0b3BsYXkgaXMgc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICBpZiAoIXNob3VsZFRyaWdnZXJSZW5kZXIgJiYgKGhhc0Zyb212YWx1ZSB8fCBpc0Zyb21Ub0FycmF5KSkgc2hvdWxkVHJpZ2dlclJlbmRlciA9IDE7XG5cbiAgICAgICAgICAgIGxldCBwcmV2U2libGluZyA9IHByZXZUd2VlbjtcblxuICAgICAgICAgICAgaWYgKHR3ZWVuQ29tcG9zaXRpb24gIT09IGNvbXBvc2l0aW9uVHlwZXMubm9uZSkge1xuICAgICAgICAgICAgICBpZiAoIXNpYmxpbmdzKSBzaWJsaW5ncyA9IGdldFR3ZWVuU2libGluZ3ModGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAgIGxldCBuZXh0U2libGluZyA9IHNpYmxpbmdzLl9oZWFkO1xuICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRyb3VnaCBhbGwgdGhlIG5leHQgc2libGluZ3MgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgd2l0aCBhbiBlcXVhbCBvciBpbmZlcmlvciBzdGFydCB0aW1lXG4gICAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZyAmJiAhbmV4dFNpYmxpbmcuX2lzT3ZlcnJpZGRlbiAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPD0gYWJzb2x1dGVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBwcmV2U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuX25leHRSZXA7XG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFsbCB0aGUgbmV4dCBzaWJsaW5ncyBpZiB0aGUgbmV4dCBzaWJsaW5nIHN0YXJ0cyBhdCB0aGUgc2FtZSB0aW1lIG9mIGFmdGVyIGFzIHRoZSBuZXcgdHdlZW4gc3RhcnQgdGltZVxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fYWJzb2x1dGVTdGFydFRpbWUgPj0gYWJzb2x1dGVTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZVR3ZWVuKG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuZHMgYm90aCB0aGUgY3VycmVudCB3aGlsZSBsb29wIGFuZCB0aGUgdXBwZXIgb25lIG9uY2UgYWxsIHRoZSBuZXh0IHNpYmxsaW5ncyBoYXZlIGJlZW4gb3ZlcnJpZGVuXG4gICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuX25leHRSZXA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29tcG9zZSB2YWx1ZXNcbiAgICAgICAgICAgIGlmIChpc0Zyb21Ub1ZhbHVlKSB7XG4gICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKGlzRnJvbVRvQXJyYXkgPyBnZXRGdW5jdGlvblZhbHVlKHR3ZWVuVG9WYWx1ZVswXSwgdGFyZ2V0LCB0aSwgdGwpIDogdHdlZW5Gcm9tVmFsdWUsIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShpc0Zyb21Ub0FycmF5ID8gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlblRvVmFsdWVbMV0sIHRhcmdldCwgdGksIHRsLCB0b0Z1bmN0aW9uU3RvcmUpIDogdHdlZW5Ub1ZhbHVlLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldlNpYmxpbmcuX3ZhbHVlVHlwZSA9PT0gdmFsdWVUeXBlcy5VTklUKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QudCA9IHZhbHVlVHlwZXMuVU5JVDtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC51ID0gcHJldlNpYmxpbmcuX3VuaXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgICBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS50ID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC50ID0gdmFsdWVUeXBlcy5VTklUO1xuICAgICAgICAgICAgICAgICAgICBmcm9tVGFyZ2V0T2JqZWN0LnUgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS51O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGhhc1RvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZSh0d2VlblRvVmFsdWUsIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlR3ZWVuKSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VUd2VlblZhbHVlKHByZXZUd2VlbiwgdG9UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGdldCBhbmQgcGFyc2UgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIHRoZSB0d2VlbiBpcyBwYXJ0IG9mIGEgdGltZWxpbmUgYW5kIGhhcyBhIHByZXZpb3VzIHNpYmxpbmcgcGFydCBvZiB0aGUgc2FtZSB0aW1lbGluZVxuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlUmF3VmFsdWUocGFyZW50ICYmIHByZXZTaWJsaW5nICYmIHByZXZTaWJsaW5nLnBhcmVudC5wYXJlbnQgPT09IHBhcmVudCA/IHByZXZTaWJsaW5nLl92YWx1ZSA6XG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLCB0b1RhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoYXNGcm9tdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZSh0d2VlbkZyb21WYWx1ZSwgZnJvbVRhcmdldE9iamVjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUd2Vlbikge1xuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlVHdlZW5WYWx1ZShwcmV2VHdlZW4sIGZyb21UYXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkZWNvbXBvc2VSYXdWYWx1ZShwYXJlbnQgJiYgcHJldlNpYmxpbmcgJiYgcHJldlNpYmxpbmcucGFyZW50LnBhcmVudCA9PT0gcGFyZW50ID8gcHJldlNpYmxpbmcuX3ZhbHVlIDpcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZ2V0IGFuZCBwYXJzZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgdGhlIHR3ZWVuIGlzIHBhcnQgb2YgYSB0aW1lbGluZSBhbmQgaGFzIGEgcHJldmlvdXMgc2libGluZyBwYXJ0IG9mIHRoZSBzYW1lIHRpbWVsaW5lXG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLCBmcm9tVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwbHkgb3BlcmF0b3JzXG4gICAgICAgICAgICBpZiAoZnJvbVRhcmdldE9iamVjdC5vKSB7XG4gICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3QubiA9IGdldFJlbGF0aXZlVmFsdWUoXG4gICAgICAgICAgICAgICAgIXByZXZTaWJsaW5nID8gZGVjb21wb3NlUmF3VmFsdWUoXG4gICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSh0YXJnZXQsIHByb3BOYW1lLCB0d2VlblR5cGUsIGFuaW1JbmxpbmVTdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgZGVjb21wb3NlZE9yaWdpbmFsVmFsdWVcbiAgICAgICAgICAgICAgICApLm4gOiBwcmV2U2libGluZy5fdG9OdW1iZXIsXG4gICAgICAgICAgICAgICAgZnJvbVRhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICAgIGZyb21UYXJnZXRPYmplY3Qub1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9UYXJnZXRPYmplY3Qubykge1xuICAgICAgICAgICAgICB0b1RhcmdldE9iamVjdC5uID0gZ2V0UmVsYXRpdmVWYWx1ZShmcm9tVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm4sIHRvVGFyZ2V0T2JqZWN0Lm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWYWx1ZXMgb21vZ2VuaXNhdGlvbiBpbiBjYXNlcyBvZiB0eXBlIGRpZmZlcmVuY2UgYmV0d2VlbiBcImZyb21cIiBhbmQgXCJ0b1wiXG4gICAgICAgICAgICBpZiAoZnJvbVRhcmdldE9iamVjdC50ICE9PSB0b1RhcmdldE9iamVjdC50KSB7XG4gICAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTVBMRVgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV4VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RDb21wbGV4VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuQ09NUExFWCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBub3RDb21wbGV4VmFsdWUudCA9IHZhbHVlVHlwZXMuQ09NUExFWDtcbiAgICAgICAgICAgICAgICBub3RDb21wbGV4VmFsdWUucyA9IGNsb25lQXJyYXkoY29tcGxleFZhbHVlLnMpO1xuICAgICAgICAgICAgICAgIG5vdENvbXBsZXhWYWx1ZS5kID0gY29tcGxleFZhbHVlLmQubWFwKCgpID0+IG5vdENvbXBsZXhWYWx1ZS5uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLlVOSVQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bml0VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RVbml0VmFsdWUgPSBmcm9tVGFyZ2V0T2JqZWN0LnQgPT09IHZhbHVlVHlwZXMuVU5JVCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBub3RVbml0VmFsdWUudCA9IHZhbHVlVHlwZXMuVU5JVDtcbiAgICAgICAgICAgICAgICBub3RVbml0VmFsdWUudSA9IHVuaXRWYWx1ZS51O1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT0xPUiB8fCB0b1RhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QudCA9PT0gdmFsdWVUeXBlcy5DT0xPUiA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RDb2xvclZhbHVlID0gZnJvbVRhcmdldE9iamVjdC50ID09PSB2YWx1ZVR5cGVzLkNPTE9SID8gdG9UYXJnZXRPYmplY3QgOiBmcm9tVGFyZ2V0T2JqZWN0O1xuICAgICAgICAgICAgICAgIG5vdENvbG9yVmFsdWUudCA9IHZhbHVlVHlwZXMuQ09MT1I7XG4gICAgICAgICAgICAgICAgbm90Q29sb3JWYWx1ZS5zID0gY29sb3JWYWx1ZS5zO1xuICAgICAgICAgICAgICAgIG5vdENvbG9yVmFsdWUuZCA9IFswLCAwLCAwLCAxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVbml0IGNvbnZlcnNpb25cbiAgICAgICAgICAgIGlmIChmcm9tVGFyZ2V0T2JqZWN0LnUgIT09IHRvVGFyZ2V0T2JqZWN0LnUpIHtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlVG9Db252ZXJ0ID0gdG9UYXJnZXRPYmplY3QudSA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgdmFsdWVUb0NvbnZlcnQgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCB2YWx1ZVRvQ29udmVydCwgdG9UYXJnZXRPYmplY3QudSA/IHRvVGFyZ2V0T2JqZWN0LnUgOiBmcm9tVGFyZ2V0T2JqZWN0LnUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgICAgLy8gY29udmVydFZhbHVlVW5pdCh0YXJnZXQsIHRvLnUgPyBmcm9tIDogdG8sIHRvLnUgPyB0by51IDogZnJvbS51KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCBpbiBub24gZXhpc3RpbmcgY29tcGxleCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICh0b1RhcmdldE9iamVjdC5kICYmIGZyb21UYXJnZXRPYmplY3QuZCAmJiAodG9UYXJnZXRPYmplY3QuZC5sZW5ndGggIT09IGZyb21UYXJnZXRPYmplY3QuZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxvbmdlc3RWYWx1ZSA9IGZyb21UYXJnZXRPYmplY3QuZC5sZW5ndGggPiB0b1RhcmdldE9iamVjdC5kLmxlbmd0aCA/IGZyb21UYXJnZXRPYmplY3QgOiB0b1RhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgY29uc3Qgc2hvcnRlc3RWYWx1ZSA9IGxvbmdlc3RWYWx1ZSA9PT0gZnJvbVRhcmdldE9iamVjdCA/IHRvVGFyZ2V0T2JqZWN0IDogZnJvbVRhcmdldE9iamVjdDtcbiAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgbiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIDAgZm9yIGRlZmF1bHQgY29tcGxleCB2YWx1ZXNcbiAgICAgICAgICAgICAgc2hvcnRlc3RWYWx1ZS5kID0gbG9uZ2VzdFZhbHVlLmQubWFwKChfLCBpKSA9PiBpc1VuZChzaG9ydGVzdFZhbHVlLmRbaV0pID8gMCA6IHNob3J0ZXN0VmFsdWUuZFtpXSk7XG4gICAgICAgICAgICAgIHNob3J0ZXN0VmFsdWUucyA9IGNsb25lQXJyYXkobG9uZ2VzdFZhbHVlLnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUd2VlbiBmYWN0b3J5XG5cbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgICAgICAgY29uc3QgdHdlZW5VcGRhdGVEdXJhdGlvbiA9IHJvdW5kKCt0d2VlbkR1cmF0aW9uIHx8IG1pblZhbHVlLCAxMik7XG5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7VHdlZW59ICovXG4gICAgICAgICAgICBjb25zdCB0d2VlbiA9IHtcbiAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgICBpZDogdHdlZW5JZCsrLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICBfdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIF9mdW5jOiB0b0Z1bmN0aW9uU3RvcmUuZnVuYyxcbiAgICAgICAgICAgICAgX2Vhc2U6IHBhcnNlRWFzaW5ncyh0d2VlbkVhc2luZyksXG4gICAgICAgICAgICAgIF9mcm9tTnVtYmVyczogY2xvbmVBcnJheShmcm9tVGFyZ2V0T2JqZWN0LmQpLFxuICAgICAgICAgICAgICBfdG9OdW1iZXJzOiBjbG9uZUFycmF5KHRvVGFyZ2V0T2JqZWN0LmQpLFxuICAgICAgICAgICAgICBfc3RyaW5nczogY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5zKSxcbiAgICAgICAgICAgICAgX2Zyb21OdW1iZXI6IGZyb21UYXJnZXRPYmplY3QubixcbiAgICAgICAgICAgICAgX3RvTnVtYmVyOiB0b1RhcmdldE9iamVjdC5uLFxuICAgICAgICAgICAgICBfbnVtYmVyczogY2xvbmVBcnJheShmcm9tVGFyZ2V0T2JqZWN0LmQpLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW4gYW5kIGFuaW1hdGFibGVzXG4gICAgICAgICAgICAgIF9udW1iZXI6IGZyb21UYXJnZXRPYmplY3QubiwgLy8gRm9yIGFkZGl0aXZlIHR3ZWVuIGFuZCBhbmltYXRhYmxlc1xuICAgICAgICAgICAgICBfdW5pdDogdG9UYXJnZXRPYmplY3QudSxcbiAgICAgICAgICAgICAgX21vZGlmaWVyOiB0d2Vlbk1vZGlmaWVyLFxuICAgICAgICAgICAgICBfY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICAgIF9zdGFydFRpbWU6IHR3ZWVuU3RhcnRUaW1lLFxuICAgICAgICAgICAgICBfZGVsYXk6ICt0d2VlbkRlbGF5LFxuICAgICAgICAgICAgICBfdXBkYXRlRHVyYXRpb246IHR3ZWVuVXBkYXRlRHVyYXRpb24sXG4gICAgICAgICAgICAgIF9jaGFuZ2VEdXJhdGlvbjogdHdlZW5VcGRhdGVEdXJhdGlvbixcbiAgICAgICAgICAgICAgX2Fic29sdXRlU3RhcnRUaW1lOiBhYnNvbHV0ZVN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgLy8gTk9URTogSW52ZXN0aWdhdGUgYml0IHBhY2tpbmcgdG8gc3RvcmVzIEVOVU0gLyBCT09MXG4gICAgICAgICAgICAgIF90d2VlblR5cGU6IHR3ZWVuVHlwZSxcbiAgICAgICAgICAgICAgX3ZhbHVlVHlwZTogdG9UYXJnZXRPYmplY3QudCxcbiAgICAgICAgICAgICAgX2NvbXBvc2l0aW9uOiB0d2VlbkNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgICBfaXNPdmVybGFwcGVkOiAwLFxuICAgICAgICAgICAgICBfaXNPdmVycmlkZGVuOiAwLFxuICAgICAgICAgICAgICBfcmVuZGVyVHJhbnNmb3JtczogMCxcbiAgICAgICAgICAgICAgX3ByZXZSZXA6IG51bGwsIC8vIEZvciByZXBsYWNlZCB0d2VlblxuICAgICAgICAgICAgICBfbmV4dFJlcDogbnVsbCwgLy8gRm9yIHJlcGxhY2VkIHR3ZWVuXG4gICAgICAgICAgICAgIF9wcmV2QWRkOiBudWxsLCAvLyBGb3IgYWRkaXRpdmUgdHdlZW5cbiAgICAgICAgICAgICAgX25leHRBZGQ6IG51bGwsIC8vIEZvciBhZGRpdGl2ZSB0d2VlblxuICAgICAgICAgICAgICBfcHJldjogbnVsbCxcbiAgICAgICAgICAgICAgX25leHQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHdlZW5Db21wb3NpdGlvbiAhPT0gY29tcG9zaXRpb25UeXBlcy5ub25lKSB7XG4gICAgICAgICAgICAgIGNvbXBvc2VUd2Vlbih0d2Vlbiwgc2libGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOYU4oZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSkpIHtcbiAgICAgICAgICAgICAgZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb3VuZGluZyBpcyBuZWNlc3NhcnkgaGVyZSB0byBtaW5pbWl6ZSBmbG9hdGluZyBwb2ludCBlcnJvcnNcbiAgICAgICAgICAgIGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgPSByb3VuZCh0d2VlblN0YXJ0VGltZSArIHR3ZWVuVXBkYXRlRHVyYXRpb24sIDEyKTtcbiAgICAgICAgICAgIHByZXZUd2VlbiA9IHR3ZWVuO1xuICAgICAgICAgICAgYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoKys7XG5cbiAgICAgICAgICAgIGFkZENoaWxkKHRoaXMsIHR3ZWVuKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gdGltaW5ncyB3aXRoIHRoZSBhZGRlZCB0d2VlbnMgcHJvcGVydGllc1xuXG4gICAgICAgICAgaWYgKGlzTmFOKGl0ZXJhdGlvbkRlbGF5KSB8fCBmaXJzdFR3ZWVuQ2hhbmdlU3RhcnRUaW1lIDwgaXRlcmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbkRlbGF5ID0gZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNOYU4oaXRlcmF0aW9uRHVyYXRpb24pIHx8IGxhc3RUd2VlbkNoYW5nZUVuZFRpbWUgPiBpdGVyYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgaXRlcmF0aW9uRHVyYXRpb24gPSBsYXN0VHdlZW5DaGFuZ2VFbmRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IEZpbmQgYSB3YXkgdG8gaW5saW5lIHR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zID0gMSBoZXJlXG4gICAgICAgICAgaWYgKHR3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk0pIHtcbiAgICAgICAgICAgIGxhc3RUcmFuc2Zvcm1Hcm91cEluZGV4ID0gYW5pbWF0aW9uQW5pbWF0aW9uTGVuZ3RoIC0gdHdlZW5JbmRleDtcbiAgICAgICAgICAgIGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCA9IGFuaW1hdGlvbkFuaW1hdGlvbkxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBfcmVuZGVyVHJhbnNmb3JtcyB0byBsYXN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byBjb3JyZWN0bHkgcmVuZGVyIHRoZSB0cmFuc2Zvcm1zIGxpc3RcbiAgICAgIGlmICghaXNOYU4obGFzdFRyYW5zZm9ybUdyb3VwSW5kZXgpKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICAgICAgaWYgKGkgPj0gbGFzdFRyYW5zZm9ybUdyb3VwSW5kZXggJiYgaSA8IGxhc3RUcmFuc2Zvcm1Hcm91cExlbmd0aCkge1xuICAgICAgICAgICAgdHdlZW4uX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICAgICAgaWYgKHR3ZWVuLl9jb21wb3NpdGlvbiA9PT0gY29tcG9zaXRpb25UeXBlcy5ibGVuZCkge1xuICAgICAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYWRkaXRpdmUuYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi9hZGRpdGl2ZVR3ZWVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aXZlVHdlZW4uaWQgPT09IHR3ZWVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICBhZGRpdGl2ZVR3ZWVuLl9yZW5kZXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRzTGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oYE5vIHRhcmdldCBmb3VuZC4gTWFrZSBzdXJlIHRoZSBlbGVtZW50IHlvdSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSBpcyBhY2Nlc3NpYmxlIGJlZm9yZSBjcmVhdGluZyB5b3VyIGFuaW1hdGlvbi5gKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlcmF0aW9uRGVsYXkpIHtcbiAgICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAvLyBJZiAoc3RhcnRUaW1lIC0gZGVsYXkpIGVxdWFscyAwLCB0aGlzIG1lYW5zIHRoZSB0d2VlbiBpcyBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGFuaW1hdGlvbiBzbyB3ZSBuZWVkIHRvIHRyaW0gdGhlIGRlbGF5IHRvb1xuICAgICAgICBpZiAoISh0d2Vlbi5fc3RhcnRUaW1lIC0gdHdlZW4uX2RlbGF5KSkge1xuICAgICAgICAgIHR3ZWVuLl9kZWxheSAtPSBpdGVyYXRpb25EZWxheTtcbiAgICAgICAgfVxuICAgICAgICB0d2Vlbi5fc3RhcnRUaW1lIC09IGl0ZXJhdGlvbkRlbGF5O1xuICAgICAgfSk7XG4gICAgICBpdGVyYXRpb25EdXJhdGlvbiAtPSBpdGVyYXRpb25EZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0aW9uRGVsYXkgPSAwO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnRzIGl0ZXJhdGlvbkR1cmF0aW9uIHRvIGJlIE5hTiBpZiBubyB2YWxpZCBhbmltYXRhYmxlIHByb3BzIGhhdmUgYmVlbiBwcm92aWRlZFxuICAgIC8vIFByZXZlbnRzIF9pdGVyYXRpb25Db3VudCB0byBiZSBOYU4gaWYgbm8gdmFsaWQgYW5pbWF0YWJsZSBwcm9wcyBoYXZlIGJlZW4gcHJvdmlkZWRcbiAgICBpZiAoIWl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IG1pblZhbHVlO1xuICAgICAgdGhpcy5pdGVyYXRpb25Db3VudCA9IDA7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7VGFyZ2V0c0FycmF5fSAqL1xuICAgIHRoaXMudGFyZ2V0cyA9IHBhcnNlZFRhcmdldHM7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5kdXJhdGlvbiA9IGl0ZXJhdGlvbkR1cmF0aW9uID09PSBtaW5WYWx1ZSA/IG1pblZhbHVlIDogY2xhbXBJbmZpbml0eSgoKGl0ZXJhdGlvbkR1cmF0aW9uICsgdGhpcy5fbG9vcERlbGF5KSAqIHRoaXMuaXRlcmF0aW9uQ291bnQpIC0gdGhpcy5fbG9vcERlbGF5KSB8fCBtaW5WYWx1ZTtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZW5kZXIgPSBvblJlbmRlciB8fCBhbmltRGVmYXVsdHMub25SZW5kZXI7XG4gICAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgICB0aGlzLl9lYXNlID0gYW5pbUVhc2U7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fZGVsYXkgPSBpdGVyYXRpb25EZWxheTtcbiAgICAvLyBOT1RFOiBJJ20ga2VlcGluZyBkZWxheSB2YWx1ZXMgc2VwYXJhdGVkIGZyb20gb2Zmc2V0cyBpbiB0aW1lbGluZXMgYmVjYXVzZSBkZWxheXMgY2FuIG92ZXJyaWRlIHByZXZpb3VzIHR3ZWVucyBhbmQgaXQgY291bGQgYmUgY29uZnVzaW5nIHRvIGRlYnVnIGEgdGltZWxpbmUgd2l0aCBvdmVycmlkZGVuIHR3ZWVucyBhbmQgbm8gYXNzb2NpYXRlZCB2aXNpYmxlIGRlbGF5cy5cbiAgICAvLyB0aGlzLl9kZWxheSA9IHBhcmVudCA/IDAgOiBpdGVyYXRpb25EZWxheTtcbiAgICAvLyB0aGlzLl9vZmZzZXQgKz0gcGFyZW50ID8gaXRlcmF0aW9uRGVsYXkgOiAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICAvKiogQHR5cGUge3t9fSAqL1xuICAgIHRoaXMuX2lubGluZVN0eWxlcyA9IGFuaW1JbmxpbmVTdHlsZXM7XG5cbiAgICBpZiAoIXRoaXMuX2F1dG9wbGF5ICYmIHNob3VsZFRyaWdnZXJSZW5kZXIpIHRoaXMub25SZW5kZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBuZXdEdXJhdGlvblxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc3RyZXRjaChuZXdEdXJhdGlvbikge1xuICAgIGNvbnN0IGN1cnJlbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgaWYgKGN1cnJlbnREdXJhdGlvbiA9PT0gbm9ybWFsaXplVGltZShuZXdEdXJhdGlvbikpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IG5ld0R1cmF0aW9uIC8gY3VycmVudER1cmF0aW9uO1xuICAgIC8vIE5PVEU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGUgc3RyZXRjaCBvZiBhbiBhbmltYXRpb24gYWZ0ZXIgc3RyZXRjaCA9IDBcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7VHdlZW59ICovdHdlZW4pID0+IHtcbiAgICAgIC8vIFJvdW5kaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIHRvIG1pbmltaXplIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgdHdlZW4uX3VwZGF0ZUR1cmF0aW9uID0gbm9ybWFsaXplVGltZSh0d2Vlbi5fdXBkYXRlRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgICAgdHdlZW4uX2NoYW5nZUR1cmF0aW9uID0gbm9ybWFsaXplVGltZSh0d2Vlbi5fY2hhbmdlRHVyYXRpb24gKiB0aW1lU2NhbGUpO1xuICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lICo9IHRpbWVTY2FsZTtcbiAgICAgIHR3ZWVuLl9zdGFydFRpbWUgKj0gdGltZVNjYWxlO1xuICAgICAgdHdlZW4uX2Fic29sdXRlU3RhcnRUaW1lICo9IHRpbWVTY2FsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3VwZXIuc3RyZXRjaChuZXdEdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgICBjb25zdCBvZ1ZhbHVlID0gZ2V0T3JpZ2luYWxBbmltYXRhYmxlVmFsdWUodHdlZW4udGFyZ2V0LCB0d2Vlbi5wcm9wZXJ0eSwgdHdlZW4uX3R3ZWVuVHlwZSk7XG4gICAgICBkZWNvbXBvc2VSYXdWYWx1ZShvZ1ZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgICB0d2Vlbi5fZnJvbU51bWJlcnMgPSBjbG9uZUFycmF5KGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLmQpO1xuICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgaWYgKHR3ZWVuLl9mdW5jKSB7XG4gICAgICAgIGRlY29tcG9zZVJhd1ZhbHVlKHR3ZWVuLl9mdW5jKCksIHRvVGFyZ2V0T2JqZWN0KTtcbiAgICAgICAgdHdlZW4uX3RvTnVtYmVycyA9IGNsb25lQXJyYXkodG9UYXJnZXRPYmplY3QuZCk7XG4gICAgICAgIHR3ZWVuLl9zdHJpbmdzID0gY2xvbmVBcnJheSh0b1RhcmdldE9iamVjdC5zKTtcbiAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gdG9UYXJnZXRPYmplY3QubjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIGFuaW1hdGlvbiBhbmQgcmV2ZXJ0IGFsbCB0aGUgdmFsdWVzIGFmZmVjdGVkIGJ5IHRoaXMgYW5pbWF0aW9uIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZXZlcnQoKSB7XG4gICAgc3VwZXIucmV2ZXJ0KCk7XG4gICAgcmV0dXJuIGNsZWFuSW5saW5lU3R5bGVzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbGxiYWNrPHRoaXM+fSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRoZW4oY2FsbGJhY2spO1xuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBhbmltYXRlID0gKHRhcmdldHMsIHBhcmFtZXRlcnMpID0+IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBwYXJhbWV0ZXJzLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuXG5cblxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVhc2luZyBmdW5jdGlvbiBpbnRvIGEgdmFsaWQgQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvbiBzdHJpbmdcbiAqIEBwYXJhbSB7RWFzaW5nRnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZXM9MTAwXVxuICogQHJldHVybnMge3N0cmluZ30gQ1NTIGxpbmVhcigpIHRpbWluZyBmdW5jdGlvblxuICovXG5jb25zdCBlYXNpbmdUb0xpbmVhciA9IChmbiwgc2FtcGxlcyA9IDEwMCkgPT4ge1xuICBjb25zdCBwb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2FtcGxlczsgaSsrKSBwb2ludHMucHVzaChmbihpIC8gc2FtcGxlcykpO1xuICByZXR1cm4gYGxpbmVhcigke3BvaW50cy5qb2luKCcsICcpfSlgO1xufTtcblxuY29uc3QgV0FBUElFYXNlc0xvb2t1cHMgPSB7XG4gIGluOiAnZWFzZS1pbicsXG4gIG91dDogJ2Vhc2Utb3V0JyxcbiAgaW5PdXQ6ICdlYXNlLWluLW91dCcsXG59O1xuXG5jb25zdCBXQUFQSWVhc2VzID0gLyojX19QVVJFX18qLygoKSA9PiB7XG4gIGNvbnN0IGxpc3QgPSB7fTtcbiAgZm9yIChsZXQgdHlwZSBpbiBlYXNlVHlwZXMpIGxpc3RbdHlwZV0gPSBhID0+IGVhc2VUeXBlc1t0eXBlXShlYXNlSW5Qb3dlcihhKSk7XG4gIHJldHVybiAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIEVhc2luZ0Z1bmN0aW9uPn0gKi8obGlzdCk7XG59KSgpO1xuXG4vKipcbiAqIEBwYXJhbSAge0Vhc2luZ1BhcmFtfSBlYXNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHBhcnNlV0FBUElFYXNpbmcgPSAoZWFzZSkgPT4ge1xuICBsZXQgcGFyc2VkRWFzZSA9IFdBQVBJRWFzZXNMb29rdXBzW2Vhc2VdO1xuICBpZiAocGFyc2VkRWFzZSkgcmV0dXJuIHBhcnNlZEVhc2U7XG4gIHBhcnNlZEVhc2UgPSAnbGluZWFyJztcbiAgaWYgKGlzU3RyKGVhc2UpKSB7XG4gICAgaWYgKFxuICAgICAgc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnbGluZWFyJykgfHxcbiAgICAgIHN0cmluZ1N0YXJ0c1dpdGgoZWFzZSwgJ2N1YmljLScpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdzdGVwcycpIHx8XG4gICAgICBzdHJpbmdTdGFydHNXaXRoKGVhc2UsICdlYXNlJylcbiAgICApIHtcbiAgICAgIHBhcnNlZEVhc2UgPSBlYXNlO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nU3RhcnRzV2l0aChlYXNlLCAnY3ViaWNCJykpIHtcbiAgICAgIHBhcnNlZEVhc2UgPSB0b0xvd2VyQ2FzZShlYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VFYXNlU3RyaW5nKGVhc2UsIFdBQVBJZWFzZXMsIFdBQVBJRWFzZXNMb29rdXBzKTtcbiAgICAgIGlmIChpc0ZuYyhwYXJzZWQpKSBwYXJzZWRFYXNlID0gcGFyc2VkID09PSBub25lID8gJ2xpbmVhcicgOiBlYXNpbmdUb0xpbmVhcihwYXJzZWQpO1xuICAgIH1cbiAgICBXQUFQSUVhc2VzTG9va3Vwc1tlYXNlXSA9IHBhcnNlZEVhc2U7XG4gIH0gZWxzZSBpZiAoaXNGbmMoZWFzZSkpIHtcbiAgICBjb25zdCBlYXNpbmcgPSBlYXNpbmdUb0xpbmVhcihlYXNlKTtcbiAgICBpZiAoZWFzaW5nKSBwYXJzZWRFYXNlID0gZWFzaW5nO1xuICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKSB7XG4gICAgcGFyc2VkRWFzZSA9IGVhc2luZ1RvTGluZWFyKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkRWFzZTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ8QXJyYXk8U3RyaW5nPnxBcnJheTxOdW1iZXI+fSBXQUFQSVR3ZWVuVmFsdWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXQUFQSUZ1bmN0aW9udmFsdWVcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSB0YXJnZXQgLSBUaGUgYW5pbWF0ZWQgdGFyZ2V0XG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgdGFyZ2V0IGluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gVGhlIHRvdGFsIG51bWJlciBvZiBhbmltYXRlZCB0YXJnZXRzXG4gKiBAcmV0dXJuIHtXQUFQSVR3ZWVuVmFsdWV9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7V0FBUElUd2VlblZhbHVlfFdBQVBJRnVuY3Rpb252YWx1ZXxBcnJheTxTdHJpbmd8TnVtYmVyfFdBQVBJRnVuY3Rpb252YWx1ZT59IFdBQVBJS2V5ZnJhbWVWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhhbmltYXRpb246IFdBQVBJQW5pbWF0aW9uKSA9PiB2b2lkfSBXQUFQSUNhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXQUFQSVR3ZWVuT3B0aW9uc1xuICogQHByb3BlcnR5IHtXQUFQSUtleWZyYW1lVmFsdWV9IFt0b11cbiAqIEBwcm9wZXJ0eSB7V0FBUElLZXlmcmFtZVZhbHVlfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfFdBQVBJRnVuY3Rpb252YWx1ZX0gW2R1cmF0aW9uXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvbnZhbHVlfSBbZGVsYXldXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7Q29tcG9zaXRlT3BlcmF0aW9ufSBbY29tcG9zaXRpb25dXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXQUFQSUFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfEJvb2xlYW59IFtsb29wXVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbUmV2ZXJzZWRdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtBbHRlcm5hdGVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58U2Nyb2xsT2JzZXJ2ZXJ9IFthdXRvcGxheV1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGxheWJhY2tSYXRlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ8V0FBUElGdW5jdGlvbnZhbHVlfSBbZHVyYXRpb25dXG4gKiBAcHJvcGVydHkge051bWJlcnxXQUFQSUZ1bmN0aW9udmFsdWV9IFtkZWxheV1cbiAqIEBwcm9wZXJ0eSB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICogQHByb3BlcnR5IHtDb21wb3NpdGVPcGVyYXRpb259IFtjb21wb3NpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7V0FBUElDYWxsYmFja30gW29uQ29tcGxldGVdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPFN0cmluZywgV0FBUElLZXlmcmFtZVZhbHVlIHwgV0FBUElBbmltYXRpb25PcHRpb25zIHwgQm9vbGVhbiB8IFNjcm9sbE9ic2VydmVyIHwgV0FBUElDYWxsYmFjayB8IEVhc2luZ1BhcmFtIHwgV0FBUElUd2Vlbk9wdGlvbnM+ICYgV0FBUElBbmltYXRpb25PcHRpb25zfSBXQUFQSUFuaW1hdGlvblBhcmFtc1xuICovXG5cbmNvbnN0IHRyYW5zZm9ybXNTaG9ydGhhbmRzID0gWyd4JywgJ3knLCAneiddO1xuY29uc3QgY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyA9IFtcbiAgJ3BlcnNwZWN0aXZlJyxcbiAgJ3dpZHRoJyxcbiAgJ2hlaWdodCcsXG4gICdtYXJnaW4nLFxuICAncGFkZGluZycsXG4gICd0b3AnLFxuICAncmlnaHQnLFxuICAnYm90dG9tJyxcbiAgJ2xlZnQnLFxuICAnYm9yZGVyV2lkdGgnLFxuICAnZm9udFNpemUnLFxuICAnYm9yZGVyUmFkaXVzJyxcbiAgLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHNcbl07XG5cbmNvbnN0IHZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMgPSBbLi4udHJhbnNmb3Jtc1Nob3J0aGFuZHMsIC4uLnZhbGlkVHJhbnNmb3Jtcy5maWx0ZXIodCA9PiBbJ1gnLCAnWScsICdaJ10uc29tZShheGlzID0+IHQuZW5kc1dpdGgoYXhpcykpKV07XG5cbi8vIFNldHRpbmcgaXQgdG8gdHJ1ZSBpbiBjYXNlIENTUy5yZWdpc3RlclByb3BlcnR5IGlzIG5vdCBzdXBwb3J0ZWQgd2lsbCBhdXRvbWF0aWNhbGx5IHNraXAgdGhlIHJlZ2lzdHJhdGlvbiBhbmQgZmFsbGJhY2sgdG8gbm8gYW5pbWF0aW9uXG5sZXQgdHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkID0gaXNCcm93c2VyICYmIChpc1VuZChDU1MpIHx8ICFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChDU1MsICdyZWdpc3RlclByb3BlcnR5JykpO1xuXG5jb25zdCByZWdpc3RlclRyYW5zZm9ybXNQcm9wZXJ0aWVzID0gKCkgPT4ge1xuICBpZiAodHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkKSByZXR1cm47XG4gIHZhbGlkVHJhbnNmb3Jtcy5mb3JFYWNoKHQgPT4ge1xuICAgIGNvbnN0IGlzU2tldyA9IHN0cmluZ1N0YXJ0c1dpdGgodCwgJ3NrZXcnKTtcbiAgICBjb25zdCBpc1NjYWxlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAnc2NhbGUnKTtcbiAgICBjb25zdCBpc1JvdGF0ZSA9IHN0cmluZ1N0YXJ0c1dpdGgodCwgJ3JvdGF0ZScpO1xuICAgIGNvbnN0IGlzVHJhbnNsYXRlID0gc3RyaW5nU3RhcnRzV2l0aCh0LCAndHJhbnNsYXRlJyk7XG4gICAgY29uc3QgaXNBbmdsZSA9IGlzUm90YXRlIHx8IGlzU2tldztcbiAgICBjb25zdCBzeW50YXggPSBpc0FuZ2xlID8gJzxhbmdsZT4nIDogaXNTY2FsZSA/IFwiPG51bWJlcj5cIiA6IGlzVHJhbnNsYXRlID8gXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XCIgOiBcIipcIjtcbiAgICB0cnkge1xuICAgICAgQ1NTLnJlZ2lzdGVyUHJvcGVydHkoe1xuICAgICAgICBuYW1lOiAnLS0nICsgdCxcbiAgICAgICAgc3ludGF4LFxuICAgICAgICBpbmhlcml0czogZmFsc2UsXG4gICAgICAgIGluaXRpYWxWYWx1ZTogaXNUcmFuc2xhdGUgPyAnMHB4JyA6IGlzQW5nbGUgPyAnMGRlZycgOiBpc1NjYWxlID8gJzEnIDogJzAnLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7fSAgfSk7XG4gIHRyYW5zZm9ybXNQcm9wZXJ0aWVzUmVnaXN0ZXJlZCA9IHRydWU7XG59O1xuXG5jb25zdCBXQUFQSUFuaW1hdGlvbnNMb29rdXBzID0ge1xuICBfaGVhZDogbnVsbCxcbiAgX3RhaWw6IG51bGwsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldXG4gKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbcGFyZW50XVxuICovXG5jb25zdCByZW1vdmVXQUFQSUFuaW1hdGlvbiA9ICgkZWwsIHByb3BlcnR5LCBwYXJlbnQpID0+IHtcbiAgbGV0IG5leHRMb29rdXAgPSBXQUFQSUFuaW1hdGlvbnNMb29rdXBzLl9oZWFkO1xuICB3aGlsZSAobmV4dExvb2t1cCkge1xuICAgIGNvbnN0IG5leHQgPSBuZXh0TG9va3VwLl9uZXh0O1xuICAgIGNvbnN0IG1hdGNoVGFyZ2V0ID0gbmV4dExvb2t1cC4kZWwgPT09ICRlbDtcbiAgICBjb25zdCBtYXRjaFByb3BlcnR5ID0gIXByb3BlcnR5IHx8IG5leHRMb29rdXAucHJvcGVydHkgPT09IHByb3BlcnR5O1xuICAgIGNvbnN0IG1hdGNoUGFyZW50ID0gIXBhcmVudCB8fCBuZXh0TG9va3VwLnBhcmVudCA9PT0gcGFyZW50O1xuICAgIGlmIChtYXRjaFRhcmdldCAmJiBtYXRjaFByb3BlcnR5ICYmIG1hdGNoUGFyZW50KSB7XG4gICAgICBjb25zdCBhbmltID0gbmV4dExvb2t1cC5hbmltYXRpb247XG4gICAgICB0cnkgeyBhbmltLmNvbW1pdFN0eWxlcygpOyB9IGNhdGNoIHt9ICAgICAgYW5pbS5jYW5jZWwoKTtcbiAgICAgIHJlbW92ZUNoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIG5leHRMb29rdXApO1xuICAgICAgY29uc3QgbG9va3VwUGFyZW50ID0gbmV4dExvb2t1cC5wYXJlbnQ7XG4gICAgICBpZiAobG9va3VwUGFyZW50KSB7XG4gICAgICAgIGxvb2t1cFBhcmVudC5fY29tcGxldGVkKys7XG4gICAgICAgIGlmIChsb29rdXBQYXJlbnQuYW5pbWF0aW9ucy5sZW5ndGggPT09IGxvb2t1cFBhcmVudC5fY29tcGxldGVkKSB7XG4gICAgICAgICAgbG9va3VwUGFyZW50LmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKCFsb29rdXBQYXJlbnQubXV0ZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgbG9va3VwUGFyZW50LnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBsb29rdXBQYXJlbnQub25Db21wbGV0ZShsb29rdXBQYXJlbnQpO1xuICAgICAgICAgICAgbG9va3VwUGFyZW50Ll9yZXNvbHZlKGxvb2t1cFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRMb29rdXAgPSBuZXh0O1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb259IHBhcmVudFxuICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1Byb3BlcnR5SW5kZXhlZEtleWZyYW1lc30ga2V5ZnJhbWVzXG4gKiBAcGFyYW0ge0tleWZyYW1lQW5pbWF0aW9uT3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dW4ge0FuaW1hdGlvbn1cbiAqL1xuY29uc3QgYWRkV0FBUElBbmltYXRpb24gPSAocGFyZW50LCAkZWwsIHByb3BlcnR5LCBrZXlmcmFtZXMsIHBhcmFtcykgPT4ge1xuICBjb25zdCBhbmltYXRpb24gPSAkZWwuYW5pbWF0ZShrZXlmcmFtZXMsIHBhcmFtcyk7XG4gIGNvbnN0IGFuaW1Ub3RhbER1cmF0aW9uID0gcGFyYW1zLmRlbGF5ICsgKCtwYXJhbXMuZHVyYXRpb24gKiBwYXJhbXMuaXRlcmF0aW9ucyk7XG4gIGFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBwYXJlbnQuX3NwZWVkO1xuICBpZiAocGFyZW50LnBhdXNlZCkgYW5pbWF0aW9uLnBhdXNlKCk7XG4gIGlmIChwYXJlbnQuZHVyYXRpb24gPCBhbmltVG90YWxEdXJhdGlvbikge1xuICAgIHBhcmVudC5kdXJhdGlvbiA9IGFuaW1Ub3RhbER1cmF0aW9uO1xuICAgIHBhcmVudC5jb250cm9sQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICB9XG4gIHBhcmVudC5hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eSk7XG4gIGFkZENoaWxkKFdBQVBJQW5pbWF0aW9uc0xvb2t1cHMsIHsgcGFyZW50LCBhbmltYXRpb24sICRlbCwgcHJvcGVydHksIF9uZXh0OiBudWxsLCBfcHJldjogbnVsbCB9KTtcbiAgY29uc3QgaGFuZGxlUmVtb3ZlID0gKCkgPT4geyByZW1vdmVXQUFQSUFuaW1hdGlvbigkZWwsIHByb3BlcnR5LCBwYXJlbnQpOyB9O1xuICBhbmltYXRpb24ub25yZW1vdmUgPSBoYW5kbGVSZW1vdmU7XG4gIGFuaW1hdGlvbi5vbmZpbmlzaCA9IGhhbmRsZVJlbW92ZTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB2YWx1ZVxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSB0YXJnZXRzTGVuZ3RoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVR3ZWVuVmFsdWUgPSAocHJvcE5hbWUsIHZhbHVlLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpID0+IHtcbiAgbGV0IHYgPSBnZXRGdW5jdGlvblZhbHVlKC8qKiBAdHlwZSB7YW55fSAqLyh2YWx1ZSksICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gIGlmICghaXNOdW0odikpIHJldHVybiB2O1xuICBpZiAoY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcy5pbmNsdWRlcyhwcm9wTmFtZSkgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3RyYW5zbGF0ZScpKSByZXR1cm4gYCR7dn1weGA7XG4gIGlmIChzdHJpbmdTdGFydHNXaXRoKHByb3BOYW1lLCAncm90YXRlJykgfHwgc3RyaW5nU3RhcnRzV2l0aChwcm9wTmFtZSwgJ3NrZXcnKSkgcmV0dXJuIGAke3Z9ZGVnYDtcbiAgcmV0dXJuIGAke3Z9YDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7RE9NVGFyZ2V0fSAkZWxcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSAge1dBQVBJS2V5ZnJhbWVWYWx1ZX0gZnJvbVxuICogQHBhcmFtICB7V0FBUElLZXlmcmFtZVZhbHVlfSB0b1xuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRhcmdldHNMZW5ndGhcbiAqIEByZXR1cm4ge1dBQVBJVHdlZW5WYWx1ZX1cbiAqL1xuY29uc3QgcGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSA9ICgkZWwsIHByb3BOYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCkgPT4ge1xuICAvKiogQHR5cGUge1dBQVBJVHdlZW5WYWx1ZX0gKi9cbiAgbGV0IHR3ZWVuVmFsdWUgPSAnMCc7XG4gIGNvbnN0IGNvbXB1dGVkVG8gPSAhaXNVbmQodG8pID8gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdG8sICRlbCwgaSwgdGFyZ2V0c0xlbmd0aCkgOiBnZXRDb21wdXRlZFN0eWxlKCRlbClbcHJvcE5hbWVdO1xuICBpZiAoIWlzVW5kKGZyb20pKSB7XG4gICAgY29uc3QgY29tcHV0ZWRGcm9tID0gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgZnJvbSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKTtcbiAgICB0d2VlblZhbHVlID0gW2NvbXB1dGVkRnJvbSwgY29tcHV0ZWRUb107XG4gIH0gZWxzZSB7XG4gICAgdHdlZW5WYWx1ZSA9IGlzQXJyKHRvKSA/IHRvLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShwcm9wTmFtZSwgdiwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgOiBjb21wdXRlZFRvO1xuICB9XG4gIHJldHVybiB0d2VlblZhbHVlO1xufTtcblxuY2xhc3MgV0FBUElBbmltYXRpb24ge1xuLyoqXG4gKiBAcGFyYW0ge0RPTVRhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtIHtXQUFQSUFuaW1hdGlvblBhcmFtc30gcGFyYW1zXG4gKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0cywgcGFyYW1zKSB7XG5cbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuXG4gICAgcmVnaXN0ZXJUcmFuc2Zvcm1zUHJvcGVydGllcygpO1xuXG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICBjb25zdCB0YXJnZXRzTGVuZ3RoID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICBpZiAoIXRhcmdldHNMZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gdGFyZ2V0IGZvdW5kLiBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgeW91J3JlIHRyeWluZyB0byBhbmltYXRlIGlzIGFjY2Vzc2libGUgYmVmb3JlIGNyZWF0aW5nIHlvdXIgYW5pbWF0aW9uLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGVhc2UgPSBzZXRWYWx1ZShwYXJhbXMuZWFzZSwgcGFyc2VXQUFQSUVhc2luZyhnbG9iYWxzLmRlZmF1bHRzLmVhc2UpKTtcbiAgICBjb25zdCBzcHJpbmcgPSAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSAmJiBlYXNlO1xuICAgIGNvbnN0IGF1dG9wbGF5ID0gc2V0VmFsdWUocGFyYW1zLmF1dG9wbGF5LCBnbG9iYWxzLmRlZmF1bHRzLmF1dG9wbGF5KTtcbiAgICBjb25zdCBzY3JvbGwgPSBhdXRvcGxheSAmJiAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqLyhhdXRvcGxheSkubGluayA/IGF1dG9wbGF5IDogZmFsc2U7XG4gICAgY29uc3QgYWx0ZXJuYXRlID0gcGFyYW1zLmFsdGVybmF0ZSAmJiAvKiogQHR5cGUge0Jvb2xlYW59ICovKHBhcmFtcy5hbHRlcm5hdGUpID09PSB0cnVlO1xuICAgIGNvbnN0IHJldmVyc2VkID0gcGFyYW1zLnJldmVyc2VkICYmIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi8ocGFyYW1zLnJldmVyc2VkKSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBsb29wID0gc2V0VmFsdWUocGFyYW1zLmxvb3AsIGdsb2JhbHMuZGVmYXVsdHMubG9vcCk7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLygobG9vcCA9PT0gdHJ1ZSB8fCBsb29wID09PSBJbmZpbml0eSkgPyBJbmZpbml0eSA6IGlzTnVtKGxvb3ApID8gbG9vcCArIDEgOiAxKTtcbiAgICAvKiogQHR5cGUge1BsYXliYWNrRGlyZWN0aW9ufSAqL1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFsdGVybmF0ZSA/IHJldmVyc2VkID8gJ2FsdGVybmF0ZS1yZXZlcnNlJyA6ICdhbHRlcm5hdGUnIDogcmV2ZXJzZWQgPyAncmV2ZXJzZScgOiAnbm9ybWFsJztcbiAgICAvKiogQHR5cGUge0ZpbGxNb2RlfSAqL1xuICAgIGNvbnN0IGZpbGwgPSAnZm9yd2FyZHMnO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xuICAgIGNvbnN0IGVhc2luZyA9IHBhcnNlV0FBUElFYXNpbmcoZWFzZSk7XG4gICAgY29uc3QgdGltZVNjYWxlID0gKGdsb2JhbHMudGltZVNjYWxlID09PSAxID8gMSA6IEspO1xuXG4gICAgLyoqIEB0eXBlIHtET01UYXJnZXRzQXJyYXl9XSAqL1xuICAgIHRoaXMudGFyZ2V0cyA9IHBhcnNlZFRhcmdldHM7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxnbG9iYWxUaGlzLkFuaW1hdGlvbj59XSAqL1xuICAgIHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259XSAqL1xuICAgIHRoaXMuY29udHJvbEFuaW1hdGlvbiA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uQ29tcGxldGUgPSBwYXJhbXMub25Db21wbGV0ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5wYXVzZWQgPSAhYXV0b3BsYXkgfHwgc2Nyb2xsICE9PSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXZlcnNlZCA9IHJldmVyc2VkO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbnxTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLmF1dG9wbGF5ID0gYXV0b3BsYXk7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fc3BlZWQgPSBzZXRWYWx1ZShwYXJhbXMucGxheWJhY2tSYXRlLCBnbG9iYWxzLmRlZmF1bHRzLnBsYXliYWNrUmF0ZSk7XG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cbiAgICB0aGlzLl9yZXNvbHZlID0gbm9vcDsgLy8gVXNlZCBieSAudGhlbigpXG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5fY29tcGxldGVkID0gMDtcbiAgICAvKiogQHR5cGUge0FycmF5PE9iamVjdD59XSAqL1xuICAgIHRoaXMuX2lubGluZVN0eWxlcyA9IHBhcnNlZFRhcmdldHMubWFwKCRlbCA9PiAkZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcblxuICAgIHBhcnNlZFRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiB7XG5cbiAgICAgIGNvbnN0IGNhY2hlZFRyYW5zZm9ybXMgPSAkZWxbdHJhbnNmb3Jtc1N5bWJvbF07XG5cbiAgICAgIGNvbnN0IGhhc0luZGl2aWR1YWxUcmFuc2Zvcm1zID0gdmFsaWRJbmRpdmlkdWFsVHJhbnNmb3Jtcy5zb21lKHQgPT4gcGFyYW1zLmhhc093blByb3BlcnR5KHQpKTtcblxuICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IChzcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oc3ByaW5nKS5kdXJhdGlvbiA6IGdldEZ1bmN0aW9uVmFsdWUoc2V0VmFsdWUocGFyYW1zLmR1cmF0aW9uLCBnbG9iYWxzLmRlZmF1bHRzLmR1cmF0aW9uKSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgKiB0aW1lU2NhbGU7XG4gICAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZShwYXJhbXMuZGVsYXksIGdsb2JhbHMuZGVmYXVsdHMuZGVsYXkpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpICogdGltZVNjYWxlO1xuICAgICAgLyoqIEB0eXBlIHtDb21wb3NpdGVPcGVyYXRpb259ICovXG4gICAgICBjb25zdCBjb21wb3NpdGUgPSAvKiogQHR5cGUge0NvbXBvc2l0ZU9wZXJhdGlvbn0gKi8oc2V0VmFsdWUocGFyYW1zLmNvbXBvc2l0aW9uLCAncmVwbGFjZScpKTtcblxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFpc0tleShuYW1lKSkgY29udGludWU7XG4gICAgICAgIC8qKiBAdHlwZSB7UHJvcGVydHlJbmRleGVkS2V5ZnJhbWVzfSAqL1xuICAgICAgICBjb25zdCBrZXlmcmFtZXMgPSB7fTtcbiAgICAgICAgLyoqIEB0eXBlIHtLZXlmcmFtZUFuaW1hdGlvbk9wdGlvbnN9ICovXG4gICAgICAgIGNvbnN0IHR3ZWVuUGFyYW1zID0geyBpdGVyYXRpb25zLCBkaXJlY3Rpb24sIGZpbGwsIGVhc2luZywgZHVyYXRpb24sIGRlbGF5LCBjb21wb3NpdGUgfTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICAgICAgY29uc3QgaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5ID0gaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMgPyB2YWxpZFRyYW5zZm9ybXMuaW5jbHVkZXMobmFtZSkgPyBuYW1lIDogc2hvcnRUcmFuc2Zvcm1zLmdldChuYW1lKSA6IGZhbHNlO1xuICAgICAgICBsZXQgcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgaWYgKGlzT2JqKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgdHdlZW5PcHRpb25zID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8ocHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgY29uc3QgdHdlZW5PcHRpb25zRWFzZSA9IHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5lYXNlLCBlYXNlKTtcbiAgICAgICAgICBjb25zdCB0d2Vlbk9wdGlvbnNTcHJpbmcgPSAvKiogQHR5cGUge1NwcmluZ30gKi8odHdlZW5PcHRpb25zRWFzZSkuZWFzZSAmJiB0d2Vlbk9wdGlvbnNFYXNlO1xuICAgICAgICAgIGNvbnN0IHRvID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8odHdlZW5PcHRpb25zKS50bztcbiAgICAgICAgICBjb25zdCBmcm9tID0gLyoqIEB0eXBlIHtXQUFQSVR3ZWVuT3B0aW9uc30gKi8odHdlZW5PcHRpb25zKS5mcm9tO1xuICAgICAgICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmR1cmF0aW9uID0gKHR3ZWVuT3B0aW9uc1NwcmluZyA/IC8qKiBAdHlwZSB7U3ByaW5nfSAqLyh0d2Vlbk9wdGlvbnNTcHJpbmcpLmR1cmF0aW9uIDogZ2V0RnVuY3Rpb25WYWx1ZShzZXRWYWx1ZSh0d2Vlbk9wdGlvbnMuZHVyYXRpb24sIGR1cmF0aW9uKSwgJGVsLCBpLCB0YXJnZXRzTGVuZ3RoKSkgKiB0aW1lU2NhbGU7XG4gICAgICAgICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgICAgICAgdHdlZW5QYXJhbXMuZGVsYXkgPSBnZXRGdW5jdGlvblZhbHVlKHNldFZhbHVlKHR3ZWVuT3B0aW9ucy5kZWxheSwgZGVsYXkpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpICogdGltZVNjYWxlO1xuICAgICAgICAgIC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmNvbXBvc2l0ZSA9IC8qKiBAdHlwZSB7Q29tcG9zaXRlT3BlcmF0aW9ufSAqLyhzZXRWYWx1ZSh0d2Vlbk9wdGlvbnMuY29tcG9zaXRpb24sIGNvbXBvc2l0ZSkpO1xuICAgICAgICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xuICAgICAgICAgIHR3ZWVuUGFyYW1zLmVhc2luZyA9IHBhcnNlV0FBUElFYXNpbmcodHdlZW5PcHRpb25zRWFzZSk7XG4gICAgICAgICAgcGFyc2VkUHJvcGVydHlWYWx1ZSA9IHBhcnNlSW5kaXZpZHVhbFR3ZWVuVmFsdWUoJGVsLCBuYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgaWYgKGluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSkge1xuICAgICAgICAgICAga2V5ZnJhbWVzW2AtLSR7aW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5fWBdID0gcGFyc2VkUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIGNhY2hlZFRyYW5zZm9ybXNbaW5kaXZpZHVhbFRyYW5zZm9ybVByb3BlcnR5XSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tuYW1lXSA9IHBhcnNlSW5kaXZpZHVhbFR3ZWVuVmFsdWUoJGVsLCBuYW1lLCBmcm9tLCB0bywgaSwgdGFyZ2V0c0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZFdBQVBJQW5pbWF0aW9uKHRoaXMsICRlbCwgbmFtZSwga2V5ZnJhbWVzLCB0d2VlblBhcmFtcyk7XG4gICAgICAgICAgaWYgKCFpc1VuZChmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgJGVsLnN0eWxlW25hbWVdID0ga2V5ZnJhbWVzW25hbWVdWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYC0tJHtpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHl9YDtcbiAgICAgICAgICAgICAgJGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwga2V5ZnJhbWVzW2tleV1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZWRQcm9wZXJ0eVZhbHVlID0gaXNBcnIocHJvcGVydHlWYWx1ZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlLm1hcCgoLyoqIEB0eXBlIHthbnl9ICovdikgPT4gbm9ybWFsaXplVHdlZW5WYWx1ZShuYW1lLCB2LCAkZWwsIGksIHRhcmdldHNMZW5ndGgpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVR3ZWVuVmFsdWUobmFtZSwgLyoqIEB0eXBlIHthbnl9ICovKHByb3BlcnR5VmFsdWUpLCAkZWwsIGksIHRhcmdldHNMZW5ndGgpO1xuICAgICAgICAgIGlmIChpbmRpdmlkdWFsVHJhbnNmb3JtUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tgLS0ke2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eX1gXSA9IHBhcnNlZFByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICBjYWNoZWRUcmFuc2Zvcm1zW2luZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eV0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbbmFtZV0gPSBwYXJzZWRQcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRXQUFQSUFuaW1hdGlvbih0aGlzLCAkZWwsIG5hbWUsIGtleWZyYW1lcywgdHdlZW5QYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW5kaXZpZHVhbFRyYW5zZm9ybXMpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybXMgPSBlbXB0eVN0cmluZztcbiAgICAgICAgZm9yIChsZXQgdCBpbiBjYWNoZWRUcmFuc2Zvcm1zKSB7XG4gICAgICAgICAgdHJhbnNmb3JtcyArPSBgJHt0cmFuc2Zvcm1zRnJhZ21lbnRTdHJpbmdzW3RdfXZhcigtLSR7dH0pKSBgO1xuICAgICAgICB9XG4gICAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi8odGhpcy5hdXRvcGxheSkubGluayh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGZvckVhY2hDYWxsYmFja1xuICAgKiBAcGFyYW0ge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSBhbmltYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge2ZvckVhY2hDYWxsYmFja3xTdHJpbmd9IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2IgPSBpc1N0cihjYWxsYmFjaykgPyBhID0+IGFbY2FsbGJhY2tdKCkgOiBjYWxsYmFjaztcbiAgICB0aGlzLmFuaW1hdGlvbnMuZm9yRWFjaChjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NwZWVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZCAqL1xuICBzZXQgc3BlZWQoc3BlZWQpIHtcbiAgICB0aGlzLl9zcGVlZCA9ICtzcGVlZDtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLnBsYXliYWNrUmF0ZSA9IHNwZWVkKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICBjb25zdCBjb250cm9sQW5pbWF0aW9uID0gdGhpcy5jb250cm9sQW5pbWF0aW9uO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGdsb2JhbHMudGltZVNjYWxlO1xuICAgIHJldHVybiB0aGlzLmNvbXBsZXRlZCA/IHRoaXMuZHVyYXRpb24gOiBjb250cm9sQW5pbWF0aW9uID8gK2NvbnRyb2xBbmltYXRpb24uY3VycmVudFRpbWUgKiAodGltZVNjYWxlID09PSAxID8gMSA6IHRpbWVTY2FsZSkgOiAwO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSB0aW1lICovXG4gIHNldCBjdXJyZW50VGltZSh0aW1lKSB7XG4gICAgY29uc3QgdCA9IHRpbWUgKiAoZ2xvYmFscy50aW1lU2NhbGUgPT09IDEgPyAxIDogSyk7XG4gICAgdGhpcy5mb3JFYWNoKGFuaW0gPT4ge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gcGxheVN0YXRlIGlzIG5vdCAncGF1c2VkJyBpbiBvcmRlciB0byBwcm9wZXJseSB0cmlnZ2VyIGFuIG9uZmluaXNoIGNhbGxiYWNrLlxuICAgICAgLy8gVGhlIFwicGF1c2VkXCIgcGxheSBzdGF0ZSBzdXBlcnNlZGVzIHRoZSBcImZpbmlzaGVkXCIgcGxheSBzdGF0ZTsgaWYgdGhlIGFuaW1hdGlvbiBpcyBib3RoIHBhdXNlZCBhbmQgZmluaXNoZWQsIHRoZSBcInBhdXNlZFwiIHN0YXRlIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlIHJlcG9ydGVkLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbi9maW5pc2hfZXZlbnRcbiAgICAgIGlmICh0ID49IHRoaXMuZHVyYXRpb24pIGFuaW0ucGxheSgpO1xuICAgICAgYW5pbS5jdXJyZW50VGltZSA9IHQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWUgLyB0aGlzLmR1cmF0aW9uO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcyAqL1xuICBzZXQgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLmZvckVhY2goYW5pbSA9PiBhbmltLmN1cnJlbnRUaW1lID0gcHJvZ3Jlc3MgKiB0aGlzLmR1cmF0aW9uIHx8IDApO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgLy8gVE9ETzogU3RvcmUgdGhlIGN1cnJlbnQgdGltZSwgYW5kIHNlZWsgYmFjayB0byB0aGUgbGFzdCBwb3NpdGlvblxuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BsYXknKTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ3BhdXNlJyk7XG4gIH1cblxuICBhbHRlcm5hdGUoKSB7XG4gICAgdGhpcy5yZXZlcnNlZCA9ICF0aGlzLnJldmVyc2VkO1xuICAgIHRoaXMuZm9yRWFjaCgncmV2ZXJzZScpO1xuICAgIGlmICh0aGlzLnBhdXNlZCkgdGhpcy5mb3JFYWNoKCdwYXVzZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlZCkgdGhpcy5hbHRlcm5hdGUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldmVyc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJldmVyc2VkKSB0aGlzLmFsdGVybmF0ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAvKipcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gbXV0ZUNhbGxiYWNrc1xuICAqL1xuICBzZWVrKHRpbWUsIG11dGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgIGlmIChtdXRlQ2FsbGJhY2tzKSB0aGlzLm11dGVDYWxsYmFja3MgPSB0cnVlO1xuICAgIGlmICh0aW1lIDwgdGhpcy5kdXJhdGlvbikgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICB0aGlzLm11dGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXVzZWQpIHRoaXMucGF1c2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3RhcnQoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5zZWVrKDAsIHRydWUpLnJlc3VtZSgpO1xuICB9XG5cbiAgY29tbWl0U3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goJ2NvbW1pdFN0eWxlcycpO1xuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vlayh0aGlzLmR1cmF0aW9uKTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmZvckVhY2goJ2NhbmNlbCcpO1xuICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoJGVsLCBpKSA9PiAkZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuX2lubGluZVN0eWxlc1tpXSkgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtXQUFQSUNhbGxiYWNrfSBbY2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICB0aGVuKGNhbGxiYWNrID0gbm9vcCkge1xuICAgIGNvbnN0IHRoZW4gPSB0aGlzLnRoZW47XG4gICAgY29uc3Qgb25SZXNvbHZlID0gKCkgPT4ge1xuICAgICAgdGhpcy50aGVuID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdGhpcy50aGVuID0gdGhlbjtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBub29wO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHIgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9ICgpID0+IHIob25SZXNvbHZlKCkpO1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVkKSB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCB3YWFwaSA9IHtcbi8qKlxuICogQHBhcmFtIHtET01UYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSB7V0FBUElBbmltYXRpb25QYXJhbXN9IHBhcmFtc1xuICogQHJldHVybiB7V0FBUElBbmltYXRpb259XG4gKi9cbiAgYW5pbWF0ZTogKHRhcmdldHMsIHBhcmFtcykgPT4gbmV3IFdBQVBJQW5pbWF0aW9uKHRhcmdldHMsIHBhcmFtcyksXG4gIGNvbnZlcnRFYXNlOiBlYXNpbmdUb0xpbmVhclxufTtcblxuXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtDYWxsYmFjazxUaW1lcj59IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1RpbWVyfVxuICovXG5jb25zdCBzeW5jID0gKGNhbGxiYWNrID0gbm9vcCkgPT4ge1xuICByZXR1cm4gbmV3IFRpbWVyKHsgZHVyYXRpb246IDEgKiBnbG9iYWxzLnRpbWVTY2FsZSwgb25Db21wbGV0ZTogY2FsbGJhY2sgfSwgbnVsbCwgMCkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0U2VsZWN0b3J9IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgcHJvcE5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge0pTVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgIHByb3BOYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICpcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtICB7RE9NVGFyZ2V0c1BhcmFtfSB0YXJnZXRTZWxlY3RvclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICB1bml0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldFNlbGVjdG9yXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHByb3BOYW1lXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIHVuaXRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19ICAgdGFyZ2V0U2VsZWN0b3JcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICBwcm9wTmFtZVxuICogQHBhcmFtICB7U3RyaW5nfEJvb2xlYW59IFt1bml0XVxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXRTZWxlY3RvciwgcHJvcE5hbWUsIHVuaXQpIHtcbiAgY29uc3QgdGFyZ2V0cyA9IHJlZ2lzdGVyVGFyZ2V0cyh0YXJnZXRTZWxlY3Rvcik7XG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHJldHVybjtcbiAgY29uc3QgWyB0YXJnZXQgXSA9IHRhcmdldHM7XG4gIGNvbnN0IHR3ZWVuVHlwZSA9IGdldFR3ZWVuVHlwZSh0YXJnZXQsIHByb3BOYW1lKTtcbiAgY29uc3Qgbm9ybWFsaXplUHJvcE5hbWUgPSBzYW5pdGl6ZVByb3BlcnR5TmFtZShwcm9wTmFtZSwgdGFyZ2V0LCB0d2VlblR5cGUpO1xuICBsZXQgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsQW5pbWF0YWJsZVZhbHVlKHRhcmdldCwgbm9ybWFsaXplUHJvcE5hbWUpO1xuICBpZiAoaXNVbmQodW5pdCkpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZWNvbXBvc2VSYXdWYWx1ZShvcmlnaW5hbFZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gICAgaWYgKGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuTlVNQkVSIHx8IGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLnQgPT09IHZhbHVlVHlwZXMuVU5JVCkge1xuICAgICAgaWYgKHVuaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZS5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0VmFsdWVVbml0KC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyh0YXJnZXQpLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSwgLyoqIEB0eXBlIHtTdHJpbmd9ICovKHVuaXQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBgJHtyb3VuZChjb252ZXJ0ZWRWYWx1ZS5uLCBnbG9iYWxzLnByZWNpc2lvbil9JHtjb252ZXJ0ZWRWYWx1ZS51fWA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSAgICB0YXJnZXRzXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0pTQW5pbWF0aW9ufVxuICovXG5jb25zdCBzZXRUYXJnZXRWYWx1ZXMgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4ge1xuICBpZiAoaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgcGFyYW1ldGVycy5kdXJhdGlvbiA9IG1pblZhbHVlO1xuICAvLyBEbyBub3Qgb3ZlcnJpZGVzIGN1cnJlbnRseSBhY3RpdmUgdHdlZW5zIGJ5IGRlZmF1bHRcbiAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IHNldFZhbHVlKHBhcmFtZXRlcnMuY29tcG9zaXRpb24sIGNvbXBvc2l0aW9uVHlwZXMubm9uZSk7XG4gIC8vIFNraXAgaW5pdCgpIGFuZCBmb3JjZSByZW5kZXJpbmcgYnkgcGxheWluZyB0aGUgYW5pbWF0aW9uXG4gIHJldHVybiBuZXcgSlNBbmltYXRpb24odGFyZ2V0cywgcGFyYW1ldGVycywgbnVsbCwgMCwgdHJ1ZSkucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNBcnJheX0gdGFyZ2V0c0FycmF5XG4gKiBAcGFyYW0gIHtKU0FuaW1hdGlvbn0gICAgYW5pbWF0aW9uXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIFtwcm9wZXJ0eU5hbWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5jb25zdCByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbiA9ICh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbiwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGxldCB0d2VlbnNNYXRjaGVzVGFyZ2V0cyA9IGZhbHNlO1xuICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqQHR5cGUge1R3ZWVufSAqL3R3ZWVuKSA9PiB7XG4gICAgY29uc3QgdHdlZW5UYXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG4gICAgaWYgKHRhcmdldHNBcnJheS5pbmNsdWRlcyh0d2VlblRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHR3ZWVuTmFtZSA9IHR3ZWVuLnByb3BlcnR5O1xuICAgICAgY29uc3QgdHdlZW5UeXBlID0gdHdlZW4uX3R3ZWVuVHlwZTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZVByb3BOYW1lID0gc2FuaXRpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lLCB0d2VlblRhcmdldCwgdHdlZW5UeXBlKTtcbiAgICAgIGlmICghbm9ybWFsaXplUHJvcE5hbWUgfHwgbm9ybWFsaXplUHJvcE5hbWUgJiYgbm9ybWFsaXplUHJvcE5hbWUgPT09IHR3ZWVuTmFtZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gZmxhZyB0aGUgcHJldmlvdXMgQ1NTIHRyYW5zZm9ybSB0d2VlbiB0byByZW5kZXJUcmFuc2Zvcm1cbiAgICAgICAgaWYgKHR3ZWVuLnBhcmVudC5fdGFpbCA9PT0gdHdlZW4gJiZcbiAgICAgICAgICAgIHR3ZWVuLl90d2VlblR5cGUgPT09IHR3ZWVuVHlwZXMuVFJBTlNGT1JNICYmXG4gICAgICAgICAgICB0d2Vlbi5fcHJldiAmJlxuICAgICAgICAgICAgdHdlZW4uX3ByZXYuX3R3ZWVuVHlwZSA9PT0gdHdlZW5UeXBlcy5UUkFOU0ZPUk1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdHdlZW4uX3ByZXYuX3JlbmRlclRyYW5zZm9ybXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIHR3ZWVuIGZyb20gdGhlIHNlbGVjdGVkIGFuaW1hdGlvblxuICAgICAgICByZW1vdmVDaGlsZChhbmltYXRpb24sIHR3ZWVuKTtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSB0d2VlbiBmcm9tIGl0cyBzaWJsaW5ncyB0byBtYWtlIHN1cmUgYmxlbmRlZCB0d2VlbnMgYXJlIGNvcnJlY3RsbHkgcmVtb3ZlZFxuICAgICAgICByZW1vdmVUd2VlblNsaWJsaW5ncyh0d2Vlbik7XG4gICAgICAgIHR3ZWVuc01hdGNoZXNUYXJnZXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRydWUpO1xuICByZXR1cm4gdHdlZW5zTWF0Y2hlc1RhcmdldHM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICogQHBhcmFtICB7UmVuZGVyYWJsZXxXQUFQSUFuaW1hdGlvbn0gW3JlbmRlcmFibGVdXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICBbcHJvcGVydHlOYW1lXVxuICogQHJldHVybiB7VGFyZ2V0c0FycmF5fVxuICovXG5jb25zdCByZW1vdmUgPSAodGFyZ2V0cywgcmVuZGVyYWJsZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gIGNvbnN0IHRhcmdldHNBcnJheSA9IHBhcnNlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtSZW5kZXJhYmxlfHR5cGVvZiBlbmdpbmV9ICoqLyhyZW5kZXJhYmxlID8gcmVuZGVyYWJsZSA6IGVuZ2luZSk7XG4gIGNvbnN0IHdhYXBpQW5pbWF0aW9uID0gcmVuZGVyYWJsZSAmJiAvKiogQHR5cGUge1dBQVBJQW5pbWF0aW9ufSAqLyhyZW5kZXJhYmxlKS5jb250cm9sQW5pbWF0aW9uICYmIC8qKiBAdHlwZSB7V0FBUElBbmltYXRpb259ICovKHJlbmRlcmFibGUpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRhcmdldHNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gICovKHRhcmdldHNBcnJheVtpXSk7XG4gICAgcmVtb3ZlV0FBUElBbmltYXRpb24oJGVsLCBwcm9wZXJ0eU5hbWUsIHdhYXBpQW5pbWF0aW9uKTtcbiAgfVxuICBsZXQgcmVtb3ZlTWF0Y2hlcztcbiAgaWYgKHBhcmVudC5faGFzQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICAgIGZvckVhY2hDaGlsZHJlbihwYXJlbnQsICgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQuX2hhc0NoaWxkcmVuKSB7XG4gICAgICAgIHJlbW92ZU1hdGNoZXMgPSByZW1vdmVUYXJnZXRzRnJvbUFuaW1hdGlvbih0YXJnZXRzQXJyYXksIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgaWYgbm8gdHdlZW5zIGFuZCBubyBjaGlsZHJlbiBsZWZ0IGFmdGVyIHRoZSByZW1vdmFsXG4gICAgICAgIGlmIChyZW1vdmVNYXRjaGVzICYmICFjaGlsZC5faGVhZCkge1xuICAgICAgICAgIGNoaWxkLmNhbmNlbCgpO1xuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGl0ZXJhdGlvbkR1cmF0aW9uIHZhbHVlIHRvIGhhbmRsZSBvbkNvbXBsZXRlIHdpdGggbGFzdCBjaGlsZCBpbiByZW5kZXIoKVxuICAgICAgICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgICAgICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgICAgICAgIGlmIChjaGlsZER1ciA+IGl0ZXJhdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRvIGFsc28gcmVtb3ZlIGVuZ2luZSdzIGNoaWxkcmVuIHRhcmdldHNcbiAgICAgIC8vIE5PVEU6IEF2b2lkIHJlY3Vyc2lvbj9cbiAgICAgIGlmIChjaGlsZC5faGVhZCkge1xuICAgICAgICByZW1vdmUodGFyZ2V0cywgY2hpbGQsIHByb3BlcnR5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgICAvLyBVcGRhdGUgaXRlcmF0aW9uRHVyYXRpb24gdmFsdWUgdG8gaGFuZGxlIG9uQ29tcGxldGUgd2l0aCBsYXN0IGNoaWxkIGluIHJlbmRlcigpXG4gICAgaWYgKCFpc1VuZCgvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24pKSB7XG4gICAgICAvKiogQHR5cGUge1JlbmRlcmFibGV9ICovKHBhcmVudCkuaXRlcmF0aW9uRHVyYXRpb24gPSBpdGVyYXRpb25EdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlTWF0Y2hlcyA9IHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uKFxuICAgICAgdGFyZ2V0c0FycmF5LFxuICAgICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8ocGFyZW50KSxcbiAgICAgIHByb3BlcnR5TmFtZVxuICAgICk7XG4gIH1cblxuICBpZiAocmVtb3ZlTWF0Y2hlcyAmJiAhcGFyZW50Ll9oZWFkKSB7XG4gICAgcGFyZW50Ll9oYXNDaGlsZHJlbiA9IGZhbHNlO1xuICAgIC8vIENhbmNlbCB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyB0d2VlbnMgYW5kIG5vIGNoaWxkcmVuIGxlZnQgYWZ0ZXIgdGhlIHJlbW92YWxcbiAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIHRoZSAuY2FuY2VsKCkgbWV0aG9kIGV4aXN0IHRvIGhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIHRoZSBlbmdpbmUgaXRzZWxmXG4gICAgaWYgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwpIC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi8ocGFyZW50KS5jYW5jZWwoKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzQXJyYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gbWluXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heFxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVjaW1hbExlbmd0aF1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmFuZG9tID0gKG1pbiwgbWF4LCBkZWNpbWFsTGVuZ3RoKSA9PiB7IGNvbnN0IG0gPSAxMCAqKiAoZGVjaW1hbExlbmd0aCB8fCAwKTsgcmV0dXJuIGZsb29yKChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArICgxIC8gbSkpICsgbWluKSAqIG0pIC8gbSB9O1xuXG4vKipcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcmFuZG9tUGljayA9IGl0ZW1zID0+IGl0ZW1zW3JhbmRvbSgwLCBpdGVtcy5sZW5ndGggLSAxKV07XG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NodWZmbGUvXG4gKiBAcGFyYW0gIHtBcnJheX0gaXRlbXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzaHVmZmxlID0gaXRlbXMgPT4ge1xuICBsZXQgbSA9IGl0ZW1zLmxlbmd0aCwgdCwgaTtcbiAgd2hpbGUgKG0pIHsgaSA9IHJhbmRvbSgwLCAtLW0pOyB0ID0gaXRlbXNbbV07IGl0ZW1zW21dID0gaXRlbXNbaV07IGl0ZW1zW2ldID0gdDsgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gZGVjaW1hbExlbmd0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCByb3VuZFBhZCA9ICh2LCBkZWNpbWFsTGVuZ3RoKSA9PiAoK3YpLnRvRml4ZWQoZGVjaW1hbExlbmd0aCk7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBwYWRTdGFydCA9ICh2LCB0b3RhbExlbmd0aCwgcGFkU3RyaW5nKSA9PiBgJHt2fWAucGFkU3RhcnQodG90YWxMZW5ndGgsIHBhZFN0cmluZyk7XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfSB2XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhZFN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5jb25zdCBwYWRFbmQgPSAodiwgdG90YWxMZW5ndGgsIHBhZFN0cmluZykgPT4gYCR7dn1gLnBhZEVuZCh0b3RhbExlbmd0aCwgcGFkU3RyaW5nKTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSAge051bWJlcn0gbWluXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1heFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCB3cmFwID0gKHYsIG1pbiwgbWF4KSA9PiAoKCh2IC0gbWluKSAlIChtYXggLSBtaW4pICsgKG1heCAtIG1pbikpICUgKG1heCAtIG1pbikpICsgbWluO1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gaW5Mb3dcbiAqIEBwYXJhbSAge051bWJlcn0gaW5IaWdoXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG91dExvd1xuICogQHBhcmFtICB7TnVtYmVyfSBvdXRIaWdoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IG1hcFJhbmdlID0gKHZhbHVlLCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpID0+IG91dExvdyArICgodmFsdWUgLSBpbkxvdykgLyAoaW5IaWdoIC0gaW5Mb3cpKSAqIChvdXRIaWdoIC0gb3V0TG93KTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgZGVnVG9SYWQgPSBkZWdyZWVzID0+IGRlZ3JlZXMgKiBQSSAvIDE4MDtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcmFkVG9EZWcgPSByYWRpYW5zID0+IHJhZGlhbnMgKiAxODAgLyBQSTtcblxuLyoqXG4gKiBodHRwczovL3d3dy5yb3J5ZHJpc2NvbGwuY29tLzIwMTYvMDMvMDcvZnJhbWUtcmF0ZS1pbmRlcGVuZGVudC1kYW1waW5nLXVzaW5nLWxlcnAvXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVuZFxuICogQHBhcmFtICB7TnVtYmVyfSBhbW91bnRcbiAqIEBwYXJhbSAge1JlbmRlcmFibGV8Qm9vbGVhbn0gW3JlbmRlcmFibGVdXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGxlcnAgPSAoc3RhcnQsIGVuZCwgYW1vdW50LCByZW5kZXJhYmxlKSA9PiB7XG4gIGxldCBkdCA9IEsgLyBnbG9iYWxzLmRlZmF1bHRzLmZyYW1lUmF0ZTtcbiAgaWYgKHJlbmRlcmFibGUgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgdGlja2VyID0gLyoqIEB0eXBlIFJlbmRlcmFibGUgKi9cbiAgICAgICAgICAgICAgICAgICAocmVuZGVyYWJsZSkgfHxcbiAgICAgICAgICAgICAgICAgICAoZW5naW5lLl9oYXNDaGlsZHJlbiAmJiBlbmdpbmUpO1xuICAgIGlmICh0aWNrZXIgJiYgdGlja2VyLmRlbHRhVGltZSkge1xuICAgICAgZHQgPSB0aWNrZXIuZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuICBjb25zdCB0ID0gMSAtIE1hdGguZXhwKC1hbW91bnQgKiBkdCAqIC4xKTtcbiAgcmV0dXJuICFhbW91bnQgPyBzdGFydCA6IGFtb3VudCA9PT0gMSA/IGVuZCA6ICgxIC0gdCkgKiBzdGFydCArIHQgKiBlbmQ7XG59O1xuXG4vLyBDaGFpbi1hYmxlIHV0aWxpdGllc1xuXG4vKipcbiAqIEBjYWxsYmFjayBVdGlsaXR5RnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqXG4gKiBAcGFyYW0ge1V0aWxpdHlGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGFzdD0wXVxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uKE51bWJlcnxTdHJpbmcpKTogZnVuY3Rpb24oTnVtYmVyfFN0cmluZyk6IChOdW1iZXJ8U3RyaW5nKX1cbiAqL1xuY29uc3QgY3VycnkgPSAoZm4sIGxhc3QgPSAwKSA9PiAoLi4uYXJncykgPT4gbGFzdCA/IHYgPT4gZm4oLi4uYXJncywgdikgOiB2ID0+IGZuKHYsIC4uLmFyZ3MpO1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpfVxuICovXG5jb25zdCBjaGFpbiA9IGZuID0+IHtcbiAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBuZXcgUHJveHkobm9vcCwge1xuICAgICAgYXBwbHk6IChfLCBfXywgW3ZdKSA9PiByZXN1bHQodiksXG4gICAgICBnZXQ6IChfLCBwcm9wKSA9PiBjaGFpbigvKipAcGFyYW0gey4uLk51bWJlcnxTdHJpbmd9IG5leHRBcmdzICovKC4uLm5leHRBcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRSZXN1bHQgPSB1dGlsc1twcm9wXSguLi5uZXh0QXJncyk7XG4gICAgICAgIHJldHVybiAoLyoqQHR5cGUge051bWJlcnxTdHJpbmd9ICovdikgPT4gbmV4dFJlc3VsdChyZXN1bHQodikpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1V0aWxpdHlGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmlnaHRdXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi4oTnVtYmVyfFN0cmluZykpOiBVdGlsaXR5RnVuY3Rpb259XG4gKi9cbmNvbnN0IG1ha2VDaGFpbmFibGUgPSAoZm4sIHJpZ2h0ID0gMCkgPT4gKC4uLmFyZ3MpID0+IChhcmdzLmxlbmd0aCA8IGZuLmxlbmd0aCA/IGNoYWluKGN1cnJ5KGZuLCByaWdodCkpIDogZm4pKC4uLmFyZ3MpO1xuXG4vKipcbiAqIEBjYWxsYmFjayBDaGFpbmVkVXRpbHNSZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYWluYWJsZVV0aWxzXG4gKiBAcHJvcGVydHkge0NoYWluZWRDbGFtcH0gY2xhbXBcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJvdW5kfSByb3VuZFxuICogQHByb3BlcnR5IHtDaGFpbmVkU25hcH0gc25hcFxuICogQHByb3BlcnR5IHtDaGFpbmVkV3JhcH0gd3JhcFxuICogQHByb3BlcnR5IHtDaGFpbmVkSW50ZXJwb2xhdGV9IGludGVycG9sYXRlXG4gKiBAcHJvcGVydHkge0NoYWluZWRNYXBSYW5nZX0gbWFwUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7Q2hhaW5lZFJvdW5kUGFkfSByb3VuZFBhZFxuICogQHByb3BlcnR5IHtDaGFpbmVkUGFkU3RhcnR9IHBhZFN0YXJ0XG4gKiBAcHJvcGVydHkge0NoYWluZWRQYWRFbmR9IHBhZEVuZFxuICogQHByb3BlcnR5IHtDaGFpbmVkRGVnVG9SYWR9IGRlZ1RvUmFkXG4gKiBAcHJvcGVydHkge0NoYWluZWRSYWRUb0RlZ30gcmFkVG9EZWdcbiAqXG4gKiBAdHlwZWRlZiB7Q2hhaW5hYmxlVXRpbHMgJiBDaGFpbmVkVXRpbHNSZXN1bHR9IENoYWluYWJsZVV0aWxcbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZENsYW1wXG4gKiBAcGFyYW0ge051bWJlcn0gbWluXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUm91bmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWNpbWFsTGVuZ3RoXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkU25hcFxuICogQHBhcmFtIHtOdW1iZXJ9IGluY3JlbWVudFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRJbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkTWFwUmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbkxvd1xuICogQHBhcmFtIHtOdW1iZXJ9IGluSGlnaFxuICogQHBhcmFtIHtOdW1iZXJ9IG91dExvd1xuICogQHBhcmFtIHtOdW1iZXJ9IG91dEhpZ2hcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRSb3VuZFBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlY2ltYWxMZW5ndGhcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWRQYWRTdGFydFxuICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsTGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFkU3RyaW5nXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICpcbiAqIEBjYWxsYmFjayBDaGFpbmVkUGFkRW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWRTdHJpbmdcbiAqIEByZXR1cm4ge0NoYWluYWJsZVV0aWx9XG4gKlxuICogQGNhbGxiYWNrIENoYWluZWREZWdUb1JhZFxuICogQHJldHVybiB7Q2hhaW5hYmxlVXRpbH1cbiAqXG4gKiBAY2FsbGJhY2sgQ2hhaW5lZFJhZFRvRGVnXG4gKiBAcmV0dXJuIHtDaGFpbmFibGVVdGlsfVxuICovXG5cbmNvbnN0IHV0aWxzID0ge1xuICAkOiByZWdpc3RlclRhcmdldHMsXG4gIGdldDogZ2V0VGFyZ2V0VmFsdWUsXG4gIHNldDogc2V0VGFyZ2V0VmFsdWVzLFxuICByZW1vdmUsXG4gIGNsZWFuSW5saW5lU3R5bGVzLFxuICByYW5kb20sXG4gIHJhbmRvbVBpY2ssXG4gIHNodWZmbGUsXG4gIGxlcnAsXG4gIHN5bmMsXG4gIGNsYW1wOiAvKiogQHR5cGUge3R5cGVvZiBjbGFtcCAmIENoYWluZWRDbGFtcH0gKi8obWFrZUNoYWluYWJsZShjbGFtcCkpLFxuICByb3VuZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmQgJiBDaGFpbmVkUm91bmR9ICovKG1ha2VDaGFpbmFibGUocm91bmQpKSxcbiAgc25hcDogLyoqIEB0eXBlIHt0eXBlb2Ygc25hcCAmIENoYWluZWRTbmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHNuYXApKSxcbiAgd3JhcDogLyoqIEB0eXBlIHt0eXBlb2Ygd3JhcCAmIENoYWluZWRXcmFwfSAqLyhtYWtlQ2hhaW5hYmxlKHdyYXApKSxcbiAgaW50ZXJwb2xhdGU6IC8qKiBAdHlwZSB7dHlwZW9mIGludGVycG9sYXRlICYgQ2hhaW5lZEludGVycG9sYXRlfSAqLyhtYWtlQ2hhaW5hYmxlKGludGVycG9sYXRlLCAxKSksXG4gIG1hcFJhbmdlOiAvKiogQHR5cGUge3R5cGVvZiBtYXBSYW5nZSAmIENoYWluZWRNYXBSYW5nZX0gKi8obWFrZUNoYWluYWJsZShtYXBSYW5nZSkpLFxuICByb3VuZFBhZDogLyoqIEB0eXBlIHt0eXBlb2Ygcm91bmRQYWQgJiBDaGFpbmVkUm91bmRQYWR9ICovKG1ha2VDaGFpbmFibGUocm91bmRQYWQpKSxcbiAgcGFkU3RhcnQ6IC8qKiBAdHlwZSB7dHlwZW9mIHBhZFN0YXJ0ICYgQ2hhaW5lZFBhZFN0YXJ0fSAqLyhtYWtlQ2hhaW5hYmxlKHBhZFN0YXJ0KSksXG4gIHBhZEVuZDogLyoqIEB0eXBlIHt0eXBlb2YgcGFkRW5kICYgQ2hhaW5lZFBhZEVuZH0gKi8obWFrZUNoYWluYWJsZShwYWRFbmQpKSxcbiAgZGVnVG9SYWQ6IC8qKiBAdHlwZSB7dHlwZW9mIGRlZ1RvUmFkICYgQ2hhaW5lZERlZ1RvUmFkfSAqLyhtYWtlQ2hhaW5hYmxlKGRlZ1RvUmFkKSksXG4gIHJhZFRvRGVnOiAvKiogQHR5cGUge3R5cGVvZiByYWRUb0RlZyAmIENoYWluZWRSYWRUb0RlZ30gKi8obWFrZUNoYWluYWJsZShyYWRUb0RlZykpLFxufTtcblxuXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyfFN0cmluZ3xGdW5jdGlvbn0gVGltZVBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBUaW1lbGluZSdzIGNoaWxkcmVuIG9mZnNldHMgcG9zaXRpb25zIHBhcnNlclxuICogQHBhcmFtICB7VGltZWxpbmV9IHRpbWVsaW5lXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBnZXRQcmV2Q2hpbGRPZmZzZXQgPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBpZiAoc3RyaW5nU3RhcnRzV2l0aCh0aW1lUG9zaXRpb24sICc8JykpIHtcbiAgICBjb25zdCBnb1RvUHJldkFuaW1hdGlvbk9mZnNldCA9IHRpbWVQb3NpdGlvblsxXSA9PT0gJzwnO1xuICAgIGNvbnN0IHByZXZBbmltYXRpb24gPSAvKiogQHR5cGUge1RpY2thYmxlfSAqLyh0aW1lbGluZS5fdGFpbCk7XG4gICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZBbmltYXRpb24gPyBwcmV2QW5pbWF0aW9uLl9vZmZzZXQgKyBwcmV2QW5pbWF0aW9uLl9kZWxheSA6IDA7XG4gICAgcmV0dXJuIGdvVG9QcmV2QW5pbWF0aW9uT2Zmc2V0ID8gcHJldk9mZnNldCA6IHByZXZPZmZzZXQgKyBwcmV2QW5pbWF0aW9uLmR1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge1RpbWVsaW5lfSB0aW1lbGluZVxuICogQHBhcmFtICB7VGltZVBvc2l0aW9ufSBbdGltZVBvc2l0aW9uXVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5jb25zdCBwYXJzZVRpbWVsaW5lUG9zaXRpb24gPSAodGltZWxpbmUsIHRpbWVQb3NpdGlvbikgPT4ge1xuICBsZXQgdGxEdXJhdGlvbiA9IHRpbWVsaW5lLml0ZXJhdGlvbkR1cmF0aW9uO1xuICBpZiAodGxEdXJhdGlvbiA9PT0gbWluVmFsdWUpIHRsRHVyYXRpb24gPSAwO1xuICBpZiAoaXNVbmQodGltZVBvc2l0aW9uKSkgcmV0dXJuIHRsRHVyYXRpb247XG4gIGlmIChpc051bSgrdGltZVBvc2l0aW9uKSkgcmV0dXJuICt0aW1lUG9zaXRpb247XG4gIGNvbnN0IHRpbWVQb3NTdHIgPSAvKiogQHR5cGUge1N0cmluZ30gKi8odGltZVBvc2l0aW9uKTtcbiAgY29uc3QgdGxMYWJlbHMgPSB0aW1lbGluZSA/IHRpbWVsaW5lLmxhYmVscyA6IG51bGw7XG4gIGNvbnN0IGhhc0xhYmVscyA9ICFpc05pbCh0bExhYmVscyk7XG4gIGNvbnN0IHByZXZPZmZzZXQgPSBnZXRQcmV2Q2hpbGRPZmZzZXQodGltZWxpbmUsIHRpbWVQb3NTdHIpO1xuICBjb25zdCBoYXNTaWJsaW5nID0gIWlzVW5kKHByZXZPZmZzZXQpO1xuICBjb25zdCBtYXRjaGVkUmVsYXRpdmVPcGVyYXRvciA9IHJlbGF0aXZlVmFsdWVzRXhlY1JneC5leGVjKHRpbWVQb3NTdHIpO1xuICBpZiAobWF0Y2hlZFJlbGF0aXZlT3BlcmF0b3IpIHtcbiAgICBjb25zdCBmdWxsT3BlcmF0b3IgPSBtYXRjaGVkUmVsYXRpdmVPcGVyYXRvclswXTtcbiAgICBjb25zdCBzcGxpdCA9IHRpbWVQb3NTdHIuc3BsaXQoZnVsbE9wZXJhdG9yKTtcbiAgICBjb25zdCBsYWJlbE9mZnNldCA9IGhhc0xhYmVscyAmJiBzcGxpdFswXSA/IHRsTGFiZWxzW3NwbGl0WzBdXSA6IHRsRHVyYXRpb247XG4gICAgY29uc3QgcGFyc2VkT2Zmc2V0ID0gaGFzU2libGluZyA/IHByZXZPZmZzZXQgOiBoYXNMYWJlbHMgPyBsYWJlbE9mZnNldCA6IHRsRHVyYXRpb247XG4gICAgY29uc3QgcGFyc2VkTnVtZXJpY2FsT2Zmc2V0ID0gK3NwbGl0WzFdO1xuICAgIHJldHVybiBnZXRSZWxhdGl2ZVZhbHVlKHBhcnNlZE9mZnNldCwgcGFyc2VkTnVtZXJpY2FsT2Zmc2V0LCBmdWxsT3BlcmF0b3JbMF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNTaWJsaW5nID8gcHJldk9mZnNldCA6XG4gICAgICAgICAgIGhhc0xhYmVscyA/ICFpc1VuZCh0bExhYmVsc1t0aW1lUG9zU3RyXSkgPyB0bExhYmVsc1t0aW1lUG9zU3RyXSA6XG4gICAgICAgICAgIHRsRHVyYXRpb24gOiB0bER1cmF0aW9uO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGltZWxpbmV9IHRsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFRpbWVsaW5lVG90YWxEdXJhdGlvbih0bCkge1xuICByZXR1cm4gY2xhbXBJbmZpbml0eSgoKHRsLml0ZXJhdGlvbkR1cmF0aW9uICsgdGwuX2xvb3BEZWxheSkgKiB0bC5pdGVyYXRpb25Db3VudCkgLSB0bC5fbG9vcERlbGF5KSB8fCBtaW5WYWx1ZTtcbn1cblxuLyoqXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSAge1RpbWVyUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHJldHVybiB7VGltZWxpbmV9XG4gKlxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0gIHtBbmltYXRpb25QYXJhbXN9IGNoaWxkUGFyYW1zXG4gKiBAcGFyYW0gIHtUaW1lbGluZX0gdGxcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAqIEBwYXJhbSAge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXVxuICogQHJldHVybiB7VGltZWxpbmV9XG4gKlxuICogQHBhcmFtICB7VGltZXJQYXJhbXN8QW5pbWF0aW9uUGFyYW1zfSBjaGlsZFBhcmFtc1xuICogQHBhcmFtICB7VGltZWxpbmV9IHRsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWVQb3NpdGlvblxuICogQHBhcmFtICB7VGFyZ2V0c1BhcmFtfSBbdGFyZ2V0c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtICB7TnVtYmVyfSBbbGVuZ3RoXVxuICovXG5mdW5jdGlvbiBhZGRUbENoaWxkKGNoaWxkUGFyYW1zLCB0bCwgdGltZVBvc2l0aW9uLCB0YXJnZXRzLCBpbmRleCwgbGVuZ3RoKSB7XG4gIGNvbnN0IGlzU2V0dGVyID0gaXNOdW0oY2hpbGRQYXJhbXMuZHVyYXRpb24pICYmIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhjaGlsZFBhcmFtcy5kdXJhdGlvbikgPD0gbWluVmFsdWU7XG4gIC8vIE9mZnNldCB0aGUgdGwgcG9zaXRpb24gd2l0aCAtbWluVmFsdWUgZm9yIDAgZHVyYXRpb24gYW5pbWF0aW9ucyBvciAuc2V0KCkgY2FsbHMgaW4gb3JkZXIgdG8gYWxpZ24gdGhlaXIgZW5kIHZhbHVlIHdpdGggdGhlIGRlZmluZWQgcG9zaXRpb25cbiAgY29uc3QgYWRqdXN0ZWRQb3NpdGlvbiA9IGlzU2V0dGVyID8gdGltZVBvc2l0aW9uIC0gbWluVmFsdWUgOiB0aW1lUG9zaXRpb247XG4gIHRpY2sodGwsIGFkanVzdGVkUG9zaXRpb24sIDEsIDEsIHRpY2tNb2Rlcy5BVVRPKTtcbiAgY29uc3QgdGxDaGlsZCA9IHRhcmdldHMgP1xuICAgIG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqLyhjaGlsZFBhcmFtcyksIHRsLCBhZGp1c3RlZFBvc2l0aW9uLCBmYWxzZSwgaW5kZXgsIGxlbmd0aCkgOlxuICAgIG5ldyBUaW1lcigvKiogQHR5cGUge1RpbWVyUGFyYW1zfSAqLyhjaGlsZFBhcmFtcyksIHRsLCBhZGp1c3RlZFBvc2l0aW9uKTtcbiAgdGxDaGlsZC5pbml0KDEpO1xuICAvLyBUT0RPOiBNaWdodCBiZSBiZXR0ZXIgdG8gaW5zZXJ0IGF0IGEgcG9zaXRpb24gcmVsYXRpdmUgdG8gc3RhcnRUaW1lP1xuICBhZGRDaGlsZCh0bCwgdGxDaGlsZCk7XG4gIGZvckVhY2hDaGlsZHJlbih0bCwgKC8qKiBAdHlwZSB7UmVuZGVyYWJsZX0gKi9jaGlsZCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkVExPZmZzZXQgPSBjaGlsZC5fb2Zmc2V0ICsgY2hpbGQuX2RlbGF5O1xuICAgIGNvbnN0IGNoaWxkRHVyID0gY2hpbGRUTE9mZnNldCArIGNoaWxkLmR1cmF0aW9uO1xuICAgIGlmIChjaGlsZER1ciA+IHRsLml0ZXJhdGlvbkR1cmF0aW9uKSB0bC5pdGVyYXRpb25EdXJhdGlvbiA9IGNoaWxkRHVyO1xuICB9KTtcbiAgdGwuZHVyYXRpb24gPSBnZXRUaW1lbGluZVRvdGFsRHVyYXRpb24odGwpO1xuICByZXR1cm4gdGw7XG59XG5cbmNsYXNzIFRpbWVsaW5lIGV4dGVuZHMgVGltZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIHN1cGVyKC8qKiBAdHlwZSB7VGltZXJQYXJhbXMmVGltZWxpbmVQYXJhbXN9ICovKHBhcmFtZXRlcnMpLCBudWxsLCAwKTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmR1cmF0aW9uID0gMDsgLy8gVEwgZHVyYXRpb24gc3RhcnRzIGF0IDAgYW5kIGdyb3dzIHdoZW4gYWRkaW5nIGNoaWxkcmVuXG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBOdW1iZXI+fSAqL1xuICAgIHRoaXMubGFiZWxzID0ge307XG4gICAgY29uc3QgZGVmYXVsdHNQYXJhbXMgPSBwYXJhbWV0ZXJzLmRlZmF1bHRzO1xuICAgIGNvbnN0IGdsb2JhbERlZmF1bHRzID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0c1BhcmFtcyA/IG1lcmdlT2JqZWN0cyhkZWZhdWx0c1BhcmFtcywgZ2xvYmFsRGVmYXVsdHMpIDogZ2xvYmFsRGVmYXVsdHM7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uUmVuZGVyID0gcGFyYW1ldGVycy5vblJlbmRlciB8fCBnbG9iYWxEZWZhdWx0cy5vblJlbmRlcjtcbiAgICBjb25zdCB0bFBsYXliYWNrRWFzZSA9IHNldFZhbHVlKHBhcmFtZXRlcnMucGxheWJhY2tFYXNlLCBnbG9iYWxEZWZhdWx0cy5wbGF5YmFja0Vhc2UpO1xuICAgIHRoaXMuX2Vhc2UgPSB0bFBsYXliYWNrRWFzZSA/IHBhcnNlRWFzaW5ncyh0bFBsYXliYWNrRWFzZSkgOiBudWxsO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaXRlcmF0aW9uRHVyYXRpb24gPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gYTFcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN9IGEyXG4gICAqIEBwYXJhbSB7VGltZVBvc2l0aW9ufSBbYTNdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1RpbWVyUGFyYW1zfSBhMVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW2EyXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbXxUaW1lclBhcmFtc30gYTFcbiAgICogQHBhcmFtIHtBbmltYXRpb25QYXJhbXN8VGltZVBvc2l0aW9ufSBhMlxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW2EzXVxuICAgKi9cbiAgYWRkKGExLCBhMiwgYTMpIHtcbiAgICBjb25zdCBpc0FuaW0gPSBpc09iaihhMik7XG4gICAgY29uc3QgaXNUaW1lciA9IGlzT2JqKGExKTtcbiAgICBpZiAoaXNBbmltIHx8IGlzVGltZXIpIHtcbiAgICAgIHRoaXMuX2hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIGlmIChpc0FuaW0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRQYXJhbXMgPSAvKiogQHR5cGUge0FuaW1hdGlvblBhcmFtc30gKi8oYTIpO1xuICAgICAgICAvLyBDaGVjayBmb3IgZnVuY3Rpb24gZm9yIGNoaWxkcmVuIHN0YWdnZXIgcG9zaXRpb25zXG4gICAgICAgIGlmIChpc0ZuYyhhMykpIHtcbiAgICAgICAgICBjb25zdCBzdGFnZ2VyZWRQb3NpdGlvbiA9IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovKGEzKTtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUYXJnZXRzQXJyYXkgPSBwYXJzZVRhcmdldHMoLyoqIEB0eXBlIHtUYXJnZXRzUGFyYW19ICovKGExKSk7XG4gICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBkdXJhdGlvbiBiZWZvcmUgYWRkaW5nIG5ldyBjaGlsZHJlbiB0aGF0IHdpbGwgY2hhbmdlIHRoZSBkdXJhdGlvblxuICAgICAgICAgIGNvbnN0IHRsRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgIC8vIFN0b3JlIGluaXRpYWwgX2l0ZXJhdGlvbkR1cmF0aW9uIGJlZm9yZSBhZGRpbmcgbmV3IGNoaWxkcmVuIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIGR1cmF0aW9uXG4gICAgICAgICAgY29uc3QgdGxJdGVyYXRpb25EdXJhdGlvbiA9IHRoaXMuaXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGlkIGluIG9yZGVyIHRvIGFkZCBzcGVjaWZpYyBpbmRleGVzIHRvIHRoZSBuZXcgYW5pbWF0aW9ucyBpZHNcbiAgICAgICAgICBjb25zdCBpZCA9IGNoaWxkUGFyYW1zLmlkO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICBjb25zdCBwYXJzZWRMZW5ndGggPSBwYXJzZWRUYXJnZXRzQXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHBhcnNlZFRhcmdldHNBcnJheS5mb3JFYWNoKCgvKiogQHR5cGUge1RhcmdldH0gKi90YXJnZXQpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJhbWV0ZXIgb2JqZWN0IGZvciBlYWNoIHN0YWdnZXJlZCBjaGlsZHJlblxuICAgICAgICAgICAgY29uc3Qgc3RhZ2dlcmVkQ2hpbGRQYXJhbXMgPSB7IC4uLmNoaWxkUGFyYW1zIH07XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lIGl0ZXJhdGlvbiBiZWZvcmUgZWFjaCBzdGFnZ2VyIHRvIHByZXZlbnQgd3Jvbmcgc3RhcnQgdmFsdWUgY2FsY3VsYXRpb25cbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSB0bER1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRpb25EdXJhdGlvbiA9IHRsSXRlcmF0aW9uRHVyYXRpb247XG4gICAgICAgICAgICBpZiAoIWlzVW5kKGlkKSkgc3RhZ2dlcmVkQ2hpbGRQYXJhbXMuaWQgPSBpZCArICctJyArIGk7XG4gICAgICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgICAgICBzdGFnZ2VyZWRDaGlsZFBhcmFtcyxcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgc3RhZ2dlcmVkUG9zaXRpb24odGFyZ2V0LCBpLCBwYXJzZWRMZW5ndGgsIHRoaXMpLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIHBhcnNlZExlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRUbENoaWxkKFxuICAgICAgICAgICAgY2hpbGRQYXJhbXMsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRoaXMsIGEzKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7VGFyZ2V0c1BhcmFtfSAqLyhhMSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhIFRpbWVyXG4gICAgICAgIGFkZFRsQ2hpbGQoXG4gICAgICAgICAgLyoqIEB0eXBlIFRpbWVyUGFyYW1zICovKGExKSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLC8qKiBAdHlwZSBUaW1lUG9zaXRpb24gKi8oYTIpKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmluaXQoMSk7IC8vIDEgPSBpbnRlcm5hbFJlbmRlclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtUaWNrYWJsZX0gW3N5bmNlZF1cbiAgICogQHBhcmFtIHtUaW1lUG9zaXRpb259IFtwb3NpdGlvbl1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7Z2xvYmFsVGhpcy5BbmltYXRpb259IFtzeW5jZWRdXG4gICAqIEBwYXJhbSB7VGltZVBvc2l0aW9ufSBbcG9zaXRpb25dXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBvdmVybG9hZFxuICAgKiBAcGFyYW0ge1dBQVBJQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAcGFyYW0ge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufGdsb2JhbFRoaXMuQW5pbWF0aW9ufSBbc3luY2VkXVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKi9cbiAgc3luYyhzeW5jZWQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHN5bmNlZCkgfHwgc3luY2VkICYmIGlzVW5kKHN5bmNlZC5wYXVzZSkpIHJldHVybiB0aGlzO1xuICAgIHN5bmNlZC5wYXVzZSgpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gKygvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqLyhzeW5jZWQpLmVmZmVjdCA/IC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259ICovKHN5bmNlZCkuZWZmZWN0LmdldFRpbWluZygpLmR1cmF0aW9uIDogLyoqIEB0eXBlIHtUaWNrYWJsZX0gKi8oc3luY2VkKS5kdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHN5bmNlZCwgeyBjdXJyZW50VGltZTogWzAsIGR1cmF0aW9uXSwgZHVyYXRpb24sIGVhc2U6ICdsaW5lYXInIH0sIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7QW5pbWF0aW9uUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSAge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0KHRhcmdldHMsIHBhcmFtZXRlcnMsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGlzVW5kKHBhcmFtZXRlcnMpKSByZXR1cm4gdGhpcztcbiAgICBwYXJhbWV0ZXJzLmR1cmF0aW9uID0gbWluVmFsdWU7XG4gICAgcGFyYW1ldGVycy5jb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uVHlwZXMucmVwbGFjZTtcbiAgICByZXR1cm4gdGhpcy5hZGQodGFyZ2V0cywgcGFyYW1ldGVycywgcG9zaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FsbGJhY2s8VGltZXI+fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgY2FsbChjYWxsYmFjaywgcG9zaXRpb24pIHtcbiAgICBpZiAoaXNVbmQoY2FsbGJhY2spIHx8IGNhbGxiYWNrICYmICFpc0ZuYyhjYWxsYmFjaykpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLmFkZCh7IGR1cmF0aW9uOiAwLCBvbkNvbXBsZXRlOiAoKSA9PiBjYWxsYmFjayh0aGlzKSB9LCBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsTmFtZVxuICAgKiBAcGFyYW0ge1RpbWVQb3NpdGlvbn0gW3Bvc2l0aW9uXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKi9cbiAgbGFiZWwobGFiZWxOYW1lLCBwb3NpdGlvbikge1xuICAgIGlmIChpc1VuZChsYWJlbE5hbWUpIHx8IGxhYmVsTmFtZSAmJiAhaXNTdHIobGFiZWxOYW1lKSkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxOYW1lXSA9IHBhcnNlVGltZWxpbmVQb3NpdGlvbih0aGlzLC8qKiBAdHlwZSBUaW1lUG9zaXRpb24gKi8ocG9zaXRpb24pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtUYXJnZXRzUGFyYW19IHRhcmdldHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbcHJvcGVydHlOYW1lXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmVtb3ZlKHRhcmdldHMsIHByb3BlcnR5TmFtZSkge1xuICAgIHJlbW92ZSh0YXJnZXRzLCB0aGlzLCBwcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3RHVyYXRpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICovXG4gIHN0cmV0Y2gobmV3RHVyYXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChjdXJyZW50RHVyYXRpb24gPT09IG5vcm1hbGl6ZVRpbWUobmV3RHVyYXRpb24pKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCB0aW1lU2NhbGUgPSBuZXdEdXJhdGlvbiAvIGN1cnJlbnREdXJhdGlvbjtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovY2hpbGQpID0+IGNoaWxkLnN0cmV0Y2goY2hpbGQuZHVyYXRpb24gKiB0aW1lU2NhbGUpKTtcbiAgICBmb3IgKGxldCBsYWJlbE5hbWUgaW4gbGFiZWxzKSBsYWJlbHNbbGFiZWxOYW1lXSAqPSB0aW1lU2NhbGU7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmV0Y2gobmV3RHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnJlZnJlc2gpIGNoaWxkLnJlZnJlc2goKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgcmV2ZXJ0KCkge1xuICAgIHN1cGVyLnJldmVydCgpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9jaGlsZCkgPT4gY2hpbGQucmV2ZXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gY2xlYW5JbmxpbmVTdHlsZXModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7Q2FsbGJhY2s8dGhpcz59IFtjYWxsYmFja11cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHRoZW4oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc3VwZXIudGhlbihjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVsaW5lUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm4ge1RpbWVsaW5lfVxuICovXG5jb25zdCBjcmVhdGVUaW1lbGluZSA9IHBhcmFtZXRlcnMgPT4gbmV3IFRpbWVsaW5lKHBhcmFtZXRlcnMpLmluaXQoKTtcblxuXG5cblxuY2xhc3MgQW5pbWF0YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhcmdldHNQYXJhbX0gdGFyZ2V0c1xuICAgKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldHMsIHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuICAgIC8qKiBAdHlwZSB7QW5pbWF0aW9uUGFyYW1zfSAqL1xuICAgIGNvbnN0IGdsb2JhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICBpZiAoaXNVbmQodGFyZ2V0cykgfHwgaXNVbmQocGFyYW1ldGVycykpIHJldHVybjtcbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBwYXJhbVZhbHVlID0gcGFyYW1ldGVyc1twcm9wTmFtZV07XG4gICAgICBpZiAoaXNLZXkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbFBhcmFtc1twcm9wTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIGNvbnN0IGlzT2JqVmFsdWUgPSBpc09iaihwcm9wVmFsdWUpO1xuICAgICAgLyoqIEB0eXBlIHtUd2VlblBhcmFtc09wdGlvbnN9ICovXG4gICAgICBsZXQgcHJvcFBhcmFtcyA9IHt9O1xuICAgICAgbGV0IHRvID0gJys9MCc7XG4gICAgICBpZiAoaXNPYmpWYWx1ZSkge1xuICAgICAgICBjb25zdCB1bml0ID0gcHJvcFZhbHVlLnVuaXQ7XG4gICAgICAgIGlmIChpc1N0cih1bml0KSkgdG8gKz0gdW5pdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXJhbXMuZHVyYXRpb24gPSBwcm9wVmFsdWU7XG4gICAgICB9XG4gICAgICBwcm9wUGFyYW1zW3Byb3BOYW1lXSA9IGlzT2JqVmFsdWUgPyBtZXJnZU9iamVjdHMoeyB0byB9LCBwcm9wVmFsdWUpIDogdG87XG4gICAgICBjb25zdCBhbmltUGFyYW1zID0gbWVyZ2VPYmplY3RzKGdsb2JhbFBhcmFtcywgcHJvcFBhcmFtcyk7XG4gICAgICBhbmltUGFyYW1zLmNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5yZXBsYWNlO1xuICAgICAgYW5pbVBhcmFtcy5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW3Byb3BOYW1lXSA9IG5ldyBKU0FuaW1hdGlvbih0YXJnZXRzLCBhbmltUGFyYW1zLCBudWxsLCAwLCBmYWxzZSkuaW5pdCgpO1xuICAgICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB0aGlzLnRhcmdldHMucHVzaCguLi5hbmltYXRpb24udGFyZ2V0cyk7XG4gICAgICAvKiogQHR5cGUge0FuaW1hdGFibGVQcm9wZXJ0eX0gKi9cbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gKHRvLCBkdXJhdGlvbiwgZWFzZSkgPT4ge1xuICAgICAgICBjb25zdCB0d2VlbiA9IC8qKiBAdHlwZSB7VHdlZW59ICovKGFuaW1hdGlvbi5faGVhZCk7XG4gICAgICAgIGlmIChpc1VuZCh0bykgJiYgdHdlZW4pIHtcbiAgICAgICAgICBjb25zdCBudW1iZXJzID0gdHdlZW4uX251bWJlcnM7XG4gICAgICAgICAgaWYgKG51bWJlcnMgJiYgbnVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JFYWNoQ2hpbGRyZW4oYW5pbWF0aW9uLCAoLyoqIEB0eXBlIHtUd2Vlbn0gKi90d2VlbikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXJyKHRvKSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKHRvKS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kKHR3ZWVuLl9udW1iZXJzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXJzW2ldID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHR3ZWVuLl9tb2RpZmllcih0d2Vlbi5fbnVtYmVyc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyc1tpXSA9IHRvW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHdlZW4uX2Zyb21OdW1iZXIgPSAvKiogQHR5cGUge051bWJlcn0gKi8odHdlZW4uX21vZGlmaWVyKHR3ZWVuLl9udW1iZXIpKTtcbiAgICAgICAgICAgICAgdHdlZW4uX3RvTnVtYmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmQoZWFzZSkpIHR3ZWVuLl9lYXNlID0gcGFyc2VFYXNpbmdzKGVhc2UpO1xuICAgICAgICAgICAgdHdlZW4uX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWlzVW5kKGR1cmF0aW9uKSkgYW5pbWF0aW9uLnN0cmV0Y2goZHVyYXRpb24pO1xuICAgICAgICAgIGFuaW1hdGlvbi5yZXNldCgxKS5yZXN1bWUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gdGhpcy5hbmltYXRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vb3A7XG4gICAgICB0aGlzLmFuaW1hdGlvbnNbcHJvcE5hbWVdLnJldmVydCgpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRhcmdldHMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRzXG4gKiBAcGFyYW0ge0FuaW1hdGFibGVQYXJhbXN9IHBhcmFtZXRlcnNcbiAqIEByZXR1cm4ge0FuaW1hdGFibGVPYmplY3R9XG4gKi9cbmNvbnN0IGNyZWF0ZUFuaW1hdGFibGUgPSAodGFyZ2V0cywgcGFyYW1ldGVycykgPT4gLyoqIEB0eXBlIHtBbmltYXRhYmxlT2JqZWN0fSAqLyhuZXcgQW5pbWF0YWJsZSh0YXJnZXRzLCBwYXJhbWV0ZXJzKSk7XG5cblxuXG5cbi8qXG4gKiBTcHJpbmcgZWFzZSBzb2x2ZXIgYWRhcHRlZCBmcm9tIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG4gKiBXZWJraXQgQ29weXJpZ2h0IMKpIDIwMTYgQXBwbGUgSW5jXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcHJpbmdQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFzcz0xXSAtIE1hc3MsIGRlZmF1bHQgMVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdGlmZm5lc3M9MTAwXSAtIFN0aWZmbmVzcywgZGVmYXVsdCAxMDBcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGFtcGluZz0xMF0gLSBEYW1waW5nLCBkZWZhdWx0IDEwXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3ZlbG9jaXR5PTBdIC0gSW5pdGlhbCB2ZWxvY2l0eSwgZGVmYXVsdCAwXG4gKi9cblxuY2xhc3MgU3ByaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIHRoaXMudGltZVN0ZXAgPSAuMDI7IC8vIEludGVydmFsIGZlZCB0byB0aGUgc29sdmVyIHRvIGNhbGN1bGF0ZSBkdXJhdGlvblxuICAgIHRoaXMucmVzdFRocmVzaG9sZCA9IC4wMDA1OyAvLyBWYWx1ZXMgYmVsb3cgdGhpcyB0aHJlc2hvbGQgYXJlIGNvbnNpZGVyZWQgcmVzdGluZyBwb3NpdGlvblxuICAgIHRoaXMucmVzdER1cmF0aW9uID0gMjAwOyAvLyBEdXJhdGlvbiBpbiBtcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSBzcHJpbmcgaXMgcmVzdGluZyBhZnRlciByZWFjaGluZyByZXN0VGhyZXNob2xkXG4gICAgdGhpcy5tYXhEdXJhdGlvbiA9IDYwMDAwOyAvLyBUaGUgbWF4aW11bSBhbGxvd2VkIHNwcmluZyBkdXJhdGlvbiBpbiBtcyAoZGVmYXVsdCAxIG1pbilcbiAgICB0aGlzLm1heFJlc3RTdGVwcyA9IHRoaXMucmVzdER1cmF0aW9uIC8gdGhpcy50aW1lU3RlcCAvIEs7IC8vIEhvdyBtYW55IHN0ZXBzIGFsbG93ZWQgYWZ0ZXIgcmVhY2hpbmcgcmVzdFRocmVzaG9sZCBiZWZvcmUgc3RvcHBpbmcgdGhlIGR1cmF0aW9uIGNhbGN1bGF0aW9uXG4gICAgdGhpcy5tYXhJdGVyYXRpb25zID0gdGhpcy5tYXhEdXJhdGlvbiAvIHRoaXMudGltZVN0ZXAgLyBLOyAvLyBDYWxjdWxhdGUgdGhlIG1heGltdW0gaXRlcmF0aW9ucyBhbGxvd2VkIGJhc2VkIG9uIG1heER1cmF0aW9uXG4gICAgdGhpcy5tID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy5tYXNzLCAxKSwgMCwgSyk7XG4gICAgdGhpcy5zID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy5zdGlmZm5lc3MsIDEwMCksIDEsIEspO1xuICAgIHRoaXMuZCA9IGNsYW1wKHNldFZhbHVlKHBhcmFtZXRlcnMuZGFtcGluZywgMTApLCAuMSwgSyk7XG4gICAgdGhpcy52ID0gY2xhbXAoc2V0VmFsdWUocGFyYW1ldGVycy52ZWxvY2l0eSwgMCksIC0xZTMsIEspO1xuICAgIHRoaXMudzAgPSAwO1xuICAgIHRoaXMuemV0YSA9IDA7XG4gICAgdGhpcy53ZCA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLnNvbHZlckR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAvKiogQHR5cGUge0Vhc2luZ0Z1bmN0aW9ufSAqL1xuICAgIHRoaXMuZWFzZSA9IHQgPT4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHRoaXMuc29sdmUodCAqIHRoaXMuc29sdmVyRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgc29sdmUodGltZSkge1xuICAgIGNvbnN0IHsgemV0YSwgdzAsIHdkLCBiIH0gPSB0aGlzO1xuICAgIGxldCB0ID0gdGltZTtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHQgPSBleHAoLXQgKiB6ZXRhICogdzApICogKDEgKiBjb3Mod2QgKiB0KSArIGIgKiBzaW4od2QgKiB0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSAoMSArIGIgKiB0KSAqIGV4cCgtdCAqIHcwKTtcbiAgICB9XG4gICAgcmV0dXJuIDEgLSB0O1xuICB9XG5cbiAgY29tcHV0ZSgpIHtcbiAgICBjb25zdCB7IG1heFJlc3RTdGVwcywgbWF4SXRlcmF0aW9ucywgcmVzdFRocmVzaG9sZCwgdGltZVN0ZXAsIG0sIGQsIHMsIHYgfSA9IHRoaXM7XG4gICAgY29uc3QgdzAgPSB0aGlzLncwID0gY2xhbXAoc3FydChzIC8gbSksIG1pblZhbHVlLCBLKTtcbiAgICBjb25zdCB6ZXRhID0gdGhpcy56ZXRhID0gZCAvICgyICogc3FydChzICogbSkpO1xuICAgIGNvbnN0IHdkID0gdGhpcy53ZCA9IHpldGEgPCAxID8gdzAgKiBzcXJ0KDEgLSB6ZXRhICogemV0YSkgOiAwO1xuICAgIHRoaXMuYiA9IHpldGEgPCAxID8gKHpldGEgKiB3MCArIC12KSAvIHdkIDogLXYgKyB3MDtcbiAgICBsZXQgc29sdmVyVGltZSA9IDA7XG4gICAgbGV0IHJlc3RTdGVwcyA9IDA7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlIChyZXN0U3RlcHMgPCBtYXhSZXN0U3RlcHMgJiYgaXRlcmF0aW9ucyA8IG1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlmIChhYnMoMSAtIHRoaXMuc29sdmUoc29sdmVyVGltZSkpIDwgcmVzdFRocmVzaG9sZCkge1xuICAgICAgICByZXN0U3RlcHMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RTdGVwcyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNvbHZlckR1cmF0aW9uID0gc29sdmVyVGltZTtcbiAgICAgIHNvbHZlclRpbWUgKz0gdGltZVN0ZXA7XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfVxuICAgIHRoaXMuZHVyYXRpb24gPSByb3VuZCh0aGlzLnNvbHZlckR1cmF0aW9uICogSywgMCkgKiBnbG9iYWxzLnRpbWVTY2FsZTtcbiAgfVxuXG4gIGdldCBtYXNzKCkge1xuICAgIHJldHVybiB0aGlzLm07XG4gIH1cblxuICBzZXQgbWFzcyh2KSB7XG4gICAgdGhpcy5tID0gY2xhbXAoc2V0VmFsdWUodiwgMSksIDAsIEspO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICB9XG5cbiAgZ2V0IHN0aWZmbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG5cbiAgc2V0IHN0aWZmbmVzcyh2KSB7XG4gICAgdGhpcy5zID0gY2xhbXAoc2V0VmFsdWUodiwgMTAwKSwgMSwgSyk7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gIH1cblxuICBnZXQgZGFtcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kO1xuICB9XG5cbiAgc2V0IGRhbXBpbmcodikge1xuICAgIHRoaXMuZCA9IGNsYW1wKHNldFZhbHVlKHYsIDEwKSwgLjEsIEspO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICB9XG5cbiAgZ2V0IHZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnY7XG4gIH1cblxuICBzZXQgdmVsb2NpdHkodikge1xuICAgIHRoaXMudiA9IGNsYW1wKHNldFZhbHVlKHYsIDApLCAtMWUzLCBLKTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ByaW5nUGFyYW1zfSBbcGFyYW1ldGVyc11cbiAqIEByZXR1cm5zIHtTcHJpbmd9XG4gKi9cbmNvbnN0IGNyZWF0ZVNwcmluZyA9IChwYXJhbWV0ZXJzKSA9PiBuZXcgU3ByaW5nKHBhcmFtZXRlcnMpO1xuXG5cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR9IGVcbiAqL1xuY29uc3QgcHJldmVudERlZmF1bHQgPSBlID0+IHtcbiAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuY2xhc3MgRE9NUHJveHkge1xuICAvKiogQHBhcmFtIHtPYmplY3R9IGVsICovXG4gIGNvbnN0cnVjdG9yKGVsKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2xhc3NMaXN0ID0ge1xuICAgICAgYWRkOiBub29wLFxuICAgICAgcmVtb3ZlOiBub29wLFxuICAgIH07XG4gIH1cblxuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuZWwueCB8fCAwIH07XG4gIHNldCB4KHYpIHsgdGhpcy5lbC54ID0gdjsgfTtcblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuZWwueSB8fCAwIH07XG4gIHNldCB5KHYpIHsgdGhpcy5lbC55ID0gdjsgfTtcblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLmVsLndpZHRoIHx8IDAgfTtcbiAgc2V0IHdpZHRoKHYpIHsgdGhpcy5lbC53aWR0aCA9IHY7IH07XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuZWwuaGVpZ2h0IHx8IDAgfTtcbiAgc2V0IGhlaWdodCh2KSB7IHRoaXMuZWwuaGVpZ2h0ID0gdjsgfTtcblxuICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdGhpcy55LFxuICAgICAgcmlnaHQ6IHRoaXMueCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICBsZWZ0OiB0aGlzLnggKyB0aGlzLndpZHRoLFxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUcmFuc2Zvcm1zIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NVGFyZ2V0fERPTVByb3h5fSAkZWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCRlbCkge1xuICAgIHRoaXMuJGVsID0gJGVsO1xuICAgIHRoaXMuaW5saW5lVHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMucG9pbnQgPSBuZXcgRE9NUG9pbnQoKTtcbiAgICB0aGlzLmludmVyc2VkTWF0cml4ID0gdGhpcy5nZXRNYXRyaXgoKS5pbnZlcnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7RE9NUG9pbnR9XG4gICAqL1xuICBub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgdGhpcy5wb2ludC54ID0geDtcbiAgICB0aGlzLnBvaW50LnkgPSB5O1xuICAgIHJldHVybiB0aGlzLnBvaW50Lm1hdHJpeFRyYW5zZm9ybSh0aGlzLmludmVyc2VkTWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgVHJhdmVyc2VQYXJlbnRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtET01UYXJnZXR9ICRlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmF2ZXJzZVBhcmVudHNDYWxsYmFja30gY2JcbiAgICovXG4gIHRyYXZlcnNlVXAoY2IpIHtcbiAgICBsZXQgJGVsID0gLyoqIEB0eXBlIHtET01UYXJnZXR8RG9jdW1lbnR9ICovKHRoaXMuJGVsLnBhcmVudEVsZW1lbnQpLCBpID0gMDtcbiAgICB3aGlsZSAoJGVsICYmICRlbCAhPT0gZG9jKSB7XG4gICAgICBjYigvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsKSwgaSk7XG4gICAgICAkZWwgPSAvKiogQHR5cGUge0RPTVRhcmdldH0gKi8oJGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGdldE1hdHJpeCgpIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgRE9NTWF0cml4KCk7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCRlbCA9PiB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoJGVsKS50cmFuc2Zvcm07XG4gICAgICBpZiAodHJhbnNmb3JtVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZWxNYXRyaXggPSBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybVZhbHVlKTtcbiAgICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihlbE1hdHJpeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLnRyYXZlcnNlVXAoKCRlbCwgaSkgPT4ge1xuICAgICAgdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldID0gJGVsLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICRlbC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy50cmF2ZXJzZVVwKCgkZWwsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN0ID0gdGhpcy5pbmxpbmVUcmFuc2Zvcm1zW2ldO1xuICAgICAgaWYgKGN0ID09PSAnJykge1xuICAgICAgICAkZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsLnN0eWxlLnRyYW5zZm9ybSA9IGN0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBcnJheTxOdW1iZXI+fERPTVRhcmdldFNlbGVjdG9yfFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxEcmFnZ2FibGVDdXJzb3JQYXJhbXN9IFRcbiAqIEBwYXJhbSB7VCB8ICgoZHJhZ2dhYmxlOiBEcmFnZ2FibGUpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgcGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgZHJhZ2dhYmxlKSA9PiB2YWx1ZSAmJiBpc0ZuYyh2YWx1ZSkgPyAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyh2YWx1ZSkoZHJhZ2dhYmxlKSA6IHZhbHVlO1xuXG5sZXQgekluZGV4ID0gMDtcblxuY2xhc3MgRHJhZ2dhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFyZ2V0c1BhcmFtfSB0YXJnZXRcbiAgICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmIChnbG9iYWxzLnNjb3BlKSBnbG9iYWxzLnNjb3BlLnJldmVydGlibGVzLnB1c2godGhpcyk7XG4gICAgY29uc3QgcGFyYW1YID0gcGFyYW1ldGVycy54O1xuICAgIGNvbnN0IHBhcmFtWSA9IHBhcmFtZXRlcnMueTtcbiAgICBjb25zdCB0cmlnZ2VyID0gcGFyYW1ldGVycy50cmlnZ2VyO1xuICAgIGNvbnN0IG1vZGlmaWVyID0gcGFyYW1ldGVycy5tb2RpZmllcjtcbiAgICBjb25zdCBlYXNlID0gcGFyYW1ldGVycy5yZWxlYXNlRWFzZTtcbiAgICBjb25zdCBjdXN0b21FYXNlID0gZWFzZSAmJiBwYXJzZUVhc2luZ3MoZWFzZSk7XG4gICAgY29uc3QgaGFzU3ByaW5nID0gIWlzVW5kKGVhc2UpICYmICFpc1VuZCgvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSk7XG4gICAgY29uc3QgeFByb3AgPSAvKiogQHR5cGUge1N0cmluZ30gKi8oaXNPYmoocGFyYW1YKSAmJiAhaXNVbmQoLyoqIEB0eXBlIHtPYmplY3R9ICovKHBhcmFtWCkubWFwVG8pID8gLyoqIEB0eXBlIHtPYmplY3R9ICovKHBhcmFtWCkubWFwVG8gOiAndHJhbnNsYXRlWCcpO1xuICAgIGNvbnN0IHlQcm9wID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGlzT2JqKHBhcmFtWSkgJiYgIWlzVW5kKC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVkpLm1hcFRvKSA/IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhwYXJhbVkpLm1hcFRvIDogJ3RyYW5zbGF0ZVknKTtcbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtZXRlcnMuY29udGFpbmVyLCB0aGlzKTtcbiAgICB0aGlzLmNvbnRhaW5lckFycmF5ID0gaXNBcnIoY29udGFpbmVyKSA/IGNvbnRhaW5lciA6IG51bGw7XG4gICAgdGhpcy4kY29udGFpbmVyID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY29udGFpbmVyICYmICF0aGlzLmNvbnRhaW5lckFycmF5ID8gcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhjb250YWluZXIpKVswXSA6IGRvYy5ib2R5KTtcbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuJGNvbnRhaW5lciA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtXaW5kb3cgfCBIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSB0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuJGNvbnRhaW5lcjtcbiAgICB0aGlzLiR0YXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhpc09iaih0YXJnZXQpID8gbmV3IERPTVByb3h5KHRhcmdldCkgOiBwYXJzZVRhcmdldHModGFyZ2V0KVswXSk7XG4gICAgdGhpcy4kdHJpZ2dlciA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHBhcnNlVGFyZ2V0cyh0cmlnZ2VyID8gdHJpZ2dlciA6IHRhcmdldClbMF0pO1xuICAgIHRoaXMuZml4ZWQgPSBnZXRUYXJnZXRWYWx1ZSh0aGlzLiR0YXJnZXQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnO1xuICAgIC8vIFJlZnJlc2hhYmxlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmlzRmluZVBvaW50ZXIgPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb250YWluZXJQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuY29udGFpbmVyRnJpY3Rpb24gPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcnxBcnJheTxOdW1iZXI+fSAqL1xuICAgIHRoaXMuc25hcFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfEFycmF5PE51bWJlcj59ICovXG4gICAgdGhpcy5zbmFwWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxTcGVlZCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhZ1NwZWVkID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm1heFZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLm1pblZlbG9jaXR5ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5TXVsdGlwbGllciA9IDA7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufERyYWdnYWJsZUN1cnNvclBhcmFtc30gKi9cbiAgICB0aGlzLmN1cnNvciA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7U3ByaW5nfSAqL1xuICAgIHRoaXMucmVsZWFzZVhTcHJpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkgOiBjcmVhdGVTcHJpbmcoe1xuICAgICAgbWFzczogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlTWFzcywgMSksXG4gICAgICBzdGlmZm5lc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZVN0aWZmbmVzcywgODApLFxuICAgICAgZGFtcGluZzogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlRGFtcGluZywgMjApLFxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7U3ByaW5nfSAqL1xuICAgIHRoaXMucmVsZWFzZVlTcHJpbmcgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkgOiBjcmVhdGVTcHJpbmcoe1xuICAgICAgbWFzczogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlTWFzcywgMSksXG4gICAgICBzdGlmZm5lc3M6IHNldFZhbHVlKHBhcmFtZXRlcnMucmVsZWFzZVN0aWZmbmVzcywgODApLFxuICAgICAgZGFtcGluZzogc2V0VmFsdWUocGFyYW1ldGVycy5yZWxlYXNlRGFtcGluZywgMjApLFxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7RWFzaW5nRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZWxlYXNlRWFzZSA9IGN1c3RvbUVhc2UgfHwgZWFzZXMub3V0UXVpbnQ7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaGFzUmVsZWFzZVNwcmluZyA9IGhhc1NwcmluZztcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25HcmFiID0gcGFyYW1ldGVycy5vbkdyYWIgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25EcmFnID0gcGFyYW1ldGVycy5vbkRyYWcgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25SZWxlYXNlID0gcGFyYW1ldGVycy5vblJlbGVhc2UgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBwYXJhbWV0ZXJzLm9uVXBkYXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazx0aGlzPn0gKi9cbiAgICB0aGlzLm9uU2V0dGxlID0gcGFyYW1ldGVycy5vblNldHRsZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblNuYXAgPSBwYXJhbWV0ZXJzLm9uU25hcCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8dGhpcz59ICovXG4gICAgdGhpcy5vblJlc2l6ZSA9IHBhcmFtZXRlcnMub25SZXNpemUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPHRoaXM+fSAqL1xuICAgIHRoaXMub25BZnRlclJlc2l6ZSA9IHBhcmFtZXRlcnMub25BZnRlclJlc2l6ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gWzAsIDBdO1xuICAgIC8qKiBAdHlwZSB7QW5pbWF0YWJsZVBhcmFtc30gKi9cbiAgICBjb25zdCBhbmltYXRhYmxlUGFyYW1zID0ge307XG4gICAgaWYgKG1vZGlmaWVyKSBhbmltYXRhYmxlUGFyYW1zLm1vZGlmaWVyID0gbW9kaWZpZXI7XG4gICAgaWYgKGlzVW5kKHBhcmFtWCkgfHwgcGFyYW1YID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3hQcm9wXSA9IDA7XG4gICAgfSBlbHNlIGlmIChpc09iaihwYXJhbVgpKSB7XG4gICAgICBjb25zdCBwYXJhbVhPYmplY3QgPSAvKiogQHR5cGUge0RyYWdnYWJsZUF4aXNQYXJhbX0gKi8ocGFyYW1YKTtcbiAgICAgIGNvbnN0IGFuaW1hdGFibGVYUGFyYW1zID0ge307XG4gICAgICBpZiAocGFyYW1YT2JqZWN0Lm1vZGlmaWVyKSBhbmltYXRhYmxlWFBhcmFtcy5tb2RpZmllciA9IHBhcmFtWE9iamVjdC5tb2RpZmllcjtcbiAgICAgIGlmIChwYXJhbVhPYmplY3QuY29tcG9zaXRpb24pIGFuaW1hdGFibGVYUGFyYW1zLmNvbXBvc2l0aW9uID0gcGFyYW1YT2JqZWN0LmNvbXBvc2l0aW9uO1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t4UHJvcF0gPSBhbmltYXRhYmxlWFBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBhcmFtWCA9PT0gZmFsc2UpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeFByb3BdID0gMDtcbiAgICAgIHRoaXMuZGlzYWJsZWRbMF0gPSAxO1xuICAgIH1cbiAgICBpZiAoaXNVbmQocGFyYW1ZKSB8fCBwYXJhbVkgPT09IHRydWUpIHtcbiAgICAgIGFuaW1hdGFibGVQYXJhbXNbeVByb3BdID0gMDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKHBhcmFtWSkpIHtcbiAgICAgIGNvbnN0IHBhcmFtWU9iamVjdCA9IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQXhpc1BhcmFtfSAqLyhwYXJhbVkpO1xuICAgICAgY29uc3QgYW5pbWF0YWJsZVlQYXJhbXMgPSB7fTtcbiAgICAgIGlmIChwYXJhbVlPYmplY3QubW9kaWZpZXIpIGFuaW1hdGFibGVZUGFyYW1zLm1vZGlmaWVyID0gcGFyYW1ZT2JqZWN0Lm1vZGlmaWVyO1xuICAgICAgaWYgKHBhcmFtWU9iamVjdC5jb21wb3NpdGlvbikgYW5pbWF0YWJsZVlQYXJhbXMuY29tcG9zaXRpb24gPSBwYXJhbVlPYmplY3QuY29tcG9zaXRpb247XG4gICAgICBhbmltYXRhYmxlUGFyYW1zW3lQcm9wXSA9IGFuaW1hdGFibGVZUGFyYW1zO1xuICAgIH0gZWxzZSBpZiAocGFyYW1ZID09PSBmYWxzZSkge1xuICAgICAgYW5pbWF0YWJsZVBhcmFtc1t5UHJvcF0gPSAwO1xuICAgICAgdGhpcy5kaXNhYmxlZFsxXSA9IDE7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7QW5pbWF0YWJsZU9iamVjdH0gKi9cbiAgICB0aGlzLmFuaW1hdGUgPSAvKiogQHR5cGUge0FuaW1hdGFibGVPYmplY3R9ICovKG5ldyBBbmltYXRhYmxlKHRoaXMuJHRhcmdldCwgYW5pbWF0YWJsZVBhcmFtcykpO1xuICAgIC8vIEludGVybmFsIHByb3BzXG4gICAgdGhpcy54UHJvcCA9IHhQcm9wO1xuICAgIHRoaXMueVByb3AgPSB5UHJvcDtcbiAgICB0aGlzLmRlc3RYID0gMDtcbiAgICB0aGlzLmRlc3RZID0gMDtcbiAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgIHRoaXMuc2Nyb2xsID0ge3g6IDAsIHk6IDB9O1xuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5jb29yZHMgPSBbdGhpcy54LCB0aGlzLnksIDAsIDBdOyAvLyB4LCB5LCB0ZW1wIHgsIHRlbXAgeVxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLnNuYXBwZWQgPSBbMCwgMF07IC8vIHgsIHlcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5wb2ludGVyID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdOyAvLyB4MSwgeTEsIHgyLCB5MiwgdGVtcCB4MSwgdGVtcCB5MSwgdGVtcCB4MiwgdGVtcCB5MlxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyXX0gKi9cbiAgICB0aGlzLnNjcm9sbFZpZXcgPSBbMCwgMF07IC8vIHcsIGhcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuZHJhZ0FyZWEgPSBbMCwgMCwgMCwgMF07IC8vIHgsIHksIHcsIGhcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29udGFpbmVyQm91bmRzID0gWy0xZTEyLCBtYXhWYWx1ZSwgbWF4VmFsdWUsIC0xZTEyXTsgLy8gdCwgciwgYiwgbFxuICAgIC8qKiBAdHlwZSB7W051bWJlciwgTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy5zY3JvbGxCb3VuZHMgPSBbMCwgMCwgMCwgMF07IC8vIHQsIHIsIGIsIGxcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMudGFyZ2V0Qm91bmRzID0gWzAsIDAsIDAsIDBdOyAvLyB0LCByLCBiLCBsXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMud2luZG93ID0gWzAsIDBdOyAvLyB3LCBoXG4gICAgLyoqIEB0eXBlIHtbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl19ICovXG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrID0gWzAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHlTdGFja0luZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG5vdygpO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5jdXJzb3JTdHlsZXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMuYm9keVN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi9cbiAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBuZXcgVHJhbnNmb3Jtcyh0aGlzLiR0YXJnZXQpO1xuICAgIHRoaXMub3ZlcnNob290Q29vcmRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5vdmVyc2hvb3RYVGlja2VyID0gbmV3IFRpbWVyKHsgYXV0b3BsYXk6IGZhbHNlIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIgPSBuZXcgVGltZXIoeyBhdXRvcGxheTogZmFsc2UgfSwgbnVsbCwgMCkuaW5pdCgpO1xuICAgIHRoaXMudXBkYXRlVGlja2VyID0gbmV3IFRpbWVyKHsgYXV0b3BsYXk6IGZhbHNlIH0sIG51bGwsIDApLmluaXQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFhUaWNrZXIub25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZFswXSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy54LCAwKTtcbiAgICB9O1xuICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWRbMF0pIHJldHVybjtcbiAgICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueCwgMCk7XG4gICAgfTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIub25VcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZFsxXSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXSh0aGlzLm92ZXJzaG9vdENvb3Jkcy55LCAwKTtcbiAgICB9O1xuICAgIHRoaXMub3ZlcnNob290WVRpY2tlci5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWRbMV0pIHJldHVybjtcbiAgICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgICB0aGlzLmFuaW1hdGVbdGhpcy55UHJvcF0odGhpcy5vdmVyc2hvb3RDb29yZHMueSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5vblVwZGF0ZSA9ICgpID0+IHRoaXMudXBkYXRlKCk7XG4gICAgdGhpcy5jb250YWluZWQgPSAhaXNVbmQoY29udGFpbmVyKTtcbiAgICB0aGlzLm1hbnVhbCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFjdGl2ZVByb3AgPSB0aGlzLmRpc2FibGVkWzFdID8geFByb3AgOiB5UHJvcDtcbiAgICB0aGlzLmFuaW1hdGUuYW5pbWF0aW9uc1t0aGlzLmFjdGl2ZVByb3BdLm9uUmVuZGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgaGFzVXBkYXRlZCA9IHRoaXMudXBkYXRlZDtcbiAgICAgIGNvbnN0IGhhc01vdmVkID0gdGhpcy5ncmFiYmVkICYmIGhhc1VwZGF0ZWQ7XG4gICAgICBjb25zdCBoYXNSZWxlYXNlZCA9ICFoYXNNb3ZlZCAmJiB0aGlzLnJlbGVhc2VkO1xuICAgICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgICBjb25zdCBkeCA9IHggLSB0aGlzLmNvb3Jkc1syXTtcbiAgICAgIGNvbnN0IGR5ID0geSAtIHRoaXMuY29vcmRzWzNdO1xuICAgICAgdGhpcy5kZWx0YVggPSBkeDtcbiAgICAgIHRoaXMuZGVsdGFZID0gZHk7XG4gICAgICB0aGlzLmNvb3Jkc1syXSA9IHg7XG4gICAgICB0aGlzLmNvb3Jkc1szXSA9IHk7XG4gICAgICBpZiAoaGFzVXBkYXRlZCkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNSZWxlYXNlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhdGFuMihkeSwgZHgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hbmltYXRlLmFuaW1hdGlvbnNbdGhpcy5hY3RpdmVQcm9wXS5vbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCghdGhpcy5ncmFiYmVkICYmIHRoaXMucmVsZWFzZWQpKSB7XG4gICAgICAgIC8vIFNldCBlbGVhc2VkIHRvIGZhbHNlIGJlZm9yZSBjYWxsaW5nIG9uU2V0dGxlIHRvIGF2b2lkIHJlY3Vyc2lvblxuICAgICAgICB0aGlzLnJlbGVhc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWFudWFsKSB7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzFdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrWzJdID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm9uU2V0dGxlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5yZXNpemVUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZHVyYXRpb246IDE1MCAqIGdsb2JhbHMudGltZVNjYWxlLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm9uUmVzaXplKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5vbkFmdGVyUmVzaXplKHRoaXMpO1xuICAgICAgfSxcbiAgICB9KS5pbml0KCk7XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplVGlja2VyLnJlc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgaWYgKCFpc09iaih0YXJnZXQpKSB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy4kdGFyZ2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGR4XG4gICAqIEBwYXJhbSAge051bWJlcn0gZHlcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY29tcHV0ZVZlbG9jaXR5KGR4LCBkeSkge1xuICAgIGNvbnN0IHByZXZUaW1lID0gdGhpcy52ZWxvY2l0eVRpbWU7XG4gICAgY29uc3QgY3VyVGltZSA9IG5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJUaW1lIC0gcHJldlRpbWU7XG4gICAgaWYgKGVsYXBzZWQgPCAxNykgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG4gICAgdGhpcy52ZWxvY2l0eVRpbWUgPSBjdXJUaW1lO1xuICAgIGNvbnN0IHZlbG9jaXR5U3RhY2sgPSB0aGlzLnZlbG9jaXR5U3RhY2s7XG4gICAgY29uc3Qgdk11bCA9IHRoaXMudmVsb2NpdHlNdWx0aXBsaWVyO1xuICAgIGNvbnN0IG1pblYgPSB0aGlzLm1pblZlbG9jaXR5O1xuICAgIGNvbnN0IG1heFYgPSB0aGlzLm1heFZlbG9jaXR5O1xuICAgIGNvbnN0IHZpID0gdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXg7XG4gICAgdmVsb2NpdHlTdGFja1t2aV0gPSByb3VuZChjbGFtcCgoc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLyBlbGFwc2VkKSAqIHZNdWwsIG1pblYsIG1heFYpLCA1KTtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IG1heCh2ZWxvY2l0eVN0YWNrWzBdLCB2ZWxvY2l0eVN0YWNrWzFdLCB2ZWxvY2l0eVN0YWNrWzJdKTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAodmkgKyAxKSAlIDM7XG4gICAgcmV0dXJuIHZlbG9jaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgeFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttdXRlVXBkYXRlQ2FsbGJhY2tdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzZXRYKHgsIG11dGVVcGRhdGVDYWxsYmFjayA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWRbMF0pIHJldHVybjtcbiAgICBjb25zdCB2ID0gcm91bmQoeCwgNSk7XG4gICAgdGhpcy5vdmVyc2hvb3RYVGlja2VyLnBhdXNlKCk7XG4gICAgdGhpcy5tYW51YWwgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlZCA9ICFtdXRlVXBkYXRlQ2FsbGJhY2s7XG4gICAgdGhpcy5kZXN0WCA9IHY7XG4gICAgdGhpcy5zbmFwcGVkWzBdID0gc25hcCh2LCB0aGlzLnNuYXBYKTtcbiAgICB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0odiwgMCk7XG4gICAgdGhpcy5tYW51YWwgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gIHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbXV0ZVVwZGF0ZUNhbGxiYWNrXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgc2V0WSh5LCBtdXRlVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkWzFdKSByZXR1cm47XG4gICAgY29uc3QgdiA9IHJvdW5kKHksIDUpO1xuICAgIHRoaXMub3ZlcnNob290WVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMubWFudWFsID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZWQgPSAhbXV0ZVVwZGF0ZUNhbGxiYWNrO1xuICAgIHRoaXMuZGVzdFkgPSB2O1xuICAgIHRoaXMuc25hcHBlZFsxXSA9IHNuYXAodiwgdGhpcy5zbmFwWSk7XG4gICAgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKHYsIDApO1xuICAgIHRoaXMubWFudWFsID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gcm91bmQoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRoaXMuYW5pbWF0ZVt0aGlzLnhQcm9wXSgpKSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuc2V0WCh4LCBmYWxzZSk7XG4gIH1cblxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gcm91bmQoLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXSgpKSwgZ2xvYmFscy5wcmVjaXNpb24pO1xuICB9XG5cbiAgc2V0IHkoeSkge1xuICAgIHRoaXMuc2V0WSh5LCBmYWxzZSk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NYKCkge1xuICAgIHJldHVybiBtYXBSYW5nZSh0aGlzLngsIHRoaXMuY29udGFpbmVyQm91bmRzWzNdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1sxXSwgMCwgMSk7XG4gIH1cblxuICBzZXQgcHJvZ3Jlc3NYKHgpIHtcbiAgICB0aGlzLnNldFgobWFwUmFuZ2UoeCwgMCwgMSwgdGhpcy5jb250YWluZXJCb3VuZHNbM10sIHRoaXMuY29udGFpbmVyQm91bmRzWzFdKSwgZmFsc2UpO1xuICB9XG5cbiAgZ2V0IHByb2dyZXNzWSgpIHtcbiAgICByZXR1cm4gbWFwUmFuZ2UodGhpcy55LCB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSwgdGhpcy5jb250YWluZXJCb3VuZHNbMl0sIDAsIDEpO1xuICB9XG5cbiAgc2V0IHByb2dyZXNzWSh5KSB7XG4gICAgdGhpcy5zZXRZKG1hcFJhbmdlKHksIDAsIDEsIHRoaXMuY29udGFpbmVyQm91bmRzWzBdLCB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSksIGZhbHNlKTtcbiAgfVxuXG4gIHVwZGF0ZVNjcm9sbENvb3JkcygpIHtcbiAgICBjb25zdCBzeCA9IHJvdW5kKHRoaXMudXNlV2luID8gd2luLnNjcm9sbFggOiB0aGlzLiRjb250YWluZXIuc2Nyb2xsTGVmdCwgMCk7XG4gICAgY29uc3Qgc3kgPSByb3VuZCh0aGlzLnVzZVdpbiA/IHdpbi5zY3JvbGxZIDogdGhpcy4kY29udGFpbmVyLnNjcm9sbFRvcCwgMCk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLnNjcm9sbFRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbC54ID0gc3g7XG4gICAgdGhpcy5zY3JvbGwueSA9IHN5O1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzBdID0gc3kgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCAtIHRocmVzaG9sZDtcbiAgICB0aGlzLnNjcm9sbEJvdW5kc1sxXSA9IHN4IC0gdGhpcy50YXJnZXRCb3VuZHNbMV0gLSBjcHIgKyB0aHJlc2hvbGQ7XG4gICAgdGhpcy5zY3JvbGxCb3VuZHNbMl0gPSBzeSAtIHRoaXMudGFyZ2V0Qm91bmRzWzJdIC0gY3BiICsgdGhyZXNob2xkO1xuICAgIHRoaXMuc2Nyb2xsQm91bmRzWzNdID0gc3ggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCAtIHRocmVzaG9sZDtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kaW5nVmFsdWVzKCkge1xuICAgIGNvbnN0ICRjb250YWluZXIgPSB0aGlzLiRjb250YWluZXI7XG4gICAgY29uc3QgY3ggPSB0aGlzLng7XG4gICAgY29uc3QgY3kgPSB0aGlzLnk7XG4gICAgY29uc3QgY3gyID0gdGhpcy5jb29yZHNbMl07XG4gICAgY29uc3QgY3kyID0gIHRoaXMuY29vcmRzWzNdO1xuICAgIC8vIFByZXZlbnRzIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbCBhcmVhIGluIGNhc2VzIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0ZW1wIGNvb3JkcyBhcmUgYWxzbyBhZGp1c2V0IHRvIHByZXZlbnRzIHdyb25nIGRlbHRhIGNhbGN1bGF0aW9uIG9uIHVwZGF0ZXNcbiAgICB0aGlzLmNvb3Jkc1syXSA9IDA7XG4gICAgdGhpcy5jb29yZHNbM10gPSAwO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1zLnJlbW92ZSgpO1xuICAgIGNvbnN0IGl3ID0gdGhpcy53aW5kb3dbMF0gPSB3aW4uaW5uZXJXaWR0aDtcbiAgICBjb25zdCBpaCA9IHRoaXMud2luZG93WzFdID0gd2luLmlubmVySGVpZ2h0O1xuICAgIGNvbnN0IHV3ID0gdGhpcy51c2VXaW47XG4gICAgY29uc3Qgc3cgPSAkY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuICAgIGNvbnN0IHNoID0gJGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgY29uc3QgZnggPSB0aGlzLmZpeGVkO1xuICAgIGNvbnN0IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QgPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IFsgY3B0LCBjcHIsIGNwYiwgY3BsIF0gPSB0aGlzLmNvbnRhaW5lclBhZGRpbmc7XG4gICAgdGhpcy5kcmFnQXJlYVswXSA9IHV3ID8gMCA6IHRyYW5zZm9ybUNvbnRhaW5lclJlY3QubGVmdDtcbiAgICB0aGlzLmRyYWdBcmVhWzFdID0gdXcgPyAwIDogdHJhbnNmb3JtQ29udGFpbmVyUmVjdC50b3A7XG4gICAgdGhpcy5zY3JvbGxWaWV3WzBdID0gdXcgPyBjbGFtcChzdywgaXcsIHN3KSA6IHN3O1xuICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IHV3ID8gY2xhbXAoc2gsIGloLCBzaCkgOiBzaDtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tIH0gPSAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuZHJhZ0FyZWFbMl0gPSByb3VuZCh1dyA/IGNsYW1wKHdpZHRoLCBpdywgaXcpIDogd2lkdGgsIDApO1xuICAgIHRoaXMuZHJhZ0FyZWFbM10gPSByb3VuZCh1dyA/IGNsYW1wKGhlaWdodCwgaWgsIGloKSA6IGhlaWdodCwgMCk7XG4gICAgY29uc3QgY29udGFpbmVyT3ZlcmZsb3cgPSBnZXRUYXJnZXRWYWx1ZSgkY29udGFpbmVyLCAnb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB2aXNpYmxlT3ZlcmZsb3cgPSBjb250YWluZXJPdmVyZmxvdyA9PT0gJ3Zpc2libGUnO1xuICAgIGNvbnN0IGhpZGRlbk92ZXJmbG93ID0gY29udGFpbmVyT3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuICAgIHRoaXMuY2FuU2Nyb2xsID0gZnggPyBmYWxzZSA6XG4gICAgICB0aGlzLmNvbnRhaW5lZCAmJlxuICAgICAgKCgkY29udGFpbmVyID09PSBkb2MuYm9keSAmJiB2aXNpYmxlT3ZlcmZsb3cpIHx8ICghaGlkZGVuT3ZlcmZsb3cgJiYgIXZpc2libGVPdmVyZmxvdykpICYmXG4gICAgICAoc3cgPiB0aGlzLmRyYWdBcmVhWzJdICsgY3BsIC0gY3ByIHx8IHNoID4gdGhpcy5kcmFnQXJlYVszXSArIGNwdCAtIGNwYikgJiZcbiAgICAgICghdGhpcy5jb250YWluZXJBcnJheSB8fCAodGhpcy5jb250YWluZXJBcnJheSAmJiAhaXNBcnIodGhpcy5jb250YWluZXJBcnJheSkpKTtcbiAgICBpZiAodGhpcy5jb250YWluZWQpIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy5zY3JvbGwueTtcbiAgICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMuJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGhpZGRlbkxlZnQgPSBjYW5TY3JvbGwgPyB1dyA/IDAgOiAkY29udGFpbmVyLnNjcm9sbExlZnQgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuVG9wID0gY2FuU2Nyb2xsID8gdXcgPyAwIDogJGNvbnRhaW5lci5zY3JvbGxUb3AgOiAwO1xuICAgICAgY29uc3QgaGlkZGVuUmlnaHQgPSBjYW5TY3JvbGwgPyB0aGlzLnNjcm9sbFZpZXdbMF0gLSBoaWRkZW5MZWZ0IC0gd2lkdGggOiAwO1xuICAgICAgY29uc3QgaGlkZGVuQm90dG9tID0gY2FuU2Nyb2xsID8gdGhpcy5zY3JvbGxWaWV3WzFdIC0gaGlkZGVuVG9wIC0gaGVpZ2h0IDogMDtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzBdID0gcm91bmQoKHRhcmdldFJlY3QudG9wICsgc3kpIC0gKHV3ID8gMCA6IHRvcCksIDApO1xuICAgICAgdGhpcy50YXJnZXRCb3VuZHNbMV0gPSByb3VuZCgodGFyZ2V0UmVjdC5yaWdodCArIHN4KSAtICh1dyA/IGl3IDogcmlnaHQpLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzJdID0gcm91bmQoKHRhcmdldFJlY3QuYm90dG9tICsgc3kpIC0gKHV3ID8gaWggOiBib3R0b20pLCAwKTtcbiAgICAgIHRoaXMudGFyZ2V0Qm91bmRzWzNdID0gcm91bmQoKHRhcmdldFJlY3QubGVmdCArIHN4KSAtICh1dyA/IDAgOiBsZWZ0KSwgMCk7XG4gICAgICBpZiAodGhpcy5jb250YWluZXJBcnJheSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbMF0gKyBjcHQ7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gdGhpcy5jb250YWluZXJBcnJheVsxXSAtIGNwcjtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZHNbMl0gPSB0aGlzLmNvbnRhaW5lckFycmF5WzJdIC0gY3BiO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1szXSA9IHRoaXMuY29udGFpbmVyQXJyYXlbM10gKyBjcGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1swXSA9IC1yb3VuZCh0YXJnZXRSZWN0LnRvcCAtIChmeCA/IGNsYW1wKHRvcCwgMCwgaWgpIDogdG9wKSArIGhpZGRlblRvcCAtIGNwdCwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzFdID0gLXJvdW5kKHRhcmdldFJlY3QucmlnaHQgLSAoZnggPyBjbGFtcChyaWdodCwgMCwgaXcpIDogcmlnaHQpIC0gaGlkZGVuUmlnaHQgKyBjcHIsIDApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kc1syXSA9IC1yb3VuZCh0YXJnZXRSZWN0LmJvdHRvbSAtIChmeCA/IGNsYW1wKGJvdHRvbSwgMCwgaWgpIDogYm90dG9tKSAtIGhpZGRlbkJvdHRvbSArIGNwYiwgMCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyQm91bmRzWzNdID0gLXJvdW5kKHRhcmdldFJlY3QubGVmdCAtIChmeCA/IGNsYW1wKGxlZnQsIDAsIGl3KSA6IGxlZnQpICsgaGlkZGVuTGVmdCAtIGNwbCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3Jtcy5yZXZlcnQoKTtcbiAgICAvLyBSZXN0b3JlIGNvb3JkaW5hdGVzXG4gICAgdGhpcy5jb29yZHNbMl0gPSBjeDI7XG4gICAgdGhpcy5jb29yZHNbM10gPSBjeTI7XG4gICAgdGhpcy5zZXRYKGN4LCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY3ksIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgMCBpZiBub3QgT0IsIDEgaWYgeCBpcyBPQiwgMiBpZiB5IGlzIE9CLCAzIGlmIGJvdGggeCBhbmQgeSBhcmUgT0JcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl9IGJvdW5kc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGlzT3V0T2ZCb3VuZHMoYm91bmRzLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lZCkgcmV0dXJuIDA7XG4gICAgY29uc3QgWyBidCwgYnIsIGJiLCBibCBdID0gYm91bmRzO1xuICAgIGNvbnN0IFsgZHgsIGR5IF0gPSB0aGlzLmRpc2FibGVkO1xuICAgIGNvbnN0IG9ieCA9ICFkeCAmJiB4IDwgYmwgfHwgIWR4ICYmIHggPiBicjtcbiAgICBjb25zdCBvYnkgPSAhZHkgJiYgeSA8IGJ0IHx8ICFkeSAmJiB5ID4gYmI7XG4gICAgcmV0dXJuIG9ieCAmJiAhb2J5ID8gMSA6ICFvYnggJiYgb2J5ID8gMiA6IG9ieCAmJiBvYnkgPyAzIDogMDtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHBhcmFtWCA9IHBhcmFtcy54O1xuICAgIGNvbnN0IHBhcmFtWSA9IHBhcmFtcy55O1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmNvbnRhaW5lciwgdGhpcyk7XG4gICAgY29uc3QgY3AgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5jb250YWluZXJQYWRkaW5nLCB0aGlzKSB8fCAwO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqLyhpc0FycihjcCkgPyBjcCA6IFtjcCwgY3AsIGNwLCBjcF0pO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIGNvbnN0IHBhcnNlZEN1cnNvclN0eWxlcyA9IHBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLmN1cnNvciwgdGhpcyk7XG4gICAgY29uc3QgY3Vyc29yU3R5bGVzID0geyBvbkhvdmVyOiAnZ3JhYicsIG9uR3JhYjogJ2dyYWJiaW5nJyB9O1xuICAgIGlmIChwYXJzZWRDdXJzb3JTdHlsZXMpIHtcbiAgICAgIGNvbnN0IHsgb25Ib3Zlciwgb25HcmFiIH0gPSAvKiogQHR5cGUge0RyYWdnYWJsZUN1cnNvclBhcmFtc30gKi8ocGFyc2VkQ3Vyc29yU3R5bGVzKTtcbiAgICAgIGlmIChvbkhvdmVyKSBjdXJzb3JTdHlsZXMub25Ib3ZlciA9IG9uSG92ZXI7XG4gICAgICBpZiAob25HcmFiKSBjdXJzb3JTdHlsZXMub25HcmFiID0gb25HcmFiO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lckFycmF5ID0gaXNBcnIoY29udGFpbmVyKSA/IGNvbnRhaW5lciA6IG51bGw7XG4gICAgdGhpcy4kY29udGFpbmVyID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY29udGFpbmVyICYmICF0aGlzLmNvbnRhaW5lckFycmF5ID8gcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0fSAqLyhjb250YWluZXIpKVswXSA6IGRvYy5ib2R5KTtcbiAgICB0aGlzLnVzZVdpbiA9IHRoaXMuJGNvbnRhaW5lciA9PT0gZG9jLmJvZHk7XG4gICAgLyoqIEB0eXBlIHtXaW5kb3cgfCBIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSB0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuJGNvbnRhaW5lcjtcbiAgICB0aGlzLmlzRmluZVBvaW50ZXIgPSBtYXRjaE1lZGlhKCcocG9pbnRlcjpmaW5lKScpLm1hdGNoZXM7XG4gICAgdGhpcy5jb250YWluZXJQYWRkaW5nID0gc2V0VmFsdWUoY29udGFpbmVyUGFkZGluZywgWzAsIDAsIDAsIDBdKTtcbiAgICB0aGlzLmNvbnRhaW5lckZyaWN0aW9uID0gY2xhbXAoc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuY29udGFpbmVyRnJpY3Rpb24sIHRoaXMpLCAuOCksIDAsIDEpO1xuICAgIHRoaXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uID0gY2xhbXAoc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMucmVsZWFzZUNvbnRhaW5lckZyaWN0aW9uLCB0aGlzKSwgdGhpcy5jb250YWluZXJGcmljdGlvbiksIDAsIDEpO1xuICAgIHRoaXMuc25hcFggPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKGlzT2JqKHBhcmFtWCkgJiYgIWlzVW5kKHBhcmFtWC5zbmFwKSA/IHBhcmFtWC5zbmFwIDogcGFyYW1zLnNuYXAsIHRoaXMpO1xuICAgIHRoaXMuc25hcFkgPSBwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKGlzT2JqKHBhcmFtWSkgJiYgIWlzVW5kKHBhcmFtWS5zbmFwKSA/IHBhcmFtWS5zbmFwIDogcGFyYW1zLnNuYXAsIHRoaXMpO1xuICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5zY3JvbGxTcGVlZCwgdGhpcyksIDEuNSk7XG4gICAgdGhpcy5zY3JvbGxUaHJlc2hvbGQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5zY3JvbGxUaHJlc2hvbGQsIHRoaXMpLCAyMCk7XG4gICAgdGhpcy5kcmFnU3BlZWQgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5kcmFnU3BlZWQsIHRoaXMpLCAxKTtcbiAgICB0aGlzLm1pblZlbG9jaXR5ID0gc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMubWluVmVsb2NpdHksIHRoaXMpLCAwKTtcbiAgICB0aGlzLm1heFZlbG9jaXR5ID0gc2V0VmFsdWUocGFyc2VEcmFnZ2FibGVGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMubWF4VmVsb2NpdHksIHRoaXMpLCA1MCk7XG4gICAgdGhpcy52ZWxvY2l0eU11bHRpcGxpZXIgPSBzZXRWYWx1ZShwYXJzZURyYWdnYWJsZUZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy52ZWxvY2l0eU11bHRpcGxpZXIsIHRoaXMpLCAxKTtcbiAgICB0aGlzLmN1cnNvciA9IHBhcnNlZEN1cnNvclN0eWxlcyA9PT0gZmFsc2UgPyBmYWxzZSA6IGN1cnNvclN0eWxlcztcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nVmFsdWVzKCk7XG5cbiAgICAvLyBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyh0aGlzLmNvbnRhaW5lckJvdW5kcywgdGhpcy54LCB0aGlzLnkpO1xuICAgIC8vIGlmIChvYiA9PT0gMSB8fCBvYiA9PT0gMykgdGhpcy5wcm9ncmVzc1ggPSBweDtcbiAgICAvLyBpZiAob2IgPT09IDIgfHwgb2IgPT09IDMpIHRoaXMucHJvZ3Jlc3NZID0gcHk7XG5cbiAgICAvLyBpZiAodGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLmNvbnRhaW5lZCkge1xuICAgIC8vICAgaWYgKHRoaXMucHJvZ3Jlc3NYICE9PSBweCkgdGhpcy5wcm9ncmVzc1ggPSBweDtcbiAgICAvLyAgIGlmICh0aGlzLnByb2dyZXNzWSAhPT0gcHkpIHRoaXMucHJvZ3Jlc3NZID0gcHk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgWyBidCwgYnIsIGJiLCBibCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgdGhpcy5zZXRYKGNsYW1wKGN4LCBibCwgYnIpLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoY2xhbXAoY3ksIGJ0LCBiYiksIHRydWUpO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29vcmRzKCk7XG4gICAgaWYgKHRoaXMuY2FuU2Nyb2xsKSB7XG4gICAgICBjb25zdCBbIGNwdCwgY3ByLCBjcGIsIGNwbCBdID0gdGhpcy5jb250YWluZXJQYWRkaW5nO1xuICAgICAgY29uc3QgWyBzdywgc2ggXSA9IHRoaXMuc2Nyb2xsVmlldztcbiAgICAgIGNvbnN0IGRhdyA9IHRoaXMuZHJhZ0FyZWFbMl07XG4gICAgICBjb25zdCBkYWggPSB0aGlzLmRyYWdBcmVhWzNdO1xuICAgICAgY29uc3QgY3N4ID0gdGhpcy5zY3JvbGwueDtcbiAgICAgIGNvbnN0IGNzeSA9IHRoaXMuc2Nyb2xsLnk7XG4gICAgICBjb25zdCBuc3cgPSB0aGlzLiRjb250YWluZXIuc2Nyb2xsV2lkdGg7XG4gICAgICBjb25zdCBuc2ggPSB0aGlzLiRjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY29uc3QgY3N3ID0gdGhpcy51c2VXaW4gPyBjbGFtcChuc3csIHRoaXMud2luZG93WzBdLCBuc3cpIDogbnN3O1xuICAgICAgY29uc3QgY3NoID0gdGhpcy51c2VXaW4gPyBjbGFtcChuc2gsIHRoaXMud2luZG93WzFdLCBuc2gpIDogbnNoO1xuICAgICAgY29uc3Qgc3dkID0gc3cgLSBjc3c7XG4gICAgICBjb25zdCBzaGQgPSBzaCAtIGNzaDtcbiAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgc2Nyb2xsYXJlYSBkaW1lbnNpb25zIGNoYW5nZXMgZHVyaW5nIGRyYWdcbiAgICAgIGlmICh0aGlzLmRyYWdnZWQgJiYgc3dkID4gMCkge1xuICAgICAgICB0aGlzLmNvb3Jkc1swXSAtPSBzd2Q7XG4gICAgICAgIHRoaXMuc2Nyb2xsVmlld1swXSA9IGNzdztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRyYWdnZWQgJiYgc2hkID4gMCkge1xuICAgICAgICB0aGlzLmNvb3Jkc1sxXSAtPSBzaGQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsVmlld1sxXSA9IGNzaDtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBhdXRvc2Nyb2xsIHdoZW4gdGFyZ2V0IGlzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGJvdW5kc1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2Nyb2xsU3BlZWQgKiAxMDtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuc2Nyb2xsVGhyZXNob2xkO1xuICAgICAgY29uc3QgWyB4LCB5IF0gPSB0aGlzLmNvb3JkcztcbiAgICAgIGNvbnN0IFsgc3QsIHNyLCBzYiwgc2wgXSA9IHRoaXMuc2Nyb2xsQm91bmRzO1xuICAgICAgY29uc3QgdCA9IHJvdW5kKGNsYW1wKCh5IC0gc3QgKyBjcHQpIC8gdGhyZXNob2xkLCAtMSwgMCkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCgoeCAtIHNyIC0gY3ByKSAvIHRocmVzaG9sZCwgMCwgMSkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IGIgPSByb3VuZChjbGFtcCgoeSAtIHNiIC0gY3BiKSAvIHRocmVzaG9sZCwgMCwgMSkgKiBzLCAwKTtcbiAgICAgIGNvbnN0IGwgPSByb3VuZChjbGFtcCgoeCAtIHNsICsgY3BsKSAvIHRocmVzaG9sZCwgLTEsIDApICogcywgMCk7XG4gICAgICBpZiAodCB8fCBiIHx8IGwgfHwgcikge1xuICAgICAgICBjb25zdCBbbngsIG55XSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIGxldCBzY3JvbGxYID0gY3N4O1xuICAgICAgICBsZXQgc2Nyb2xsWSA9IGNzeTtcbiAgICAgICAgaWYgKCFueCkge1xuICAgICAgICAgIHNjcm9sbFggPSByb3VuZChjbGFtcChjc3ggKyAobCB8fCByKSwgMCwgc3cgLSBkYXcpLCAwKTtcbiAgICAgICAgICB0aGlzLmNvb3Jkc1swXSAtPSBjc3ggLSBzY3JvbGxYO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbnkpIHtcbiAgICAgICAgICBzY3JvbGxZID0gcm91bmQoY2xhbXAoY3N5ICsgKHQgfHwgYiksIDAsIHNoIC0gZGFoKSwgMCk7XG4gICAgICAgICAgdGhpcy5jb29yZHNbMV0gLT0gY3N5IC0gc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTYWZhcmkgbW9iaWxlIHJlcXVpcmVzIHRvIHVzZSBkaWZmZXJlbnQgc2Nyb2xsIG1ldGhvZHMgZGVwZW5kaW5nIGlmIHVzaW5nIHRoZSB3aW5kb3cgb3Igbm90XG4gICAgICAgIGlmICh0aGlzLnVzZVdpbikge1xuICAgICAgICAgIHRoaXMuJHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSgtKGNzeCAtIHNjcm9sbFgpLCAtKGNzeSAtIHNjcm9sbFkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgWyBweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzIF0gPSB0aGlzLnBvaW50ZXI7XG4gICAgdGhpcy5jb29yZHNbMF0gKz0gKHB4MSAtIHB4MykgKiB0aGlzLmRyYWdTcGVlZDtcbiAgICB0aGlzLmNvb3Jkc1sxXSArPSAocHkxIC0gcHkzKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIHRoaXMucG9pbnRlcls0XSA9IHB4MTtcbiAgICB0aGlzLnBvaW50ZXJbNV0gPSBweTE7XG4gICAgY29uc3QgWyBjeCwgY3kgXSA9IHRoaXMuY29vcmRzO1xuICAgIGNvbnN0IFsgc3gsIHN5IF0gPSB0aGlzLnNuYXBwZWQ7XG4gICAgY29uc3QgY2YgPSAoMSAtIHRoaXMuY29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgdGhpcy5zZXRYKGN4ID4gY3IgPyBjciArIChjeCAtIGNyKSAqIGNmIDogY3ggPCBjbCA/IGNsICsgKGN4IC0gY2wpICogY2YgOiBjeCwgZmFsc2UpO1xuICAgIHRoaXMuc2V0WShjeSA+IGNiID8gY2IgKyAoY3kgLSBjYikgKiBjZiA6IGN5IDwgY3QgPyBjdCArIChjeSAtIGN0KSAqIGNmIDogY3ksIGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVWZWxvY2l0eShweDEgLSBweDMsIHB5MSAtIHB5Myk7XG4gICAgdGhpcy5hbmdsZSA9IGF0YW4yKHB5MSAtIHB5MiwgcHgxIC0gcHgyKTtcbiAgICBjb25zdCBbIG5zeCwgbnN5IF0gPSB0aGlzLnNuYXBwZWQ7XG4gICAgaWYgKG5zeCAhPT0gc3ggJiYgdGhpcy5zbmFwWCB8fCBuc3kgIT09IHN5ICYmIHRoaXMuc25hcFkpIHtcbiAgICAgIHRoaXMub25TbmFwKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy51cGRhdGVUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFhUaWNrZXIucGF1c2UoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIucGF1c2UoKTtcbiAgICAvLyBQYXVzZXMgdGhlIGluIGJvdW5kcyBvblJlbGVhc2UgYW5pbWF0aW9uc1xuICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5hbmltYXRlLmFuaW1hdGlvbnMpIHRoaXMuYW5pbWF0ZS5hbmltYXRpb25zW3Byb3BdLnBhdXNlKCk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICd4Jyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICd5Jyk7XG4gICAgcmVtb3ZlKHRoaXMsIG51bGwsICdwcm9ncmVzc1gnKTtcbiAgICByZW1vdmUodGhpcywgbnVsbCwgJ3Byb2dyZXNzWScpO1xuICAgIHJlbW92ZSh0aGlzLnNjcm9sbCk7IC8vIFJlbW92ZXMgYW55IGFjdGl2ZSBhbmltYXRpb25zIG9uIHRoZSBjb250YWluZXIgc2Nyb2xsXG4gICAgcmVtb3ZlKHRoaXMub3ZlcnNob290Q29vcmRzKTsgLy8gUmVtb3ZlcyBhY3RpdmUgb3ZlcnNob290IGFuaW1hdGlvbnNcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtIHtFYXNpbmdQYXJhbX0gW2Vhc2VdXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBzY3JvbGxJblZpZXcoZHVyYXRpb24sIGdhcCA9IDAsIGVhc2UgPSBlYXNlcy5pbk91dFF1YWQpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIGNvbnN0IHggPSB0aGlzLmRlc3RYO1xuICAgIGNvbnN0IHkgPSB0aGlzLmRlc3RZO1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuc2Nyb2xsO1xuICAgIGNvbnN0IHNjcm9sbEJvdW5kcyA9IHRoaXMuc2Nyb2xsQm91bmRzO1xuICAgIGNvbnN0IGNhblNjcm9sbCA9IHRoaXMuY2FuU2Nyb2xsO1xuICAgIGlmICghdGhpcy5jb250YWluZXJBcnJheSAmJiB0aGlzLmlzT3V0T2ZCb3VuZHMoc2Nyb2xsQm91bmRzLCB4LCB5KSkge1xuICAgICAgY29uc3QgWyBzdCwgc3IsIHNiLCBzbCBdID0gc2Nyb2xsQm91bmRzO1xuICAgICAgY29uc3QgdCA9IHJvdW5kKGNsYW1wKHkgLSBzdCwgLTFlMTIsIDApLCAwKTtcbiAgICAgIGNvbnN0IHIgPSByb3VuZChjbGFtcCh4IC0gc3IsIDAsIG1heFZhbHVlKSwgMCk7XG4gICAgICBjb25zdCBiID0gcm91bmQoY2xhbXAoeSAtIHNiLCAwLCBtYXhWYWx1ZSksIDApO1xuICAgICAgY29uc3QgbCA9IHJvdW5kKGNsYW1wKHggLSBzbCwgLTFlMTIsIDApLCAwKTtcbiAgICAgIG5ldyBKU0FuaW1hdGlvbihzY3JvbGwsIHtcbiAgICAgICAgeDogcm91bmQoc2Nyb2xsLnggKyAobCA/IGwgLSBnYXAgOiByID8gciArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgeTogcm91bmQoc2Nyb2xsLnkgKyAodCA/IHQgLSBnYXAgOiBiID8gYiArIGdhcCA6IDApLCAwKSxcbiAgICAgICAgZHVyYXRpb246IGlzVW5kKGR1cmF0aW9uKSA/IDM1MCAqIGdsb2JhbHMudGltZVNjYWxlIDogZHVyYXRpb24sXG4gICAgICAgIGVhc2UsXG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW5TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLiRzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgICAgICAgfVxuICAgICAgfSkuaW5pdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmNhblNjcm9sbCA9IGNhblNjcm9sbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhbmRsZUhvdmVyKCkge1xuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IgJiYgIXRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0cmlnZ2VyLCB7XG4gICAgICAgIGN1cnNvcjogLyoqIEB0eXBlIHtEcmFnZ2FibGVDdXJzb3JQYXJhbXN9ICovKHRoaXMuY3Vyc29yKS5vbkhvdmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbZHVyYXRpb25dXG4gICAqIEBwYXJhbSAge051bWJlcn0gW2dhcF1cbiAgICogQHBhcmFtICB7RWFzaW5nUGFyYW19IFtlYXNlXVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgYW5pbWF0ZUluVmlldyhkdXJhdGlvbiwgZ2FwID0gMCwgZWFzZSA9IGVhc2VzLmluT3V0UXVhZCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgWyBjcHQsIGNwciwgY3BiLCBjcGwgXSA9IHRoaXMuY29udGFpbmVyUGFkZGluZztcbiAgICBjb25zdCBidCA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1swXSArIGNwdCArIGdhcDtcbiAgICBjb25zdCBiciA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1sxXSAtIGNwciAtIGdhcDtcbiAgICBjb25zdCBiYiA9IHRoaXMuc2Nyb2xsLnkgLSB0aGlzLnRhcmdldEJvdW5kc1syXSAtIGNwYiAtIGdhcDtcbiAgICBjb25zdCBibCA9IHRoaXMuc2Nyb2xsLnggLSB0aGlzLnRhcmdldEJvdW5kc1szXSArIGNwbCArIGdhcDtcbiAgICBjb25zdCBvYiA9IHRoaXMuaXNPdXRPZkJvdW5kcyhbYnQsIGJyLCBiYiwgYmxdLCB4LCB5KTtcbiAgICBpZiAob2IpIHtcbiAgICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICBjb25zdCBkZXN0WCA9IGNsYW1wKHNuYXAoeCwgdGhpcy5zbmFwWCksIGJsLCBicik7XG4gICAgICBjb25zdCBkZXN0WSA9IGNsYW1wKHNuYXAoeSwgdGhpcy5zbmFwWSksIGJ0LCBiYik7XG4gICAgICBjb25zdCBkdXIgPSBpc1VuZChkdXJhdGlvbikgPyAzNTAgKiBnbG9iYWxzLnRpbWVTY2FsZSA6IGR1cmF0aW9uO1xuICAgICAgaWYgKCFkaXNhYmxlZFggJiYgKG9iID09PSAxIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueFByb3BdKGRlc3RYLCBkdXIsIGVhc2UpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkgJiYgKG9iID09PSAyIHx8IG9iID09PSAzKSkgdGhpcy5hbmltYXRlW3RoaXMueVByb3BdKGRlc3RZLCBkdXIsIGVhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR8VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRG93bihlKSB7XG4gICAgY29uc3QgJGVUYXJnZXQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgaWYgKHRoaXMuZ3JhYmJlZCB8fCAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICAqLygkZVRhcmdldCkudHlwZSA9PT0gJ3JhbmdlJykgcmV0dXJuO1xuXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuZ3JhYmJlZCA9IHRydWU7XG4gICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdWYWx1ZXMoKTtcbiAgICBjb25zdCB0b3VjaGVzID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhlKS5jaGFuZ2VkVG91Y2hlcztcbiAgICBjb25zdCBldmVudFggPSB0b3VjaGVzID8gdG91Y2hlc1swXS5jbGllbnRYIDogLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyhlKS5jbGllbnRYO1xuICAgIGNvbnN0IGV2ZW50WSA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFkgOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRyYW5zZm9ybXMubm9ybWFsaXplUG9pbnQoZXZlbnRYLCBldmVudFkpO1xuICAgIGNvbnN0IFsgY3QsIGNyLCBjYiwgY2wgXSA9IHRoaXMuY29udGFpbmVyQm91bmRzO1xuICAgIGNvbnN0IGNmID0gKDEgLSB0aGlzLmNvbnRhaW5lckZyaWN0aW9uKSAqIHRoaXMuZHJhZ1NwZWVkO1xuICAgIGNvbnN0IGN4ID0gdGhpcy54O1xuICAgIGNvbnN0IGN5ID0gdGhpcy55O1xuICAgIHRoaXMuY29vcmRzWzBdID0gdGhpcy5jb29yZHNbMl0gPSAhY2YgPyBjeCA6IGN4ID4gY3IgPyBjciArIChjeCAtIGNyKSAvIGNmIDogY3ggPCBjbCA/IGNsICsgKGN4IC0gY2wpIC8gY2YgOiBjeDtcbiAgICB0aGlzLmNvb3Jkc1sxXSA9IHRoaXMuY29vcmRzWzNdID0gIWNmID8gY3kgOiBjeSA+IGNiID8gY2IgKyAoY3kgLSBjYikgLyBjZiA6IGN5IDwgY3QgPyBjdCArIChjeSAtIGN0KSAvIGNmIDogY3k7XG4gICAgdGhpcy5wb2ludGVyWzBdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbMV0gPSB5O1xuICAgIHRoaXMucG9pbnRlclsyXSA9IHg7XG4gICAgdGhpcy5wb2ludGVyWzNdID0geTtcbiAgICB0aGlzLnBvaW50ZXJbNF0gPSB4O1xuICAgIHRoaXMucG9pbnRlcls1XSA9IHk7XG4gICAgdGhpcy5wb2ludGVyWzZdID0geDtcbiAgICB0aGlzLnBvaW50ZXJbN10gPSB5O1xuICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICB0aGlzLmRlbHRhWSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMV0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIGlmICh0aGlzLnRhcmdldFN0eWxlcykge1xuICAgICAgdGhpcy50YXJnZXRTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHogPSAvKiogQHR5cGUge051bWJlcn0gKi8oZ2V0VGFyZ2V0VmFsdWUodGhpcy4kdGFyZ2V0LCAnekluZGV4JywgZmFsc2UpKTtcbiAgICB6SW5kZXggPSAoeiA+IHpJbmRleCA/IHogOiB6SW5kZXgpICsgMTtcbiAgICB0aGlzLnRhcmdldFN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyh0aGlzLiR0YXJnZXQsIHsgekluZGV4IH0pO1xuICAgIGlmICh0aGlzLnRyaWdnZXJTdHlsZXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudHJpZ2dlclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnNvclN0eWxlcykge1xuICAgICAgdGhpcy5jdXJzb3JTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRmluZVBvaW50ZXIgJiYgdGhpcy5jdXJzb3IpIHtcbiAgICAgIHRoaXMuYm9keVN0eWxlcyA9IHNldFRhcmdldFZhbHVlcyhkb2MuYm9keSwge1xuICAgICAgICBjdXJzb3I6IC8qKiBAdHlwZSB7RHJhZ2dhYmxlQ3Vyc29yUGFyYW1zfSAqLyh0aGlzLmN1cnNvcikub25HcmFiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxJblZpZXcoMTAwLCAwLCBlYXNlcy5vdXQoMykpO1xuICAgIHRoaXMub25HcmFiKHRoaXMpO1xuXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudHxUb3VjaEV2ZW50fSBlXG4gICAqL1xuICBoYW5kbGVNb3ZlKGUpIHtcbiAgICBpZiAoIXRoaXMuZ3JhYmJlZCkgcmV0dXJuO1xuICAgIGNvbnN0IHRvdWNoZXMgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpLmNoYW5nZWRUb3VjaGVzO1xuICAgIGNvbnN0IGV2ZW50WCA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLmNsaWVudFggOiAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovKGUpLmNsaWVudFg7XG4gICAgY29uc3QgZXZlbnRZID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0uY2xpZW50WSA6IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkuY2xpZW50WTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudHJhbnNmb3Jtcy5ub3JtYWxpemVQb2ludChldmVudFgsIGV2ZW50WSk7XG4gICAgY29uc3QgbW92ZWRYID0geCAtIHRoaXMucG9pbnRlcls2XTtcbiAgICBjb25zdCBtb3ZlZFkgPSB5IC0gdGhpcy5wb2ludGVyWzddO1xuXG4gICAgbGV0ICRwYXJlbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhlLnRhcmdldCk7XG4gICAgbGV0IGlzQXRUb3AgPSBmYWxzZTtcbiAgICBsZXQgaXNBdEJvdHRvbSA9IGZhbHNlO1xuICAgIGxldCBjYW5Ub3VjaFNjcm9sbCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRvdWNoZXMgJiYgJHBhcmVudCAmJiAkcGFyZW50ICE9PSB0aGlzLiR0cmlnZ2VyKSB7XG4gICAgICBjb25zdCBvdmVyZmxvd1kgPSBnZXRUYXJnZXRWYWx1ZSgkcGFyZW50LCAnb3ZlcmZsb3cteScpO1xuICAgICAgaWYgKG92ZXJmbG93WSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3dZICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0IH0gPSAkcGFyZW50O1xuICAgICAgICBpZiAoc2Nyb2xsSGVpZ2h0ID4gY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgY2FuVG91Y2hTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgIGlzQXRUb3AgPSBzY3JvbGxUb3AgPD0gMztcbiAgICAgICAgICBpc0F0Qm90dG9tID0gc2Nyb2xsVG9wID49IChzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpIC0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHBhcmVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRwYXJlbnQucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhblRvdWNoU2Nyb2xsICYmICgoIWlzQXRUb3AgJiYgIWlzQXRCb3R0b20pIHx8IChpc0F0VG9wICYmIG1vdmVkWSA8IDApIHx8IChpc0F0Qm90dG9tICYmIG1vdmVkWSA+IDApKSkge1xuXG4gICAgICB0aGlzLnBvaW50ZXJbMF0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzFdID0geTtcbiAgICAgIHRoaXMucG9pbnRlclsyXSA9IHg7XG4gICAgICB0aGlzLnBvaW50ZXJbM10gPSB5O1xuICAgICAgdGhpcy5wb2ludGVyWzRdID0geDtcbiAgICAgIHRoaXMucG9pbnRlcls1XSA9IHk7XG4gICAgICB0aGlzLnBvaW50ZXJbNl0gPSB4O1xuICAgICAgdGhpcy5wb2ludGVyWzddID0geTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICAvLyBOZWVkZWQgdG8gcHJldmVudHMgY2xpY2sgb24gaGFuZGxlVXBcbiAgICAgIGlmICghdGhpcy50cmlnZ2VyU3R5bGVzKSB0aGlzLnRyaWdnZXJTdHlsZXMgPSBzZXRUYXJnZXRWYWx1ZXModGhpcy4kdHJpZ2dlciwgeyBwb2ludGVyRXZlbnRzOiAnbm9uZScgfSk7XG4gICAgICAvLyBOZWVkZWQgdG8gcHJldmVudCBwYWdlIHNjcm9sbCB3aGlsZSBkcmFnZ2luZyBvbiB0b3VjaCBkZXZ2aWNlXG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMuJHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgcHJldmVudERlZmF1bHQpO1xuXG5cbiAgICAgIGlmICgoIXRoaXMuZGlzYWJsZWRbMF0gJiYgYWJzKG1vdmVkWCkgPiAzKSB8fCAoIXRoaXMuZGlzYWJsZWRbMV0gJiYgYWJzKG1vdmVkWSkgPiAzKSkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlVGlja2VyLnJlc3VtZSgpO1xuICAgICAgICB0aGlzLnBvaW50ZXJbMl0gPSB0aGlzLnBvaW50ZXJbMF07XG4gICAgICAgIHRoaXMucG9pbnRlclszXSA9IHRoaXMucG9pbnRlclsxXTtcbiAgICAgICAgdGhpcy5wb2ludGVyWzBdID0geDtcbiAgICAgICAgdGhpcy5wb2ludGVyWzFdID0geTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uRHJhZyh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVVcCgpIHtcblxuICAgIGlmICghdGhpcy5ncmFiYmVkKSByZXR1cm47XG5cbiAgICB0aGlzLnVwZGF0ZVRpY2tlci5wYXVzZSgpO1xuXG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5U3R5bGVzKSB7XG4gICAgICB0aGlzLmJvZHlTdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB0aGlzLmJvZHlTdHlsZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IFsgZGlzYWJsZWRYLCBkaXNhYmxlZFkgXSA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgY29uc3QgWyBweDEsIHB5MSwgcHgyLCBweTIsIHB4MywgcHkzIF0gPSB0aGlzLnBvaW50ZXI7XG4gICAgY29uc3QgWyBjdCwgY3IsIGNiLCBjbCBdID0gdGhpcy5jb250YWluZXJCb3VuZHM7XG4gICAgY29uc3QgWyBzeCwgc3kgXSA9IHRoaXMuc25hcHBlZDtcbiAgICBjb25zdCBzcHJpbmdYID0gdGhpcy5yZWxlYXNlWFNwcmluZztcbiAgICBjb25zdCBzcHJpbmdZID0gdGhpcy5yZWxlYXNlWVNwcmluZztcbiAgICBjb25zdCByZWxlYXNlRWFzZSA9IHRoaXMucmVsZWFzZUVhc2U7XG4gICAgY29uc3QgaGFzUmVsZWFzZVNwcmluZyA9IHRoaXMuaGFzUmVsZWFzZVNwcmluZztcbiAgICBjb25zdCBvdmVyc2hvb3RDb29yZHMgPSB0aGlzLm92ZXJzaG9vdENvb3JkcztcbiAgICBjb25zdCBjeCA9IHRoaXMueDtcbiAgICBjb25zdCBjeSA9IHRoaXMueTtcbiAgICBjb25zdCBwdiA9IHRoaXMuY29tcHV0ZVZlbG9jaXR5KHB4MSAtIHB4MywgcHkxIC0gcHkzKTtcbiAgICBjb25zdCBwYSA9IHRoaXMuYW5nbGUgPSBhdGFuMihweTEgLSBweTIsIHB4MSAtIHB4Mik7XG4gICAgY29uc3QgZHMgPSBwdiAqIDE1MDtcbiAgICBjb25zdCBjZiA9ICgxIC0gdGhpcy5yZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24pICogdGhpcy5kcmFnU3BlZWQ7XG4gICAgY29uc3QgbnggPSBjeCArIChjb3MocGEpICogZHMpO1xuICAgIGNvbnN0IG55ID0gY3kgKyAoc2luKHBhKSAqIGRzKTtcbiAgICBjb25zdCBieCA9IG54ID4gY3IgPyBjciArIChueCAtIGNyKSAqIGNmIDogbnggPCBjbCA/IGNsICsgKG54IC0gY2wpICogY2YgOiBueDtcbiAgICBjb25zdCBieSA9IG55ID4gY2IgPyBjYiArIChueSAtIGNiKSAqIGNmIDogbnkgPCBjdCA/IGN0ICsgKG55IC0gY3QpICogY2YgOiBueTtcbiAgICBjb25zdCBkeCA9IHRoaXMuZGVzdFggPSBjbGFtcChyb3VuZChzbmFwKGJ4LCB0aGlzLnNuYXBYKSwgNSksIGNsLCBjcik7XG4gICAgY29uc3QgZHkgPSB0aGlzLmRlc3RZID0gY2xhbXAocm91bmQoc25hcChieSwgdGhpcy5zbmFwWSksIDUpLCBjdCwgY2IpO1xuICAgIGNvbnN0IG9iID0gdGhpcy5pc091dE9mQm91bmRzKHRoaXMuY29udGFpbmVyQm91bmRzLCBueCwgbnkpO1xuXG4gICAgbGV0IGR1cmF0aW9uWCA9IDA7XG4gICAgbGV0IGR1cmF0aW9uWSA9IDA7XG4gICAgbGV0IGVhc2VYID0gcmVsZWFzZUVhc2U7XG4gICAgbGV0IGVhc2VZID0gcmVsZWFzZUVhc2U7XG4gICAgbGV0IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSAwO1xuXG4gICAgb3ZlcnNob290Q29vcmRzLnggPSBjeDtcbiAgICBvdmVyc2hvb3RDb29yZHMueSA9IGN5O1xuXG4gICAgaWYgKCFkaXNhYmxlZFgpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvblggPSBkeCA9PT0gY3IgPyBjeCA+IGNyID8gLTEgOiAxIDogY3ggPCBjbCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IHJvdW5kKGN4IC0gZHgsIDApO1xuICAgICAgc3ByaW5nWC52ZWxvY2l0eSA9IGRpc2FibGVkWSAmJiBoYXNSZWxlYXNlU3ByaW5nID8gZGlzdGFuY2VYID8gKGRzICogZGlyZWN0aW9uWCkgLyBhYnMoZGlzdGFuY2VYKSA6IDAgOiBwdjtcbiAgICAgIGNvbnN0IHsgZWFzZSwgZHVyYXRpb24sIHJlc3REdXJhdGlvbiB9ID0gc3ByaW5nWDtcbiAgICAgIGR1cmF0aW9uWCA9IGN4ID09PSBkeCA/IDAgOiBoYXNSZWxlYXNlU3ByaW5nID8gZHVyYXRpb24gOiBkdXJhdGlvbiAtIChyZXN0RHVyYXRpb24gKiBnbG9iYWxzLnRpbWVTY2FsZSk7XG4gICAgICBpZiAoaGFzUmVsZWFzZVNwcmluZykgZWFzZVggPSBlYXNlO1xuICAgICAgaWYgKGR1cmF0aW9uWCA+IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24pIGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSBkdXJhdGlvblg7XG4gICAgfVxuXG4gICAgaWYgKCFkaXNhYmxlZFkpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvblkgPSBkeSA9PT0gY2IgPyBjeSA+IGNiID8gLTEgOiAxIDogY3kgPCBjdCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IHJvdW5kKGN5IC0gZHksIDApO1xuICAgICAgc3ByaW5nWS52ZWxvY2l0eSA9IGRpc2FibGVkWCAmJiBoYXNSZWxlYXNlU3ByaW5nID8gZGlzdGFuY2VZID8gKGRzICogZGlyZWN0aW9uWSkgLyBhYnMoZGlzdGFuY2VZKSA6IDAgOiBwdjtcbiAgICAgIGNvbnN0IHsgZWFzZSwgZHVyYXRpb24sIHJlc3REdXJhdGlvbiB9ID0gc3ByaW5nWTtcbiAgICAgIGR1cmF0aW9uWSA9IGN5ID09PSBkeSA/IDAgOiBoYXNSZWxlYXNlU3ByaW5nID8gZHVyYXRpb24gOiBkdXJhdGlvbiAtIChyZXN0RHVyYXRpb24gKiBnbG9iYWxzLnRpbWVTY2FsZSk7XG4gICAgICBpZiAoaGFzUmVsZWFzZVNwcmluZykgZWFzZVkgPSBlYXNlO1xuICAgICAgaWYgKGR1cmF0aW9uWSA+IGxvbmdlc3RSZWxlYXNlRHVyYXRpb24pIGxvbmdlc3RSZWxlYXNlRHVyYXRpb24gPSBkdXJhdGlvblk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNSZWxlYXNlU3ByaW5nICYmIG9iICYmIGNmICYmIChkdXJhdGlvblggfHwgZHVyYXRpb25ZKSkge1xuXG4gICAgICAgIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25UeXBlcy5ibGVuZDtcblxuICAgICAgICBuZXcgSlNBbmltYXRpb24ob3ZlcnNob290Q29vcmRzLCB7XG4gICAgICAgICAgeDogeyB0bzogYngsIGR1cmF0aW9uOiBkdXJhdGlvblggKiAuNjUgfSxcbiAgICAgICAgICB5OiB7IHRvOiBieSwgZHVyYXRpb246IGR1cmF0aW9uWSAqIC42NSB9LFxuICAgICAgICAgIGVhc2U6IHJlbGVhc2VFYXNlLFxuICAgICAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgICB9KS5pbml0KCk7XG5cbiAgICAgICAgbmV3IEpTQW5pbWF0aW9uKG92ZXJzaG9vdENvb3Jkcywge1xuICAgICAgICAgIHg6IHsgdG86IGR4LCBkdXJhdGlvbjogZHVyYXRpb25YIH0sXG4gICAgICAgICAgeTogeyB0bzogZHksIGR1cmF0aW9uOiBkdXJhdGlvblkgfSxcbiAgICAgICAgICBlYXNlOiByZWxlYXNlRWFzZSxcbiAgICAgICAgICBjb21wb3NpdGlvbixcbiAgICAgICAgfSkuaW5pdCgpO1xuXG4gICAgICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5zdHJldGNoKGR1cmF0aW9uWCkucmVzdGFydCgpO1xuICAgICAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIuc3RyZXRjaChkdXJhdGlvblkpLnJlc3RhcnQoKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICghZGlzYWJsZWRYKSB0aGlzLmFuaW1hdGVbdGhpcy54UHJvcF0oZHgsIGR1cmF0aW9uWCwgZWFzZVgpO1xuICAgICAgaWYgKCFkaXNhYmxlZFkpIHRoaXMuYW5pbWF0ZVt0aGlzLnlQcm9wXShkeSwgZHVyYXRpb25ZLCBlYXNlWSk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbEluVmlldyhsb25nZXN0UmVsZWFzZUR1cmF0aW9uLCB0aGlzLnNjcm9sbFRocmVzaG9sZCwgcmVsZWFzZUVhc2UpO1xuXG4gICAgbGV0IGhhc1NuYXBwZWQgPSBmYWxzZTtcblxuICAgIGlmIChkeCAhPT0gc3gpIHtcbiAgICAgIHRoaXMuc25hcHBlZFswXSA9IGR4O1xuICAgICAgaWYgKHRoaXMuc25hcFgpIGhhc1NuYXBwZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkeSAhPT0gc3kgJiYgdGhpcy5zbmFwWSkge1xuICAgICAgdGhpcy5zbmFwcGVkWzFdID0gZHk7XG4gICAgICBpZiAodGhpcy5zbmFwWSkgaGFzU25hcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc1NuYXBwZWQpIHRoaXMub25TbmFwKHRoaXMpO1xuXG4gICAgdGhpcy5ncmFiYmVkID0gZmFsc2U7XG4gICAgdGhpcy5kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbGVhc2VkID0gdHJ1ZTtcblxuICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSByZWxlYXNlIGFuaW1hdGlvbnMgdG8gYmUgYWJsZSB0byBjYW5jZWwgdGhlbVxuICAgIHRoaXMub25SZWxlYXNlKHRoaXMpO1xuXG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMuJHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnJlc2l6ZVRpY2tlci5wYXVzZSgpO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0WCgwLCB0cnVlKTtcbiAgICB0aGlzLnNldFkoMCwgdHJ1ZSk7XG4gICAgdGhpcy5jb29yZHNbMF0gPSAwO1xuICAgIHRoaXMuY29vcmRzWzFdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbMF0gPSAwO1xuICAgIHRoaXMucG9pbnRlclsxXSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzJdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbM10gPSAwO1xuICAgIHRoaXMucG9pbnRlcls0XSA9IDA7XG4gICAgdGhpcy5wb2ludGVyWzVdID0gMDtcbiAgICB0aGlzLnBvaW50ZXJbNl0gPSAwO1xuICAgIHRoaXMucG9pbnRlcls3XSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrWzBdID0gMDtcbiAgICB0aGlzLnZlbG9jaXR5U3RhY2tbMV0gPSAwO1xuICAgIHRoaXMudmVsb2NpdHlTdGFja1syXSA9IDA7XG4gICAgdGhpcy52ZWxvY2l0eVN0YWNrSW5kZXggPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uU3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKHRoaXMuJHRyaWdnZXIsIHtcbiAgICAgICAgdG91Y2hBY3Rpb246IHRoaXMuZGlzYWJsZWRbMF0gPyAncGFuLXgnIDogdGhpcy5kaXNhYmxlZFsxXSA/ICdwYW4teScgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgdGhpcy4kdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLiR0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hBY3Rpb25TdHlsZXMucmV2ZXJ0KCk7XG4gICAgaWYgKHRoaXMuY3Vyc29yU3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnNvclN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuY3Vyc29yU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJpZ2dlclN0eWxlcykge1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy50cmlnZ2VyU3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYm9keVN0eWxlcykge1xuICAgICAgdGhpcy5ib2R5U3R5bGVzLnJldmVydCgpO1xuICAgICAgdGhpcy5ib2R5U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0U3R5bGVzKSB7XG4gICAgICB0aGlzLnRhcmdldFN0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMudGFyZ2V0U3R5bGVzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy4kdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2lzLWRpc2FibGVkJyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcyk7XG4gICAgdGhpcy4kdHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcbiAgICB0aGlzLiR0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuJHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMudXBkYXRlVGlja2VyLnJldmVydCgpO1xuICAgIHRoaXMub3ZlcnNob290WFRpY2tlci5yZXZlcnQoKTtcbiAgICB0aGlzLm92ZXJzaG9vdFlUaWNrZXIucmV2ZXJ0KCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIucmV2ZXJ0KCk7XG4gICAgdGhpcy5hbmltYXRlLnJldmVydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duKC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICB0aGlzLmhhbmRsZURvd24oLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8oZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZSgvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICAgICAgdGhpcy5oYW5kbGVVcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICB0aGlzLmhhbmRsZUhvdmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldFxuICogQHBhcmFtIHtEcmFnZ2FibGVQYXJhbXN9IFtwYXJhbWV0ZXJzXVxuICogQHJldHVybiB7RHJhZ2dhYmxlfVxuICovXG5jb25zdCBjcmVhdGVEcmFnZ2FibGUgPSAodGFyZ2V0LCBwYXJhbWV0ZXJzKSA9PiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgcGFyYW1ldGVycyk7XG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhY3RSZWZcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudHxudWxsfSBbY3VycmVudF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuZ3VsYXJSZWZcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudH0gW25hdGl2ZUVsZW1lbnRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY29wZVBhcmFtc1xuICogQHByb3BlcnR5IHtET01UYXJnZXRTZWxlY3RvcnxSZWFjdFJlZnxBbmd1bGFyUmVmfSBbcm9vdF1cbiAqIEBwcm9wZXJ0eSB7RGVmYXVsdHNQYXJhbXN9IFtkZWZhdWx0c11cbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPFN0cmluZywgU3RyaW5nPn0gW21lZGlhUXVlcmllc11cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNsZWFudXBcbiAqIEBwYXJhbSB7U2NvcGV9IFtzY29wZV1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZUNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Njb3BlfSBbc2NvcGVdXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXB8dm9pZH1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTY29wZU1ldGhvZFxuICogQHBhcmFtIHsuLi4qfSBhcmdzXG4gKiBAcmV0dXJuIHtTY29wZUNsZWFudXB8dm9pZH1cbiAqL1xuXG5jbGFzcyBTY29wZSB7XG4gIC8qKiBAcGFyYW0ge1Njb3BlUGFyYW1zfSBbcGFyYW1ldGVyc10gKi9cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgaWYgKGdsb2JhbHMuc2NvcGUpIGdsb2JhbHMuc2NvcGUucmV2ZXJ0aWJsZXMucHVzaCh0aGlzKTtcbiAgICBjb25zdCByb290UGFyYW0gPSBwYXJhbWV0ZXJzLnJvb3Q7XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudHxET01UYXJnZXR9ICovXG4gICAgbGV0IHJvb3QgPSBkb2M7XG4gICAgaWYgKHJvb3RQYXJhbSkge1xuICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7UmVhY3RSZWZ9ICovKHJvb3RQYXJhbSkuY3VycmVudCB8fFxuICAgICAgICAgICAgIC8qKiBAdHlwZSB7QW5ndWxhclJlZn0gKi8ocm9vdFBhcmFtKS5uYXRpdmVFbGVtZW50IHx8XG4gICAgICAgICAgICAgcGFyc2VUYXJnZXRzKC8qKiBAdHlwZSB7RE9NVGFyZ2V0U2VsZWN0b3J9ICovKHJvb3RQYXJhbSkpWzBdIHx8XG4gICAgICAgICAgICAgZG9jO1xuICAgIH1cbiAgICBjb25zdCBzY29wZURlZmF1bHRzID0gcGFyYW1ldGVycy5kZWZhdWx0cztcbiAgICBjb25zdCBnbG9iYWxEZWZhdWx0ID0gZ2xvYmFscy5kZWZhdWx0cztcbiAgICBjb25zdCBtZWRpYVF1ZXJpZXMgPSBwYXJhbWV0ZXJzLm1lZGlhUXVlcmllcztcbiAgICAvKiogQHR5cGUge0RlZmF1bHRzUGFyYW1zfSAqL1xuICAgIHRoaXMuZGVmYXVsdHMgPSBzY29wZURlZmF1bHRzID8gbWVyZ2VPYmplY3RzKHNjb3BlRGVmYXVsdHMsIGdsb2JhbERlZmF1bHQpIDogZ2xvYmFsRGVmYXVsdDtcbiAgICAvKiogQHR5cGUge0RvY3VtZW50fERPTVRhcmdldH0gKi9cbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8U2NvcGVDb25zdHJ1Y3Rvcj59ICovXG4gICAgdGhpcy5jb25zdHJ1Y3RvcnMgPSBbXTtcbiAgICAvKiogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn0gKi9cbiAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8UmV2ZXJ0aWJsZT59ICovXG4gICAgdGhpcy5yZXZlcnRpYmxlcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgRnVuY3Rpb24+fSAqL1xuICAgIHRoaXMubWV0aG9kcyA9IHt9O1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPFN0cmluZywgQm9vbGVhbj59ICovXG4gICAgdGhpcy5tYXRjaGVzID0ge307XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8U3RyaW5nLCBNZWRpYVF1ZXJ5TGlzdD59ICovXG4gICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdHMgPSB7fTtcbiAgICAvKiogQHR5cGUge1JlY29yZDxTdHJpbmcsIGFueT59ICovXG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgaWYgKG1lZGlhUXVlcmllcykge1xuICAgICAgZm9yIChsZXQgbXEgaW4gbWVkaWFRdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IF9tcSA9IHdpbi5tYXRjaE1lZGlhKG1lZGlhUXVlcmllc1ttcV0pO1xuICAgICAgICB0aGlzLm1lZGlhUXVlcnlMaXN0c1ttcV0gPSBfbXE7XG4gICAgICAgIF9tcS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIFNjb3BwZWRDYWxsYmFja1xuICAgKiBAcGFyYW0ge3RoaXN9IHNjb3BlXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICpcbiAgICogQHBhcmFtIHtTY29wcGVkQ2FsbGJhY2t9IGNiXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICBleGVjdXRlKGNiKSB7XG4gICAgbGV0IGFjdGl2ZVNjb3BlID0gZ2xvYmFscy5zY29wZTtcbiAgICBsZXQgYWN0aXZlUm9vdCA9IGdsb2JhbHMucm9vdDtcbiAgICBsZXQgYWN0aXZlRGVmYXVsdHMgPSBnbG9iYWxzLmRlZmF1bHRzO1xuICAgIGdsb2JhbHMuc2NvcGUgPSB0aGlzO1xuICAgIGdsb2JhbHMucm9vdCA9IHRoaXMucm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gdGhpcy5kZWZhdWx0cztcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBmb3IgKGxldCBtcSBpbiBtcXMpIHRoaXMubWF0Y2hlc1ttcV0gPSBtcXNbbXFdLm1hdGNoZXM7XG4gICAgY29uc3QgcmV0dXJuZWQgPSBjYih0aGlzKTtcbiAgICBnbG9iYWxzLnNjb3BlID0gYWN0aXZlU2NvcGU7XG4gICAgZ2xvYmFscy5yb290ID0gYWN0aXZlUm9vdDtcbiAgICBnbG9iYWxzLmRlZmF1bHRzID0gYWN0aXZlRGVmYXVsdHM7XG4gICAgcmV0dXJuIHJldHVybmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuZXhlY3V0ZSgoKSA9PiB7XG4gICAgICBsZXQgaSA9IHRoaXMucmV2ZXJ0aWJsZXMubGVuZ3RoO1xuICAgICAgbGV0IHkgPSB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB0aGlzLnJldmVydGlibGVzW2ldLnJldmVydCgpO1xuICAgICAgd2hpbGUgKHktLSkgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnNbeV0odGhpcyk7XG4gICAgICB0aGlzLnJldmVydGlibGVzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvcnMuZm9yRWFjaCggY29uc3RydWN0b3IgPT4ge1xuICAgICAgICBjb25zdCByZXZlcnRDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICBpZiAocmV2ZXJ0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICB0aGlzLnJldmVydENvbnN0cnVjdG9ycy5wdXNoKHJldmVydENvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGNvbnRydWN0b3JDYWxsYmFja1xuICAgKiBAcGFyYW0ge3RoaXN9IHNlbGZcbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhMVxuICAgKiBAcGFyYW0ge1Njb3BlTWV0aG9kfSBhMlxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtjb250cnVjdG9yQ2FsbGJhY2t9IGExXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfGNvbnRydWN0b3JDYWxsYmFja30gYTFcbiAgICogQHBhcmFtIHtTY29wZU1ldGhvZH0gW2EyXVxuICAgKi9cbiAgYWRkKGExLCBhMikge1xuICAgIGlmIChpc0ZuYyhhMSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHtjb250cnVjdG9yQ2FsbGJhY2t9ICovKGExKTtcbiAgICAgIHRoaXMuY29uc3RydWN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xuICAgICAgdGhpcy5leGVjdXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmV2ZXJ0Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgaWYgKHJldmVydENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgdGhpcy5yZXZlcnRDb25zdHJ1Y3RvcnMucHVzaChyZXZlcnRDb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGhvZHNbLyoqIEB0eXBlIHtTdHJpbmd9ICovKGExKV0gPSAoLyoqIEB0eXBlIHthbnl9ICovLi4uYXJncykgPT4gdGhpcy5leGVjdXRlKCgpID0+IGEyKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdjaGFuZ2UnOlxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV2ZXJ0KCkge1xuICAgIGNvbnN0IHJldmVydGlibGVzID0gdGhpcy5yZXZlcnRpYmxlcztcbiAgICBjb25zdCByZXZlcnRDb25zdHJ1Y3RvcnMgPSB0aGlzLnJldmVydENvbnN0cnVjdG9ycztcbiAgICBjb25zdCBtcXMgPSB0aGlzLm1lZGlhUXVlcnlMaXN0cztcbiAgICBsZXQgaSA9IHJldmVydGlibGVzLmxlbmd0aDtcbiAgICBsZXQgeSA9IHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgcmV2ZXJ0aWJsZXNbaV0ucmV2ZXJ0KCk7XG4gICAgd2hpbGUgKHktLSkgcmV2ZXJ0Q29uc3RydWN0b3JzW3ldKHRoaXMpO1xuICAgIGZvciAobGV0IG1xIGluIG1xcykgbXFzW21xXS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzKTtcbiAgICByZXZlcnRpYmxlcy5sZW5ndGggPSAwO1xuICAgIHJldmVydENvbnN0cnVjdG9ycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY29uc3RydWN0b3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXRjaGVzID0ge307XG4gICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgdGhpcy5tZWRpYVF1ZXJ5TGlzdHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NvcGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJuIHtTY29wZX1cbiAqL1xuY29uc3QgY3JlYXRlU2NvcGUgPSBwYXJhbXMgPT4gbmV3IFNjb3BlKHBhcmFtcyk7XG5cbi8qKlxuICogQHR5cGVkZWYge1N0cmluZ3xOdW1iZXJ9IFNjcm9sbFRocmVzaG9sZFZhbHVlXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmNvbnN0IGdldE1heFZpZXdIZWlnaHQgPSAoKSA9PiB7XG4gIGNvbnN0ICRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZCgkZWwpO1xuICAkZWwuc3R5bGUuaGVpZ2h0ID0gJzEwMGx2aCc7XG4gIGNvbnN0IGhlaWdodCA9ICRlbC5vZmZzZXRIZWlnaHQ7XG4gIGRvYy5ib2R5LnJlbW92ZUNoaWxkKCRlbCk7XG4gIHJldHVybiBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV8U3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufE9iamVjdH0gVFxuICogQHBhcmFtIHtUIHwgKChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IFQpfSB2YWx1ZVxuICogQHBhcmFtIHtTY3JvbGxPYnNlcnZlcn0gc2Nyb2xsZXJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlciA9ICh2YWx1ZSwgc2Nyb2xsZXIpID0+IHZhbHVlICYmIGlzRm5jKHZhbHVlKSA/IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovKHZhbHVlKShzY3JvbGxlcikgOiB2YWx1ZTtcblxuY29uc3Qgc2Nyb2xsQ29udGFpbmVycyA9IG5ldyBNYXAoKTtcblxuY2xhc3MgU2Nyb2xsQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRlbFxuICAgKi9cbiAgY29uc3RydWN0b3IoJGVsKSB7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLmVsZW1lbnQgPSAkZWw7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMudXNlV2luID0gdGhpcy5lbGVtZW50ID09PSBkb2MuYm9keTtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLndpbldpZHRoID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLndpbkhlaWdodCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy50b3AgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnNjcm9sbFggPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuc2Nyb2xsWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5wcmV2U2Nyb2xsWCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5wcmV2U2Nyb2xsWSA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxXaWR0aCA9IDA7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkWCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJhY2t3YXJkWSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5zY3JvbGxUaWNrZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgb25CZWdpbjogKCkgPT4gdGhpcy5kYXRhVGltZXIucmVzdW1lKCksXG4gICAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBiYWNrd2FyZHMgPSB0aGlzLmJhY2t3YXJkWCB8fCB0aGlzLmJhY2t3YXJkWTtcbiAgICAgICAgZm9yRWFjaENoaWxkcmVuKHRoaXMsICgvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL2NoaWxkKSA9PiBjaGlsZC5oYW5kbGVTY3JvbGwoKSwgYmFja3dhcmRzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB0aGlzLmRhdGFUaW1lci5wYXVzZSgpXG4gICAgfSkuaW5pdCgpO1xuICAgIC8qKiBAdHlwZSB7VGltZXJ9ICovXG4gICAgdGhpcy5kYXRhVGltZXIgPSBuZXcgVGltZXIoe1xuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgZnJhbWVSYXRlOiAzMCxcbiAgICAgIG9uVXBkYXRlOiBzZWxmID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSBzZWxmLmRlbHRhVGltZTtcbiAgICAgICAgY29uc3QgcHggPSB0aGlzLnByZXZTY3JvbGxYO1xuICAgICAgICBjb25zdCBweSA9IHRoaXMucHJldlNjcm9sbFk7XG4gICAgICAgIGNvbnN0IG54ID0gdGhpcy5zY3JvbGxYO1xuICAgICAgICBjb25zdCBueSA9IHRoaXMuc2Nyb2xsWTtcbiAgICAgICAgY29uc3QgZHggPSBweCAtIG54O1xuICAgICAgICBjb25zdCBkeSA9IHB5IC0gbnk7XG4gICAgICAgIHRoaXMucHJldlNjcm9sbFggPSBueDtcbiAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWSA9IG55O1xuICAgICAgICBpZiAoZHgpIHRoaXMuYmFja3dhcmRYID0gcHggPiBueDtcbiAgICAgICAgaWYgKGR5KSB0aGlzLmJhY2t3YXJkWSA9IHB5ID4gbnk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSByb3VuZChkdCA+IDAgPyBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZHQgOiAwLCA1KTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtUaW1lcn0gKi9cbiAgICB0aGlzLnJlc2l6ZVRpY2tlciA9IG5ldyBUaW1lcih7XG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogMjUwICogZ2xvYmFscy50aW1lU2NhbGUsXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlV2luZG93Qm91bmRzKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgICAgfVxuICAgIH0pLmluaXQoKTtcbiAgICAvKiogQHR5cGUge1RpbWVyfSAqL1xuICAgIHRoaXMud2FrZVRpY2tlciA9IG5ldyBUaW1lcih7XG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICBkdXJhdGlvbjogNTAwICogZ2xvYmFscy50aW1lU2NhbGUsXG4gICAgICBvbkJlZ2luOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGlja2VyLnJlc3VtZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zY3JvbGxUaWNrZXIucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9KS5pbml0KCk7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29vcmRzKCk7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMucmVmcmVzaFNjcm9sbE9ic2VydmVycygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLnJlc2l6ZVRpY2tlci5yZXN0YXJ0KCkpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLnVzZVdpbiA/IHdpbiA6IHRoaXMuZWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgZmFsc2UpO1xuICB9XG5cbiAgdXBkYXRlU2Nyb2xsQ29vcmRzKCkge1xuICAgIGNvbnN0IHVzZVdpbiA9IHRoaXMudXNlV2luO1xuICAgIGNvbnN0ICRlbCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLnNjcm9sbFggPSByb3VuZCh1c2VXaW4gPyB3aW4uc2Nyb2xsWCA6ICRlbC5zY3JvbGxMZWZ0LCAwKTtcbiAgICB0aGlzLnNjcm9sbFkgPSByb3VuZCh1c2VXaW4gPyB3aW4uc2Nyb2xsWSA6ICRlbC5zY3JvbGxUb3AsIDApO1xuICB9XG5cbiAgdXBkYXRlV2luZG93Qm91bmRzKCkge1xuICAgIHRoaXMud2luV2lkdGggPSB3aW4uaW5uZXJXaWR0aDtcbiAgICB0aGlzLndpbkhlaWdodCA9IGdldE1heFZpZXdIZWlnaHQoKTtcbiAgfVxuXG4gIHVwZGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KTtcbiAgICBjb25zdCAkZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxXaWR0aCA9ICRlbC5zY3JvbGxXaWR0aCArIHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9ICRlbC5zY3JvbGxIZWlnaHQgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkJvdHRvbSk7XG4gICAgdGhpcy51cGRhdGVXaW5kb3dCb3VuZHMoKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAodGhpcy51c2VXaW4pIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aW5XaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMud2luSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbFJlY3QgPSAkZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGVsUmVjdC5oZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IGVsUmVjdC50b3A7XG4gICAgICB0aGlzLmxlZnQgPSBlbFJlY3QubGVmdDtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgcmVmcmVzaFNjcm9sbE9ic2VydmVycygpIHtcbiAgICBmb3JFYWNoQ2hpbGRyZW4odGhpcywgKC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5fZGVidWcpIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlRGVidWcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIGZvckVhY2hDaGlsZHJlbih0aGlzLCAoLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlcn0gKi9jaGlsZCkgPT4ge1xuICAgICAgY2hpbGQucmVmcmVzaCgpO1xuICAgICAgaWYgKGNoaWxkLl9kZWJ1Zykge1xuICAgICAgICBjaGlsZC5kZWJ1ZygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnVwZGF0ZVdpbmRvd0JvdW5kcygpO1xuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgdGhpcy5yZWZyZXNoU2Nyb2xsT2JzZXJ2ZXJzKCk7XG4gICAgdGhpcy5oYW5kbGVTY3JvbGwoKTtcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCgpIHtcbiAgICB0aGlzLnVwZGF0ZVNjcm9sbENvb3JkcygpO1xuICAgIHRoaXMud2FrZVRpY2tlci5yZXN0YXJ0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgdGhpcy5zY3JvbGxUaWNrZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5kYXRhVGltZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5yZXNpemVUaWNrZXIuY2FuY2VsKCk7XG4gICAgdGhpcy53YWtlVGlja2VyLmNhbmNlbCgpO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgKHRoaXMudXNlV2luID8gd2luIDogdGhpcy5lbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzKTtcbiAgICBzY3JvbGxDb250YWluZXJzLmRlbGV0ZSh0aGlzLmVsZW1lbnQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUYXJnZXRzUGFyYW19IHRhcmdldFxuICogQHJldHVybiB7U2Nyb2xsQ29udGFpbmVyfVxuICovXG5jb25zdCByZWdpc3RlckFuZEdldFNjcm9sbENvbnRhaW5lciA9IHRhcmdldCA9PiB7XG4gIGNvbnN0ICRlbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHRhcmdldCA/IHBhcnNlVGFyZ2V0cyh0YXJnZXQpWzBdIHx8IGRvYy5ib2R5IDogZG9jLmJvZHkpO1xuICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVycy5nZXQoJGVsKTtcbiAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICBzY3JvbGxDb250YWluZXIgPSBuZXcgU2Nyb2xsQ29udGFpbmVyKCRlbCk7XG4gICAgc2Nyb2xsQ29udGFpbmVycy5zZXQoJGVsLCBzY3JvbGxDb250YWluZXIpO1xuICB9XG4gIHJldHVybiBzY3JvbGxDb250YWluZXI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRlbFxuICogQHBhcmFtIHtOdW1iZXJ8c3RyaW5nfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFt1bmRlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3Zlcl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgY29udmVydFZhbHVlVG9QeCA9ICgkZWwsIHYsIHNpemUsIHVuZGVyLCBvdmVyKSA9PiB7XG4gIGNvbnN0IGNsYW1wTWluID0gdiA9PT0gJ21pbic7XG4gIGNvbnN0IGNsYW1wTWF4ID0gdiA9PT0gJ21heCc7XG4gIGNvbnN0IHZhbHVlID0gdiA9PT0gJ3RvcCcgfHwgdiA9PT0gJ2xlZnQnIHx8IHYgPT09ICdzdGFydCcgfHwgY2xhbXBNaW4gPyAwIDpcbiAgICAgICAgICAgICAgICB2ID09PSAnYm90dG9tJyB8fCB2ID09PSAncmlnaHQnIHx8IHYgPT09ICdlbmQnIHx8IGNsYW1wTWF4ID8gJzEwMCUnIDpcbiAgICAgICAgICAgICAgICB2ID09PSAnY2VudGVyJyA/ICc1MCUnIDpcbiAgICAgICAgICAgICAgICB2O1xuICBjb25zdCB7IG4sIHUgfSA9IGRlY29tcG9zZVJhd1ZhbHVlKHZhbHVlLCBkZWNvbXBvc2VkT3JpZ2luYWxWYWx1ZSk7XG4gIGxldCBweCA9IG47XG4gIGlmICh1ID09PSAnJScpIHtcbiAgICBweCA9IChuIC8gMTAwKSAqIHNpemU7XG4gIH0gZWxzZSBpZiAodSkge1xuICAgIHB4ID0gY29udmVydFZhbHVlVW5pdCgkZWwsIGRlY29tcG9zZWRPcmlnaW5hbFZhbHVlLCAncHgnLCB0cnVlKS5uO1xuICB9XG4gIGlmIChjbGFtcE1heCAmJiB1bmRlciA8IDApIHB4ICs9IHVuZGVyO1xuICBpZiAoY2xhbXBNaW4gJiYgb3ZlciA+IDApIHB4ICs9IG92ZXI7XG4gIHJldHVybiBweDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gKiBAcGFyYW0ge1Njcm9sbFRocmVzaG9sZFZhbHVlfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFt1bmRlcl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3Zlcl1cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuY29uc3QgcGFyc2VCb3VuZFZhbHVlID0gKCRlbCwgdiwgc2l6ZSwgdW5kZXIsIG92ZXIpID0+IHtcbiAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gIGxldCB2YWx1ZTtcbiAgaWYgKGlzU3RyKHYpKSB7XG4gICAgY29uc3QgbWF0Y2hlZE9wZXJhdG9yID0gcmVsYXRpdmVWYWx1ZXNFeGVjUmd4LmV4ZWMoLyoqIEB0eXBlIHtTdHJpbmd9ICovKHYpKTtcbiAgICBpZiAobWF0Y2hlZE9wZXJhdG9yKSB7XG4gICAgICBjb25zdCBzcGxpdHRlciA9IG1hdGNoZWRPcGVyYXRvclswXTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gc3BsaXR0ZXJbMF07XG4gICAgICBjb25zdCBzcGxpdHRlZCA9IC8qKiBAdHlwZSB7U3RyaW5nfSAqLyh2KS5zcGxpdChzcGxpdHRlcik7XG4gICAgICBjb25zdCBjbGFtcE1pbiA9IHNwbGl0dGVkWzBdID09PSAnbWluJztcbiAgICAgIGNvbnN0IGNsYW1wTWF4ID0gc3BsaXR0ZWRbMF0gPT09ICdtYXgnO1xuICAgICAgY29uc3QgdmFsdWVBUHggPSBjb252ZXJ0VmFsdWVUb1B4KCRlbCwgc3BsaXR0ZWRbMF0sIHNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICAgIGNvbnN0IHZhbHVlQlB4ID0gY29udmVydFZhbHVlVG9QeCgkZWwsIHNwbGl0dGVkWzFdLCBzaXplLCB1bmRlciwgb3Zlcik7XG4gICAgICBpZiAoY2xhbXBNaW4pIHtcbiAgICAgICAgY29uc3QgbWluID0gZ2V0UmVsYXRpdmVWYWx1ZShjb252ZXJ0VmFsdWVUb1B4KCRlbCwgJ21pbicsIHNpemUpLCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgICB2YWx1ZSA9IG1pbiA8IHZhbHVlQVB4ID8gdmFsdWVBUHggOiBtaW47XG4gICAgICB9IGVsc2UgaWYgKGNsYW1wTWF4KSB7XG4gICAgICAgIGNvbnN0IG1heCA9IGdldFJlbGF0aXZlVmFsdWUoY29udmVydFZhbHVlVG9QeCgkZWwsICdtYXgnLCBzaXplKSwgdmFsdWVCUHgsIG9wZXJhdG9yKTtcbiAgICAgICAgdmFsdWUgPSBtYXggPiB2YWx1ZUFQeCA/IHZhbHVlQVB4IDogbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbHVlQVB4LCB2YWx1ZUJQeCwgb3BlcmF0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGNvbnZlcnRWYWx1ZVRvUHgoJGVsLCB2LCBzaXplLCB1bmRlciwgb3Zlcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKHYpO1xuICB9XG4gIHJldHVybiByb3VuZCh2YWx1ZSwgMCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SlNBbmltYXRpb259IGxpbmtlZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmNvbnN0IGdldEFuaW1hdGlvbkRvbVRhcmdldCA9IGxpbmtlZCA9PiB7XG4gIGxldCAkbGlua2VkVGFyZ2V0O1xuICBjb25zdCBsaW5rZWRUYXJnZXRzID0gbGlua2VkLnRhcmdldHM7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlua2VkVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSBsaW5rZWRUYXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXRbaXNEb21TeW1ib2xdKSB7XG4gICAgICAkbGlua2VkVGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8odGFyZ2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJGxpbmtlZFRhcmdldDtcbn07XG5cbmxldCBzY3JvbGxlckluZGV4ID0gMDtcblxuY29uc3QgZGVidWdDb2xvcnMgPSBbJyNGRjRCNEInLCcjRkY5NzFCJywnI0ZGQzczMCcsJyNGOUY2NDAnLCcjN0FGRjVBJywnIzE4RkY3NCcsJyMxN0UwOUInLCcjM0NGRkVDJywnIzA1REJFOScsJyMzM0IzRjEnLCcjNjM4Q0Y5JywnI0M1NjNGRScsJyNGRjRGQ0YnLCcjRjkzRjhBJ107XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2Nyb2xsVGhyZXNob2xkUGFyYW1cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkge1Njcm9sbFRocmVzaG9sZFZhbHVlfSBbY29udGFpbmVyXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjcm9sbE9ic2VydmVyQXhpc0NhbGxiYWNrXG4gKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyfSBzZWxmXG4gKiBAcmV0dXJuIHsneCd8J3knfVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNjcm9sbFRocmVzaG9sZENhbGxiYWNrXG4gKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyfSBzZWxmXG4gKiBAcmV0dXJuIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbX1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjcm9sbE9ic2VydmVyUGFyYW1zXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtpZF1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ8U3RyaW5nfEVhc2luZ1BhcmFtfSBbc3luY11cbiAqIEBwcm9wZXJ0eSB7VGFyZ2V0c1BhcmFtfSBbY29udGFpbmVyXVxuICogQHByb3BlcnR5IHtUYXJnZXRzUGFyYW19IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkgeyd4J3wneSd8U2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2t8KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+ICd4J3wneSd8U2Nyb2xsT2JzZXJ2ZXJBeGlzQ2FsbGJhY2spfSBbYXhpc11cbiAqIEBwcm9wZXJ0eSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t8KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IFNjcm9sbFRocmVzaG9sZFZhbHVlfFNjcm9sbFRocmVzaG9sZFBhcmFtfFNjcm9sbFRocmVzaG9sZENhbGxiYWNrKX0gW2VudGVyXVxuICogQHByb3BlcnR5IHtTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja3woKG9ic2VydmVyOiBTY3JvbGxPYnNlcnZlcikgPT4gU2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2spfSBbbGVhdmVdXG4gKiBAcHJvcGVydHkge0Jvb2xlYW58KChvYnNlcnZlcjogU2Nyb2xsT2JzZXJ2ZXIpID0+IEJvb2xlYW4pfSBbcmVwZWF0XVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZGVidWddXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uRW50ZXJdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uTGVhdmVdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uRW50ZXJGb3J3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkxlYXZlRm9yd2FyZF1cbiAqIEBwcm9wZXJ0eSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSBbb25FbnRlckJhY2t3YXJkXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvbkxlYXZlQmFja3dhcmRdXG4gKiBAcHJvcGVydHkge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gW29uVXBkYXRlXVxuICogQHByb3BlcnR5IHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59IFtvblN5bmNDb21wbGV0ZV1cbiAqL1xuXG5jbGFzcyBTY3JvbGxPYnNlcnZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Njcm9sbE9ic2VydmVyUGFyYW1zfSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBpZiAoZ2xvYmFscy5zY29wZSkgZ2xvYmFscy5zY29wZS5yZXZlcnRpYmxlcy5wdXNoKHRoaXMpO1xuICAgIGNvbnN0IHN5bmNNb2RlID0gc2V0VmFsdWUocGFyYW1ldGVycy5zeW5jLCAncGxheSBwYXVzZScpO1xuICAgIGNvbnN0IGVhc2UgPSBzeW5jTW9kZSA/IHBhcnNlRWFzaW5ncygvKiogQHR5cGUge0Vhc2luZ1BhcmFtfSAqLyhzeW5jTW9kZSkpIDogbnVsbDtcbiAgICBjb25zdCBpc0xpbmVhciA9IHN5bmNNb2RlICYmIChzeW5jTW9kZSA9PT0gJ2xpbmVhcicgfHwgc3luY01vZGUgPT09IG5vbmUpO1xuICAgIGNvbnN0IGlzRWFzZSA9IHN5bmNNb2RlICYmICEoZWFzZSA9PT0gbm9uZSAmJiAhaXNMaW5lYXIpO1xuICAgIGNvbnN0IGlzU21vb3RoID0gc3luY01vZGUgJiYgKGlzTnVtKHN5bmNNb2RlKSB8fCBzeW5jTW9kZSA9PT0gdHJ1ZSB8fCBpc0xpbmVhcik7XG4gICAgY29uc3QgaXNNZXRob2RzID0gc3luY01vZGUgJiYgKGlzU3RyKHN5bmNNb2RlKSAmJiAhaXNFYXNlICYmICFpc1Ntb290aCk7XG4gICAgY29uc3Qgc3luY01ldGhvZHMgPSBpc01ldGhvZHMgPyAvKiogQHR5cGUge1N0cmluZ30gKi8oc3luY01vZGUpLnNwbGl0KCcgJykubWFwKFxuICAgICAgKC8qKiBAdHlwZSB7U3RyaW5nfSAqL20pID0+ICgpID0+IHtcbiAgICAgICAgY29uc3QgbGlua2VkID0gdGhpcy5saW5rZWQ7XG4gICAgICAgIHJldHVybiBsaW5rZWQgJiYgbGlua2VkW21dID8gbGlua2VkW21dKCkgOiBudWxsO1xuICAgICAgfVxuICAgICkgOiBudWxsO1xuICAgIGNvbnN0IGJpRGlyU3luYyA9IGlzTWV0aG9kcyAmJiBzeW5jTWV0aG9kcy5sZW5ndGggPiAyO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMuaW5kZXggPSBzY3JvbGxlckluZGV4Kys7XG4gICAgLyoqIEB0eXBlIHtTdHJpbmd8TnVtYmVyfSAqL1xuICAgIHRoaXMuaWQgPSAhaXNVbmQocGFyYW1ldGVycy5pZCkgPyBwYXJhbWV0ZXJzLmlkIDogdGhpcy5pbmRleDtcbiAgICAvKiogQHR5cGUge1Njcm9sbENvbnRhaW5lcn0gKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IHJlZ2lzdGVyQW5kR2V0U2Nyb2xsQ29udGFpbmVyKHBhcmFtZXRlcnMuY29udGFpbmVyKTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufSAqL1xuICAgIHRoaXMubGlua2VkID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXBlYXQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmhvcml6b250YWwgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW18U2Nyb2xsVGhyZXNob2xkVmFsdWV8U2Nyb2xsVGhyZXNob2xkQ2FsbGJhY2t9ICovXG4gICAgdGhpcy5lbnRlciA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRQYXJhbXxTY3JvbGxUaHJlc2hvbGRWYWx1ZXxTY3JvbGxUaHJlc2hvbGRDYWxsYmFja30gKi9cbiAgICB0aGlzLmxlYXZlID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5zeW5jID0gaXNFYXNlIHx8IGlzU21vb3RoIHx8ICEhc3luY01ldGhvZHM7XG4gICAgLyoqIEB0eXBlIHtFYXNpbmdGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnN5bmNFYXNlID0gaXNFYXNlID8gZWFzZSA6IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5zeW5jU21vb3RoID0gaXNTbW9vdGggPyBzeW5jTW9kZSA9PT0gdHJ1ZSB8fCBpc0xpbmVhciA/IDEgOiAvKiogQHR5cGUge051bWJlcn0gKi8oc3luY01vZGUpIDogbnVsbDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyID0gc3luY01ldGhvZHMgJiYgIWJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1swXSA/IHN5bmNNZXRob2RzWzBdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0xlYXZlID0gc3luY01ldGhvZHMgJiYgIWJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1sxXSA/IHN5bmNNZXRob2RzWzFdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyRm9yd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1swXSA/IHN5bmNNZXRob2RzWzBdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0xlYXZlRm9yd2FyZCA9IHN5bmNNZXRob2RzICYmIGJpRGlyU3luYyAmJiBzeW5jTWV0aG9kc1sxXSA/IHN5bmNNZXRob2RzWzFdIDogbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uU3luY0VudGVyQmFja3dhcmQgPSBzeW5jTWV0aG9kcyAmJiBiaURpclN5bmMgJiYgc3luY01ldGhvZHNbMl0gPyBzeW5jTWV0aG9kc1syXSA6IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNMZWF2ZUJhY2t3YXJkID0gc3luY01ldGhvZHMgJiYgYmlEaXJTeW5jICYmIHN5bmNNZXRob2RzWzNdID8gc3luY01ldGhvZHNbM10gOiBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25FbnRlciA9IHBhcmFtZXRlcnMub25FbnRlciB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25MZWF2ZSA9IHBhcmFtZXRlcnMub25MZWF2ZSB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25FbnRlckZvcndhcmQgPSBwYXJhbWV0ZXJzLm9uRW50ZXJGb3J3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkxlYXZlRm9yd2FyZCA9IHBhcmFtZXRlcnMub25MZWF2ZUZvcndhcmQgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0NhbGxiYWNrPFNjcm9sbE9ic2VydmVyPn0gKi9cbiAgICB0aGlzLm9uRW50ZXJCYWNrd2FyZCA9IHBhcmFtZXRlcnMub25FbnRlckJhY2t3YXJkIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vbkxlYXZlQmFja3dhcmQgPSBwYXJhbWV0ZXJzLm9uTGVhdmVCYWNrd2FyZCB8fCBub29wO1xuICAgIC8qKiBAdHlwZSB7Q2FsbGJhY2s8U2Nyb2xsT2JzZXJ2ZXI+fSAqL1xuICAgIHRoaXMub25VcGRhdGUgPSBwYXJhbWV0ZXJzLm9uVXBkYXRlIHx8IG5vb3A7XG4gICAgLyoqIEB0eXBlIHtDYWxsYmFjazxTY3JvbGxPYnNlcnZlcj59ICovXG4gICAgdGhpcy5vblN5bmNDb21wbGV0ZSA9IHBhcmFtZXRlcnMub25TeW5jQ29tcGxldGUgfHwgbm9vcDtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5yZXZlcnRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLmJlZ2FuID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge0Jvb2xlYW59ICovXG4gICAgdGhpcy5mb3JjZUVudGVyID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtCb29sZWFufSAqL1xuICAgIHRoaXMuaGFzRW50ZXJlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7QXJyYXkuPE51bWJlcj59ICovXG4gICAgdGhpcy5vZmZzZXRzID0gW107XG4gICAgLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMub2Zmc2V0U3RhcnQgPSAwO1xuICAgIC8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuICAgIHRoaXMub2Zmc2V0RW5kID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cbiAgICB0aGlzLnByZXZQcm9ncmVzcyA9IDA7XG4gICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICB0aGlzLnRocmVzaG9sZHMgPSBbJ3N0YXJ0JywgJ2VuZCcsICdlbmQnLCAnc3RhcnQnXTtcbiAgICAvKiogQHR5cGUge1tOdW1iZXIsIE51bWJlciwgTnVtYmVyLCBOdW1iZXJdfSAqL1xuICAgIHRoaXMuY29vcmRzID0gWzAsIDAsIDAsIDBdO1xuICAgIC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovXG4gICAgdGhpcy5kZWJ1Z1N0eWxlcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLiRkZWJ1ZyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxPYnNlcnZlclBhcmFtc30gKi9cbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbWV0ZXJzO1xuICAgIC8qKiBAdHlwZSB7Qm9vbGVhbn0gKi9cbiAgICB0aGlzLl9kZWJ1ZyA9IHNldFZhbHVlKHBhcmFtZXRlcnMuZGVidWcsIGZhbHNlKTtcbiAgICAvKiogQHR5cGUge1Njcm9sbE9ic2VydmVyfSAqL1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgYWRkQ2hpbGQodGhpcy5jb250YWluZXIsIHRoaXMpO1xuICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lIHRvIGFkZCB0byB0aGUgY29udGFpbmVyIGluIG9yZGVyIHRvIGhhbmRsZSBjYWxscyB0byBsaW5rKClcbiAgICBzeW5jKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJldmVydGVkKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHBhcnNlVGFyZ2V0cyhwYXJhbWV0ZXJzLnRhcmdldClbMF0pO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBkb2MuYm9keTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGVidWcpIHRoaXMuZGVidWcoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpY2thYmxlfFdBQVBJQW5pbWF0aW9ufSBsaW5rZWRcbiAgICovXG4gIGxpbmsobGlua2VkKSB7XG4gICAgaWYgKGxpbmtlZCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRvIHBhdXNlIHRoZSBsaW5rZWQgb2JqZWN0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgbGlua2VkLnBhdXNlKCk7XG4gICAgICB0aGlzLmxpbmtlZCA9IGxpbmtlZDtcbiAgICAgIC8vIFRyeSB0byB1c2UgYSB0YXJnZXQgb2YgdGhlIGxpbmtlZCBvYmplY3QgaWYgbm8gdGFyZ2V0IHBhcmFtZXRlcnMgc3BlY2lmaWVkXG4gICAgICBpZiAoIXRoaXMuX3BhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgbGV0ICRsaW5rZWRUYXJnZXQ7XG4gICAgICAgIGlmICghaXNVbmQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8obGlua2VkKS50YXJnZXRzKSkge1xuICAgICAgICAgICRsaW5rZWRUYXJnZXQgPSBnZXRBbmltYXRpb25Eb21UYXJnZXQoLyoqIEB0eXBlIHtKU0FuaW1hdGlvbn0gKi8obGlua2VkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yRWFjaENoaWxkcmVuKC8qKiBAdHlwZSB7VGltZWxpbmV9ICovKGxpbmtlZCksICgvKiogQHR5cGUge0pTQW5pbWF0aW9ufSAqL2NoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudGFyZ2V0cyAmJiAhJGxpbmtlZFRhcmdldCkge1xuICAgICAgICAgICAgICAkbGlua2VkVGFyZ2V0ID0gZ2V0QW5pbWF0aW9uRG9tVGFyZ2V0KC8qKiBAdHlwZSB7SlNBbmltYXRpb259ICovKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gYm9keSBpZiBubyB0YXJnZXQgZm91bmRcbiAgICAgICAgdGhpcy50YXJnZXQgPSAkbGlua2VkVGFyZ2V0IHx8IGRvYy5ib2R5O1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnZlbG9jaXR5O1xuICB9XG5cbiAgZ2V0IGJhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyB0aGlzLmNvbnRhaW5lci5iYWNrd2FyZFggOiB0aGlzLmNvbnRhaW5lci5iYWNrd2FyZFk7XG4gIH1cblxuICBnZXQgc2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhvcml6b250YWwgPyB0aGlzLmNvbnRhaW5lci5zY3JvbGxYIDogdGhpcy5jb250YWluZXIuc2Nyb2xsWTtcbiAgfVxuXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICBjb25zdCBwID0gKHRoaXMuc2Nyb2xsIC0gdGhpcy5vZmZzZXRTdGFydCkgLyB0aGlzLmRpc3RhbmNlO1xuICAgIHJldHVybiBwID09PSBJbmZpbml0eSB8fCBpc05hTihwKSA/IDAgOiByb3VuZChjbGFtcChwLCAwLCAxKSwgNik7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgdGhpcy5yZXBlYXQgPSBzZXRWYWx1ZShwYXJzZVNjcm9sbE9ic2VydmVyRnVuY3Rpb25QYXJhbWV0ZXIocGFyYW1zLnJlcGVhdCwgdGhpcyksIHRydWUpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHNldFZhbHVlKHBhcnNlU2Nyb2xsT2JzZXJ2ZXJGdW5jdGlvblBhcmFtZXRlcihwYXJhbXMuYXhpcywgdGhpcyksICd5JykgPT09ICd4JztcbiAgICB0aGlzLmVudGVyID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5lbnRlciwgdGhpcyksICdlbmQgc3RhcnQnKTtcbiAgICB0aGlzLmxlYXZlID0gc2V0VmFsdWUocGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyKHBhcmFtcy5sZWF2ZSwgdGhpcyksICdzdGFydCBlbmQnKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVEZWJ1ZygpIHtcbiAgICBpZiAodGhpcy4kZGVidWcpIHtcbiAgICAgIHRoaXMuJGRlYnVnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZGVidWcpO1xuICAgICAgdGhpcy4kZGVidWcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Z1N0eWxlcykge1xuICAgICAgdGhpcy5kZWJ1Z1N0eWxlcy5yZXZlcnQoKTtcbiAgICAgIHRoaXMuJGRlYnVnID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1ZygpIHtcbiAgICB0aGlzLnJlbW92ZURlYnVnKCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0ICRleGlzdGluZ0RlYnVnID0gY29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gLmFuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICBjb25zdCAkZGVidWcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRocmVzaG9sZHMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgJHRyaWdnZXJzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gZGVidWdDb2xvcnNbdGhpcy5pbmRleCAlIGRlYnVnQ29sb3JzLmxlbmd0aF07XG4gICAgY29uc3QgdXNlV2luID0gY29udGFpbmVyLnVzZVdpbjtcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IHVzZVdpbiA/IGNvbnRhaW5lci53aW5XaWR0aCA6IGNvbnRhaW5lci53aWR0aDtcbiAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSB1c2VXaW4gPyBjb250YWluZXIud2luSGVpZ2h0IDogY29udGFpbmVyLmhlaWdodDtcbiAgICBjb25zdCBzY3JvbGxXaWR0aCA9IGNvbnRhaW5lci5zY3JvbGxXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbnRhaW5lci53aWR0aCA+IDM2MCA/IDMyMCA6IDI2MDtcbiAgICBjb25zdCBvZmZMZWZ0ID0gaXNIb3JpID8gMCA6IDEwO1xuICAgIGNvbnN0IG9mZlRvcCA9IGlzSG9yaSA/IDEwIDogMDtcbiAgICBjb25zdCBoYWxmID0gaXNIb3JpID8gMjQgOiBzaXplIC8gMjtcbiAgICBjb25zdCBsYWJlbEhlaWdodCA9IGlzSG9yaSA/IGhhbGYgOiAxNTtcbiAgICBjb25zdCBsYWJlbFdpZHRoID0gaXNIb3JpID8gNjAgOiBoYWxmO1xuICAgIGNvbnN0IGxhYmVsU2l6ZSA9IGlzSG9yaSA/IGxhYmVsV2lkdGggOiBsYWJlbEhlaWdodDtcbiAgICBjb25zdCByZXBlYXQgPSBpc0hvcmkgPyAncmVwZWF0LXgnIDogJ3JlcGVhdC15JztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjb25zdCBncmFkaWVudE9mZnNldCA9IHYgPT4gaXNIb3JpID8gJzBweCAnKyh2KSsncHgnIDogKHYpKydweCcrJyAycHgnO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnN0IGxpbmVDU1MgPSAoYykgPT4gYGxpbmVhci1ncmFkaWVudCgke2lzSG9yaSA/IDkwIDogMH1kZWcsICR7Y30gMnB4LCB0cmFuc3BhcmVudCAxcHgpYDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnN0IGJhc2VDU1MgPSAocCwgbCwgdCwgdywgaCkgPT4gYHBvc2l0aW9uOiR7cH07bGVmdDoke2x9cHg7dG9wOiR7dH1weDt3aWR0aDoke3d9cHg7aGVpZ2h0OiR7aH1weDtgO1xuICAgICRkZWJ1Zy5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygnYWJzb2x1dGUnLCBvZmZMZWZ0LCBvZmZUb3AsIGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogc2l6ZSwgaXNIb3JpID8gc2l6ZSA6IHNjcm9sbEhlaWdodCl9XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIHotaW5kZXg6ICR7dGhpcy5jb250YWluZXIuekluZGV4Kyt9O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiAke2lzSG9yaSA/ICdjb2x1bW4nIDogJ3Jvdyd9O1xuICAgICAgZmlsdGVyOiBkcm9wLXNoYWRvdygwcHggMXB4IDBweCByZ2JhKDAsMCwwLC43NSkpO1xuICAgIGA7XG4gICAgJHRocmVzaG9sZHMuc3R5bGUuY3NzVGV4dCA9IGAke2Jhc2VDU1MoJ3N0aWNreScsIDAsIDAsIGlzSG9yaSA/IGNvbnRhaW5lcldpZHRoIDogaGFsZiwgaXNIb3JpID8gaGFsZiA6IGNvbnRhaW5lckhlaWdodCl9YDtcbiAgICBpZiAoISRleGlzdGluZ0RlYnVnKSB7XG4gICAgICAkdGhyZXNob2xkcy5zdHlsZS5jc3NUZXh0ICs9IGBiYWNrZ3JvdW5kOlxuICAgICAgICAke2xpbmVDU1MoJyNGRkZGJyl9JHtncmFkaWVudE9mZnNldChoYWxmLTEwKX0gLyAke2lzSG9yaSA/ICcxMDBweCAxMDBweCcgOiAnMTAwcHggMTAwcHgnfSAke3JlcGVhdH0sXG4gICAgICAgICR7bGluZUNTUygnI0ZGRjgnKX0ke2dyYWRpZW50T2Zmc2V0KGhhbGYtMTApfSAvICR7aXNIb3JpID8gJzEwcHggMTBweCcgOiAnMTBweCAxMHB4J30gJHtyZXBlYXR9O1xuICAgICAgYDtcbiAgICB9XG4gICAgJHRyaWdnZXJzLnN0eWxlLmNzc1RleHQgPSBgJHtiYXNlQ1NTKCdyZWxhdGl2ZScsIDAsIDAsIGlzSG9yaSA/IHNjcm9sbFdpZHRoIDogaGFsZiwgaXNIb3JpID8gaGFsZiA6IHNjcm9sbEhlaWdodCl9YDtcbiAgICBpZiAoISRleGlzdGluZ0RlYnVnKSB7XG4gICAgICAkdHJpZ2dlcnMuc3R5bGUuY3NzVGV4dCArPSBgYmFja2dyb3VuZDpcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGRicpfSR7Z3JhZGllbnRPZmZzZXQoMCl9IC8gJHtpc0hvcmkgPyAnMTAwcHggMTBweCcgOiAnMTBweCAxMDBweCd9ICR7cmVwZWF0fSxcbiAgICAgICAgJHtsaW5lQ1NTKCcjRkZGOCcpfSR7Z3JhZGllbnRPZmZzZXQoMCl9IC8gJHtpc0hvcmkgPyAnMTBweCAwcHgnIDogJzBweCAxMHB4J30gJHtyZXBlYXR9O1xuICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gWycgZW50ZXI6ICcsICcgbGVhdmU6ICddO1xuICAgIHRoaXMuY29vcmRzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIGNvbnN0IGlzVmlldyA9IGkgPiAxO1xuICAgICAgY29uc3QgdmFsdWUgPSAoaXNWaWV3ID8gMCA6IHRoaXMub2Zmc2V0KSArIHY7XG4gICAgICBjb25zdCBpc1RhaWwgPSBpICUgMjtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB2YWx1ZSA8IGxhYmVsU2l6ZTtcbiAgICAgIGNvbnN0IGlzT3ZlciA9IHZhbHVlID4gKGlzVmlldyA/IGlzSG9yaSA/IGNvbnRhaW5lcldpZHRoIDogY29udGFpbmVySGVpZ2h0IDogaXNIb3JpID8gc2Nyb2xsV2lkdGggOiBzY3JvbGxIZWlnaHQpIC0gbGFiZWxTaXplO1xuICAgICAgY29uc3QgaXNGbGlwID0gKGlzVmlldyA/IGlzVGFpbCAmJiAhaXNGaXJzdCA6ICFpc1RhaWwgJiYgIWlzRmlyc3QpIHx8IGlzT3ZlcjtcbiAgICAgIGNvbnN0ICRsYWJlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0ICR0ZXh0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgZGlyUHJvcCA9IGlzSG9yaSA/IGlzRmxpcCA/ICdyaWdodCcgOiAnbGVmdCcgOiBpc0ZsaXAgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgY29uc3QgZmxpcE9mZnNldCA9IGlzRmxpcCA/IChpc0hvcmkgPyBsYWJlbFdpZHRoIDogbGFiZWxIZWlnaHQpICsgKCFpc1ZpZXcgPyBpc0hvcmkgPyAtMSA6IC0yIDogaXNIb3JpID8gLTEgOiBpc092ZXIgPyAwIDogLTIpIDogIWlzVmlldyA/IGlzSG9yaSA/IDEgOiAwIDogaXNIb3JpID8gMSA6IDA7XG4gICAgICAvLyAkdGV4dC5pbm5lckhUTUwgPSBgJHshaXNWaWV3ID8gJycgOiBsYWJlbHNbaXNUYWlsXSArICcgJ30ke3RoaXMuaWR9OiAke3RoaXMudGhyZXNob2xkc1tpXX0gJHtpc1ZpZXcgPyAnJyA6IGxhYmVsc1tpc1RhaWxdfWA7XG4gICAgICAkdGV4dC5pbm5lckhUTUwgPSBgJHt0aGlzLmlkfSR7bGFiZWxzW2lzVGFpbF19JHt0aGlzLnRocmVzaG9sZHNbaV19YDtcbiAgICAgICRsYWJlbC5zdHlsZS5jc3NUZXh0ID0gYCR7YmFzZUNTUygnYWJzb2x1dGUnLCAwLCAwLCBsYWJlbFdpZHRoLCBsYWJlbEhlaWdodCl9XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiAke2lzSG9yaSA/ICdjb2x1bW4nIDogJ3Jvdyd9O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtJHtpc1ZpZXcgPyAnc3RhcnQnIDogJ2VuZCd9O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC0ke2lzRmxpcCA/ICdlbmQnIDogJ3N0YXJ0J307XG4gICAgICAgIGJvcmRlci0ke2RpclByb3B9OiAycHggJHtpc1RhaWwgPyAnc29saWQnIDogJ3NvbGlkJ30gJHtjb2xvcn07XG4gICAgICBgO1xuICAgICAgJHRleHQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbWF4LXdpZHRoOiAkeyhzaXplIC8gMikgLSAxMH1weDtcbiAgICAgICAgaGVpZ2h0OiAke2xhYmVsSGVpZ2h0fTtcbiAgICAgICAgbWFyZ2luLSR7aXNIb3JpID8gaXNGbGlwID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGlzRmxpcCA/ICdib3R0b20nIDogJ3RvcCd9OiAtMnB4O1xuICAgICAgICBwYWRkaW5nOiAxcHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIG1vbm9zcGFjZTtcbiAgICAgICAgZm9udC1zaXplOiAxMHB4O1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMjVlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDlweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgICAgdGV4dC1hbGlnbjogJHtpc0hvcmkgJiYgaXNGbGlwIHx8ICFpc0hvcmkgJiYgIWlzVmlldyA/ICdyaWdodCcgOiAnbGVmdCd9O1xuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgY29sb3I6ICR7aXNUYWlsID8gY29sb3IgOiAncmdiYSgwLDAsMCwuNzUpJ307XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7aXNUYWlsID8gJ3JnYmEoMCwwLDAsLjY1KScgOiBjb2xvcn07XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkICR7aXNUYWlsID8gY29sb3IgOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgICAgYm9yZGVyLSR7aXNIb3JpID8gaXNGbGlwID8gJ3RvcC1sZWZ0JyA6ICd0b3AtcmlnaHQnIDogaXNGbGlwID8gJ3RvcC1sZWZ0JyA6ICdib3R0b20tbGVmdCd9LXJhZGl1czogNXB4O1xuICAgICAgICBib3JkZXItJHtpc0hvcmkgPyBpc0ZsaXAgPyAnYm90dG9tLWxlZnQnIDogJ2JvdHRvbS1yaWdodCcgOiBpc0ZsaXAgPyAndG9wLXJpZ2h0JyA6ICdib3R0b20tcmlnaHQnfS1yYWRpdXM6IDVweDtcbiAgICAgIGA7XG4gICAgICAkbGFiZWwuYXBwZW5kQ2hpbGQoJHRleHQpO1xuICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUgLSBmbGlwT2Zmc2V0ICsgKGlzSG9yaSA/IDEgOiAwKTtcbiAgICAgICRsYWJlbC5zdHlsZVtpc0hvcmkgPyAnbGVmdCcgOiAndG9wJ10gPSBgJHtwb3NpdGlvbn1weGA7XG4gICAgICAvLyAkbGFiZWwuc3R5bGVbaXNIb3JpID8gJ2xlZnQnIDogJ3RvcCddID0gdmFsdWUgLSBmbGlwT2Zmc2V0ICsgKCFpc0ZsaXAgJiYgaXNGaXJzdCAmJiAhaXNWaWV3ID8gMSA6IGlzRmxpcCA/IDAgOiAtMikgKyAncHgnO1xuICAgICAgKGlzVmlldyA/ICR0aHJlc2hvbGRzIDogJHRyaWdnZXJzKS5hcHBlbmRDaGlsZCgkbGFiZWwpO1xuICAgIH0pO1xuXG4gICAgJGRlYnVnLmFwcGVuZENoaWxkKCR0aHJlc2hvbGRzKTtcbiAgICAkZGVidWcuYXBwZW5kQ2hpbGQoJHRyaWdnZXJzKTtcbiAgICBjb250YWluZXIuZWxlbWVudC5hcHBlbmRDaGlsZCgkZGVidWcpO1xuXG4gICAgaWYgKCEkZXhpc3RpbmdEZWJ1ZykgJGRlYnVnLmNsYXNzTGlzdC5hZGQoJ2FuaW1lanMtb25zY3JvbGwtZGVidWcnKTtcbiAgICB0aGlzLiRkZWJ1ZyA9ICRkZWJ1ZztcbiAgICBjb25zdCBjb250YWluZXJQb3NpdGlvbiA9IGdldFRhcmdldFZhbHVlKGNvbnRhaW5lci5lbGVtZW50LCAncG9zaXRpb24nKTtcbiAgICBpZiAoY29udGFpbmVyUG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB0aGlzLmRlYnVnU3R5bGVzID0gc2V0VGFyZ2V0VmFsdWVzKGNvbnRhaW5lci5lbGVtZW50LCB7IHBvc2l0aW9uOiAncmVsYXRpdmUgJ30pO1xuICAgIH1cblxuICB9XG5cbiAgdXBkYXRlQm91bmRzKCkge1xuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5yZW1vdmVEZWJ1ZygpO1xuICAgIH1cbiAgICBsZXQgc3RpY2t5cztcbiAgICBjb25zdCAkdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgIGxldCBsaW5rZWRUaW1lO1xuICAgIGxldCAkZWwgPSAkdGFyZ2V0O1xuICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgIGxldCAkb2Zmc2V0UGFyZW50ID0gJGVsO1xuICAgIGlmIChsaW5rZWQpIHtcbiAgICAgIGxpbmtlZFRpbWUgPSBsaW5rZWQuY3VycmVudFRpbWU7XG4gICAgICBsaW5rZWQuc2VlaygwLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3QgaXNDb250YWluZXJTdGF0aWMgPSBnZXRUYXJnZXRWYWx1ZShjb250YWluZXIuZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnID8gc2V0VGFyZ2V0VmFsdWVzKGNvbnRhaW5lci5lbGVtZW50LCB7IHBvc2l0aW9uOiAncmVsYXRpdmUgJ30pIDogZmFsc2U7XG4gICAgd2hpbGUgKCRlbCAmJiAkZWwgIT09IGNvbnRhaW5lci5lbGVtZW50ICYmICRlbCAhPT0gZG9jLmJvZHkpIHtcbiAgICAgIGNvbnN0IGlzU3RpY2t5ID0gZ2V0VGFyZ2V0VmFsdWUoJGVsLCAncG9zaXRpb24nKSA9PT0gJ3N0aWNreScgP1xuICAgICAgICAgICAgICAgICAgICAgICBzZXRUYXJnZXRWYWx1ZXMoJGVsLCB7IHBvc2l0aW9uOiAnc3RhdGljJyB9KSA6XG4gICAgICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgaWYgKCRlbCA9PT0gJG9mZnNldFBhcmVudCkge1xuICAgICAgICBvZmZzZXRYICs9ICRlbC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgIG9mZnNldFkgKz0gJGVsLm9mZnNldFRvcCB8fCAwO1xuICAgICAgICAkb2Zmc2V0UGFyZW50ID0gJGVsLm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgICRlbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKCRlbC5wYXJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChpc1N0aWNreSkge1xuICAgICAgICBpZiAoIXN0aWNreXMpIHN0aWNreXMgPSBbXTtcbiAgICAgICAgc3RpY2t5cy5wdXNoKGlzU3RpY2t5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQ29udGFpbmVyU3RhdGljKSBpc0NvbnRhaW5lclN0YXRpYy5yZXZlcnQoKTtcbiAgICBjb25zdCBvZmZzZXQgPSBpc0hvcmkgPyBvZmZzZXRYIDogb2Zmc2V0WTtcbiAgICBjb25zdCB0YXJnZXRTaXplID0gaXNIb3JpID8gJHRhcmdldC5vZmZzZXRXaWR0aCA6ICR0YXJnZXQub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBpc0hvcmkgPyBjb250YWluZXIud2lkdGggOiBjb250YWluZXIuaGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbFNpemUgPSBpc0hvcmkgPyBjb250YWluZXIuc2Nyb2xsV2lkdGggOiBjb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgIGNvbnN0IG1heFNjcm9sbCA9IHNjcm9sbFNpemUgLSBjb250YWluZXJTaXplO1xuICAgIGNvbnN0IGVudGVyID0gdGhpcy5lbnRlcjtcbiAgICBjb25zdCBsZWF2ZSA9IHRoaXMubGVhdmU7XG5cbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBlbnRlclRhcmdldCA9ICdzdGFydCc7XG4gICAgLyoqIEB0eXBlIHtTY3JvbGxUaHJlc2hvbGRWYWx1ZX0gKi9cbiAgICBsZXQgbGVhdmVUYXJnZXQgPSAnZW5kJztcbiAgICAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFZhbHVlfSAqL1xuICAgIGxldCBlbnRlckNvbnRhaW5lciA9ICdlbmQnO1xuICAgIC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkVmFsdWV9ICovXG4gICAgbGV0IGxlYXZlQ29udGFpbmVyID0gJ3N0YXJ0JztcblxuICAgIGlmIChpc1N0cihlbnRlcikpIHtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gLyoqIEB0eXBlIHtTdHJpbmd9ICovKGVudGVyKS5zcGxpdCgnICcpO1xuICAgICAgZW50ZXJDb250YWluZXIgPSBzcGxpdHRlZFswXTtcbiAgICAgIGVudGVyVGFyZ2V0ID0gc3BsaXR0ZWQubGVuZ3RoID4gMSA/IHNwbGl0dGVkWzFdIDogZW50ZXJUYXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc09iaihlbnRlcikpIHtcbiAgICAgIGNvbnN0IGUgPSAvKiogQHR5cGUge1Njcm9sbFRocmVzaG9sZFBhcmFtfSAqLyhlbnRlcik7XG4gICAgICBpZiAoIWlzVW5kKGUuY29udGFpbmVyKSkgZW50ZXJDb250YWluZXIgPSBlLmNvbnRhaW5lcjtcbiAgICAgIGlmICghaXNVbmQoZS50YXJnZXQpKSBlbnRlclRhcmdldCA9IGUudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAoaXNOdW0oZW50ZXIpKSB7XG4gICAgICBlbnRlckNvbnRhaW5lciA9IC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhlbnRlcik7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyKGxlYXZlKSkge1xuICAgICAgY29uc3Qgc3BsaXR0ZWQgPSAvKiogQHR5cGUge1N0cmluZ30gKi8obGVhdmUpLnNwbGl0KCcgJyk7XG4gICAgICBsZWF2ZUNvbnRhaW5lciA9IHNwbGl0dGVkWzBdO1xuICAgICAgbGVhdmVUYXJnZXQgPSBzcGxpdHRlZC5sZW5ndGggPiAxID8gc3BsaXR0ZWRbMV0gOiBsZWF2ZVRhcmdldDtcbiAgICB9IGVsc2UgaWYgKGlzT2JqKGxlYXZlKSkge1xuICAgICAgY29uc3QgdCA9IC8qKiBAdHlwZSB7U2Nyb2xsVGhyZXNob2xkUGFyYW19ICovKGxlYXZlKTtcbiAgICAgIGlmICghaXNVbmQodC5jb250YWluZXIpKSBsZWF2ZUNvbnRhaW5lciA9IHQuY29udGFpbmVyO1xuICAgICAgaWYgKCFpc1VuZCh0LnRhcmdldCkpIGxlYXZlVGFyZ2V0ID0gdC50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChpc051bShsZWF2ZSkpIHtcbiAgICAgIGxlYXZlQ29udGFpbmVyID0gLyoqIEB0eXBlIHtOdW1iZXJ9ICovKGxlYXZlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRFbnRlclRhcmdldCA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBlbnRlclRhcmdldCwgdGFyZ2V0U2l6ZSk7XG4gICAgY29uc3QgcGFyc2VkTGVhdmVUYXJnZXQgPSBwYXJzZUJvdW5kVmFsdWUoJHRhcmdldCwgbGVhdmVUYXJnZXQsIHRhcmdldFNpemUpO1xuICAgIGNvbnN0IHVuZGVyID0gKHBhcnNlZEVudGVyVGFyZ2V0ICsgb2Zmc2V0KSAtIGNvbnRhaW5lclNpemU7XG4gICAgY29uc3Qgb3ZlciA9IChwYXJzZWRMZWF2ZVRhcmdldCArIG9mZnNldCkgLSBtYXhTY3JvbGw7XG4gICAgY29uc3QgcGFyc2VkRW50ZXJDb250YWluZXIgPSBwYXJzZUJvdW5kVmFsdWUoJHRhcmdldCwgZW50ZXJDb250YWluZXIsIGNvbnRhaW5lclNpemUsIHVuZGVyLCBvdmVyKTtcbiAgICBjb25zdCBwYXJzZWRMZWF2ZUNvbnRhaW5lciA9IHBhcnNlQm91bmRWYWx1ZSgkdGFyZ2V0LCBsZWF2ZUNvbnRhaW5lciwgY29udGFpbmVyU2l6ZSwgdW5kZXIsIG92ZXIpO1xuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gcGFyc2VkRW50ZXJUYXJnZXQgKyBvZmZzZXQgLSBwYXJzZWRFbnRlckNvbnRhaW5lcjtcbiAgICBjb25zdCBvZmZzZXRFbmQgPSBwYXJzZWRMZWF2ZVRhcmdldCArIG9mZnNldCAtIHBhcnNlZExlYXZlQ29udGFpbmVyO1xuICAgIGNvbnN0IHNjcm9sbERlbHRhID0gb2Zmc2V0RW5kIC0gb2Zmc2V0U3RhcnQ7XG4gICAgdGhpcy5vZmZzZXRzWzBdID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldHNbMV0gPSBvZmZzZXRZO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMub2Zmc2V0U3RhcnQgPSBvZmZzZXRTdGFydDtcbiAgICB0aGlzLm9mZnNldEVuZCA9IG9mZnNldEVuZDtcbiAgICB0aGlzLmRpc3RhbmNlID0gc2Nyb2xsRGVsdGEgPD0gMCA/IDAgOiBzY3JvbGxEZWx0YTtcbiAgICB0aGlzLnRocmVzaG9sZHMgPSBbZW50ZXJUYXJnZXQsIGxlYXZlVGFyZ2V0LCBlbnRlckNvbnRhaW5lciwgbGVhdmVDb250YWluZXJdO1xuICAgIHRoaXMuY29vcmRzID0gW3BhcnNlZEVudGVyVGFyZ2V0LCBwYXJzZWRMZWF2ZVRhcmdldCwgcGFyc2VkRW50ZXJDb250YWluZXIsIHBhcnNlZExlYXZlQ29udGFpbmVyXTtcbiAgICBpZiAoc3RpY2t5cykge1xuICAgICAgc3RpY2t5cy5mb3JFYWNoKHN0aWNreSA9PiBzdGlja3kucmV2ZXJ0KCkpO1xuICAgIH1cbiAgICBpZiAobGlua2VkKSB7XG4gICAgICBsaW5rZWQuc2VlayhsaW5rZWRUaW1lLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlYnVnKSB7XG4gICAgICB0aGlzLmRlYnVnKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsKCkge1xuICAgIGNvbnN0IGxpbmtlZCA9IHRoaXMubGlua2VkO1xuICAgIGNvbnN0IHN5bmMgPSB0aGlzLnN5bmM7XG4gICAgY29uc3Qgc3luY0Vhc2UgPSB0aGlzLnN5bmNFYXNlO1xuICAgIGNvbnN0IHN5bmNTbW9vdGggPSB0aGlzLnN5bmNTbW9vdGg7XG4gICAgY29uc3Qgc2hvdWxkU2VlayA9IGxpbmtlZCAmJiAoc3luY0Vhc2UgfHwgc3luY1Ntb290aCk7XG4gICAgY29uc3QgaXNIb3JpID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuc2Nyb2xsO1xuICAgIGNvbnN0IGlzQmVmb3JlID0gc2Nyb2xsIDw9IHRoaXMub2Zmc2V0U3RhcnQ7XG4gICAgY29uc3QgaXNBZnRlciA9IHNjcm9sbCA+PSB0aGlzLm9mZnNldEVuZDtcbiAgICBjb25zdCBpc0luVmlldyA9ICFpc0JlZm9yZSAmJiAhaXNBZnRlcjtcbiAgICBjb25zdCBpc09uVGhlRWRnZSA9IHNjcm9sbCA9PT0gdGhpcy5vZmZzZXRTdGFydCB8fCBzY3JvbGwgPT09IHRoaXMub2Zmc2V0RW5kO1xuICAgIGNvbnN0IGZvcmNlRW50ZXIgPSAhdGhpcy5oYXNFbnRlcmVkICYmIGlzT25UaGVFZGdlO1xuICAgIGNvbnN0ICRkZWJ1ZyA9IHRoaXMuX2RlYnVnICYmIHRoaXMuJGRlYnVnO1xuICAgIGxldCBoYXNVcGRhdGVkID0gZmFsc2U7XG4gICAgbGV0IHN5bmNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcCA9IHRoaXMucHJvZ3Jlc3M7XG5cbiAgICBpZiAoaXNCZWZvcmUgJiYgdGhpcy5iZWdhbikge1xuICAgICAgdGhpcy5iZWdhbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwID4gMCAmJiAhdGhpcy5iZWdhbikge1xuICAgICAgdGhpcy5iZWdhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNlZWspIHtcbiAgICAgIGNvbnN0IGxwID0gbGlua2VkLnByb2dyZXNzO1xuICAgICAgaWYgKHN5bmNTbW9vdGggJiYgaXNOdW0oc3luY1Ntb290aCkpIHtcbiAgICAgICAgaWYgKC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzeW5jU21vb3RoKSA8IDEpIHtcbiAgICAgICAgICBjb25zdCBzdGVwID0gMC4wMDAxO1xuICAgICAgICAgIGNvbnN0IHNuYXAgPSBscCA8IHAgJiYgcCA9PT0gMSA/IHN0ZXAgOiBscCA+IHAgJiYgIXAgPyAtMWUtNCA6IDA7XG4gICAgICAgICAgcCA9IHJvdW5kKGxlcnAobHAsIHAsIGludGVycG9sYXRlKC4wMSwgLjIsIC8qKiBAdHlwZSB7TnVtYmVyfSAqLyhzeW5jU21vb3RoKSksIGZhbHNlKSArIHNuYXAsIDYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN5bmNFYXNlKSB7XG4gICAgICAgIHAgPSBzeW5jRWFzZShwKTtcbiAgICAgIH1cbiAgICAgIGhhc1VwZGF0ZWQgPSBwICE9PSB0aGlzLnByZXZQcm9ncmVzcztcbiAgICAgIHN5bmNDb21wbGV0ZWQgPSBscCA9PT0gMTtcbiAgICAgIGlmIChoYXNVcGRhdGVkICYmICFzeW5jQ29tcGxldGVkICYmIChzeW5jU21vb3RoICYmIGxwKSkge1xuICAgICAgICBjb250YWluZXIud2FrZVRpY2tlci5yZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRkZWJ1Zykge1xuICAgICAgY29uc3Qgc3RpY2t5ID0gaXNIb3JpID8gY29udGFpbmVyLnNjcm9sbFkgOiBjb250YWluZXIuc2Nyb2xsWDtcbiAgICAgICRkZWJ1Zy5zdHlsZVtpc0hvcmkgPyAndG9wJyA6ICdsZWZ0J10gPSBzdGlja3kgKyAxMCArICdweCc7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBlbnRlciBjYWxsYmFja3MgaWYgYWxyZWFkeSBpbiB2aWV3IG9yIHdoZW4gZW50ZXJpbmcgdGhlIHZpZXdcbiAgICBpZiAoKGlzSW5WaWV3ICYmICF0aGlzLmlzSW5WaWV3KSB8fCAoZm9yY2VFbnRlciAmJiAhdGhpcy5mb3JjZUVudGVyICYmICF0aGlzLmhhc0VudGVyZWQpKSB7XG4gICAgICBpZiAoaXNJblZpZXcpIHRoaXMuaXNJblZpZXcgPSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLmZvcmNlRW50ZXIgfHwgIXRoaXMuaGFzRW50ZXJlZCkge1xuICAgICAgICBpZiAoJGRlYnVnICYmIGlzSW5WaWV3KSAkZGVidWcuc3R5bGUuekluZGV4ID0gYCR7dGhpcy5jb250YWluZXIuekluZGV4Kyt9YDtcbiAgICAgICAgdGhpcy5vblN5bmNFbnRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVudGVyKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5iYWNrd2FyZCkge1xuICAgICAgICAgIHRoaXMub25TeW5jRW50ZXJCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9uRW50ZXJCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uU3luY0VudGVyRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9uRW50ZXJGb3J3YXJkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzRW50ZXJlZCA9IHRydWU7XG4gICAgICAgIGlmIChmb3JjZUVudGVyKSB0aGlzLmZvcmNlRW50ZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0luVmlldykge1xuICAgICAgICB0aGlzLmZvcmNlRW50ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNJblZpZXcgfHwgIWlzSW5WaWV3ICYmIHRoaXMuaXNJblZpZXcpIHtcbiAgICAgIGhhc1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNVcGRhdGVkKSB7XG4gICAgICBpZiAoc2hvdWxkU2VlaykgbGlua2VkLnNlZWsobGlua2VkLmR1cmF0aW9uICogcCk7XG4gICAgICB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIGlmICghaXNJblZpZXcgJiYgdGhpcy5pc0luVmlldykge1xuICAgICAgdGhpcy5pc0luVmlldyA9IGZhbHNlO1xuICAgICAgdGhpcy5vblN5bmNMZWF2ZSh0aGlzKTtcbiAgICAgIHRoaXMub25MZWF2ZSh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmJhY2t3YXJkKSB7XG4gICAgICAgIHRoaXMub25TeW5jTGVhdmVCYWNrd2FyZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxlYXZlQmFja3dhcmQodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uU3luY0xlYXZlRm9yd2FyZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkxlYXZlRm9yd2FyZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW5jICYmICFzeW5jU21vb3RoKSB7XG4gICAgICAgIHN5bmNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwID49IDEgJiYgdGhpcy5iZWdhbiAmJiAhdGhpcy5jb21wbGV0ZWQgJiYgKHN5bmMgJiYgc3luY0NvbXBsZXRlZCB8fCAhc3luYykpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHRoaXMub25TeW5jQ29tcGxldGUodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICBpZiAoKCF0aGlzLnJlcGVhdCAmJiAhbGlua2VkKSB8fCAoIXRoaXMucmVwZWF0ICYmIGxpbmtlZCAmJiBsaW5rZWQuY29tcGxldGVkKSkge1xuICAgICAgICB0aGlzLnJldmVydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwIDwgMSAmJiB0aGlzLmNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZQcm9ncmVzcyA9IHA7XG4gIH1cblxuICByZXZlcnQoKSB7XG4gICAgaWYgKHRoaXMucmV2ZXJ0ZWQpIHJldHVybjtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICByZW1vdmVDaGlsZChjb250YWluZXIsIHRoaXMpO1xuICAgIGlmICghY29udGFpbmVyLl9oZWFkKSB7XG4gICAgICBjb250YWluZXIucmV2ZXJ0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWJ1Zykge1xuICAgICAgdGhpcy5yZW1vdmVEZWJ1ZygpO1xuICAgIH1cbiAgICB0aGlzLnJldmVydGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHtTY3JvbGxPYnNlcnZlclBhcmFtc30gW3BhcmFtZXRlcnM9e31dXG4gKiBAcmV0dXJuIHtTY3JvbGxPYnNlcnZlcn1cbiAqL1xuY29uc3Qgb25TY3JvbGwgPSAocGFyYW1ldGVycyA9IHt9KSA9PiBuZXcgU2Nyb2xsT2JzZXJ2ZXIocGFyYW1ldGVycyk7XG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYgIHtPYmplY3R9IFN0YWdnZXJQYXJhbWV0ZXJzXG4gKiBAcHJvcGVydHkge051bWJlcnxTdHJpbmd9IFtzdGFydF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfCdmaXJzdCd8J2NlbnRlcid8J2xhc3QnfSBbZnJvbV1cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JldmVyc2VkXVxuICogQHByb3BlcnR5IHtBcnJheS48TnVtYmVyPn0gW2dyaWRdXG4gKiBAcHJvcGVydHkgeygneCd8J3knKX0gW2F4aXNdXG4gKiBAcHJvcGVydHkge0Vhc2luZ1BhcmFtfSBbZWFzZV1cbiAqIEBwcm9wZXJ0eSB7VHdlZW5Nb2RpZmllcn0gW21vZGlmaWVyXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFN0YWdnZXJGdW5jdGlvblxuICogQHBhcmFtIHtUYXJnZXR9IFt0YXJnZXRdXG4gKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZW5ndGhdXG4gKiBAcGFyYW0ge1RpbWVsaW5lfSBbdGxdXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICovXG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ3xbTnVtYmVyfFN0cmluZyxOdW1iZXJ8U3RyaW5nXX0gdmFsXG4gKiBAcGFyYW0gIHtTdGFnZ2VyUGFyYW1ldGVyc30gcGFyYW1zXG4gKiBAcmV0dXJuIHtTdGFnZ2VyRnVuY3Rpb259XG4gKi9cbmNvbnN0IHN0YWdnZXIgPSAodmFsLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGxldCBtYXhWYWx1ZSA9IDA7XG4gIGNvbnN0IGZyb20gPSBwYXJhbXMuZnJvbTtcbiAgY29uc3QgcmV2ZXJzZWQgPSBwYXJhbXMucmV2ZXJzZWQ7XG4gIGNvbnN0IGVhc2UgPSBwYXJhbXMuZWFzZTtcbiAgY29uc3QgaGFzRWFzaW5nID0gIWlzVW5kKGVhc2UpO1xuICBjb25zdCBoYXNTcHJpbmcgPSBoYXNFYXNpbmcgJiYgIWlzVW5kKC8qKiBAdHlwZSB7U3ByaW5nfSAqLyhlYXNlKS5lYXNlKTtcbiAgY29uc3Qgc3RhZ2dlckVhc2UgPSBoYXNTcHJpbmcgPyAvKiogQHR5cGUge1NwcmluZ30gKi8oZWFzZSkuZWFzZSA6IGhhc0Vhc2luZyA/IHBhcnNlRWFzaW5ncyhlYXNlKSA6IG51bGw7XG4gIGNvbnN0IGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgY29uc3QgYXhpcyA9IHBhcmFtcy5heGlzO1xuICBjb25zdCBmcm9tRmlyc3QgPSBpc1VuZChmcm9tKSB8fCBmcm9tID09PSAwIHx8IGZyb20gPT09ICdmaXJzdCc7XG4gIGNvbnN0IGZyb21DZW50ZXIgPSBmcm9tID09PSAnY2VudGVyJztcbiAgY29uc3QgZnJvbUxhc3QgPSBmcm9tID09PSAnbGFzdCc7XG4gIGNvbnN0IGlzUmFuZ2UgPSBpc0Fycih2YWwpO1xuICBjb25zdCB2YWwxID0gaXNSYW5nZSA/IHBhcnNlTnVtYmVyKHZhbFswXSkgOiBwYXJzZU51bWJlcih2YWwpO1xuICBjb25zdCB2YWwyID0gaXNSYW5nZSA/IHBhcnNlTnVtYmVyKHZhbFsxXSkgOiAwO1xuICBjb25zdCB1bml0TWF0Y2ggPSB1bml0c0V4ZWNSZ3guZXhlYygoaXNSYW5nZSA/IHZhbFsxXSA6IHZhbCkgKyBlbXB0eVN0cmluZyk7XG4gIGNvbnN0IHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDAgKyAoaXNSYW5nZSA/IHZhbDEgOiAwKTtcbiAgbGV0IGZyb21JbmRleCA9IGZyb21GaXJzdCA/IDAgOiBpc051bShmcm9tKSA/IGZyb20gOiAwO1xuICByZXR1cm4gKF8sIGksIHQsIHRsKSA9PiB7XG4gICAgaWYgKGZyb21DZW50ZXIpIGZyb21JbmRleCA9ICh0IC0gMSkgLyAyO1xuICAgIGlmIChmcm9tTGFzdCkgZnJvbUluZGV4ID0gdCAtIDE7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChhYnMoZnJvbUluZGV4IC0gaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4ICUgZ3JpZFswXSA6IChncmlkWzBdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IGZyb21ZID0gIWZyb21DZW50ZXIgPyBmbG9vcihmcm9tSW5kZXggLyBncmlkWzBdKSA6IChncmlkWzFdIC0gMSkgLyAyO1xuICAgICAgICAgIGNvbnN0IHRvWCA9IGluZGV4ICUgZ3JpZFswXTtcbiAgICAgICAgICBjb25zdCB0b1kgPSBmbG9vcihpbmRleCAvIGdyaWRbMF0pO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWCA9IGZyb21YIC0gdG9YO1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlWSA9IGZyb21ZIC0gdG9ZO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHNxcnQoZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZKTtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB2YWx1ZSA9IC1kaXN0YW5jZVg7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd5JykgdmFsdWUgPSAtZGlzdGFuY2VZO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IG1heCguLi52YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWdnZXJFYXNlKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHZhbCA9PiBzdGFnZ2VyRWFzZSh2YWwgLyBtYXhWYWx1ZSkgKiBtYXhWYWx1ZSk7XG4gICAgICBpZiAocmV2ZXJzZWQpIHZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+IGF4aXMgPyAodmFsIDwgMCkgPyB2YWwgKiAtMSA6IC12YWwgOiBhYnMobWF4VmFsdWUgLSB2YWwpKTtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IGlzUmFuZ2UgPyAodmFsMiAtIHZhbDEpIC8gbWF4VmFsdWUgOiB2YWwxO1xuICAgIGNvbnN0IG9mZnNldCA9IHRsID8gcGFyc2VUaW1lbGluZVBvc2l0aW9uKHRsLCBpc1VuZChwYXJhbXMuc3RhcnQpID8gdGwuaXRlcmF0aW9uRHVyYXRpb24gOiBzdGFydCkgOiAvKiogQHR5cGUge051bWJlcn0gKi8oc3RhcnQpO1xuICAgIC8qKiBAdHlwZSB7U3RyaW5nfE51bWJlcn0gKi9cbiAgICBsZXQgb3V0cHV0ID0gb2Zmc2V0ICsgKChzcGFjaW5nICogcm91bmQodmFsdWVzW2ldLCAyKSkgfHwgMCk7XG4gICAgaWYgKHBhcmFtcy5tb2RpZmllcikgb3V0cHV0ID0gcGFyYW1zLm1vZGlmaWVyKG91dHB1dCk7XG4gICAgaWYgKHVuaXRNYXRjaCkgb3V0cHV0ID0gYCR7b3V0cHV0fSR7dW5pdE1hdGNoWzJdfWA7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxuZXhwb3J0IHsgQW5pbWF0YWJsZSwgRHJhZ2dhYmxlLCBKU0FuaW1hdGlvbiwgU2NvcGUsIFNjcm9sbE9ic2VydmVyLCBTcHJpbmcsIFRpbWVsaW5lLCBUaW1lciwgV0FBUElBbmltYXRpb24sIGFuaW1hdGUsIGNyZWF0ZUFuaW1hdGFibGUsIGNyZWF0ZURyYWdnYWJsZSwgY3JlYXRlU2NvcGUsIGNyZWF0ZVNwcmluZywgY3JlYXRlVGltZWxpbmUsIGNyZWF0ZVRpbWVyLCBlYXNlcywgZW5naW5lLCBvblNjcm9sbCwgc2Nyb2xsQ29udGFpbmVycywgc3RhZ2dlciwgc3ZnLCB1dGlscywgd2FhcGkgfTtcbiJdLCJuYW1lcyI6WyJpc0Jyb3dzZXIiLCJ3aW4iLCJ3aW5kb3ciLCJkb2MiLCJkb2N1bWVudCIsInR3ZWVuVHlwZXMiLCJPQkpFQ1QiLCJBVFRSSUJVVEUiLCJDU1MiLCJUUkFOU0ZPUk0iLCJDU1NfVkFSIiwidmFsdWVUeXBlcyIsIk5VTUJFUiIsIlVOSVQiLCJDT0xPUiIsIkNPTVBMRVgiLCJ0aWNrTW9kZXMiLCJOT05FIiwiQVVUTyIsIkZPUkNFIiwiY29tcG9zaXRpb25UeXBlcyIsInJlcGxhY2UiLCJub25lIiwiYmxlbmQiLCJpc1JlZ2lzdGVyZWRUYXJnZXRTeW1ib2wiLCJTeW1ib2wiLCJpc0RvbVN5bWJvbCIsImlzU3ZnU3ltYm9sIiwidHJhbnNmb3Jtc1N5bWJvbCIsIm1vcnBoUG9pbnRzU3ltYm9sIiwicHJveHlUYXJnZXRTeW1ib2wiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiSyIsIm1heEZwcyIsImVtcHR5U3RyaW5nIiwic2hvcnRUcmFuc2Zvcm1zIiwiTWFwIiwic2V0IiwidmFsaWRUcmFuc2Zvcm1zIiwidHJhbnNmb3Jtc0ZyYWdtZW50U3RyaW5ncyIsInJlZHVjZSIsImEiLCJ2Iiwibm9vcCIsImhleFRlc3RSZ3giLCJyZ2JFeGVjUmd4IiwicmdiYUV4ZWNSZ3giLCJoc2xFeGVjUmd4IiwiaHNsYUV4ZWNSZ3giLCJkaWdpdFdpdGhFeHBvbmVudFJneCIsInVuaXRzRXhlY1JneCIsImxvd2VyQ2FzZVJneCIsInRyYW5zZm9ybXNFeGVjUmd4IiwicmVsYXRpdmVWYWx1ZXNFeGVjUmd4IiwiZGVmYXVsdHMiLCJpZCIsImtleWZyYW1lcyIsInBsYXliYWNrRWFzZSIsInBsYXliYWNrUmF0ZSIsImZyYW1lUmF0ZSIsImxvb3AiLCJyZXZlcnNlZCIsImFsdGVybmF0ZSIsImF1dG9wbGF5IiwiZHVyYXRpb24iLCJkZWxheSIsImxvb3BEZWxheSIsImVhc2UiLCJjb21wb3NpdGlvbiIsIm1vZGlmaWVyIiwib25CZWdpbiIsIm9uQmVmb3JlVXBkYXRlIiwib25VcGRhdGUiLCJvbkxvb3AiLCJvblBhdXNlIiwib25Db21wbGV0ZSIsIm9uUmVuZGVyIiwiZ2xvYmFscyIsInJvb3QiLCJzY29wZSIsInByZWNpc2lvbiIsInRpbWVTY2FsZSIsInRpY2tUaHJlc2hvbGQiLCJnbG9iYWxWZXJzaW9ucyIsInZlcnNpb24iLCJlbmdpbmUiLCJBbmltZUpTIiwicHVzaCIsInRvTG93ZXJDYXNlIiwic3RyIiwic3RyaW5nU3RhcnRzV2l0aCIsInN1YiIsImluZGV4T2YiLCJub3ciLCJEYXRlIiwiaXNBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJpc09iaiIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiaXNOdW0iLCJpc05hTiIsImlzU3RyIiwiaXNGbmMiLCJpc1VuZCIsImlzTmlsIiwiaXNTdmciLCJTVkdFbGVtZW50IiwiaXNIZXgiLCJ0ZXN0IiwiaXNSZ2IiLCJpc0hzbCIsImlzQ29sIiwiaXNLZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnNlTnVtYmVyIiwicGFyc2VGbG9hdCIsInBvdyIsIk1hdGgiLCJzcXJ0Iiwic2luIiwiY29zIiwiYWJzIiwiZXhwIiwiY2VpbCIsImZsb29yIiwiYXNpbiIsIm1heCIsImF0YW4yIiwiUEkiLCJfcm91bmQiLCJyb3VuZCIsImNsYW1wIiwibWluIiwicG93Q2FjaGUiLCJkZWNpbWFsTGVuZ3RoIiwicCIsInNuYXAiLCJpbmNyZW1lbnQiLCJjbG9zZXN0IiwiY3YiLCJpbnRlcnBvbGF0ZSIsInN0YXJ0IiwiZW5kIiwicHJvZ3Jlc3MiLCJjbGFtcEluZmluaXR5IiwiSW5maW5pdHkiLCJub3JtYWxpemVUaW1lIiwiY2xvbmVBcnJheSIsIm1lcmdlT2JqZWN0cyIsIm8xIiwibzIiLCJtZXJnZWQiLCJvMXAiLCJmb3JFYWNoQ2hpbGRyZW4iLCJwYXJlbnQiLCJjYWxsYmFjayIsInJldmVyc2UiLCJwcmV2UHJvcCIsIm5leHRQcm9wIiwibmV4dCIsIl9oZWFkIiwiYWRqdXN0ZWROZXh0UHJvcCIsIl90YWlsIiwiY3VycmVudE5leHQiLCJyZW1vdmVDaGlsZCIsImNoaWxkIiwicHJldiIsImFkZENoaWxkIiwic29ydE1ldGhvZCIsIkNsb2NrIiwiZnBzIiwiX2ZwcyIsInByZXZpb3VzRnJhbWVEdXJhdGlvbiIsIl9mcmFtZUR1cmF0aW9uIiwiZnIiLCJmcmFtZUR1cmF0aW9uIiwiX3NjaGVkdWxlZFRpbWUiLCJzcGVlZCIsIl9zcGVlZCIsInBiciIsInJlcXVlc3RUaWNrIiwidGltZSIsInNjaGVkdWxlZFRpbWUiLCJlbGFwc2VkVGltZSIsIl9lbGFwc2VkVGltZSIsImZyYW1lRGVsdGEiLCJjb21wdXRlRGVsdGFUaW1lIiwiZGVsdGEiLCJfbGFzdFRpbWUiLCJkZWx0YVRpbWUiLCJpbml0VGltZSIsIl9jdXJyZW50VGltZSIsIl9zdGFydFRpbWUiLCJfaGFzQ2hpbGRyZW4iLCJyZW5kZXIiLCJ0aWNrYWJsZSIsIm11dGVDYWxsYmFja3MiLCJpbnRlcm5hbFJlbmRlciIsInRpY2tNb2RlIiwiY29tcGxldGVkIiwiaXRlcmF0aW9uRHVyYXRpb24iLCJpdGVyYXRpb25Db3VudCIsIl9jdXJyZW50SXRlcmF0aW9uIiwiX2xvb3BEZWxheSIsIl9yZXZlcnNlZCIsIl9hbHRlcm5hdGUiLCJ0aWNrYWJsZURlbGF5IiwiX2RlbGF5IiwidGlja2FibGVQcmV2QWJzb2x1dGVUaW1lIiwidGlja2FibGVFbmRUaW1lIiwidGlja2FibGVBYnNvbHV0ZVRpbWUiLCJ0aWNrYWJsZVByZXZUaW1lIiwidGlja2FibGVDdXJyZW50VGltZSIsImlzQ3VycmVudFRpbWVBYm92ZVplcm8iLCJpc0N1cnJlbnRUaW1lRXF1YWxPckFib3ZlRHVyYXRpb24iLCJpc1NldHRlciIsImZvcmNlZFRpY2siLCJpc09kZCIsIml0ZXJhdGlvbkVsYXBzZWRUaW1lIiwiaGFzUmVuZGVyZWQiLCJjdXJyZW50SXRlcmF0aW9uIiwiaXNSZXZlcnNlZCIsIl9lYXNlIiwiaXRlcmF0aW9uVGltZSIsImlzUnVubmluZ0JhY2t3YXJkcyIsImJhY2t3YXJkcyIsIl9pdGVyYXRpb25UaW1lIiwiYmVnYW4iLCJmb3JjZWRSZW5kZXIiLCJhYnNvbHV0ZVRpbWUiLCJfb2Zmc2V0IiwidHdlZW4iLCJ0d2VlblRhcmdldCIsInR3ZWVuU3R5bGUiLCJ0d2VlblRhcmdldFRyYW5zZm9ybXMiLCJ0d2VlblRhcmdldFRyYW5zZm9ybXNQcm9wZXJ0aWVzIiwidHdlZW5UcmFuc2Zvcm1zTmVlZFVwZGF0ZSIsInR3ZWVuQ29tcG9zaXRpb24iLCJfY29tcG9zaXRpb24iLCJ0d2VlbkN1cnJlbnRUaW1lIiwidHdlZW5DaGFuZ2VEdXJhdGlvbiIsIl9jaGFuZ2VEdXJhdGlvbiIsInR3ZWVuQWJzRW5kVGltZSIsIl9hYnNvbHV0ZVN0YXJ0VGltZSIsInR3ZWVuTmV4dFJlcCIsIl9uZXh0UmVwIiwidHdlZW5QcmV2UmVwIiwiX3ByZXZSZXAiLCJ0d2Vlbkhhc0NvbXBvc2l0aW9uIiwiX2lzT3ZlcnJpZGRlbiIsIl9pc092ZXJsYXBwZWQiLCJ0d2Vlbk5ld1RpbWUiLCJ0d2VlblByb2dyZXNzIiwiX3VwZGF0ZUR1cmF0aW9uIiwidHdlZW5Nb2RpZmllciIsIl9tb2RpZmllciIsInR3ZWVuVmFsdWVUeXBlIiwiX3ZhbHVlVHlwZSIsInR3ZWVuVHlwZSIsIl90d2VlblR5cGUiLCJ0d2VlbklzT2JqZWN0IiwidHdlZW5Jc051bWJlciIsInR3ZWVuUHJlY2lzaW9uIiwidmFsdWUiLCJudW1iZXIiLCJfZnJvbU51bWJlciIsIl90b051bWJlciIsIl91bml0IiwiZm4iLCJfZnJvbU51bWJlcnMiLCJ0biIsIl90b051bWJlcnMiLCJyIiwiZyIsImIiLCJucyIsIl9udW1iZXJzIiwiX3N0cmluZ3MiLCJqIiwibCIsImxlbmd0aCIsIm4iLCJzIiwiX251bWJlciIsInR3ZWVuUHJvcGVydHkiLCJwcm9wZXJ0eSIsInRhcmdldCIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJfdmFsdWUiLCJfcmVuZGVyVHJhbnNmb3JtcyIsImtleSIsInRyYW5zZm9ybSIsIl9uZXh0IiwicGF1c2VkIiwiX3Jlc29sdmUiLCJ0aWNrIiwidGwiLCJ0bElzUnVubmluZ0JhY2t3YXJkcyIsInRsQ2hpbGRyZW5UaW1lIiwidGxDaWxkcmVuVGlja1RpbWUiLCJ0bENoaWxkcmVuSGFzUmVuZGVyZWQiLCJ0bENoaWxkcmVuSGF2ZUNvbXBsZXRlZCIsInRsSXRlcmF0aW9uRHVyYXRpb24iLCJjaGlsZER1cmF0aW9uIiwiY2hpbGRTdGFydFRpbWUiLCJjaGlsZEVuZFRpbWUiLCJjaGlsZFRpbWUiLCJjaGlsZFRpY2tNb2RlIiwiYWRkaXRpdmUiLCJhbmltYXRpb24iLCJ1cGRhdGUiLCJhZGRBZGRpdGl2ZUFuaW1hdGlvbiIsImxvb2t1cHMiLCJmb3JFYWNoIiwicHJvcGVydHlBbmltYXRpb24iLCJwcm9wZXJ0eU5hbWUiLCJ0d2VlbnMiLCJsb29rdXBUd2VlbiIsInZhbHVlVHlwZSIsImFkZGl0aXZlVmFsdWVzIiwiYWRkaXRpdmVWYWx1ZSIsImkiLCJfcHJldkFkZCIsImVuZ2luZVRpY2tNZXRob2QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRJbW1lZGlhdGUiLCJlbmdpbmVDYW5jZWxNZXRob2QiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFySW1tZWRpYXRlIiwiRW5naW5lIiwiZW5naW5lU3BlZWQiLCJlbmdpbmVGcHMiLCJhY3RpdmVUaWNrYWJsZSIsIm5leHRUaWNrYWJsZSIsIl9ydW5uaW5nIiwiX2NhbmNlbGxlZCIsImNhbmNlbCIsIndha2UiLCJ1c2VEZWZhdWx0TWFpbkxvb3AiLCJyZXFJZCIsInRpY2tFbmdpbmUiLCJwYXVzZSIsImtpbGxFbmdpbmUiLCJyZXN1bWUiLCJyZXNldFRpbWUiLCJ0aW1lVW5pdCIsInVuaXQiLCJzZWNvbmRzU2NhbGUiLCJpc1NlY29uZCIsIm5ld1NjYWxlIiwic2NhbGVGYWN0b3IiLCJwYXVzZU9uRG9jdW1lbnRIaWRkZW4iLCJoaWRkZW4iLCJhZGRFdmVudExpc3RlbmVyIiwicGFyc2VJbmxpbmVUcmFuc2Zvcm1zIiwicHJvcE5hbWUiLCJhbmltYXRpb25JbmxpbmVTdHlsZXMiLCJpbmxpbmVUcmFuc2Zvcm1zIiwiaW5saW5lZFN0eWxlc1Byb3BlcnR5VmFsdWUiLCJjYWNoZWRUcmFuc2Zvcm1zIiwidCIsImV4ZWMiLCJpbmxpbmVQcm9wZXJ0eU5hbWUiLCJpbmxpbmVQcm9wZXJ0eVZhbHVlIiwic2xpY2UiLCJnZXROb2RlTGlzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJOb2RlTGlzdCIsIkhUTUxDb2xsZWN0aW9uIiwicGFyc2VUYXJnZXRzIiwidGFyZ2V0cyIsImZsYXR0ZW5lZCIsImZsYXQiLCJwYXJzZWQiLCJpdGVtIiwibm9kZUxpc3QiLCJqbCIsInN1Ykl0ZW0iLCJpc0R1cGxpY2F0ZSIsImsiLCJrbCIsImZyb20iLCJyZWdpc3RlclRhcmdldHMiLCJwYXJzZWRUYXJnZXRzQXJyYXkiLCJwYXJzZWRUYXJnZXRzTGVuZ3RoIiwiaXNTdmdUeXBlIiwiaXNEb20iLCJub2RlVHlwZSIsImdldFBhdGgiLCJwYXRoIiwicGFyc2VkVGFyZ2V0cyIsIiRwYXJzZWRTdmciLCJtb3JwaFRvIiwicGF0aDIiLCIkcGF0aDEiLCIkcGF0aDIiLCJpc1BhdGgiLCJ0YWdOYW1lIiwic2VwYXJhdG9yIiwicHJldmlvdXNQb2ludHMiLCJ2MSIsInYyIiwiZ2V0QXR0cmlidXRlIiwibGVuZ3RoMSIsImdldFRvdGFsTGVuZ3RoIiwibGVuZ3RoMiIsIm1heFBvaW50cyIsInBvaW50T25QYXRoMSIsImdldFBvaW50QXRMZW5ndGgiLCJwb2ludE9uUGF0aDIiLCJwcmVmaXgiLCJ4IiwieSIsImdldFNjYWxlRmFjdG9yIiwiJGVsIiwiZ2V0Q1RNIiwiY3RtIiwic2NhbGVYIiwic2NhbGVZIiwiYyIsImQiLCJjcmVhdGVEcmF3YWJsZVByb3h5IiwicGF0aExlbmd0aCIsImNvbXB1dGVkU3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN0cm9rZUxpbmVDYXAiLCJzdHJva2VMaW5lY2FwIiwiJHNjYWxsZWQiLCJ2ZWN0b3JFZmZlY3QiLCJjdXJyZW50Q2FwIiwicHJveHkiLCJQcm94eSIsImdldCIsImFyZ3MiLCJ2YWx1ZXMiLCJzcGxpdCIsIm9zIiwiZDEiLCJkMiIsIm5ld0NhcCIsIlJlZmxlY3QiLCJhcHBseSIsImNyZWF0ZURyYXdhYmxlIiwic2VsZWN0b3IiLCJlbHMiLCJtYXAiLCJnZXRQYXRoUG9pbnQiLCIkcGF0aCIsImxvb2t1cCIsImdldFBhdGhQcm9nZXNzIiwicGF0aFByb3BlcnR5IiwidG90YWxMZW5ndGgiLCJpblN2ZyIsInRvIiwicDAiLCJwMSIsImUiLCJmIiwiY3JlYXRlTW90aW9uUGF0aCIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwicm90YXRlIiwiY3NzUmVzZXJ2ZWRQcm9wZXJ0aWVzIiwiaXNWYWxpZFNWR0F0dHJpYnV0ZSIsImVsIiwiaW5jbHVkZXMiLCJlbFBhcmVudE5vZGUiLCJwYXJlbnROb2RlIiwic3ZnIiwicmdiVG9SZ2JhIiwicmdiVmFsdWUiLCJyZ2JhIiwiaGV4VG9SZ2JhIiwiaGV4VmFsdWUiLCJoZXhMZW5ndGgiLCJpc1Nob3J0IiwidG9GaXhlZCIsImh1ZTJyZ2IiLCJxIiwiaHNsVG9SZ2JhIiwiaHNsVmFsdWUiLCJoc2xhIiwiaCIsImNvbnZlcnRDb2xvclN0cmluZ1ZhbHVlc1RvUmdiYUFycmF5IiwiY29sb3JTdHJpbmciLCJzZXRWYWx1ZSIsInRhcmdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0RnVuY3Rpb25WYWx1ZSIsImluZGV4IiwidG90YWwiLCJzdG9yZSIsImZ1bmMiLCJjb21wdXRlZCIsImdldFR3ZWVuVHlwZSIsInByb3AiLCJnZXRDU1NWYWx1ZSIsImlubGluZVN0eWxlcyIsImdldFByb3BlcnR5VmFsdWUiLCJnZXRPcmlnaW5hbEFuaW1hdGFibGVWYWx1ZSIsInR5cGUiLCJ0cmltU3RhcnQiLCJnZXRSZWxhdGl2ZVZhbHVlIiwib3BlcmF0b3IiLCJjcmVhdGVEZWNvbXBvc2VkVmFsdWVUYXJnZXRPYmplY3QiLCJ1IiwibyIsImRlY29tcG9zZVJhd1ZhbHVlIiwicmF3VmFsdWUiLCJ0YXJnZXRPYmplY3QiLCJudW0iLCJ1bml0TWF0Y2giLCJtYXRjaGVkTnVtYmVycyIsIm1hdGNoIiwiTnVtYmVyIiwiZGVjb21wb3NlVHdlZW5WYWx1ZSIsImRlY29tcG9zZWRPcmlnaW5hbFZhbHVlIiwiX3JlcCIsIldlYWtNYXAiLCJfYWRkIiwiZ2V0VHdlZW5TaWJsaW5ncyIsImxvb2t1cE1hcCIsInRhcmdldExvb2t1cCIsImFkZFR3ZWVuU29ydE1ldGhvZCIsIm92ZXJyaWRlVHdlZW4iLCJjb21wb3NlVHdlZW4iLCJzaWJsaW5ncyIsInR3ZWVuQ29tcG9zaXRpb25UeXBlIiwidHdlZW5BYnNTdGFydFRpbWUiLCJwcmV2U2libGluZyIsInByZXZQYXJlbnQiLCJwcmV2QWJzRW5kVGltZSIsInByZXZQcmV2U2libGluZyIsImFic29sdXRlVXBkYXRlU3RhcnRUaW1lIiwicHJldkNoYW5nZVN0YXJ0VGltZSIsInByZXZUTE9mZnNldCIsInBhdXNlUHJldlBhcmVudEFuaW1hdGlvbiIsInByZXZQYXJlbnRUTCIsInBhdXNlUHJldlBhcmVudFRMIiwiYWRkaXRpdmVUd2VlblNpYmxpbmdzIiwiYWRkaXRpdmVBbmltYXRpb24iLCJfcHJldiIsInRvTnVtYmVyIiwidG9OdW1iZXJzIiwicmVtb3ZlVHdlZW5TbGlibGluZ3MiLCJyZXBsYWNlVHdlZW5zTG9va3VwIiwicmVwbGFjZVRhcmdldFByb3BzIiwidHdlZW5SZXBsYWNlU2libGluZ3MiLCJhZGRUd2VlbnNMb29rdXAiLCJhZGRUYXJnZXRQcm9wcyIsInNob3VsZENsZWFuIiwiZGVsZXRlIiwicmVzZXRUaW1lclByb3BlcnRpZXMiLCJ0aW1lciIsInJldml2ZVRpbWVyIiwidGltZXJJZCIsIlRpbWVyIiwiY2FuY2VsbGVkIiwicmVzZXQiLCJwbGF5IiwiY3VycmVudFRpbWUiLCJzZWVrIiwiaXRlcmF0aW9uQ3VycmVudFRpbWUiLCJpdGVyYXRpb25Qcm9ncmVzcyIsIl9yZXZlcnNlIiwiaW5pdCIsIl9hdXRvcGxheSIsImxpbmtlZCIsImxpbmsiLCJyZXN0YXJ0IiwiaXNQYXVzZWQiLCJjb3VudCIsIml0ZXJhdGlvbnMiLCJzdHJldGNoIiwibmV3RHVyYXRpb24iLCJjdXJyZW50RHVyYXRpb24iLCJub3JtbGl6ZWREdXJhdGlvbiIsInJldmVydCIsImFwIiwiY29tcGxldGUiLCJ0aGVuIiwib25SZXNvbHZlIiwiUHJvbWlzZSIsInBhcmFtZXRlcnMiLCJwYXJlbnRQb3NpdGlvbiIsInJldmVydGlibGVzIiwidGltZXJJbml0VGltZSIsInRpbWVyRGVmYXVsdHMiLCJ0aW1lckRlbGF5IiwidGltZXJEdXJhdGlvbiIsInRpbWVyTG9vcCIsInRpbWVyTG9vcERlbGF5IiwidGltZXJJdGVyYXRpb25Db3VudCIsIm9mZnNldFBvc2l0aW9uIiwic3RhcnRUaW1lIiwiY3JlYXRlVGltZXIiLCJjYWxjQmV6aWVyIiwiYVQiLCJhQTEiLCJhQTIiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsIm1YMSIsIm1YMiIsImFBIiwiYUIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiY3ViaWNCZXppZXIiLCJtWTEiLCJtWTIiLCJzdGVwcyIsImZyb21TdGFydCIsInJvdW5kTWV0aG9kIiwibGluZWFyIiwiYXJnc0xlbmd0aCIsInRvdGFsUG9pbnRzIiwiZmlyc3RBcmciLCJsYXN0QXJnIiwieFBvaW50cyIsInlQb2ludHMiLCJhcmciLCJzcGxpdFZhbHVlIiwidHJpbSIsInBlcmNlbnQiLCJlYXNlTGluZWFyIiwicHJldlgiLCJwcmV2WSIsImlycmVndWxhciIsInJhbmRvbW5lc3MiLCJwcmV2aW91c1ZhbHVlIiwic3BhY2luZyIsInNlZ21lbnRFbmQiLCJyYW5kb21WYXJpYXRpb24iLCJyYW5kb20iLCJyYW5kb21WYWx1ZSIsImhhbGZQSSIsImRvdWJsZVBJIiwiZWFzZUluUG93ZXIiLCJlYXNlSW5GdW5jdGlvbnMiLCJRdWFkIiwiQ3ViaWMiLCJRdWFydCIsIlF1aW50IiwiU2luZSIsIkNpcmMiLCJFeHBvIiwiQm91bmNlIiwicG93MiIsIkJhY2siLCJvdmVyc2hvb3QiLCJFbGFzdGljIiwiYW1wbGl0dWRlIiwicGVyaW9kIiwiZWFzZVR5cGVzIiwiaW4iLCJlYXNlSW4iLCJvdXQiLCJpbk91dCIsIm91dEluIiwicGFyc2VFYXNlU3RyaW5nIiwic3RyaW5nIiwiZWFzZXNGdW5jdGlvbnMiLCJlYXNlc0xvb2t1cHMiLCJoYXNQYXJhbXMiLCJwYXJzZWRGbiIsImVhc2VzIiwibGlzdCIsIm5hbWUiLCJlYXNlVHlwZSIsIkpTRWFzZXNMb29rdXBzIiwicGFyc2VFYXNpbmdzIiwicHJvcGVydHlOYW1lc0NhY2hlIiwic2FuaXRpemVQcm9wZXJ0eU5hbWUiLCJjYWNoZWRQcm9wZXJ0eU5hbWUiLCJsb3dlckNhc2VOYW1lIiwiYW5nbGVVbml0c01hcCIsImNvbnZlcnRlZFZhbHVlc0NhY2hlIiwiY29udmVydFZhbHVlVW5pdCIsImRlY29tcG9zZWRWYWx1ZSIsImZvcmNlIiwiY3VycmVudFVuaXQiLCJjdXJyZW50TnVtYmVyIiwiY2FjaGVkS2V5IiwiY2FjaGVkIiwiY29udmVydGVkVmFsdWUiLCJiYXNlbGluZSIsInRlbXBFbCIsImNsb25lTm9kZSIsInBhcmVudEVsIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZWxTdHlsZSIsIndpZHRoIiwiY3VycmVudFVuaXRXaWR0aCIsIm9mZnNldFdpZHRoIiwibmV3VW5pdFdpZHRoIiwiZmFjdG9yIiwiY2xlYW5JbmxpbmVTdHlsZXMiLCJyZW5kZXJhYmxlIiwidGFyZ2V0U3R5bGUiLCJvcmlnaW5hbElubGluZWRWYWx1ZSIsIl9pbmxpbmVTdHlsZXMiLCJrZXlzIiwicmVtb3ZlUHJvcGVydHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJmcm9tVGFyZ2V0T2JqZWN0IiwidG9UYXJnZXRPYmplY3QiLCJ0b0Z1bmN0aW9uU3RvcmUiLCJrZXlmcmFtZXNUYXJnZXRBcnJheSIsImZhc3RTZXRWYWx1ZXNBcnJheSIsImtleU9iamVjdFRhcmdldCIsInR3ZWVuSWQiLCJnZW5lcmF0ZUtleWZyYW1lcyIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eU5hbWVzIiwiY29uY2F0IiwiZmlsdGVyIiwicHJvcEFycmF5IiwibmV3S2V5Iiwia2V5VmFsdWUiLCJ0b3RhbER1cmF0aW9uIiwic29ydCIsIm9mZnNldCIsInByZXZLZXkiLCJrZXlPYmoiLCJkdXJQcm9ncmVzcyIsInByZXZFYXNlIiwiY3VycmVudEVhc2UiLCJ1bmRlZmluZWQiLCJzaGlmdCIsIkpTQW5pbWF0aW9uIiwicmVmcmVzaCIsIm9nVmFsdWUiLCJfZnVuYyIsImZhc3RTZXQiLCJ0YXJnZXRzTGVuZ3RoIiwia2ZQYXJhbXMiLCJwYXJhbXMiLCJhbmltRGVmYXVsdHMiLCJhbmltYVBsYXliYWNrRWFzZSIsImFuaW1FYXNlIiwiaGFzU3ByaW5nIiwidEVhc2luZyIsInREdXJhdGlvbiIsInREZWxheSIsInRNb2RpZmllciIsInRDb21wb3NpdGlvbiIsImFuaW1JbmxpbmVTdHlsZXMiLCJhYnNvbHV0ZU9mZnNldFRpbWUiLCJOYU4iLCJpdGVyYXRpb25EZWxheSIsImFuaW1hdGlvbkFuaW1hdGlvbkxlbmd0aCIsInNob3VsZFRyaWdnZXJSZW5kZXIiLCJ0YXJnZXRJbmRleCIsInRpIiwibGFzdFRyYW5zZm9ybUdyb3VwSW5kZXgiLCJsYXN0VHJhbnNmb3JtR3JvdXBMZW5ndGgiLCJwcm9wVmFsdWUiLCJpc1Byb3BWYWx1ZUFycmF5IiwiYXJyYXlMZW5ndGgiLCJpc05vdE9iamVjdFZhbHVlIiwicHJldlR3ZWVuIiwiZmlyc3RUd2VlbkNoYW5nZVN0YXJ0VGltZSIsImxhc3RUd2VlbkNoYW5nZUVuZFRpbWUiLCJ0d2VlbkluZGV4Iiwia2V5ZnJhbWUiLCJjb21wdXRlZFRvVmFsdWUiLCJ0d2VlblRvVmFsdWUiLCJ0d2VlbkZyb21WYWx1ZSIsImtleUVhc2luZyIsInR3ZWVuRWFzaW5nIiwidHdlZW5EdXJhdGlvbiIsInR3ZWVuRGVsYXkiLCJjb21wdXRlZENvbXBvc2l0aW9uIiwiaGFzRnJvbXZhbHVlIiwiaGFzVG9WYWx1ZSIsImlzRnJvbVRvQXJyYXkiLCJpc0Zyb21Ub1ZhbHVlIiwidHdlZW5TdGFydFRpbWUiLCJhYnNvbHV0ZVN0YXJ0VGltZSIsIm5leHRTaWJsaW5nIiwiY29tcGxleFZhbHVlIiwibm90Q29tcGxleFZhbHVlIiwidW5pdFZhbHVlIiwibm90VW5pdFZhbHVlIiwiY29sb3JWYWx1ZSIsIm5vdENvbG9yVmFsdWUiLCJ2YWx1ZVRvQ29udmVydCIsImxvbmdlc3RWYWx1ZSIsInNob3J0ZXN0VmFsdWUiLCJfIiwidHdlZW5VcGRhdGVEdXJhdGlvbiIsIl9uZXh0QWRkIiwiYWRkaXRpdmVUd2VlbiIsImNvbnNvbGUiLCJ3YXJuIiwiYW5pbWF0ZSIsImVhc2luZ1RvTGluZWFyIiwic2FtcGxlcyIsInBvaW50cyIsImpvaW4iLCJXQUFQSUVhc2VzTG9va3VwcyIsIldBQVBJZWFzZXMiLCJwYXJzZVdBQVBJRWFzaW5nIiwicGFyc2VkRWFzZSIsImVhc2luZyIsInRyYW5zZm9ybXNTaG9ydGhhbmRzIiwiY29tbW9uRGVmYXVsdFBYUHJvcGVydGllcyIsInZhbGlkSW5kaXZpZHVhbFRyYW5zZm9ybXMiLCJzb21lIiwiYXhpcyIsImVuZHNXaXRoIiwidHJhbnNmb3Jtc1Byb3BlcnRpZXNSZWdpc3RlcmVkIiwiY2FsbCIsInJlZ2lzdGVyVHJhbnNmb3Jtc1Byb3BlcnRpZXMiLCJpc1NrZXciLCJpc1NjYWxlIiwiaXNSb3RhdGUiLCJpc1RyYW5zbGF0ZSIsImlzQW5nbGUiLCJzeW50YXgiLCJyZWdpc3RlclByb3BlcnR5IiwiaW5oZXJpdHMiLCJpbml0aWFsVmFsdWUiLCJXQUFQSUFuaW1hdGlvbnNMb29rdXBzIiwicmVtb3ZlV0FBUElBbmltYXRpb24iLCJuZXh0TG9va3VwIiwibWF0Y2hUYXJnZXQiLCJtYXRjaFByb3BlcnR5IiwibWF0Y2hQYXJlbnQiLCJhbmltIiwiY29tbWl0U3R5bGVzIiwibG9va3VwUGFyZW50IiwiX2NvbXBsZXRlZCIsImFuaW1hdGlvbnMiLCJhZGRXQUFQSUFuaW1hdGlvbiIsImFuaW1Ub3RhbER1cmF0aW9uIiwiY29udHJvbEFuaW1hdGlvbiIsImhhbmRsZVJlbW92ZSIsIm9ucmVtb3ZlIiwib25maW5pc2giLCJub3JtYWxpemVUd2VlblZhbHVlIiwicGFyc2VJbmRpdmlkdWFsVHdlZW5WYWx1ZSIsInR3ZWVuVmFsdWUiLCJjb21wdXRlZFRvIiwiY29tcHV0ZWRGcm9tIiwiV0FBUElBbmltYXRpb24iLCJjYiIsInNwcmluZyIsInNjcm9sbCIsImRpcmVjdGlvbiIsImZpbGwiLCJoYXNJbmRpdmlkdWFsVHJhbnNmb3JtcyIsImNvbXBvc2l0ZSIsInR3ZWVuUGFyYW1zIiwicHJvcGVydHlWYWx1ZSIsImluZGl2aWR1YWxUcmFuc2Zvcm1Qcm9wZXJ0eSIsInBhcnNlZFByb3BlcnR5VmFsdWUiLCJ0d2Vlbk9wdGlvbnMiLCJ0d2Vlbk9wdGlvbnNFYXNlIiwidHdlZW5PcHRpb25zU3ByaW5nIiwidHJhbnNmb3JtcyIsIndhYXBpIiwiY29udmVydEVhc2UiLCJzeW5jIiwiZ2V0VGFyZ2V0VmFsdWUiLCJ0YXJnZXRTZWxlY3RvciIsIm5vcm1hbGl6ZVByb3BOYW1lIiwib3JpZ2luYWxWYWx1ZSIsInNldFRhcmdldFZhbHVlcyIsInJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9uIiwidGFyZ2V0c0FycmF5IiwidHdlZW5zTWF0Y2hlc1RhcmdldHMiLCJ0d2Vlbk5hbWUiLCJyZW1vdmUiLCJ3YWFwaUFuaW1hdGlvbiIsInJlbW92ZU1hdGNoZXMiLCJjaGlsZFRMT2Zmc2V0IiwiY2hpbGREdXIiLCJtIiwicmFuZG9tUGljayIsIml0ZW1zIiwic2h1ZmZsZSIsInJvdW5kUGFkIiwicGFkU3RhcnQiLCJwYWRTdHJpbmciLCJwYWRFbmQiLCJ3cmFwIiwibWFwUmFuZ2UiLCJpbkxvdyIsImluSGlnaCIsIm91dExvdyIsIm91dEhpZ2giLCJkZWdUb1JhZCIsImRlZ3JlZXMiLCJyYWRUb0RlZyIsInJhZGlhbnMiLCJsZXJwIiwiYW1vdW50IiwiZHQiLCJ0aWNrZXIiLCJjdXJyeSIsImxhc3QiLCJjaGFpbiIsInJlc3VsdCIsIl9fIiwibmV4dEFyZ3MiLCJuZXh0UmVzdWx0IiwidXRpbHMiLCJtYWtlQ2hhaW5hYmxlIiwicmlnaHQiLCIkIiwiZ2V0UHJldkNoaWxkT2Zmc2V0IiwidGltZWxpbmUiLCJ0aW1lUG9zaXRpb24iLCJnb1RvUHJldkFuaW1hdGlvbk9mZnNldCIsInByZXZBbmltYXRpb24iLCJwcmV2T2Zmc2V0IiwicGFyc2VUaW1lbGluZVBvc2l0aW9uIiwidGxEdXJhdGlvbiIsInRpbWVQb3NTdHIiLCJ0bExhYmVscyIsImxhYmVscyIsImhhc0xhYmVscyIsImhhc1NpYmxpbmciLCJtYXRjaGVkUmVsYXRpdmVPcGVyYXRvciIsImZ1bGxPcGVyYXRvciIsImxhYmVsT2Zmc2V0IiwicGFyc2VkT2Zmc2V0IiwicGFyc2VkTnVtZXJpY2FsT2Zmc2V0IiwiZ2V0VGltZWxpbmVUb3RhbER1cmF0aW9uIiwiYWRkVGxDaGlsZCIsImNoaWxkUGFyYW1zIiwiYWRqdXN0ZWRQb3NpdGlvbiIsInRsQ2hpbGQiLCJUaW1lbGluZSIsImFkZCIsImExIiwiYTIiLCJhMyIsImlzQW5pbSIsImlzVGltZXIiLCJzdGFnZ2VyZWRQb3NpdGlvbiIsInBhcnNlZExlbmd0aCIsInN0YWdnZXJlZENoaWxkUGFyYW1zIiwic3luY2VkIiwicG9zaXRpb24iLCJlZmZlY3QiLCJnZXRUaW1pbmciLCJsYWJlbCIsImxhYmVsTmFtZSIsImRlZmF1bHRzUGFyYW1zIiwiZ2xvYmFsRGVmYXVsdHMiLCJ0bFBsYXliYWNrRWFzZSIsImNyZWF0ZVRpbWVsaW5lIiwiQW5pbWF0YWJsZSIsImdsb2JhbFBhcmFtcyIsInBhcmFtVmFsdWUiLCJpc09ialZhbHVlIiwicHJvcFBhcmFtcyIsImFuaW1QYXJhbXMiLCJudW1iZXJzIiwiY3JlYXRlQW5pbWF0YWJsZSIsIlNwcmluZyIsInNvbHZlIiwiemV0YSIsIncwIiwid2QiLCJjb21wdXRlIiwibWF4UmVzdFN0ZXBzIiwibWF4SXRlcmF0aW9ucyIsInJlc3RUaHJlc2hvbGQiLCJ0aW1lU3RlcCIsInNvbHZlclRpbWUiLCJyZXN0U3RlcHMiLCJzb2x2ZXJEdXJhdGlvbiIsIm1hc3MiLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwidmVsb2NpdHkiLCJyZXN0RHVyYXRpb24iLCJtYXhEdXJhdGlvbiIsImNyZWF0ZVNwcmluZyIsInByZXZlbnREZWZhdWx0IiwiY2FuY2VsYWJsZSIsIkRPTVByb3h5IiwiaGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInpJbmRleCIsInBhcmVudEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJUcmFuc2Zvcm1zIiwibm9ybWFsaXplUG9pbnQiLCJwb2ludCIsIm1hdHJpeFRyYW5zZm9ybSIsImludmVyc2VkTWF0cml4IiwidHJhdmVyc2VVcCIsImdldE1hdHJpeCIsIm1hdHJpeCIsIkRPTU1hdHJpeCIsInRyYW5zZm9ybVZhbHVlIiwiZWxNYXRyaXgiLCJwcmVNdWx0aXBseVNlbGYiLCJjdCIsIkRPTVBvaW50IiwiaW52ZXJzZSIsInBhcnNlRHJhZ2dhYmxlRnVuY3Rpb25QYXJhbWV0ZXIiLCJkcmFnZ2FibGUiLCJEcmFnZ2FibGUiLCJjb21wdXRlVmVsb2NpdHkiLCJkeCIsImR5IiwicHJldlRpbWUiLCJ2ZWxvY2l0eVRpbWUiLCJjdXJUaW1lIiwiZWxhcHNlZCIsInZlbG9jaXR5U3RhY2siLCJ2TXVsIiwidmVsb2NpdHlNdWx0aXBsaWVyIiwibWluViIsIm1pblZlbG9jaXR5IiwibWF4ViIsIm1heFZlbG9jaXR5IiwidmkiLCJ2ZWxvY2l0eVN0YWNrSW5kZXgiLCJzZXRYIiwibXV0ZVVwZGF0ZUNhbGxiYWNrIiwiZGlzYWJsZWQiLCJvdmVyc2hvb3RYVGlja2VyIiwibWFudWFsIiwidXBkYXRlZCIsImRlc3RYIiwic25hcHBlZCIsInNuYXBYIiwieFByb3AiLCJzZXRZIiwib3ZlcnNob290WVRpY2tlciIsImRlc3RZIiwic25hcFkiLCJ5UHJvcCIsInByb2dyZXNzWCIsImNvbnRhaW5lckJvdW5kcyIsInByb2dyZXNzWSIsInVwZGF0ZVNjcm9sbENvb3JkcyIsInN4IiwidXNlV2luIiwic2Nyb2xsWCIsIiRjb250YWluZXIiLCJzY3JvbGxMZWZ0Iiwic3kiLCJzY3JvbGxZIiwic2Nyb2xsVG9wIiwiY3B0IiwiY3ByIiwiY3BiIiwiY3BsIiwiY29udGFpbmVyUGFkZGluZyIsInRocmVzaG9sZCIsInNjcm9sbFRocmVzaG9sZCIsInNjcm9sbEJvdW5kcyIsInRhcmdldEJvdW5kcyIsInVwZGF0ZUJvdW5kaW5nVmFsdWVzIiwiY3giLCJjeSIsImN4MiIsImNvb3JkcyIsImN5MiIsIml3IiwiaW5uZXJXaWR0aCIsImloIiwiaW5uZXJIZWlnaHQiLCJ1dyIsInN3Iiwic2Nyb2xsV2lkdGgiLCJzaCIsInNjcm9sbEhlaWdodCIsImZ4IiwiZml4ZWQiLCJ0cmFuc2Zvcm1Db250YWluZXJSZWN0IiwiZHJhZ0FyZWEiLCJzY3JvbGxWaWV3IiwiY29udGFpbmVyT3ZlcmZsb3ciLCJ2aXNpYmxlT3ZlcmZsb3ciLCJoaWRkZW5PdmVyZmxvdyIsImNhblNjcm9sbCIsImNvbnRhaW5lZCIsImNvbnRhaW5lckFycmF5IiwidGFyZ2V0UmVjdCIsIiR0YXJnZXQiLCJoaWRkZW5MZWZ0IiwiaGlkZGVuVG9wIiwiaGlkZGVuUmlnaHQiLCJoaWRkZW5Cb3R0b20iLCJpc091dE9mQm91bmRzIiwiYm91bmRzIiwiYnQiLCJiciIsImJiIiwiYmwiLCJvYngiLCJvYnkiLCJwYXJhbVgiLCJwYXJhbVkiLCJjb250YWluZXIiLCJjcCIsInBhcnNlZEN1cnNvclN0eWxlcyIsImN1cnNvciIsImN1cnNvclN0eWxlcyIsIm9uSG92ZXIiLCJvbkdyYWIiLCIkc2Nyb2xsQ29udGFpbmVyIiwiaXNGaW5lUG9pbnRlciIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiY29udGFpbmVyRnJpY3Rpb24iLCJyZWxlYXNlQ29udGFpbmVyRnJpY3Rpb24iLCJzY3JvbGxTcGVlZCIsImRyYWdTcGVlZCIsImRhdyIsImRhaCIsImNzeCIsImNzeSIsIm5zdyIsIm5zaCIsImNzdyIsImNzaCIsInN3ZCIsInNoZCIsImRyYWdnZWQiLCJzdCIsInNyIiwic2IiLCJzbCIsIm54IiwibnkiLCJzY3JvbGxCeSIsInNjcm9sbFRvIiwiY3IiLCJjbCIsInB4MSIsInB5MSIsInB4MiIsInB5MiIsInB4MyIsInB5MyIsInBvaW50ZXIiLCJjZiIsImFuZ2xlIiwibnN4IiwibnN5Iiwib25TbmFwIiwic3RvcCIsInVwZGF0ZVRpY2tlciIsIm92ZXJzaG9vdENvb3JkcyIsInNjcm9sbEluVmlldyIsImdhcCIsImluT3V0UXVhZCIsImhhbmRsZUhvdmVyIiwiJHRyaWdnZXIiLCJhbmltYXRlSW5WaWV3Iiwib2IiLCJkaXNhYmxlZFgiLCJkaXNhYmxlZFkiLCJkdXIiLCJoYW5kbGVEb3duIiwiJGVUYXJnZXQiLCJncmFiYmVkIiwic3RvcFByb3BhZ2F0aW9uIiwicmVsZWFzZWQiLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJldmVudFgiLCJjbGllbnRYIiwiZXZlbnRZIiwiY2xpZW50WSIsImRlbHRhWCIsImRlbHRhWSIsInRhcmdldFN0eWxlcyIsInoiLCJ0cmlnZ2VyU3R5bGVzIiwiYm9keVN0eWxlcyIsImhhbmRsZU1vdmUiLCJtb3ZlZFgiLCJtb3ZlZFkiLCIkcGFyZW50IiwiaXNBdFRvcCIsImlzQXRCb3R0b20iLCJjYW5Ub3VjaFNjcm9sbCIsIm92ZXJmbG93WSIsImNsaWVudEhlaWdodCIsInBvaW50ZXJFdmVudHMiLCJwYXNzaXZlIiwib25EcmFnIiwiaGFuZGxlVXAiLCJzcHJpbmdYIiwicmVsZWFzZVhTcHJpbmciLCJzcHJpbmdZIiwicmVsZWFzZVlTcHJpbmciLCJyZWxlYXNlRWFzZSIsImhhc1JlbGVhc2VTcHJpbmciLCJwdiIsInBhIiwiZHMiLCJieCIsImJ5IiwiZHVyYXRpb25YIiwiZHVyYXRpb25ZIiwiZWFzZVgiLCJlYXNlWSIsImxvbmdlc3RSZWxlYXNlRHVyYXRpb24iLCJkaXJlY3Rpb25YIiwiZGlzdGFuY2VYIiwiZGlyZWN0aW9uWSIsImRpc3RhbmNlWSIsImhhc1NuYXBwZWQiLCJvblJlbGVhc2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVzaXplVGlja2VyIiwiZW5hYmxlIiwiZW5hYmxlZCIsInRvdWNoQWN0aW9uU3R5bGVzIiwidG91Y2hBY3Rpb24iLCJkaXNhYmxlIiwiaGFuZGxlRXZlbnQiLCJ0cmlnZ2VyIiwiY3VzdG9tRWFzZSIsIm1hcFRvIiwicmVsZWFzZU1hc3MiLCJyZWxlYXNlU3RpZmZuZXNzIiwicmVsZWFzZURhbXBpbmciLCJvdXRRdWludCIsIm9uU2V0dGxlIiwib25SZXNpemUiLCJvbkFmdGVyUmVzaXplIiwiYW5pbWF0YWJsZVBhcmFtcyIsInBhcmFtWE9iamVjdCIsImFuaW1hdGFibGVYUGFyYW1zIiwicGFyYW1ZT2JqZWN0IiwiYW5pbWF0YWJsZVlQYXJhbXMiLCJpbml0aWFsaXplZCIsImFjdGl2ZVByb3AiLCJoYXNVcGRhdGVkIiwiaGFzTW92ZWQiLCJoYXNSZWxlYXNlZCIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY3JlYXRlRHJhZ2dhYmxlIiwiU2NvcGUiLCJleGVjdXRlIiwiYWN0aXZlU2NvcGUiLCJhY3RpdmVSb290IiwiYWN0aXZlRGVmYXVsdHMiLCJtcXMiLCJtZWRpYVF1ZXJ5TGlzdHMiLCJtcSIsInJldHVybmVkIiwicmV2ZXJ0Q29uc3RydWN0b3JzIiwiY29uc3RydWN0b3JzIiwicmV2ZXJ0Q29uc3RydWN0b3IiLCJtZXRob2RzIiwiZGF0YSIsInJvb3RQYXJhbSIsImN1cnJlbnQiLCJuYXRpdmVFbGVtZW50Iiwic2NvcGVEZWZhdWx0cyIsImdsb2JhbERlZmF1bHQiLCJtZWRpYVF1ZXJpZXMiLCJfbXEiLCJjcmVhdGVTY29wZSIsImdldE1heFZpZXdIZWlnaHQiLCJjcmVhdGVFbGVtZW50Iiwib2Zmc2V0SGVpZ2h0IiwicGFyc2VTY3JvbGxPYnNlcnZlckZ1bmN0aW9uUGFyYW1ldGVyIiwic2Nyb2xsZXIiLCJzY3JvbGxDb250YWluZXJzIiwiU2Nyb2xsQ29udGFpbmVyIiwiZWxlbWVudCIsInVwZGF0ZVdpbmRvd0JvdW5kcyIsIndpbldpZHRoIiwid2luSGVpZ2h0IiwidXBkYXRlQm91bmRzIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwiZWxSZWN0IiwicmVmcmVzaFNjcm9sbE9ic2VydmVycyIsIl9kZWJ1ZyIsInJlbW92ZURlYnVnIiwiZGVidWciLCJoYW5kbGVTY3JvbGwiLCJ3YWtlVGlja2VyIiwic2Nyb2xsVGlja2VyIiwiZGF0YVRpbWVyIiwidW5vYnNlcnZlIiwicHJldlNjcm9sbFgiLCJwcmV2U2Nyb2xsWSIsImJhY2t3YXJkWCIsImJhY2t3YXJkWSIsInNlbGYiLCJweCIsInB5IiwicmVnaXN0ZXJBbmRHZXRTY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXIiLCJjb252ZXJ0VmFsdWVUb1B4Iiwic2l6ZSIsInVuZGVyIiwib3ZlciIsImNsYW1wTWluIiwiY2xhbXBNYXgiLCJwYXJzZUJvdW5kVmFsdWUiLCJtYXRjaGVkT3BlcmF0b3IiLCJzcGxpdHRlciIsInNwbGl0dGVkIiwidmFsdWVBUHgiLCJ2YWx1ZUJQeCIsImdldEFuaW1hdGlvbkRvbVRhcmdldCIsIiRsaW5rZWRUYXJnZXQiLCJsaW5rZWRUYXJnZXRzIiwic2Nyb2xsZXJJbmRleCIsImRlYnVnQ29sb3JzIiwiU2Nyb2xsT2JzZXJ2ZXIiLCJfcGFyYW1zIiwiYmFja3dhcmQiLCJob3Jpem9udGFsIiwib2Zmc2V0U3RhcnQiLCJkaXN0YW5jZSIsInJldmVydGVkIiwicmVwZWF0IiwiZW50ZXIiLCJsZWF2ZSIsIiRkZWJ1ZyIsImRlYnVnU3R5bGVzIiwiaXNIb3JpIiwiJGV4aXN0aW5nRGVidWciLCJxdWVyeVNlbGVjdG9yIiwiJHRocmVzaG9sZHMiLCIkdHJpZ2dlcnMiLCJjb2xvciIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0Iiwib2ZmTGVmdCIsIm9mZlRvcCIsImhhbGYiLCJsYWJlbEhlaWdodCIsImxhYmVsV2lkdGgiLCJsYWJlbFNpemUiLCJncmFkaWVudE9mZnNldCIsImxpbmVDU1MiLCJiYXNlQ1NTIiwidyIsImNzc1RleHQiLCJpc1ZpZXciLCJpc1RhaWwiLCJpc0ZpcnN0IiwiaXNPdmVyIiwiaXNGbGlwIiwiJGxhYmVsIiwiJHRleHQiLCJkaXJQcm9wIiwiZmxpcE9mZnNldCIsImlubmVySFRNTCIsInRocmVzaG9sZHMiLCJjb250YWluZXJQb3NpdGlvbiIsInN0aWNreXMiLCJsaW5rZWRUaW1lIiwib2Zmc2V0WCIsIm9mZnNldFkiLCIkb2Zmc2V0UGFyZW50IiwiaXNDb250YWluZXJTdGF0aWMiLCJpc1N0aWNreSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJ0YXJnZXRTaXplIiwiY29udGFpbmVyU2l6ZSIsInNjcm9sbFNpemUiLCJtYXhTY3JvbGwiLCJlbnRlclRhcmdldCIsImxlYXZlVGFyZ2V0IiwiZW50ZXJDb250YWluZXIiLCJsZWF2ZUNvbnRhaW5lciIsInBhcnNlZEVudGVyVGFyZ2V0IiwicGFyc2VkTGVhdmVUYXJnZXQiLCJwYXJzZWRFbnRlckNvbnRhaW5lciIsInBhcnNlZExlYXZlQ29udGFpbmVyIiwib2Zmc2V0RW5kIiwic2Nyb2xsRGVsdGEiLCJvZmZzZXRzIiwic3RpY2t5Iiwic3luY0Vhc2UiLCJzeW5jU21vb3RoIiwic2hvdWxkU2VlayIsImlzQmVmb3JlIiwiaXNBZnRlciIsImlzSW5WaWV3IiwiaXNPblRoZUVkZ2UiLCJmb3JjZUVudGVyIiwiaGFzRW50ZXJlZCIsInN5bmNDb21wbGV0ZWQiLCJscCIsInN0ZXAiLCJwcmV2UHJvZ3Jlc3MiLCJvblN5bmNFbnRlciIsIm9uRW50ZXIiLCJvblN5bmNFbnRlckJhY2t3YXJkIiwib25FbnRlckJhY2t3YXJkIiwib25TeW5jRW50ZXJGb3J3YXJkIiwib25FbnRlckZvcndhcmQiLCJvblN5bmNMZWF2ZSIsIm9uTGVhdmUiLCJvblN5bmNMZWF2ZUJhY2t3YXJkIiwib25MZWF2ZUJhY2t3YXJkIiwib25TeW5jTGVhdmVGb3J3YXJkIiwib25MZWF2ZUZvcndhcmQiLCJvblN5bmNDb21wbGV0ZSIsInN5bmNNb2RlIiwiaXNMaW5lYXIiLCJpc0Vhc2UiLCJpc1Ntb290aCIsImlzTWV0aG9kcyIsInN5bmNNZXRob2RzIiwiYmlEaXJTeW5jIiwib25TY3JvbGwiLCJzdGFnZ2VyIiwidmFsIiwiaGFzRWFzaW5nIiwic3RhZ2dlckVhc2UiLCJncmlkIiwiZnJvbUZpcnN0IiwiZnJvbUNlbnRlciIsImZyb21MYXN0IiwiaXNSYW5nZSIsInZhbDEiLCJ2YWwyIiwiZnJvbUluZGV4IiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/animejs/lib/anime.esm.js\n"));

/***/ })

});